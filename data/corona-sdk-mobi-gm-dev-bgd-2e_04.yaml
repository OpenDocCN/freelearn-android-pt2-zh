- en: Chapter 4. Game Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 游戏控制
- en: '*So far, we have completed the first half of our game in the previous chapter.
    We started by developing the initial structure for the project by introducing
    the game objects to the screen. Currently, the paddle and ball movement is inactive,
    but everything displayed in the simulator is scaled according to the original
    game design. The last phase of completing this tutorial is to add in all the actions
    that will occur in the game, including object movement and updating the score.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*到目前为止，我们在上一章完成了游戏的前半部分。我们通过向屏幕引入游戏对象来开发项目的初始结构。目前，挡板和球体的移动是无效的，但在模拟器中显示的所有内容都根据原始游戏设计进行了缩放。完成本教程的最后阶段是添加游戏中将发生的所有动作，包括对象移动和更新得分。*'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Moving the paddle using touch events and accelerometer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触摸事件和加速度计移动挡板
- en: Collision detection between all game objects in the scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中所有游戏对象之间的碰撞检测
- en: Removing objects upon collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在碰撞检测时移除对象
- en: Ball movement within the screen boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕边界内球体的移动
- en: Calculating the score
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算得分
- en: Win and lose conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利和失败条件
- en: Home stretch! We can do it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后阶段！我们能行！
- en: Moving in the up direction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上移动
- en: If making objects appear on screen is exciting to you, wait till you see them
    move! The main object of Breakout is to keep the ball above the paddle position
    to stay in play and have it collide with all the bricks to complete the level.
    What keeps the suspense going is the anticipation of the ball movement around
    the game screen. This wouldn't be possible without adding physical boundaries
    on the game objects to react to collision detection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为让对象在屏幕上出现很有趣，那么等到你看到它们移动时！`Breakout`游戏的主要目标是保持球在挡板位置之上以保持游戏进行，并让它与所有砖块碰撞以完成关卡。让悬念持续的是对球在游戏屏幕周围移动的期待。如果没有在游戏对象上添加物理边界以对碰撞检测做出反应，这是不可能的。
- en: Let's get even more physical
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们变得更加物理化
- en: In the previous chapter, we talked about how to integrate the physics engine
    into your code. We also started implementing physical bodies to the brick objects,
    and now, we'll need to do the same with other active game objects, such as the
    paddle and ball. Let's continue with this last half of the tutorial. We will continue
    using our `main.lua` file from the `Breakout` project folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何将物理引擎集成到代码中。我们还开始为砖块对象实现物理实体，现在，我们需要对其他活动游戏对象（如挡板和球）做同样的处理。让我们继续后半部分的教程。我们将继续使用`Breakout`项目文件夹中的`main.lua`文件。
- en: physics.addBody()
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: physics.addBody()
- en: 'Corona display objects can be turned into simulated physical objects using
    one line of code. The following information explains the different forms of physics
    bodies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Corona显示对象可以用一行代码变成模拟的物理对象。以下信息解释了不同的物理实体形式：
- en: If no shape information is specified, the display object takes on the form of
    the actual rectangular boundary of the original image to create the physics body.
    For example, if a display object is 100 x 100 pixels, then this would be the actual
    size of the physics body.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定形状信息，显示对象将采用原始图像的实际矩形边界来创建物理实体。例如，如果一个显示对象是100x100像素，那么这将是物理实体的实际大小。
- en: If a shape is specified, then the body boundaries will follow the polygon provided
    by the shape. The shape coordinates must be defined in a clockwise order, and
    the resulting shape must be convex only.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了一个形状，那么实体的边界将遵循该形状提供的多边形。形状坐标必须按顺时针顺序定义，且结果形状只能是凸的。
- en: If a radius is specified, then the body boundaries will be circular, centered
    at the middle of the display object used to create the physics body.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了半径，那么实体边界将是圆形的，以用于创建物理实体的显示对象的中心为中心。
- en: A body shape is a table of local (x,y) coordinates relative to the center of
    the display object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实体形状是一个相对于显示对象中心的本地（x,y）坐标表。
- en: 'The syntaxes for the body shapes are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实体形状的语法如下：
- en: 'Circular shapes:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形形状：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Polygon shapes:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形形状：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are the examples of the body shapes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实体形状的示例：
- en: 'Circular bodies:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形实体：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Polygon bodies:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形实体：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will discuss the parameters of the preceding methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论前面方法的相关参数：
- en: '`Object`: This is a display object.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象`：这是一个显示对象。'
- en: '`bodyType`: This is a string that specifies that the body type is optional.
    It uses a string parameter before the first body element. The possible types are
    `"static"`, `"dynamic"`, and `"kinematic"`. The default type is `"dynamic"` if
    no value is specified. Let''s talk about these types:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyType`：这是一个字符串，用于指定身体类型是可选的。它在第一个身体元素之前使用一个字符串参数。可能的类型是`"static"`（静态）、`"dynamic"`（动态）和`"kinematic"`（动力学）。如果未指定值，默认类型是`"dynamic"`。让我们来谈谈这些类型：'
- en: Static bodies don't move unless manually moved in code, and they don't interact
    with each other; examples of static objects would include the ground or the walls
    of a pinball machine.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态物体除非在代码中手动移动，否则不会移动，它们也不会相互交互；静态物体的例子包括弹球机的地面或墙壁。
- en: Dynamic bodies are affected by gravity and collisions with the other body types.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态物体受重力和与其他物体类型的碰撞影响。
- en: Kinematic objects are affected by forces but not by gravity, so you should generally
    set draggable objects to kinematic, at least for the duration of the drag event.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动力学物体受力的影响，但不受重力影响，因此你通常应该将可拖动的物体设置为动力学物体，至少在拖动事件期间是这样。
- en: '`Density`: This is a number that is multiplied by the area of the body''s shape
    to determine mass. It is based on a standard value of 1.0 for water. Lighter materials
    (such as wood) have a density below 1.0, and heavier materials (such as stone)
    have a density greater than 1.0\. The default value is `1.0`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Density`：这是一个数值，通过乘以物体形状的面积来确定质量。它基于水的标准值1.0。较轻的材料（如木材）的密度低于1.0，而较重的材料（如石头）的密度则高于1.0。默认值为`1.0`。'
- en: '`Friction`: This is a number. This may be any non-negative value; a value of
    0 means no friction, and 1.0 means fairly strong friction. The default value is
    `0.3`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Friction`：这是一个数值。可以是任何非负值；0表示没有摩擦力，1.0表示相当强的摩擦力。默认值为`0.3`。'
- en: '`Bounce`: This is a number that determines the object''s velocity that is returned
    after a collision. The default value is `0.2`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bounce`：这是一个数值，决定了物体碰撞后返回的速度。默认值为`0.2`。'
- en: '`Radius`: This is a number. This is the radius of the bounding circle in pixels.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radius`：这是一个数值。这是边界圆的半径，单位为像素。'
- en: '`Shape`: This is a number. It is the shape value in the form of a table of
    the shape vertices, that is, {x1, y1, x2, y2, …, xn, yn}, for example, `rectangleShape
    = { -6,-48, 6,-48, 6,48, -6,48 }`. The coordinates must be defined in a clockwise
    order, and the resulting shape must be convex only. Physics assumes that the (0,0)
    point of an object is the center of the object. A *-x* coordinate will be to the
    left of object''s center and *-y* coordinate will be at the top of object''s center.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape`：这是一个数值。它是形状顶点的表格形式的形状值，即{x1, y1, x2, y2, …, xn, yn}，例如`rectangleShape
    = { -6,-48, 6,-48, 6,48, -6,48 }`。坐标必须按顺时针顺序定义，且结果形状必须是凸的。物理引擎假设物体的(0,0)点是物体的中心。一个*负x*坐标将位于物体中心的左侧，而*负y*坐标将位于物体中心的顶部。'
- en: Time for action – starting physics for the paddle and ball
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——为挡板和球启动物理效果。
- en: 'Right now, our display objects are rather stagnant. In order for the game play
    to initiate, we have to activate physics for collision detection to occur between
    the paddle and ball. Perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的显示对象相当静止。为了让游戏开始，我们必须为挡板和球激活物理效果，以发生碰撞检测。执行以下步骤：
- en: 'Above the `gameLevel1()` function, create a new function called `startGame()`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameLevel1()`函数之上，创建一个名为`startGame()`的新函数：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add in the following lines to instantiate the physics for the paddle and ball:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下几行代码来为挡板和球实例化物理效果：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create an event listener that uses the background display object to remove
    the `"tap"` event for `startGame()`. Close the function with `end`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个事件监听器，使用背景显示对象来移除`startGame()`的`"tap"`事件。使用`end`关闭函数：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `addGameScreen()` function that we created in the previous chapter,
    we have to add the following line after the call to the `gameLevel1()` function.
    This starts the actual game when the background is touched:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中我们创建的`addGameScreen()`函数里，需要在调用`gameLevel1()`函数之后添加以下这行代码。这样，当触摸背景时，就会开始实际的游戏：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The paddle object has a `"static"` body type, so it is not affected by any collision
    that occurs against it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 挡板对象有一个`"static"`（静态）的物体类型，所以它不会受到任何与之相撞的碰撞影响。
- en: The ball object has a `"dynamic"` body type because we want it to be affected
    by the collisions on the screen due to directional changes caused by the wall
    borders, bricks, and paddle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 球对象有一个`"dynamic"`（动态）的物体类型，因为我们需要它受到屏幕上由于墙壁边界、砖块和挡板造成的方向改变而产生的碰撞影响。
- en: The event listener on the background is removed from the `startGame()` function;
    this way, it doesn't affect any of the other touch events that are applied in
    the game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`startGame()`函数中从背景移除了事件监听器；这样它就不会影响游戏中应用的其他触摸事件。'
- en: Paddle movement
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挡板移动
- en: Getting the paddle to move side to side is one of the key actions that needs
    to be accomplished. Part of the game design is to prevent the ball from reaching
    the bottom of the screen. We will be separating the paddle movement in the simulator
    and the accelerometer. The movement in the simulator enables us to test with touch
    events since accelerometer actions cannot be tested in the simulator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让挡板左右移动是必须完成的关键动作之一。游戏设计的一部分是防止球到达屏幕底部。我们将把模拟器中的挡板移动与加速度计分离。在模拟器中的移动使我们能够通过触摸事件进行测试，因为加速度计动作无法在模拟器中测试。
- en: Time for action – dragging the paddle in the simulator
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——在模拟器中拖动挡板
- en: 'Right now, the paddle does not move at all. There are no coordinates set that
    will allow the paddle to move side to side on the screen. So let''s create them
    by performing the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，挡板根本不会移动。没有设置允许挡板在屏幕上左右移动的坐标。所以让我们通过执行以下步骤来创建它们：
- en: 'Underneath the `addGameScreen()` function, create a new function called `dragPaddle(event)`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addGameScreen()`函数下方，创建一个名为`dragPaddle(event)`的新函数：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we''ll focus on moving the paddle side to side within the boundary of
    the game screen. Add in the following block of code to enable paddle movement
    in the simulator and then close the function. The reason for adding this block
    is because the simulator does not support accelerometer events:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将关注在游戏屏幕边界内左右移动挡板。添加以下代码块以在模拟器中启用挡板移动，然后关闭函数。添加此代码块的原因是模拟器不支持加速度计事件：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'See the following image of the ball colliding with the bricks and the paddle
    and anticipate where the ball will move towards next:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图像，预测球与砖块和挡板碰撞后球将向何处移动：
- en: '![Time for action – dragging the paddle in the simulator](img/9343OT_04_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![动作时间——在模拟器中拖动挡板](img/9343OT_04_01.jpg)'
- en: '*What just happened?*'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have created a function where the drag event only works in the simulator.
    For `if event.phase == "began"`, a touch event has been made to the paddle. On
    `elseif event.phase == "moved"`, a touch event where the paddle moved from its
    original position has been made.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个仅在模拟器中起作用的拖动事件函数。对于`if event.phase == "began"`，已经对挡板进行了触摸事件。在`elseif
    event.phase == "moved"`，已经对挡板从原始位置移动的触摸事件进行了处理。
- en: In order to keep the paddle from moving past the wall boundaries, `paddle.x`
    does not go less than `0` in the *x* direction when it hits the coordinate. When
    the paddle slides to the right-hand side of the screen, `paddle.x` does not go
    greater than `display.contentWidth` in the *x* direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止挡板移动超过墙壁边界，当挡板碰到坐标时，`paddle.x`在*x*方向上不会小于`0`。当挡板滑向屏幕右侧时，`paddle.x`在*x*方向上不会大于`display.contentWidth`。
- en: There is no designated coordinate for the right-hand side of the screen since
    the code is supposed to be universal for all screen sizes on iOS and Android devices.
    Both platforms have varying screen resolutions, so `display.contentWidth` takes
    this into account.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码应该适用于iOS和Android设备上所有屏幕尺寸，因此没有指定屏幕右侧的坐标。这两个平台具有不同的屏幕分辨率，所以`display.contentWidth`考虑到了这一点。
- en: Time for action – moving the paddle with the accelerometer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——使用加速度计移动挡板
- en: 'As mentioned earlier, accelerometer events cannot be tested in the simulator.
    They only work when a game build is uploaded to a device to see the results. The
    paddle movement will stay within the wall borders of the level across the *x*
    axis. To move the paddle, follow the steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，加速度计事件无法在模拟器中测试。它们仅在将游戏构建上传到设备以查看结果时才起作用。挡板移动将保持在关卡*x*轴上的墙壁边界内。要移动挡板，请按照以下步骤操作：
- en: 'Below the `dragPaddle()` function, create a new function called `movePaddle(event)`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dragPaddle()`函数下方，创建一个名为`movePaddle(event)`的新函数：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add in the accelerometer movement using `yGravity`. It provides acceleration
    due to gravity in the *y* direction:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`yGravity`添加加速度计移动。它提供了*y*方向上的重力加速度：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add in the wall borders for the level and close the function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加关卡墙壁边界并在函数末尾关闭：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使加速度计移动在设备上工作，我们必须使用`yGravity`。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for the landscape mode,
    the `xGravity` and `yGravity` values are switched to compensate for the events
    to work properly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`xGravity`和`yGravity`时，加速度计事件基于竖屏刻度。当显示对象被指定为横屏模式时，`xGravity`和`yGravity`的值会交换，以补偿事件正常工作。
- en: 'We have applied the same code for the paddle from `function dragPaddle()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对挡板应用了与`function dragPaddle()`中相同的代码：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This still keeps the paddle from going past any wall boundaries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然可以防止挡板越过任何墙壁边界。
- en: Ball collision with the paddle
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球与挡板的碰撞
- en: The motion of the ball has to flow in a fluid manner every time it collides
    with the paddle. This means proper direction changes on all sides of the game
    field.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每次球与挡板碰撞时，其运动都必须流畅。这意味着在游戏场的所有侧面都要有适当的方向改变。
- en: Time for action – making the ball bounce against the paddle
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——让球反弹到挡板上
- en: 'We will check which side of the paddle the ball has hit to choose the side
    where it will move next. It''s important to have the motion to follow through
    any directional hits as it would in a realistic environment. With every paddle
    collision, we want to make sure that the ball goes in the up direction. For this,
    follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查球击中了挡板的哪一侧，以选择它接下来将移动的一侧。让运动跟随任何方向打击，就像在真实环境中一样，这很重要。每次与挡板碰撞，我们都要确保球向上移动。为此，请按照以下步骤操作：
- en: 'Create a new function called `bounce()` for the ball after the `movePaddle()`
    function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`movePaddle()`函数后创建一个名为`bounce()`的新函数，用于处理球：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add in a value of `-3` for velocity in the *y* direction. This will make the
    ball move in an upward motion:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*y*方向上添加一个值为`-3`的速度。这将使球向上移动：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Check when a collision is made with the `paddle` and `ball` objects and close
    the function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`paddle`和`ball`对象之间的碰撞，并关闭函数：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*What just happened?*'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: When the ball collides with the paddle, the motion follows through, depending
    on what side of the paddle is touched by the ball. In the first part of the `if`
    statement, the ball travels toward 0 in the *x* direction. The last part of the
    `if` statement shows the ball travelling toward the opposite side of the screen
    in the *x* direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当球与挡板碰撞时，其运动取决于球接触挡板的哪一侧。在`if`语句的第一部分，球在*x*方向上向0移动。`if`语句的最后部分显示了球在*x*方向上向屏幕的另一侧移动。
- en: Removing objects from the scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从场景中移除对象
- en: There are limited resources on a device. As much as we wish they were as powerful
    as a desktop to hold so much memory, it's not at that point yet. This is why it
    is important to remove display objects from the display hierarchy when you no
    longer use them in your application. This helps overall system performance by
    reducing memory consumption and eliminates unnecessary drawing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的资源是有限的。我们希望它们能像桌面一样强大，拥有如此多的内存，但现在还没有达到这个水平。这就是为什么当您在应用程序中不再使用显示对象时，从显示层次结构中移除它们很重要的原因。这有助于通过减少内存消耗来提高整体系统性能，并消除不必要的绘制。
- en: When a display object is created, it is added by default to the root object
    of the display hierarchy. This object is a special kind of group object known
    as the **stage** object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建显示对象时，默认会添加到显示层次结构的根对象中。这个对象是一种特殊的组对象，称为**舞台**对象。
- en: 'In order to keep an object from rendering on screen, it needs to be removed
    from the scene. The object needs to be removed explicitly from its parent. This
    removes the object from the display hierarchy. This can be done in either in the
    following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止对象在屏幕上渲染，需要将其从场景中移除。需要明确地从其父对象中移除该对象。这将对象从显示层次结构中移除。可以通过以下方式完成：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, this can be done using the following line of code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用以下代码行完成此操作：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This does not free all the memory from the display object. To make sure that
    the display object is removed properly, we need to eliminate all the variable
    references to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不会释放显示对象所有的内存。为了确保显示对象被正确移除，我们需要消除所有对其的变量引用。
- en: Variable references
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量引用
- en: 'Even though a display object has been removed from the hierarchy, there are
    situations in which the object continues to exist. To do this, we will set the
    property to `nil`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使显示对象已从层次结构中移除，但在某些情况下，对象仍然存在。为此，我们将属性设置为`nil`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Brick by brick
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一砖一瓦
- en: The bricks in the game are the main obstacles, since they have to be cleared
    in order to move on to the next round. In this version of Breakout, the player
    must destroy all the bricks in one turn. Failure to do so results in starting
    over from the beginning of the current level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的砖块是主要的障碍物，因为必须清除它们才能进入下一轮。在这个版本的打砖块游戏中，玩家必须一次性摧毁所有砖块。如果做不到这一点，则需要从当前关卡的开始处重新开始。
- en: Time for action – removing the bricks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——移除砖块
- en: 'When the ball collides with a brick, we will use the same technique applied
    to the paddle to determine the path the ball will follow. When a brick is hit,
    we''ll need to figure out which brick has been touched and then remove it from
    both the stage and the bricks group. Each brick removal will increment 100 points
    to the score. The score will be taken from the `score` constant and added to the
    current score as text. To remove the bricks from the game, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当球与砖块碰撞时，我们将使用与挡板相同的技术来确定球的路径。当击中砖块时，我们需要找出哪块砖被触碰，然后将其从舞台和砖块组中移除。每移除一块砖，分数增加100分。分数将从`score`常数中取出，并作为文本添加到当前分数中。要移除游戏中的砖块，请按照以下步骤操作：
- en: 'Below the `gameLevel2()` function, create a function called `removeBrick(event)`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameLevel2()`函数下方，创建一个名为`removeBrick(event)`的函数：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check which side of the brick the ball hits by using the `if` statement. When
    checking for an event, we''ll refer the event to the object name, `"brick"`. This
    is the name we gave our `brick` display object:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if`语句检查球击中砖块的哪一侧。在检查事件时，我们将事件引用到对象名称`"brick"`。这是我们给`brick`显示对象起的名字：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add in the following `if` statement to remove the brick from the scene when
    the ball collides with one. After a collision has been made, increase `score`
    by 1\. Initiate `scoreNum` to take the value of the score and multiply it by `scoreIncrease`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`if`语句，当球与砖块碰撞时，从场景中移除砖块。碰撞发生后，将`score`增加1。将`scoreNum`初始化为取分数的值，并将其乘以`scoreIncrease`：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When all the bricks in the level are destroyed, create an `if` statement that
    pops up the alert screen for a win condition and set the `gameEvent` string to
    `"win"`;
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当关卡中的所有砖块被摧毁时，创建一个`if`语句，弹出胜利条件的警告屏幕，并将`gameEvent`字符串设置为`"win"`；
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Close the function with `end`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`end`关闭函数：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is a screenshot of the ball colliding with the paddle:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是球与挡板碰撞的截图：
- en: '![Time for action – removing the bricks](img/9343OT_04_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——移除砖块](img/9343OT_04_02.jpg)'
- en: '*What just happened?*'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: If you remember from the previous chapter, we gave the `brick` objects a name
    called `"brick"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章的内容，我们给`brick`对象起了一个名为`"brick"`的名字。
- en: When the ball hits the left-hand side of any of the individual bricks, it travels
    towards the left. When the ball hits the right-hand side of the bricks, it travels
    toward the right. The width of each object is taken as a whole to calculate the
    direction in which the ball travels.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当球击中砖块的左侧时，它会向左移动。当球击中砖块的右侧时，它会向右移动。每个对象的宽度被视为整体，以计算球移动的方向。
- en: When a brick is hit, the ball bounces upward (the *y* direction). After every
    collision the ball makes with a brick, the brick is removed from the scene and
    destroyed from the memory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当砖块被击中时，球会向上弹起（即*y*方向）。球与每块砖碰撞后，砖块会从场景中移除，并从内存中销毁。
- en: The `bricks.numChildren – 1` statement subtracts the count from the total number
    of bricks it started out with originally. When a brick is removed, the score increments
    100 points each time. The `scoreNum` text object updates the score every time
    a brick is hit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`bricks.numChildren – 1`语句从最初开始的总砖块数中减去计数。每当移除一块砖，分数增加100分。每当击中砖块时，`scoreNum`文本对象会更新分数。'
- en: When all the bricks are gone, the alert screen pops up with a notification that
    the player has won the level. We also set `gameEvent` equal to `"win"`, which
    will be used in another function that will transition the event to a new scene.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有砖块都被移除时，警告屏幕会弹出通知玩家已经赢得关卡。我们还设置`gameEvent`等于`"win"`，这将在另一个函数中使用，以将事件过渡到新场景。
- en: Directional changes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向变化
- en: Apart from the ball motion against the paddle, the other factor is the collision
    state against the wall borders. When a collision occurs, the ball diverts its
    direction in the opposite way. For every action, there is a reaction, just like
    real-world physics.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了球与挡板相对运动之外，另一个因素是球与墙壁边界的碰撞状态。当发生碰撞时，球会以相反的方向改变其移动方向。每个动作都有相应的反应，就像现实世界中的物理一样。
- en: Time for action – updating the ball
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——更新球的位置
- en: 'The ball needs to move in a continuous motion without gravity affecting it.
    We''ll have to take into account the side walls and the top and bottom walls.
    The velocity in the *x* and *y* direction have to reflect the other way when a
    collision happens on any of the boundaries. We need to set coordinates so that
    the ball is only allowed to move through and alert when it passes through the
    area below the paddle region. Let''s perform the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 球需要以连续的运动移动，不受重力影响。我们需要考虑侧墙以及顶底墙壁。当球在任何边界上发生碰撞时，*x*和*y*方向的速度必须反射回来。我们需要设置坐标，以便球只能通过并在穿过挡板区域以下时发出警告。让我们执行以下步骤：
- en: 'Create a new function called `function updateBall()` below the `removeBrick(event)`
    function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`removeBrick(event)`函数下方创建一个名为`function updateBall()`的新函数：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add in the ball movement:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加球的移动：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add in the ball movement for the *x* direction:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加球在*x*方向上的移动：
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the movement of ball in the *x* direction:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的截图展示了球在*x*方向上的移动：
- en: '![Time for action – updating the ball](img/9343OT_04_03.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——更新球的位置](img/9343OT_04_03.jpg)'
- en: 'Add in the ball movement for the *y* direction:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加球在*y*方向上的移动：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot shows the movement of the ball in the *y* direction:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的截图展示了球在*y*方向上的移动：
- en: '![Time for action – updating the ball](img/9343OT_04_04.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——更新球的位置](img/9343OT_04_04.jpg)'
- en: 'Add in the ball movement when it collides with the bottom of the game play
    screen. Create the lost alert screen and a game event for `"lose"`. Close the
    function with `end`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加球与游戏屏幕底部碰撞时的移动。创建失败警告屏幕并设置一个`"lose"`的游戏事件。使用`end`结束函数：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows the lost alert screen when the ball collides
    with the bottom of the game play screen:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的截图显示了当球与游戏屏幕底部碰撞时出现的失败警告屏幕：
- en: '![Time for action – updating the ball](img/9343OT_04_05.jpg)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——更新球的位置](img/9343OT_04_05.jpg)'
- en: '*What just happened?*'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Everywhere the ball travels, proper direction change is needed when it hits
    the wall. Any time the ball hits the side walls, we used `vx = -vx`. When the
    ball hits the top boundary, `vy = -vy` is used. The only time the ball doesn't
    reflect the opposite direction is when it hits the bottom of the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 球移动的每个位置，当它撞击墙壁时都需要改变方向。每当球撞击侧墙，我们使用`vx = -vx`。当球撞击顶部边界时，使用`vy = -vy`。唯一球不会反射相反方向的情况是它撞击屏幕底部。
- en: The alert screen displays the lose condition, which emphasizes to the player
    to play again. The `gameEvent = "lose"` statement will be used in another `if`
    statement to reset the current level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 警告屏幕显示了失败条件，这强调了玩家需要再次游戏。`gameEvent = "lose"`的声明将在另一个`if`语句中使用，以重置当前关卡。
- en: Transitioning levels
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换关卡
- en: When a win or lose condition occurs, the game needs a way to transition to the
    next level or repeat the current one. The main game objects have to be reset to
    their starting position and the bricks redrawn. It's pretty much the same idea
    as when you first start a game.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现胜利或失败的条件时，游戏需要一种方式来转换到下一个关卡或重复当前关卡。主要游戏对象必须被重置到起始位置，并且重新绘制砖块。这与游戏开始时的想法基本相同。
- en: Time for action – resetting and changing levels
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——重置和改变关卡
- en: 'We''ll need to create functions that set up the first and second levels in
    the game. If a level needs to be replayed, only the current level the user lost
    in can be accessed. Follow these steps to transition between the levels:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一些函数来设置游戏中的第一关和第二关。如果一个关卡需要重玩，只能访问用户在当前关卡中失败的那一关。以下是转换关卡之间的步骤：
- en: 'Create a new function called `changeLevel1()`. This will be placed below the
    `updateBall()` function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`changeLevel1()`的新函数。这将被放置在`updateBall()`函数下方：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clear the `bricks` group when the player loses the round, and then reset them:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家输掉一轮游戏时，清除`bricks`组，然后重置它们：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Remove `alertDisplayGroup`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`alertDisplayGroup`：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Reset the `ball` and `paddle` positions:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置`ball`和`paddle`的位置：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Redraw the bricks for the current level:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新绘制当前关卡的砖块：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add an event listener to the `background` object for `startGame()`. Close the
    function:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`background`对象上添加一个`startGame()`的事件监听器，并结束此函数：
- en: '[PRE35]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, create a new function called `changeLevel2()`. Apply the same code used
    for `changeLevel1()`, but make sure that the bricks are redrawn for `gameLevel2()`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`changeLevel2()`的新函数。应用与`changeLevel1()`相同的代码，但确保为`gameLevel2()`重绘砖块：
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*What just happened?*'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: When a level needs to be reset or changed, the display objects have to be wiped
    from the screen. In this case, we removed the `bricks` group using `bricks:removeSelf()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要重置或更改关卡时，必须从屏幕上清除显示对象。在这种情况下，我们使用`bricks:removeSelf()`移除了`bricks`组。
- en: When any alert screen pops up, whether win or lose, the entire `alertDisplayGroup`
    is removed during the reset as well. The `ball` and `paddle` objects are set back
    to their starting position.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何提示屏幕弹出时，无论是赢还是输，整个`alertDisplayGroup`在重置时也会被移除。`ball`和`paddle`对象会被设置回起始位置。
- en: The `gameLevel1()` function is called to redraw the bricks for level 1\. The
    function holds the initial setup for the `brick` display objects and `bricks`
    group.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameLevel1()`函数被调用，以重绘第一关的砖块。该函数负责`brick`显示对象和`bricks`组的初始设置。'
- en: The `background` object is used again to call the `startGame()` function with
    an event listener. When level 2 needs to be set up, the same procedure like in
    function `changeLevel1()`is used, but `changeLevel2()` and `gameLevel2()` are
    called to redraw the bricks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`background`对象再次使用事件监听器调用`startGame()`函数。当需要设置第二关时，使用与`changeLevel1()`函数相同的程序，但是调用`changeLevel2()`和`gameLevel2()`来重绘砖块。'
- en: Have a go hero –add more levels
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——添加更多关卡。
- en: Right now, the game only has two levels. What can be done to extend this game
    is to add more levels. They can be created using the same logic used for `gameLevel1()`
    and `gameLevel2()`, by adjusting the numbers used to create rows and columns of
    bricks. You'll have to create a new function that resets the level. We can use
    the same method followed for `changeLevel1()` and `changeLevel2()` to recreate
    a level and reset it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏只有两个关卡。要扩展这个游戏，可以添加更多的关卡。它们可以使用与`gameLevel1()`和`gameLevel2()`相同的逻辑来创建，通过调整用于创建砖块行和列的数字。你需要创建一个新的函数来重置关卡。我们可以使用与`changeLevel1()`和`changeLevel2()`相同的方法来重新创建并重置关卡。
- en: You win some, you lose some
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有赢就有输。
- en: Nothing is more exhilarating than the anticipation of winning. That is until
    you make that one small mistake, and it causes you to start over. Don't worry;
    it's not the end of the world; you can always try again and learn from your errors
    to beat the level.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比期待胜利更令人兴奋了。直到你犯了一个小错误，导致你必须重新开始。别担心，这并不是世界末日；你总是可以再次尝试并从错误中学习，以打败这一关卡。
- en: Game events such as a win or lose condition will alert the player of their progress.
    The game has to have some way of guiding the player about what action they need
    to take next to replay the level or move on to the next one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏事件，如胜负条件，会提示玩家他们的进度。游戏必须有某种方式指导玩家下一步需要采取什么行动来重玩关卡或进入下一关。
- en: Time for action –making win and lose conditions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候制定胜负条件了。
- en: 'For any game alerts to even appear during game play, we need to create some
    `if` statements for every possible scenario available in each level. When this
    occurs, the score needs to be reset back to zero. To make the win and lose conditions,
    follow these steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏中的任何提示出现，我们需要为每个关卡中可能出现的每一种情况创建一些`if`语句。当这种情况发生时，分数需要重置回零。要制定胜负条件，请按照以下步骤操作：
- en: 'Below the `alertScreen()` function, create a new function called `restart()`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`alertScreen()`函数下面，创建一个名为`restart()`的新函数：
- en: '[PRE37]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create an `if` statement for a `"win"` game event when the first level has
    been completed and transitions to level 2:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为在完成第一关并过渡到第二关时创建一个游戏胜利的`if`语句：
- en: '[PRE38]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `tostring()` method converts any argument to a string. In the preceding
    example, the `currentLevel` value changes from `1` to `2` when a `"win"` game
    event occurs. The value will convert to a string format that the `levelNum` text
    object can display on screen for level 2.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tostring()`方法将任何参数转换为字符串。在前面示例中，当发生`"win"`游戏事件时，`currentLevel`的值从`1`变为`2`。该值将转换为字符串格式，以便`levelNum`文本对象可以在屏幕上显示第二关的数字。'
- en: 'Add an `elseif` statement for a `"win"` game event when the second level has
    been completed and when it notifies the player that the game has been completed:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为在完成第二关时创建一个游戏胜利的`elseif`语句，并在通知玩家游戏已完成时：
- en: '[PRE39]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add another `elseif` statement for the `"lose"` game event at the first level.
    Reset the score to zero and replay level 1:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一级中为“lose”游戏事件添加另一个`elseif`语句。将分数重置为零，重新开始第一级：
- en: '[PRE40]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add another `elseif` statement for a `"lose"` game event at the second level.
    Reset the score to zero and replay level 2:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第二级的“lose”游戏事件添加另一个`elseif`语句。将分数重置为零，重新开始第二级：
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, add another `elseif` statement for `gameEvent = "completed"`. Close
    the function with `end`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为`gameEvent = "completed"`添加另一个`elseif`语句。用`end`结束函数：
- en: '[PRE42]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we need to backtrack and add an event listener to the `alertScreen()`
    function using the `alertBox` object. We will add it to the bottom of the function.
    This will activate the `restart()` function:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要回溯并在`alertScreen()`函数中使用`alertBox`对象添加一个事件监听器。我们将它添加到函数底部。这将激活`restart()`函数：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `restart()` function checks all the `gameEvent` and `currentLevel` variables
    that occur during game play. When a game event checks for the `"win"` string,
    it also goes down the list of statements to see what comes out true. For example,
    if the player wins and is currently on level 1, then the player moves on to level
    2.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart()`函数检查游戏过程中发生的所有`gameEvent`和`currentLevel`变量。当一个游戏事件检查到“win”字符串时，它也会继续执行下面的语句，看哪个为真。例如，如果玩家赢了且当前在第一级，那么玩家将进入第二级。'
- en: If the player loses, `gameEvent == "lose"` becomes true, and the code checks
    what level the player lost in. For any level the player loses in, the score reverts
    to 0, and the current level the player was on is set up again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家输了，`gameEvent == "lose"`变为真，代码会检查玩家在哪个级别输掉。无论玩家在哪个级别输掉，分数都会重置为0，并且玩家所在的当前级别将重新设置。
- en: Activating event listeners
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活事件监听器
- en: The event listeners in this game basically turn the movements of the objects
    on and off. We have already coded the functions that carry out the actions of
    our game objects to run the level. Now, it's time to activate them using a certain
    type of events. As you've noticed from the previous chapter, we can add event
    listeners to display objects or have them run globally.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏中的事件监听器基本上控制了物体的运动开关。我们已经编写了执行游戏对象动作的函数来运行级别。现在是时候通过特定类型的事件来激活它们了。正如你在前一章注意到的，我们可以向显示对象添加事件监听器，或者让它们全局运行。
- en: Collision events
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞事件
- en: 'Collision events within the physics engine occur through Corona''s event listener
    model. There are three new event types, which are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎中的碰撞事件通过Corona的事件监听器模型发生。有三个新的事件类型，如下所示：
- en: '`"collision"`: This event includes phases for `"began"` and `"ended"`, which
    signify the moments of initial contact and broken contact. These phases exist
    for both normal two-body collisions and body-sensor collisions. If you do not
    implement a `"collision"` listener, this event will not fire.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"collision"`：此事件包括`"began"`和`"ended"`阶段，分别表示初次接触和接触断开时刻。这些阶段适用于正常的两物体碰撞和物体传感器碰撞。如果你没有实现`"collision"`监听器，此事件将不会触发。'
- en: '`"preCollision"`: This is an event type that fires right before the objects
    start to interact. Depending on your game logic, you may wish to detect this event
    and conditionally override the collision. It may also result in multiple reports
    per contact and affect the application''s performance.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"preCollision"`：这是一个在物体开始交互之前触发的事件类型。根据你的游戏逻辑，你可能希望检测此事件并有条件地覆盖碰撞。它也可能导致每个接触点多次报告，影响应用程序的性能。'
- en: '`"postCollision"`: This is an event type that fires right after the objects
    have interacted. This is the only event in which the collision force is reported.
    If you do not implement a `"postCollision"` listener, this event will not fire.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"postCollision"`：这是一个在物体交互后立即触发的事件类型。这是唯一一个报告碰撞力的事件。如果你没有实现`"postCollision"`监听器，此事件将不会触发。'
- en: Collisions are reported between pairs of objects and can be detected either
    globally, using a runtime listener, or locally within an object, using a table
    listener.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞事件在对象对之间报告，可以通过运行时监听器全局检测，或者在对象内部使用表监听器本地检测。
- en: Global collision listeners
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局碰撞监听器
- en: When detected as a runtime event, each collision event includes `event.object1`,
    which contains the table ID of the Corona display object involved.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为运行时事件检测时，每个碰撞事件包括`event.object1`，其中包含涉及到的Corona显示对象的表ID。
- en: 'Here is an example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Local collision listeners
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地碰撞监听器
- en: When detected with a table listener within an object, each collision event includes
    `event.other`, which contains the table ID of the other display object involved
    in the collision.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当在对象内部使用表监听器检测时，每个碰撞事件都包括`event.other`，其中包含参与碰撞的另一个显示对象的表ID。
- en: 'Here is an example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Time for action – adding game listeners
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加游戏监听器
- en: 'For many of the functions we have created for our game objects, we need to
    activate the event listeners so that they will run the code and then disable them
    when game play has stopped. To add game listeners, follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们为游戏对象创建的许多功能，我们需要激活事件监听器，以便它们能够运行代码，并在游戏停止时禁用它们。要添加游戏监听器，请按照以下步骤操作：
- en: 'The last function we need to create in order to complete this game is called
    `gameListeners()`, which will also have a parameter called `event`. This should
    be added right after the `gameLevel2()` function:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个游戏，我们需要创建的最后一个函数叫做`gameListeners()`，它还将有一个名为`event`的参数。这应该在`gameLevel2()`函数之后直接添加：
- en: '[PRE46]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add in the following event listeners that will start several events in the
    application, using an `if` statement:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下事件监听器，它们将使用`if`语句在应用程序中启动多个事件：
- en: '[PRE47]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we''ll add in an `elseif` statement for the event listeners that will
    remove the events and then close the function:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为事件监听器添加一个`elseif`语句，以移除事件并关闭函数：
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order for `function gameListeners()` to work properly, we need to instantiate
    it in the `startGame()` function using the `"add"` string in the parameter. Place
    it before the end of the function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`function gameListeners()`正常工作，我们需要在`startGame()`函数中使用参数中的`"add"`字符串对其进行实例化。将其放在函数末尾之前：
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `alertScreen()` function, add the `"remove"` string in the parameter
    and place it at the start of the function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`alertScreen()`函数中，将`"remove"`字符串添加到参数中，并将其放在函数开始处：
- en: '[PRE50]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: All the code has been written! Go ahead and run the game in the simulator. The
    application is also device ready. Make a simple icon image that fits the required
    dimensions for the device you're developing on. Compile a build and run it on
    your device.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有代码都已经编写完成！继续在模拟器中运行游戏。该应用程序也适用于设备。为你正在开发的设备制作一个符合所需尺寸的简单图标图像。编译构建并在你的设备上运行。
- en: '*What just happened?*'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'There are two sets of `if` statements for the `event` parameter: `"add"` and
    `"remove"`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`event`参数，有两个`if`语句集：`"add"`和`"remove"`。
- en: All the event listeners in this function play an important role in making the
    game run. The `"accelerometer"` and `"enterframe"` events are used as runtime
    events since they have no specific target.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的所有事件监听器在使游戏运行方面都起着重要作用。`"accelerometer"`和`"enterframe"`事件被用作运行时事件，因为它们没有特定的目标。
- en: Both the `paddle` and `ball` objects have `"collision"` events that will carry
    out their purpose in any object contact made.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`挡板`和`球`对象都具有`"collision"`事件，在任何对象接触时都会执行其功能。'
- en: The `"touch"` event allows the user to touch and drag the paddle so that it
    can move back and forth in the simulator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`"touch"`事件允许用户触摸并拖动挡板，使其在模拟器中来回移动。'
- en: Notice that when `event == "remove"`, it removes all the event listeners that
    were active in the game. When the game starts, `gameListeners("add")` is activated.
    When a win or lose condition is achieved, `gameListeners("remove")` is activated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`event == "remove"`时，它会移除游戏中所有活动的事件监听器。当游戏开始时，`gameListeners("add")`会被激活。当达到胜利或失败条件时，`gameListeners("remove")`会被激活。
- en: Have a go hero – let's turn everything upside down
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下吧——让我们将一切颠倒过来
- en: What if we decided to flip the game upside down, that is, have the paddle placed
    near the top of the screen, the ball below the paddle, and the group of bricks
    closer to the bottom of the screen?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将游戏上下颠倒，也就是说，将挡板放置在屏幕顶部附近，球在挡板下方，砖块组靠近屏幕底部，该怎么办？
- en: 'Things you''ll have to consider are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的事情如下：
- en: The top wall is now the area you have to keep the ball from entering
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在顶部墙壁是你必须防止球进入的区域
- en: The *y* direction is where the ball travels when it collides with the bricks
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球与砖块碰撞时，*y*方向是球移动的方向
- en: The ball has to reflect off the bottom wall when it collides with it
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球与底部墙壁碰撞时，它必须从底部墙壁反射回来
- en: As you can see, there are a couple of things to consider before switching values
    from negative to positive and vice versa. Be sure to verify your logic and ensure
    that it makes sense when creating this new variation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在将值从负数切换到正数以及反之之前，有一些事情需要考虑。在创建这个新变体时，请确保验证你的逻辑，并确保它是有意义的。
- en: The results are in!
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果出来了！
- en: Let's summarize what has been made to make sure that you have everything added
    into your game. You can also refer to the `Breakout Final` folder in the `Chapter
    4` folder to see the final code. You made sure that the necessary variables were
    introduced in the game. You also initialized the `main()` function that starts
    the game play. A main menu screen was implemented with the game title and a play
    button.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下你所做的工作，确保你的游戏中已经包含了所有内容。你也可以参考`Chapter 4`文件夹中的`Breakout Final`文件夹，查看最终的代码。你确保了在游戏中引入了必要的变量。你还初始化了启动游戏玩的`main()`函数。实现了一个主菜单屏幕，带有游戏标题和一个播放按钮。
- en: Next, you transitioned the `menuScreenGroup` away from the screen to load the
    main playing field. The main display objects of the game, such as the paddle,
    ball, and bricks, were added. The score and level number were displayed as the
    UI elements and updated throughout game play. Paddle movement in both the simulator
    and accelerometer were added as well as the collision detection with the paddle
    and the ball.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将`menuScreenGroup`从屏幕上移开，加载主游戏区域。添加了游戏的主要显示对象，如挡板、球和砖块。分数和关卡数作为UI元素显示并在游戏过程中更新。还添加了模拟器和加速度计中的挡板移动以及挡板和球的碰撞检测。
- en: The physical properties of the paddle and ball were added at the start of the
    game. The brick layouts for each of the two levels were created. You have also
    added event listeners to all our game objects from the point when they need to
    be activated during the game and removed when game play is over.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时添加了挡板和球的物理属性。为两个关卡创建了砖块布局。你还在游戏对象需要激活时添加了事件监听器，并在游戏结束时移除。
- en: Every time the ball collides with a brick, the brick is removed from the scene.
    The directional changes of the ball are updated for every wall, paddle, or brick
    collision made. Every time a win or lose condition occurred, all game objects
    are reset to begin the start of the current or new level.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当球与砖块碰撞，砖块就会从场景中移除。球的方向变化在每次与墙壁、挡板或砖块碰撞后都会更新。每当出现赢或输的条件时，所有游戏对象都会重置，以便开始当前或新关卡。
- en: When a condition occurs, an alert screen pops up, notifying the player of what
    has happened. The display objects that initiate the alerts are created in a function.
    Finally, the win and lose arguments are created to determine whether the current
    level has to be replayed, whether the player goes to the next level, or whether
    the game has been completed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生某个条件时，会弹出一个警告屏幕，通知玩家发生了什么。触发警告的显示对象是在一个函数中创建的。最后，创建了赢和输的参数，以确定是否需要重玩当前关卡，玩家是否进入下一关，或者游戏是否已经完成。
- en: Beware of case-sensitive variables and functions in case you run into errors.
    Also, be sure to check whether you're missing any punctuation required in your
    code. These can be easily overlooked. Refer to your terminal window in the simulator
    for any error references.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意大小写敏感的变量和函数，以免遇到错误。同时，确保你没有遗漏代码中所需的标点符号。这些容易被忽视。如果在模拟器中遇到错误，请参考终端窗口中的错误引用。
- en: Pop quiz – working with game controls
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验——使用游戏控制
- en: Q1\. How do you properly remove a display object from the stage?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你应该如何正确地从舞台中移除一个显示对象？
- en: '`remove()`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`remove()`'
- en: '`object: remove()`'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object: remove()`'
- en: '`object:removeSelf()`'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object:removeSelf()`'
- en: '`object = nil`'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`object = nil`'
- en: None of the above.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: Q2\. What is the correct way to make the following display object into a physics
    object?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 将以下显示对象转换为物理对象正确的方法是什么？
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`physics.addBody( ball, { density=2.0, friction=0.5, bounce=0.2,radius = 25
    })`'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`physics.addBody( ball, { density=2.0, friction=0.5, bounce=0.2,radius = 25
    })`'
- en: '`physics.addBody( ball, "dynamic", { density=2.0, friction=0.5, bounce=0.2,radius
    = 15 } )`'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`physics.addBody( ball, "dynamic", { density=2.0, friction=0.5, bounce=0.2,radius
    = 15 } )`'
- en: 1and 2`.`
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1and 2`.（这一行似乎不完整，但按照要求保留原文）'
- en: None of the above.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: Q3\. What best represents what `"began"` means in the following function?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 在以下函数中，`"began"`一词的最佳解释是什么？
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A finger was moved on the screen.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手指在屏幕上移动。
- en: A finger was lifted from the screen.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个手指从屏幕上抬起。
- en: The system cancelled tracking the start touch.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统取消了开始触摸的跟踪。
- en: A finger touched the screen.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个手指触摸了屏幕。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You have completed making your very first game! You should
    be very proud of yourself. Now, you have experienced how simple it is to make
    an application with Corona SDK. It can take just a few hundred lines of code to
    make an application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经完成了你的第一个游戏制作！你应当为自己感到非常骄傲。现在，你已经体验到了使用 Corona SDK 制作应用程序有多么简单。只需几百行代码就能制作一个应用程序。
- en: 'In this chapter, we did the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了以下工作：
- en: Added movement to the paddle with touch events
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为挡板添加了触摸事件移动
- en: Introduced the accelerometer features
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了加速度计功能
- en: Implemented collision event listeners for all game objects affected
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有受影响的游戏对象实现了碰撞事件监听器
- en: Removed objects from memory when they weren't needed on the game screen
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当游戏屏幕不再需要对象时，从内存中移除它们
- en: Implemented movement of the ball as a physical object
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将球的移动实现为物理对象
- en: Updated a scoreboard for every brick collision
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新了每次砖块碰撞的计分板
- en: Learned how to handle win and lose conditions
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何处理胜利和失败的条件
- en: The last two chapters weren't so bad now, were they? You're getting familiar
    with the workflow as you continue programming in Lua. It will definitely get easier
    to understand as long as you keep progressing and working with different game
    frameworks.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两章并没有那么糟糕，不是吗？随着你继续使用 Lua 编程，你会越来越熟悉工作流程。只要你不断进步并与不同的游戏框架合作，理解起来肯定会更加容易。
- en: The next chapter holds another game that will surely catch your attention. You'll
    create animated sprite sheets for your display objects. How's that for eye candy?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍另一个肯定会吸引你注意的游戏。你将为你的显示对象创建动画精灵表。这对视觉来说是不是很棒？
