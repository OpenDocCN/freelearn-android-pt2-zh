- en: Chapter 2. Application Building Blocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 应用程序构建块
- en: 'This chapter focuses on the building blocks of an Android application, namely,
    the application components and the inter-component communication. There are four
    types of components in the Android system: Activities, Services, Broadcast Receivers,
    and Content Providers. Each component is specially designed to accomplish a specific
    task. A collection of these components makes an Android application. These components
    talk to each other using Intents which is Android''s mechanism for inter-process
    communication.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节关注Android应用程序的构建块，即应用程序组件和组件间通信。Android系统中有四种类型的组件：活动（Activities）、服务（Services）、广播接收器（Broadcast
    Receivers）和内容提供器（Content Providers）。每个组件都特别设计用来完成一个特定任务。这些组件的集合构成了一个Android应用程序。这些组件通过Intents进行相互通信，Intents是Android的跨进程通信机制。
- en: There are several books that discuss how to build Android components and Intents.
    In fact, the Android developer website does a pretty good job introducing programming
    using these components as well. So in this chapter, instead of covering the implementation
    details, our objective is to discuss the security aspects of each component and
    how to define and use component and Intents securely in an application to protect
    our reputation as a developer and the privacy of our consumers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有几本书讨论了如何构建Android组件和Intents。实际上，Android开发者网站在介绍使用这些组件进行编程方面也做得相当不错。因此，在本章中，我们不是要涵盖实施细节，而是要讨论每个组件的安全方面，以及如何在应用程序中定义和使用组件及Intents，以保护我们作为开发者的声誉和消费者的隐私。
- en: Components and Intents are the focus of this chapter. For each Android component,
    we will cover component declaration, permissions associated with the component,
    and other security considerations specific to that particular component. We will
    discuss different types of Intents and the best Intent to use in a particular
    context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的重点是组件和Intents。对于每个Android组件，我们将涵盖组件声明、与组件相关的权限以及特定于该组件的其他安全考虑。我们将讨论不同类型的Intents以及在不同情境下最佳Intents的使用。
- en: Application components
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: As we have briefly touched in [Chapter 1](ch01.html "Chapter 1. The Android
    Security Model – the Big Picture"), *Android Security Model – the Big Picture*,
    an Android application is a loosely bound stack of application components. Application
    components, manifest file, and application resources are packaged in an **Application
    Package Format** `.apk` file. An **APK** file is essentially a ZIP file formatted
    in JAR file format. The Android system only recognizes the APK format, so all
    packages have to be in the APK format to be installed on the Android device. An
    APK file is then signed with the developer's signature to assert the authorship.
    The `PackageManager` class handles the task of installing and uninstalling the
    application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章. Android安全模型 - 大蓝图")简要提及的，*Android安全模型 - 大蓝图*，一个Android应用程序是由一系列松散绑定的应用组件组成的。应用组件、清单文件以及应用资源被打包在一个**应用包格式**
    `.apk` 文件中。一个**APK**文件本质上是一个采用JAR文件格式的ZIP文件。Android系统只识别APK格式，因此所有要安装在Android设备上的包都必须是APK格式。APK文件随后使用开发者的签名进行签名，以确认作者身份。`PackageManager`
    类负责安装和卸载应用程序的任务。
- en: In this section, we will talk about the security of each of the components in
    detail. This includes the declaration of a component in the manifest file, so
    we prune loose ends and other security considerations that are unique to each
    component.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细讨论每个组件的安全性。这包括在清单文件中声明组件，因此我们会梳理掉松散的结尾以及其他针对每个组件的独特安全考虑。
- en: Activity
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: An Activity is the application component that usually interacts with the user.
    An Activity extends the `Activity` class and is implemented as views and fragments.
    Fragments were introduced in **Honeycomb** to address the issue of different screen
    sizes. On a smaller screen, a fragment is shown as a single Activity and allows
    the user to navigate to the second Activity to display the second fragment. Fragments
    and threads spun by an Activity run in the context of the Activity. So if the
    Activity is destroyed, the fragments and threads associated with it will be destroyed
    as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 活动是通常与用户交互的应用程序组件。活动扩展了 `Activity` 类，并作为视图和片段实现。片段是在**Honeycomb**中引入的，以解决不同屏幕尺寸的问题。在较小的屏幕上，一个片段显示为一个单一的活动，并允许用户导航到第二个活动以显示第二个片段。片段和活动启动的线程在活动的上下文中运行。因此，如果活动被销毁，与其相关的片段和线程也将被销毁。
- en: An application can have several activities. It is best to use an Activity to
    focus on a single task and to create different activities for individual tasks.
    For example, if we are creating an application that lets users order books on
    a website, it is best to create an Activity to log the user in, another Activity
    for searching books in the database, another Activity for entering ordering information,
    another one for entering payment information, and so on. This style encourages
    Activity reuse within the application and by other applications installed on the
    device. The reuse of components has two major benefits. First, it helps to reduce
    bugs, as there is less duplication of code. Second, it makes the application more
    secure as there is less sharing of data between different components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个活动。最好使用一个活动专注于单一任务，并为各个任务创建不同的活动。例如，如果我们正在创建一个让用户在网站上订购书籍的应用程序，最好创建一个用于用户登录的活动，另一个用于在数据库中搜索书籍的活动，另一个用于输入订购信息，再一个用于输入支付信息，等等。这种风格鼓励在应用程序内以及设备上安装的其他应用程序中重用活动。组件的重用有两个主要好处。首先，它有助于减少错误，因为代码重复较少。其次，它使应用程序更安全，因为不同组件之间的数据共享较少。
- en: Activity declaration
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动声明
- en: 'Any Activity that an application uses has to be declared in the `AndroidManifest.xml`
    file. The following code snippet shows a login Activity and an order Activity
    declared in the manifest file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用的任何活动都必须在`AndroidManifest.xml`文件中声明。以下代码段显示了在清单文件中声明的登录活动和订单活动：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that `LoginActivity` is declared as a public Activity that may be launched
    by any other Activity in the system. The `OrderActivity` is declared as a private
    Activity (an Activity with no Intent filters is a private Activity to be invoked
    only by specifying its exact filename) that is not exposed outside the application.
    An additional `android:exported` tag can be used to specify if it is visible outside
    the application. A value of `true` makes the Activity visible outside the application,
    and a value of `false` does otherwise. The Intent Filter is discussed later in
    this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`LoginActivity`被声明为一个公共活动，可以被系统中的任何其他活动启动。`OrderActivity`被声明为一个私有活动（没有意图过滤器的活动是一个私有活动，只能通过指定其确切的文件名来调用）。此外，可以使用`android:exported`标签指定它是否对应用程序外部可见。值为`true`使活动在应用程序外部可见，值为`false`则相反。本章稍后将讨论意图过滤器（Intent
    Filter）。
- en: All the Activities can be secured by permissions. In the preceding example,
    the `OrderActivity,` besides being private, is also protected by a permission
    `com.example.project.ORDER_BOOK`. Any component that tries to invoke `OrderActivity`
    should have this custom permission to invoke it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的活动都可以通过权限进行保护。在上述示例中，除了是私有的，`OrderActivity`还受到权限`com.example.project.ORDER_BOOK`的保护。任何尝试调用`OrderActivity`的组件都应该具有此自定义权限才能调用它。
- en: Usually, whenever an Activity is launched, it runs in the process of the application
    that declared it. Setting the `android:multiprocess` attribute to `true` lets
    an Activity run in a process different from the application. These process specifics
    can be defined using the `android:process` attribute. If the value of this attribute
    starts with a colon (`:`), a new process private to the application is created;
    if it starts with a lowercase character, the Activity runs in a global process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，每当启动一个活动时，它都会运行在声明它的应用程序进程中。将`android:multiprocess`属性设置为`true`可以让活动运行在一个与应用程序不同的进程中。这些进程的具体设置可以通过使用`android:process`属性来定义。如果此属性的值以冒号（`:`）开头，将为应用程序创建一个新的私有进程；如果以小写字母开头，则活动将在全局进程中运行。
- en: The `android:configChanges` tag lets the application handle Activity restarts
    due to listed configuration changes. Such changes include changes in locale, plugging
    an external keyboard, and SIM changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:configChanges`标签允许应用程序处理由于列出的配置更改而重新启动活动。这样的更改包括本地化更改、插入外部键盘和SIM卡更改。'
- en: Saving the Activity state
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存活动状态
- en: All the Activities are managed by the system in the **activity stack**. The
    Activity currently interacting with the user runs in the foreground. The current
    Activity can then launch other Activity. Any Activity that is in the background
    may be killed by the Android system due to resource constraints. An Activity may
    also be restarted during configuration changes such as change in orientation from
    vertical to horizontal. As mentioned in the preceding section, an Activity can
    use the `android:configChanges` tag to handle some of these events itself. It
    is not encouraged as it may lead to inconsistencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过**活动栈**管理所有活动（Activities）。当前与用户交互的活动在前台运行。当前活动可以启动其他活动。由于资源限制，处于后台的任何活动都可能被Android系统杀死。在配置更改（例如从垂直方向更改为水平方向）期间，活动也可能被重新启动。如前一部分所述，活动可以使用`android:configChanges`标签自行处理其中一些事件。不建议这样做，因为它可能导致不一致。
- en: 'The state of the Activity should be preserved before a restart happens. The
    lifecycle of an Activity is defined by the following methods:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动之前，应该保存活动（Activity）的状态。活动的生命周期由以下方法定义：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An Activity may override `onSaveInstanceState(Bundle savedInstanceState)` and
    `onRestoreInstanceState(Bundle savedInstanceState)`, to save and restore the instance
    values such as user preferences and unsaved text. The Android developer website,
    [http://www.developer.android.com](http://www.developer.android.com), illustrates
    this process beautifully with the following flowchart:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 活动可以重写`onSaveInstanceState(Bundle savedInstanceState)`和`onRestoreInstanceState(Bundle
    savedInstanceState)`方法，以保存和恢复例如用户偏好和未保存文本的实例值。Android开发者网站 [http://www.developer.android.com](http://www.developer.android.com)
    使用以下流程图精美地说明了这个过程：
- en: '![Saving the Activity state](img/5603OT_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![保存活动状态](img/5603OT_02_01.jpg)'
- en: The following code snippet shows how an Activity may store and retrieve the
    preferred language, number of search results, and author name. User preferences
    are stored as a **Bundle**, which stores name-value pairs, when the Activity is
    killed. When the Activity restarts, this Bundle is passed to the `onCreate` method,
    which restores the Activity state. It is important to note that this method of
    storage does not persist application restarts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了活动（Activity）如何存储和检索首选语言、搜索结果数量和作者名称。当活动被销毁时，用户偏好作为**Bundle**存储，它存储名称-值对。当活动重新启动时，这个Bundle会被传递给`onCreate`方法，该方法恢复了活动的状态。需要注意的是，这种存储方法不会在应用程序重新启动后保持。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Saving user data
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存用户数据
- en: As we discussed earlier, the Activities interact with the users so they may
    collect some user data. The data could be private to the application or shared
    with others. An example of such data could be the user's preferred language or
    book category. This kind of data is generally retained by the application to enhance
    the user experience. It is useful within the application itself and is not shared
    with other applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所讨论的，活动（Activities）与用户交互，因此它们可能会收集一些用户数据。这些数据可能是应用程序私有的，也可能是与其他人共享的。这类数据的一个例子可能是用户的偏好语言或书籍类别。这种数据通常被应用程序保留以增强用户体验。它对应用程序本身有用，并且不与其他应用程序共享。
- en: An example of shared data could be the wish list of books that the user keeps
    adding to the collection as users browse through the store. This data may or may
    not be shared with other applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个共享数据的例子可能是用户在浏览商店时不断添加到收藏中的书籍愿望清单。这类数据可能与其他应用程序共享，也可能不共享。
- en: Based on the privacy and kind of data, a different storage mechanism can be
    employed. An application can decide to use `SharedPreferences,` Content Provider,
    a file stored on internal or external memory, or even on the developer's own website
    to store this type of data. Content providers are discussed in this chapter. Other
    persistent data storage mechanisms are discussed in detail in [Chapter 7](ch07.html
    "Chapter 7. Securing Application Data"), *Securing Application Data*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据的隐私性和类型，可以采用不同的存储机制。应用程序可以决定使用`SharedPreferences`、内容提供者、内部或外部存储的文件，甚至是开发者自己的网站来存储这类数据。本章将讨论内容提供者。其他持久性数据存储机制将在[第7章](ch07.html
    "第7章. 保护应用程序数据")《保护应用程序数据》中详细讨论。
- en: Service
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务（Service）
- en: Unlike Activities, Services lack a visual interface and are used in the background
    for long running tasks. Ideally, a Service should keep running in the background
    even when the Activity that started it no longer exists. When the task is completed,
    a Service should stop by itself. Examples of tasks best suited for a Service are
    syncing with database, uploading or downloading files from the network, interacting
    with the music player to play tracks selected by the user, and global services
    that applications can bind to for information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动（Activities）不同，服务（Services）没有视觉界面，主要用于后台长时间运行的任务。理想情况下，即使启动它的活动（Activity）不再存在，服务也应该在后台继续运行。任务完成后，服务应该自行停止。适合使用服务执行的任务例如与数据库同步、从网络上传或下载文件、与音乐播放器交互以播放用户选择的曲目，以及应用程序可以绑定获取信息的全局服务。
- en: Securing a Service starts with the Service declaration in the manifest file.
    Next it is important to identify the correct Service for a use case and manage
    the lifecycle of a Service. This includes starting and stopping a Service and
    creating a worker thread to avoid blocking the application. In the next few sections,
    we will walk through each of these aspects. The last section of the chapter is
    about binders, which is the backbone for most of Android's IPC and enables the
    Service to be used in a client-server fashion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 保护服务的第一步是在清单文件中声明服务。接下来，识别正确服务用例并管理服务生命周期非常重要。这包括启动和停止服务，并创建工作线程以避免阻塞应用程序。在接下来的几节中，我们将逐一介绍这些方面。本章的最后一节是关于绑定器（binders），它是大多数Android进程间通信（IPC）的基础，并使服务能够以客户端-服务器的方式使用。
- en: Service declaration
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务声明
- en: 'All the Services that an application plans to start need to be declared in
    the manifest file. The Service declaration defines how a Service, once created,
    will run. The syntax of the `<service>` tag in the manifest file is shown in the
    following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序计划启动的所有服务都需要在清单文件中声明。服务声明定义了一旦创建服务后，它将如何运行。清单文件中`<service>`标签的语法在以下代码段中展示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Based on the preceding declaration syntax, a Service that is private to the
    application, and runs in its global process to store books in the database, can
    be declared as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述声明语法，一个私有的、在全局进程中运行以将书籍存储在数据库中的应用程序服务可以如下声明：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, a Service runs in the global process of the application. In case
    an application wants to start a Service in a different process, it may do so using
    the attribute `android:process`. If the value of this attribute starts with a
    colon (`:`), the Service starts in a new private process within the application.
    If the value starts with a lowercase, a new global process is created that is
    visible and accessible to all applications of the Android system. In the preceding
    example, the Service runs in its own global process. The application should have
    permissions to create such a process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务在应用程序的全局进程中运行。如果应用程序想要在不同的进程中启动服务，可以使用`android:process`属性。如果此属性的值以冒号（`:`）开头，服务将在应用程序内的新私有进程中启动。如果值以小写字母开头，将创建一个新的全局进程，该进程对Android系统的所有应用程序可见和可访问。在上述示例中，服务在其自己的全局进程中运行。应用程序应该有权限创建此类进程。
- en: This `android:enabled` attribute defines if the Service can be instantiated
    by the system or not. The default value is `true`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`android:enabled`属性定义了系统是否可以实例化服务。默认值为`true`。
- en: The `android:exported` attribute limits the exposure of the Service. A value
    of `true` means that this Service is visible outside the application. If the Service
    contains an Intent Filter then the Service is visible to other applications. The
    default value of this attribute is `true`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:exported`属性限制了服务的暴露。值为`true`意味着此服务对应用程序外部可见。如果服务包含意图过滤器（Intent Filter），则该服务对其他应用程序可见。此属性的默认值为`true`。'
- en: To run the Service in an isolated process, devoid of all permissions, set the
    `android:isolatedProcess` attribute to `true`. In this case, the only way to interact
    with the Service is through binding to the Service. The default value of this
    attribute is `false`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在隔离的进程中运行服务，且没有任何权限，请将`android:isolatedProcess`属性设置为`true`。在这种情况下，与服务交互的唯一方式是通过绑定到服务。此属性的默认值为`false`。
- en: As with Activities, Services can be protected by permissions. These services
    are declared in the manifest file using the `android:permission` attribute. The
    invoking components need to have proper permission to invoke the Service, otherwise
    a `SecurityException` is thrown from the call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动一样，服务可以通过权限进行保护。这些服务在清单文件中使用`android:permission`属性声明。调用组件需要有适当的权限来调用服务，否则从调用中抛出`SecurityException`。
- en: Service modes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务模式
- en: A Service can be used in two contexts. In the first case, a Service acts as
    a helper Service that a component can start to run long running tasks. Such a
    Service is called a **started service**. The second use case for a Service is
    as a provider of information to components of one or many applications. In this
    case, the Service runs in the background and the application components bind to
    the Service by calling `bindService ()`. Such a Service is called a **bound service**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以在两个上下文中使用。第一种情况是，服务作为一个辅助服务，组件可以启动它来运行长时间运行的任务。这样的服务被称为**启动服务**。服务的第二种用例是作为向一个或多个应用程序组件提供信息的服务。在这种情况下，服务在后台运行，应用程序组件通过调用`bindService()`来绑定服务。这样的服务被称为**绑定服务**。
- en: A started service extends either the `Service` class or the `IntentService`
    class. The main difference between the two approaches is the handling of multiple
    requests. When extending the `Service` class, the application needs to take care
    of handling multiple requests. This is done in the `onStartCommand()` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 启动的服务可以扩展`Service`类或`IntentService`类。这两种方法的主要区别在于处理多个请求的方式。当扩展`Service`类时，应用程序需要处理多个请求，这通过`onStartCommand()`方法完成。
- en: 'The `IntentService()` class makes it easier by queuing all the requests and
    processing them one at a time, so the developer does not need to take care of
    threading. If suitable for a use case, it is always better to use the `IntentService`
    class to avoid multithreading bugs. The `IntentService` class starts a worker
    thread for the task and requests are queued automatically. The task is done in
    `onHandleIntent` and that''s it! The following is an example of an `IntentService`
    class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService()`类通过排队所有请求并一次处理一个，从而简化了操作，因此开发者无需处理线程问题。如果适用于某种用例，最好使用`IntentService`类以避免多线程错误。`IntentService`类为任务启动一个工作线程，并且请求会自动排队。任务在`onHandleIntent`中完成，就是这样！以下是`IntentService`类的一个示例：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A bound service is the client server case where a Service acts as the server
    and clients bind to it for information. This is done using the `bindService()`
    method. When the clients are satisfied, they unbind themselves from the Service
    using `unbindService()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定服务是客户端服务器的情况，服务作为服务器，客户端绑定到它以获取信息。这是通过使用`bindService()`方法完成的。当客户端满意时，它们使用`unbindService()`从服务中解绑自己。
- en: A bound service can cater to components of one application or components of
    different applications. A bound service that only caters to one application component
    can extend the `Binder` class and implements the `onBind()` method which returns
    the `IBinder` object. If a Service caters to multiple applications, a messenger
    or **Android Interface Definition Language** (**AIDL**) tool can be used to generate
    interfaces published by a Service. Using a messenger is easier to implement as
    it takes care of multithreading.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定服务可以服务于一个应用程序的组件，也可以服务于不同应用程序的组件。仅服务于一个应用程序组件的绑定服务可以扩展`Binder`类并实现返回`IBinder`对象的`onBind()`方法。如果一个服务服务于多个应用程序，可以使用信使或**Android接口定义语言**（**AIDL**）工具来生成服务发布的接口。使用信使更容易实现，因为它处理多线程问题。
- en: When binding to a Service, it is important to check the identity of the Service
    that the Activity is binding to. This can be done by explicitly specifying the
    Service name. If the Service name is not available, the client can check the identity
    of the Service it is connected to using `ServiceConnection.onServiceConnected()`.
    Another method is to use permission checks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到一个服务时，检查活动绑定到的服务身份是非常重要的。这可以通过显式指定服务名称来完成。如果服务名称不可用，客户端可以使用`ServiceConnection.onServiceConnected()`来检查它所连接的服务的身份。另一种方法是使用权限检查。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a started service the `onBind()` method returns null.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于启动的服务，`onBind()`方法返回null。
- en: Lifecycle management
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期管理
- en: 'A Service can be started by any component using the `startService()` method
    and passing an Intent object as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何组件都可以通过使用`startService()`方法并传递一个Intent对象来启动一个服务，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just like any other component, a started service can also be destroyed by the
    Android system to gather resources for the process that the user is interacting
    with. In such a scenario, the Service will be restarted based on the return value
    set in the `onStartCommand` method. The following is an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他任何组件一样，启动的 Service 也可以被 Android 系统销毁，以便为用户交互的进程收集资源。在这种情况下，Service 将根据 `onStartCommand`
    方法中设置的返回值重新启动。以下是一个示例：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are three options for restarting a Service:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 Service 有以下三种选项：
- en: '`START_NOT_STICKY`: This option indicates the Android system not to restart
    the Service unless there are pending Intents. Pending Intents are discussed later
    in this chapter. This option is best for cases where an unfinished job can be
    safely restarted and finished later.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_NOT_STICKY`：这个选项表示除非有挂起的 Intent，否则 Android 系统不应重新启动 Service。挂起的 Intent
    在本章后面会讨论。这个选项最适合可以安全地稍后重新启动并完成未完成工作的场景。'
- en: '`START_STICKY`: This option indicates that a Service should be started by the
    system. If the initial Intent is lost, the `onStartCommand()` method is started
    with a null Intent. This is best for cases, where even if the initial Intent is
    lost, the Service can resume its task. An example is the music player that starts
    again once it is killed by the system.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_STICKY`：这个选项表示系统应该启动 Service。如果最初的 Intent 丢失，`onStartCommand()` 方法会以
    null Intent 的形式被启动。这对于即使初始 Intent 丢失，Service 也能恢复其任务的情况最为合适。例如音乐播放器，一旦被系统杀死，可以重新开始播放。'
- en: '`START_REDELIVER_INTENT`: In this option, the Service is restarted and the
    pending Intent is redelivered to the Service `onStartCommand()`. An example is
    downloading a file over the network.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_REDELIVER_INTENT`：在这种情况下，Service 会被重新启动，并且挂起的 Intent 会重新传递给 Service
    的 `onStartCommand()`。例如，通过网络下载文件。'
- en: It is important to note that a Service is different from creating a thread.
    A thread is killed immediately when the component that spun it is killed. A Service
    by default runs in the global application thread and remains alive even if the
    invoking component is destroyed. If the Service is doing some time consuming activity
    such as downloading a huge file, it is prudent to do it in a separate thread to
    avoid blocking the application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的是，Service 与创建线程是不同的。当启动线程的组件被销毁时，线程会立即被杀死。而默认情况下，Service 在全局应用线程中运行，即使调用它的组件被销毁，Service
    仍然保持存活。如果 Service 正在进行一些耗时操作，比如下载大文件，最好在一个单独的线程中进行，以避免阻塞应用程序。
- en: A started service runs in the application thread by default. Any blocking Activities
    should be done in a separate thread to avoid potential bottlenecks when running
    your application. The `IntentService` class takes care of this scenario by spawning
    a worker thread.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 启动的 Service 默认在应用线程中运行。任何可能阻塞的活动都应该在一个单独的线程中进行，以避免在运行应用程序时出现潜在的瓶颈。`IntentService`
    类通过生成一个工作线程来处理这种情况。
- en: Both kinds of started services should stop themselves by calling `stopSelf()`
    when the task has completed. Any component can stop the Service as well by using
    the method `stopService()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 两种启动服务都应该在任务完成后通过调用 `stopSelf()` 来停止自己。任何组件也可以通过使用 `stopService()` 方法来停止 Service。
- en: A bound service is destroyed by the system when no more clients are binding
    to it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的客户端绑定到 Service 时，系统会销毁绑定的服务。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A Service can be both started and bound. In this case, do not forget to call
    `stopSelf()` or `stopService()` to stop a Service from continuing to run in the
    background.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Service 可以被启动也可以被绑定。在这种情况下，不要忘记调用 `stopSelf()` 或 `stopService()` 来停止 Service
    在后台继续运行。
- en: Binder
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定器
- en: '**Binder** is the backbone of most of Android''s IPC. It is a kernel driver
    and all calls to Binder go through the kernel. The messenger is based on Binder
    as well. Binders can be confusing to implement and should only be used if the
    Service caters to multiple applications running in different processes and wants
    to handle multithreading itself. The Binder framework is integrated in the OS,
    so a process that intends to use a Service of another process needs to marshal
    the objects into primitives. The OS then delivers it across the process boundary.
    To make this task easier for developers, Android provides the AIDL. The following
    figure illustrates how Binder is the core of all Android IPC. A Binder is exposed
    by AIDL. Intents are implemented as Binders as well. But these intricacies are
    hidden from the user. As we move to bigger concentric circles, the implementation
    becomes more abstract.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Binder**是大多数Android IPC的核心。它是一个内核驱动程序，所有对Binder的调用都通过内核进行。信使也是基于Binder的。Binder的实现可能会令人困惑，只有当服务需要为在不同进程中运行的多应用程序提供服务，并希望自行处理多线程时，才应使用Binder。Binder框架集成在操作系统中，因此，如果一个进程打算使用另一个进程的服务，它需要将对象封送进基本类型。操作系统然后将它跨进程边界传递。为了使开发者的这项任务更加容易，Android提供了AIDL。下图说明了Binder是如何成为所有Android
    IPC的核心的。Binder通过AIDL暴露。意图也被实现为Binder。但这些复杂性对用户是隐藏的。随着我们向更大的同心圆移动，实现变得更加抽象。'
- en: '![Binder](img/5603OT_02_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Binder](img/5603OT_02_02.jpg)'
- en: To create a bounded service using AIDL, we first create the AIDL file. Then,
    using the Android SDK tools, we generate the interface. This interface contains
    the `stub` method that extends the `android.os.Binder` class and implements the
    `onTransact()` method. The client receives a reference to the Binder interface
    and calls its `transact()` method. Data flows through this channel as a `Parcel`
    object. A `Parcel` object is serializable so it can effectively cross process
    boundaries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用AIDL创建绑定服务，我们首先创建AIDL文件。然后，使用Android SDK工具，我们生成接口。这个接口包含扩展了`android.os.Binder`类并实现了`onTransact()`方法的`stub`方法。客户端接收Binder接口的引用，并调用其`transact()`方法。数据通过这个通道作为一个`Parcel`对象流动。`Parcel`对象是可序列化的，因此它可以有效地跨越进程边界。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The `Parcel` objects are defined for high performance IPC transport, so they
    should not be used for general-purpose serialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parcel`对象是为了高性能的IPC传输而定义的，因此它们不应用于通用目的的序列化。'
- en: If multiple processes are using the Service, beware not to change your AIDL
    once you have exposed it, as other applications might be using it as well. If
    this change is absolutely necessary then it should at least be backward compatible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个进程正在使用服务，请注意，一旦公开了AIDL，就尽量不要更改它，因为其他应用程序可能也在使用它。如果这种更改是绝对必要的，那么至少它应该是向后兼容的。
- en: Binders are globally unique in the system and references to binders can be used
    as a shared secret to verify a trusted component. It is always a good idea to
    keep Binders private. Anyone who has a reference to the Binder can make calls
    to it and can call the `transact()` method. It is up to the Service to respond
    to the request. For example, Zygote, the system Service, exposes a Binder that
    any Activity can bind to. But calling its `transact()` method does not mean it
    will be entertained.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Binder在系统中全局唯一，对Binder的引用可以用作验证可信组件的共享密钥。保持Binder私有始终是一个好主意。任何拥有Binder引用的人都可以调用它，并且可以调用`transact()`方法。由服务来响应请求。例如，Zygote，这个系统服务，公开了一个任何Activity都可以绑定的Binder。但是调用它的`transact()`方法并不意味着它会得到响应。
- en: Binder can run in the same process or different process based on the `android:process`
    attribute of the `<service>` tag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `<service>` 标签的 `android:process` 属性，Binder可以在同一进程或不同进程中运行。
- en: A Binder provides the identity of the calling component and its permission securely
    through the kernel. The identity of the caller can be checked using the methods
    `getCallingPid()` and `getCallingUid()` of the Binder. A Binder in turn can call
    other Binders which in this case can use the identity of the calling Binder. To
    check the permission of the caller, `Context.checkCallingPermission()` can be
    used. To check if the caller or Binder itself has a particular permission, `Context.checkCallingOrSelfPermission()`
    can be used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Binder通过内核安全地提供调用组件及其权限的身份。可以使用Binder的`getCallingPid()`和`getCallingUid()`方法来检查调用者的身份。Binder反过来可以调用其他Binder，在这种情况下，它们可以使用调用Binder的身份。要检查调用者的权限，可以使用`Context.checkCallingPermission()`。要检查调用者或Binder本身是否有特定权限，可以使用`Context.checkCallingOrSelfPermission()`。
- en: Content Provider
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容提供者
- en: Android system uses Content Providers for data storage such as contact list,
    calendar, and word dictionary. A Content Provider is Android's mechanism to handle
    structured data across process boundaries. It can be used within an application
    as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统使用内容提供者（Content Providers）来存储数据，如联系人列表、日历和字典。内容提供者是安卓跨进程边界处理结构化数据的机制，也可以在应用内使用。
- en: In most cases, the Content Provider's data is stored in the SQL database. The
    identifier `_id` is used as the primary key. As with SQL, users access data by
    writing queries. These can be `rawQuery()` or `query()` depending on whether they
    are raw SQL statements or structured queries. The return type of a query is a
    `Cursor` object that points to one of the rows of the results. Users can use helper
    methods such as `getCount()`, `moveToFirst()`, `isAfterLast()`, and `moveToNext()`
    to navigate multiple rows. `Cursor` needs to be closed using `close()` once the
    task is completed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，内容提供者的数据存储在SQL数据库中。标识符`_id`用作主键。与SQL一样，用户通过编写查询来访问数据。这些可以是`rawQuery()`或`query()`，具体取决于它们是原始SQL语句还是结构化查询。查询的返回类型是一个指向结果行之一的`Cursor`对象。用户可以使用辅助方法如`getCount()`、`moveToFirst()`、`isAfterLast()`和`moveToNext()`来导航多行。完成任务后，需要使用`close()`关闭`Cursor`。
- en: Providers support many different types of data including integer, long, float,
    double, and BLOB (Binary Large Object) implemented as a 64 KB array. Providers
    can also return standard or MIME types. An example of a standard MIME type is
    `text/html`. For custom MIME types, the value is always `vnd.android.cursor.dir`
    and `vnd.android.cursor.item` for multiple and single rows respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者支持许多不同类型的数据，包括整数、长整数、浮点数、双精度数以及作为64 KB数组实现的BLOB（二进制大对象）。提供者还可以返回标准或MIME类型。标准MIME类型的一个例子是`text/html`。对于自定义MIME类型，值总是`vnd.android.cursor.dir`和`vnd.android.cursor.item`，分别用于多行和单行。
- en: The following figure illustrates a Content Provider that can abstract a database,
    a file, or even a remote server. Other components of the application can access
    it. So can other application components, provided they have appropriate permissions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个可以抽象数据库、文件甚至远程服务器的内容提供者。应用程序的其他组件可以访问它，其他应用组件也可以访问，前提是它们具有适当的权限。
- en: '![Content Provider](img/5603OT_02_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![内容提供者](img/5603OT_02_03.jpg)'
- en: The following sections discuss the proper declaration of a provider, defining
    appropriate permissions, and avoiding common security pitfalls that are necessary
    for the secure access of provider data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将讨论正确声明提供者、定义适当的权限以及避免常见的安全陷阱，这些都是安全访问提供者数据所必需的。
- en: Provider declaration
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供者声明
- en: 'Any provider that the application wants to use has to be declared in the manifest
    file. The syntax of the `provider` tag is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序想要使用的任何提供者都必须在清单文件中声明。`provider`标签的语法如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Based on the preceding declaration syntax, a custom provider that maintains
    a list of books in the user's wish list can be declared as follows. The provider
    has read and write permissions and the client can request for temporary access
    to the path `/figures`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的声明语法，可以如下声明一个自定义提供者，用于维护用户愿望清单中的书籍列表。该提供者具有读写权限，客户端可以请求对`/figures`路径的临时访问。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The string `android:authorities` lists the providers exposed by an application.
    For example, if the URI of a provider is `content://com.example.android.books.contentprovider/wishlist/English`,
    `content://` is the scheme, `com.example.android.books.contentprovider` is the
    authority, and `wishlist/English` is the path. At least one authority has to be
    specified. Semicolons should separate multiple authorities. It should follow Java
    namespace rules to avoid conflicts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`android:authorities`列出了应用程序公开的提供者。例如，如果一个提供者的URI是`content://com.example.android.books.contentprovider/wishlist/English`，`content://`是方案，`com.example.android.books.contentprovider`是权限，而`wishlist/English`是路径。至少需要指定一个权限。如果有多权限，应该使用分号分隔。它应该遵循Java命名空间规则以避免冲突。
- en: The boolean `android:enabled` tag specifies that the system can initiate the
    provider. If the value is true, the system can. A value false does not let the
    system initiate the provider. It is important to note that both the `android:enabled`
    attributes, one in the `<application>` tag and the other in the `<provider>` tag,
    need to be true for this to happen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔型标签`android:enabled`指定系统可以启动提供者。如果值为true，系统可以启动。如果值为false，系统则不能启动提供者。需要注意的是，为了实现这一点，`<application>`标签和`<provider>`标签中的`android:enabled`属性都需要为true。
- en: If the provider is published to other applications, `android:exported` is set
    to true. The default value is true for applications with `android:targetSdkVersion`
    or `android:minSdkVersion` set to 16 or lower. For all other applications, the
    default value is false.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供商被发布给其他应用程序，`android:exported`会被设置为true。对于将`android:targetSdkVersion`或`android:minSdkVersion`设置为16或更低的应用程序，默认值为true。对于所有其他应用程序，默认值是false。
- en: The attribute tag `android:grantUriPermissions` is used to provide one time
    access to data that is protected by permissions otherwise and is not accessible
    by the component. This facility, if set to `true`, lets the component overcome
    the restrictions imposed by the `android:readPermission`, `android:writePermission`,
    and `android:permission` attributes and will allow access to any of Content Provider's
    data. If this attribute is set to `false` then permissions can only be granted
    to datasets listed in the `<grant-uri-permission>` tag. The default value of this
    tag is false.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 属性标签`android:grantUriPermissions`用于提供一次性访问受权限保护的数据，否则该数据无法被组件访问。如果此功能设置为`true`，则允许组件绕过`android:readPermission`、`android:writePermission`和`android:permission`属性施加的限制，并允许访问内容提供商的任何数据。如果此属性设置为`false`，则权限只能授予`<grant-uri-permission>`标签中列出的数据集。此标签的默认值为false。
- en: The integer `android:initOrder` is the order in which a provider is initialized.
    The higher the number, the earlier it is initialized. This attribute is of particular
    importance if there are dependencies in the providers of an application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 整数`android:initOrder`是提供商初始化的顺序。数字越大，初始化越早。如果应用程序中的提供商之间存在依赖关系，这个属性特别重要。
- en: The string `android:label` is the user-readable label for the Content Provider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`android:label`是内容提供商的用户可读标签。
- en: The boolean `android:multiprocess` attribute, if set to true, lets the system
    create an instance of the provider in each application's process that interacts
    with it. This avoids the overhead of inter-process communication. The default
    value is false which means that the provider is instantiated only in the application
    process that defined it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值`android:multiprocess`属性，如果设置为true，允许系统在每个与应用程序交互的应用程序进程中创建提供商的实例。这样可以避免进程间通信的开销。默认值为false，意味着提供商仅在定义它的应用程序进程中实例化。
- en: The string `android:permission` tag declares the permissions that a client should
    have to interact with the provider.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`android:permission`标签声明了客户端应具备的与提供商交互的权限。
- en: The string `android:readPermission` and string `android:writePermission` define
    permissions that the client should have to read and write provider data respectively.
    If defined, these permission supersede the `android:permission` value. It is interesting
    to note that although the string `android:writePermission` allows only writes
    on the database, it usually uses a `WHERE` clause and a smart engineer can work
    around these to read the database. So write permission should be regarded as read
    permission as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`android:readPermission`和字符串`android:writePermission`分别定义了客户端应具备的读取和写入提供商数据的权限。如果定义了这些权限，它们将覆盖`android:permission`的值。值得注意的是，尽管字符串`android:writePermission`只允许对数据库进行写操作，但它通常会使用`WHERE`子句，一个聪明的工程师可以绕过这些来读取数据库。因此，写权限也应被视为读权限。
- en: The `android:process` attribute defines the process in which the provider should
    run. Usually, the provider runs in the same process as the application. However,
    if it is required to run the process in a separate private process, it can be
    assigned a name starting with a colon (`:`). If the name begins with a lowercase
    character, the provider is instantiated in a global process to enable cross application
    sharing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:process`属性定义了提供商应该运行在哪个进程中。通常，提供商运行在与应用程序相同的进程中。但是，如果需要将进程运行在单独的私有进程中，可以分配一个以冒号（`:`）开头的名称。如果名称以小写字母开头，则提供商将在全局进程中实例化，以实现跨应用程序共享。'
- en: The `android:syncable` attribute allows data to sync to the server by setting
    the value to `true`. A value of `false` does not let data sync to the server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:syncable`属性通过设置为`true`允许数据同步到服务器。值为`false`时不允许数据同步到服务器。'
- en: A `<provider>` tag can contain three sub tags.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`<provider>`标签可以包含三个子标签。'
- en: 'The first is `<grant-uri-permission>` with the following syntax:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是具有以下语法的`<grant-uri-permission>`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The other is the `<path-permission>` tag with the following syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是具有以下语法的`<path-permission>`标签：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The third is the `<meta-data>` tag that defines the metadata associated with
    the provider as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是`<meta-data>`标签，它定义了与提供商相关的元数据，如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To provide with provider level single read and write, use `android:readPermission`
    and `android:writePermission` respectively. To provide blanket provider level
    read/write permissions, use the `android:permission` attribute. To enable temporary
    permissions, set the `android:grantUriPermissions` attribute. You can also use
    the `<grant-uri-permission>` child element for the same. To enable path level
    permission, use the `<path-permission>` child element of `<provider>`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供提供者级别的单一读写权限，分别使用`android:readPermission`和`android:writePermission`。要提供提供者级别的全面读写权限，请使用`android:permission`属性。要启用临时权限，请设置`android:grantUriPermissions`属性。你也可以使用`<grant-uri-permission>`子元素来实现同样的功能。要启用路径级别的权限，请使用`<provider>`的`<path-permission>`子元素。
- en: Other security consideration
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他安全考虑
- en: A Content Provider extends the `ContentProvider` abstract class. This class
    has six methods such as `query()`, `insert()`, `update()`, `delete()`, `getType()`,
    and `onCreate()`, all of which need to be implemented. If the provider does not
    support some functionality, an exception should be returned. This exception should
    be able to communicate across process boundaries.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者扩展了`ContentProvider`抽象类。这个类有六个方法，如`query()`、`insert()`、`update()`、`delete()`、`getType()`和`onCreate()`，都需要被实现。如果提供者不支持某些功能，应该返回一个异常。这个异常应该能够跨进程边界进行通信。
- en: Synchronization can be an issue if multiple threads are reading and writing
    provider data. This can be taken care of by making all the previously mentioned
    methods synchronized by using the keyword `synchronize` so only one thread can
    access the provider. Alternatively, `android:multipleprocess=true` can be set
    so that an instance is created for each client. Latency and performance issues
    have to be balanced in this case.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程正在读取和写入提供者数据，同步可能是一个问题。这可以通过使用关键字`synchronize`使所有先前提到的方法同步来解决，这样只有一个线程可以访问提供者。另外，可以设置`android:multipleprocess=true`，以便为每个客户端创建一个实例。在这种情况下，需要平衡延迟和性能问题。
- en: In some cases, to maintain data integrity, data may have to be entered in the
    provider in a certain format. For example, it might be necessary that a tag append
    each element. To achieve this, a client may decide to not call the `ContentProvider`
    and `ContentResolver` classes directly. Instead, an Activity can be entrusted
    to interface with the provider. All clients who need to access the provider data
    should send an Intent to this Activity and then this Activity performs the intended
    action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为了维护数据完整性，可能需要以特定格式在提供者中输入数据。例如，可能需要每个元素都附加一个标签。为了实现这一点，客户端可能会决定不直接调用`ContentProvider`和`ContentResolver`类。相反，可以委托一个活动与提供者进行接口交互。所有需要访问提供者数据的客户端都应该向这个活动发送一个Intent，然后这个活动执行预期的操作。
- en: 'SQL injection can easily happen with Content Providers if the value fed to
    the query is not validated. The following is an example of how it can happen:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向查询中输入的值没有得到验证，内容提供者很容易受到SQL注入的攻击。以下是发生这种情况的一个示例：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A malicious user can enter any text here. It could be `nothing; DROP TABLE *;`,
    which will delete tables. Developers should use the same discretion that applies
    for any SQL query. The user data should be parameterized and vetted for possible
    bad activities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户可以在这里输入任何文本。它可能是`nothing; DROP TABLE *;`，这将删除表。开发人员应该对任何SQL查询应用同样的判断。用户数据应该是参数化的，并经过检查以排除可能的恶意行为。
- en: The user may decide to use regular expressions to check the syntax of the input
    that the user enters. The following code snippet shows how to validate user input
    for alphanumeric characters. The snippet uses the `matches` function of the `String`
    class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会决定使用正则表达式来检查用户输入的输入语法。以下代码段展示了如何验证用户输入的字母数字字符。该代码段使用了`String`类的`matches`函数。
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When storing data in the database, you might like to encrypt sensitive information
    such as passwords and credit card information before storing it. Be aware that
    encrypting some fields may affect your ability to index and sort fields. Additionally,
    there are some open source tools, such as SQLCipher for Android ([http://sqlcipher.net](http://sqlcipher.net))
    that provides full SQLite database encryption using 256-bit AES.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中存储数据时，你可能会想在存储之前对敏感信息（如密码和信用卡信息）进行加密。请注意，加密某些字段可能会影响你索引和排序字段的能力。此外，还有一些开源工具，如针对Android的SQLCipher（[http://sqlcipher.net](http://sqlcipher.net)），它使用256位AES提供了完整的SQLite数据库加密。
- en: Broadcast Receiver
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播接收器
- en: Introduced in API level 1, a Broadcast Receiver is a mechanism for an application
    to receive Intents from the system or other applications. The beauty of a receiver
    is that even if the application is not running, it still receives Intents that
    can trigger further events. The user is unaware of a broadcast. As an example,
    an application that intends to start a background Service as soon as the system
    is up can register for the `Intent.ACTION_BOOT_COMPLETE` system Intent. An application
    that wants to customize itself to a new time zone can register for an `ACTION_TIMEZONE_CHANGED`
    event. An example of a Service sending out a broadcast Intent is shown in the
    following figure. Receivers that have registered with the Android system for such
    a broadcast will receive the broadcast Intent.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 级别 1 中引入，广播接收器是一种应用程序从系统或其他应用程序接收 Intent 的机制。接收器的美妙之处在于，即使应用程序没有运行，它仍然可以接收到可以触发进一步事件的
    Intent。用户不会察觉到广播。例如，一个应用程序打算在系统启动后立即启动后台服务，可以注册 `Intent.ACTION_BOOT_COMPLETE`
    系统Intent。想要根据新的时区自定义自己的应用程序可以注册 `ACTION_TIMEZONE_CHANGED` 事件。下面显示了发送广播 Intent
    的服务的一个示例。已使用 Android 系统注册此类广播的接收器将收到广播 Intent。
- en: '![Broadcast Receiver](img/5603OT_02_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![广播接收器](img/5603OT_02_04.jpg)'
- en: An application can declare a receiver in the manifest file. The receiver class
    then extends the `BroadcastReceiver` class and implements the `onReceive()` method.
    Or an application can create and register a receiver dynamically using `Context.registerReceiver`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以在清单文件中声明接收器。然后接收器类扩展 `BroadcastReceiver` 类并实现 `onReceive()` 方法。或者应用程序也可以动态创建并注册接收器，使用
    `Context.registerReceiver`。
- en: Receiver declaration
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收器声明
- en: 'A receiver can be declared in the manifest file as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '接收器可以在清单文件中如下声明： '
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As an example, let''s assume there are two applications. The first application
    lets users search for books and add books to a wish list. The second application
    listens for the Intent that a book has been added to wish list. The second application
    then syncs up the wish list to the list on the server. An example receiver declaration
    in the manifest file of the second application could be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，假设有两个应用程序。第一个应用程序允许用户搜索书籍并将书籍添加到愿望清单中。第二个应用程序监听一个书籍被添加到愿望清单的 Intent。第二个应用程序然后将愿望清单与服务器上的列表同步。第二个应用程序清单文件中的示例接收器声明可能如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The receiver `com.example.android.book2.MessageListener` is a public receiver
    and listens to events from application `com.example.android.book1`. The `intent-filter`
    tag filters out Intents.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器 `com.example.android.book2.MessageListener` 是一个公共接收器，它监听来自应用程序 `com.example.android.book1`
    的事件。`intent-filter` 标签过滤出 Intent。
- en: 'The application `book1` can send an Intent as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 `book1` 可以如下发送 Intent：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The attributes of the `<receiver>` tag are discussed as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`<receiver>` 标签的属性如下所述：'
- en: '`android:enabled`: Setting this attribute to true lets the system instantiate
    the receiver. The default value for this attribute is true. This tag has to be
    used in conjunction with the `android:enabled` attribute of `<application>`. Both
    have to be true for the system to instantiate it.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:enabled`：将此属性设置为 true 允许系统实例化接收器。此属性的默认值是 true。此标签必须与 `<application>`
    的 `android:enabled` 属性结合使用。两者都必须为 true，系统才能实例化它。'
- en: '`android:exported`: Setting this attribute to true makes your receiver visible
    to all applications in the system. If it is false then it can receive Intents
    only from the same application or applications with the same user ID. If your
    application does not have Intent Filters then the default value is false as it
    assumes that this receiver is private to you. If you define Intent filters then
    the default value is true. In our preceding example, we do have Intent filters,
    so the receiver is visible to the rest of the system.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:exported`：将此属性设置为 true 使你的接收器对所有系统中的应用程序可见。如果设置为 false，则它只能接收来自同一应用程序或具有相同用户ID的应用程序的Intent。如果你的应用程序没有
    Intent 过滤器，那么默认值是 false，因为它假定这个接收器对你来说是私有的。如果你定义了 Intent 过滤器，那么默认值是 true。在我们前面的示例中，我们确实有
    Intent 过滤器，所以接收器对系统的其余部分是可见的。'
- en: '`android:name`: This is the name of the class that implements the receiver.
    This is a required attribute and should be a fully qualified name of the class.
    Once you have declared a receiver you should try not to change the name as other
    applications might be using it and changing the name will break their functionality.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:name`：这是实现接收器的类的名称。这是一个必需的属性，应该是类的完全限定名。声明接收器后，应尽量不要更改名称，因为其他应用程序可能会使用它，更改名称将破坏它们的功能。'
- en: '`android:permission`: You can protect your receiver with permissions. Using
    this attribute you specify the permissions that the components that send an Intent
    to your receiver should have. If no permissions are listed here then the permissions
    of the `<application>` tag are used. If no permissions are specified there as
    well then your receiver is not protected at all.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:permission`：你可以通过权限保护你的接收器。使用此属性，你可以指定发送意图到你的接收器的组件应该具有的权限。如果这里没有列出权限，则使用`<application>`标签的权限。如果那里也没有指定权限，那么你的接收器将完全不受保护。'
- en: '`android:process`: By default the receiver is instantiated in the application
    process. If you want to, you may declare a name of the process here. If the name
    starts with a colon (`:`), it is instantiated in a private process within your
    application. If it starts with a lowercase letter, and your applications have
    permission to do so, it is run in a global process.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:process`：默认情况下，接收器在应用程序进程中实例化。如果你愿意，可以在这里声明一个进程的名称。如果名称以冒号（`:`）开头，它将在应用程序内的私有进程中实例化。如果以小写字母开头，并且你的应用程序有权限这样做，它将在全局进程中运行。'
- en: Secure sending and receiving broadcasts
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全地发送和接收广播。
- en: There are two types of broadcasts, normal broadcasts and ordered broadcasts.
    Normal broadcasts are sent asynchronously using `Context.sendBroadcast()` and
    all the receivers listening to it will receive it. Ordered broadcasts, sent with
    a `Context.sendOrderedBoradcast`, are delivered to one receiver at a time. The
    receiver adds its result and sends it to the next receiver. The order can be set
    using the `android:priority` attribute in an Intent Filter. If there are multiple
    filters with same priority, the order in which the broadcast is received is random.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 广播分为两种类型：普通广播和有序广播。普通广播通过`Context.sendBroadcast()`以异步方式发送，所有监听它的接收器都将收到它。有序广播通过`Context.sendOrderedBoradcast`发送，一次只传递给一个接收器。接收器添加其结果并将其发送给下一个接收器。可以使用Intent
    Filter中的`android:priority`属性设置顺序。如果有多个具有相同优先级的过滤器，则接收广播的顺序是随机的。
- en: Broadcasts are asynchronous. You send them off but cannot be guaranteed that
    the receiver will receive it. An application must act gracefully in such a situation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是异步的。你发送它们，但不能保证接收器一定能收到。在这种情况下，应用程序必须优雅地处理。
- en: A broadcast can contain extra information. Any receiver listening to a broadcast
    can receive a sent broadcast. It is thus prudent to not send any sensitive information
    in the broadcast. Additionally, broadcasts can be protected with permissions.
    This is done by supplying a permission string in the `sendBroadcast()` method.
    Only applications that have appropriate permissions, by declaring it with `<uses-permission>`
    can receive it. Similarly, a permission string can be added to the `sendOrderedBroadcast()`
    method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 广播可以包含额外的信息。任何监听广播的接收器都可以接收到发送的广播。因此，明智的做法是在广播中不要发送任何敏感信息。此外，可以通过权限保护广播。这是通过在`sendBroadcast()`方法中提供权限字符串来完成的。只有通过使用`<uses-permission>`声明适当权限的应用程序才能接收它。同样，可以在`sendOrderedBroadcast()`方法中添加权限字符串。
- en: When a process is still executing `onReceive()`, it is considered as a foreground
    process. Once the process is out of the `onReceive()` method, it is considered
    as an inactive process and the system will try to kill it. Any asynchronous action
    being performed in the `onReceive()` method may be killed. As an example, starting
    a Service when a broadcast is received should be done using `Context.startService()`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程仍在执行`onReceive()`时，它被视为前台进程。一旦进程离开了`onReceive()`方法，它就被视为非活动进程，系统将尝试杀死它。在`onReceive()`方法中执行的任何异步操作可能会被杀死。例如，当接收到广播时启动服务应该使用`Context.startService()`。
- en: A sticky broadcast keeps living on until the phone powers off or some component
    removes it. When the information in the broadcast is updated, the broadcast is
    updated with the newer information. Any application that has the `BROADCAST_STICKY`
    permission can remove or send sticky broadcasts, so do not put any sensitive information
    in there. Moreover, a sticky broadcast cannot be protected by permissions so they
    should be used sparingly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性广播会在手机关机或某些组件移除之前一直存在。当广播中的信息更新时，广播会使用新信息进行更新。任何拥有`BROADCAST_STICKY`权限的应用程序都可以移除或发送粘性广播，因此不要在其中放置任何敏感信息。此外，粘性广播不能通过权限保护，因此应谨慎使用。
- en: Permissions can be enforced on receivers. As discussed in the previous section,
    this can be done by adding a permission in the manifest file or dynamically by
    adding it in the `registerReceiver()` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在接收器上实施权限。如前所述，这可以通过在清单文件中添加权限或在`registerReceiver()`方法中动态添加来实现。
- en: Starting an **Ice Cream Sandwich**, you can restrict broadcasts to be received
    by only one application by setting `Intent.setPackage`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`Intent.setPackage`，从**冰淇淋三明治**开始，你可以限制广播只被一个应用程序接收。
- en: There are some system broadcast actions that are defined in the `Intent` class.
    These events are triggered by the system and an application cannot trigger them.
    Receivers can register to listen to any of these events. Some of these actions
    include `ACTION_TIMEZONE_CHANGED`, `ACTION_BOOT_COMPLETED`, `ACTION_PACKAGE_ADDED`,
    `ACTION_PACKAGE_REMOVED`, `ACTION_POWER_DISCONNECTED`, and `ACTION_SHUTDOWN`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类中定义了一些系统广播动作。这些事件由系统触发，应用程序无法触发它们。接收者可以注册监听这些事件中的任何一个。这些动作包括`ACTION_TIMEZONE_CHANGED`、`ACTION_BOOT_COMPLETED`、`ACTION_PACKAGE_ADDED`、`ACTION_PACKAGE_REMOVED`、`ACTION_POWER_DISCONNECTED`和`ACTION_SHUTDOWN`。'
- en: Local broadcasts
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地广播
- en: If the broadcast is intended for components within an application only, it is
    better to use a `LocalBroadcastManager` helper class. This helper class is a part
    of the Android support package. Besides being more efficient than sending a global
    broadcast, it is more secure as it does not leave the application process and
    other applications cannot see it. A local broadcast does not need to be declared
    in the manifest, as it is local to the application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果广播仅针对应用程序内的组件，最好使用`LocalBroadcastManager`帮助类。这个帮助类是Android支持包的一部分。除了比发送全局广播更有效之外，它还更安全，因为它不会离开应用程序进程，其他应用程序也无法看到它。本地广播不需要在清单中声明，因为它仅限于应用程序内部。
- en: 'A local broadcast can be created as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下创建本地广播：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code snippet listens to a local broadcast:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码段监听一个本地广播：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Intents
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图
- en: Intents are Android's mechanism for inter-component communication. Intents are
    asynchronous so components fire them off and it is the onus of the receiving component
    to validate the incoming Intent's data and act upon it. Intents are used by the
    Android system for starting an Activity or Service, for communicating with a Service,
    to broadcast events or changes, for receiving notifications using pending Intents,
    and to query the Content Provider.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是Android组件间通信的机制。意图是异步的，组件发出它们，而接收组件有责任验证传入意图的数据并据此采取行动。Android系统使用意图来启动活动或服务，与服务通信，广播事件或变化，使用待定意图接收通知，以及查询内容提供者。
- en: There are different mechanisms to handle Intents for each component. So, the
    Intents sent out to Activities, Services, and Broadcast Receivers are only sent
    to their respective counterparts by the Android system. For example, an event
    sent out to start an Activity using `Context.startActivity()` will resolve only
    Activities matching the Intent criterion. Similarly, a broadcast sent out using
    `Context.sendBroadcast()` will be received only by receivers and not by other
    components.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个组件，有不同的机制来处理意图。因此，发送到活动、服务和广播接收器的意图只由Android系统发送给它们各自的对应组件。例如，使用`Context.startActivity()`发送出去以启动活动的的事件将只解决与意图标准匹配的活动。同样，使用`Context.sendBroadcast()`发送的广播将只被接收者接收，而不是其他组件。
- en: Before an Intent is sent out, it is important to check if there is a component
    to handle the Intent. If there is no component to handle the Intent, the application
    will crash. Matching Intents can be queried using the `queryIntentActivities()`
    method of the `PackageManager` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在意图被发送出去之前，重要的是要检查是否有组件来处理意图。如果没有组件来处理意图，应用程序将会崩溃。可以使用`PackageManager`类的`queryIntentActivities()`方法查询匹配的意图。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any rogue application can send an Intent to an exposed component. It is your
    component's responsibility to validate the input before acting on it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何恶意应用程序都可以向暴露的组件发送Intent。在对其采取行动之前，验证输入是您组件的责任。
- en: Intents are basically serialized objects passed between components. This object
    contains some information used by the other component to act upon. For example,
    an Activity that logs in the user using their login credentials may start another
    Activity that loads up the books previously selected by the user using `Context.startActivity()`.
    In this case, the Intent may contain the user's account name that will be used
    to fetch books stored on the server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Intent基本上是在组件间传递的序列化对象。这个对象包含了一些被其他组件用来执行操作的信息。例如，使用用户登录凭据登录用户的Activity可能会启动另一个Activity，使用`Context.startActivity()`加载用户之前选择的书籍。在这种情况下，Intent可能包含用户的账户名，该账户名将用于从服务器获取存储的书籍。
- en: 'An `Intent` object contains the following four kinds of information:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`对象包含以下四种信息：'
- en: '**Component Name**: A Component Name is required only in case of an explicit
    Intent. It has to be a fully qualified classname if communicating with an external
    component or just the classname in case of an internal component.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组件名称（Component Name）**：只有在显式Intent的情况下才需要组件名称。如果与外部组件通信，它必须是完全限定类名；如果是内部组件，则只需类名。'
- en: '**Action String**: An Action String is the action that should be performed.
    For example, an Action String `ACTION_ CALL` initiates a phone call. A broadcast
    action `ACTION_BATTERY_LOW` is a warning to applications about low battery.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作字符串（Action String）**：动作字符串是应该执行的动作。例如，动作字符串`ACTION_CALL`发起电话呼叫。广播动作`ACTION_BATTERY_LOW`是关于低电量对应用程序的警告。'
- en: '**Data**: This is the URI of the data along with the MIME type. For example,
    for `ACTION_CALL`, the data will be of type `tel:`. Both data and the type of
    data go hand in hand. In order to work on some data, it is important to know the
    type so that it can be handled appropriately.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据（Data）**：这是带有MIME类型的数据的URI。例如，对于`ACTION_CALL`，数据类型将为`tel:`。数据和数据的类型是相辅相成的。为了处理某些数据，了解其类型很重要，以便可以适当地处理。'
- en: '**Category**: The Category provides additional information about the kind of
    Intents a component can receive, thereby adding further restrictions. For example,
    the browser can safely invoke an Activity with a Category of `CATEGORY_BROWSERABLE`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类别（Category）**：类别提供了关于组件可以接收的Intent类型附加信息，从而增加了进一步的限制。例如，浏览器可以安全地调用具有`CATEGORY_BROWSERABLE`类别的Activity。'
- en: Intents are asynchronous so no result is expected. In case of Activities, Intents
    can also be used for starting an Activity for result. This is done using `Context.startActivityForResult()`
    and the result is returned to the calling Activity using the `finish()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Intents是异步的，因此不期望有结果。在Activity的情况下，Intent也可以用于启动一个Activity以获取结果。这是通过使用`Context.startActivityForResult()`完成的，结果通过`finish()`方法返回给调用Activity。
- en: Intents used for broadcasts are usually announcements about an action that just
    happened. Broadcast Receivers register to listen to such events. Some examples
    include `ACTION_PACKAGE_ADDED`, `ACTION_TIME_TICK`, `ACTION_BOOT_COMPLETED`. In
    this scenario, an Intent works like a trigger for some action to be performed
    once an event takes place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于广播的Intent通常是关于刚刚发生动作的通告。广播接收者注册监听这些事件。一些示例包括`ACTION_PACKAGE_ADDED`、`ACTION_TIME_TICK`、`ACTION_BOOT_COMPLETED`。在这种情况下，Intent就像一个触发器，一旦事件发生就会执行某些动作。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not put any sensitive information in the `Intent` object. Use another mechanism
    such as a Content Provider that can be protected by permissions to share information
    between components.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`Intent`对象中放置任何敏感信息。应使用其他机制，如可以通过权限保护的内容提供者（Content Provider）来在组件间共享信息。
- en: The receiving component gets extra information attached to the `Intent` class
    using `getIntent().getExtras()`. A secure programming practice requires that this
    input be validated and vetted for accepted values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接收组件通过使用`getIntent().getExtras()`获取附加在`Intent`类上的额外信息。安全的编程实践要求对此输入进行验证，并确保其值为可接受值。
- en: Explicit Intents
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式Intents
- en: 'A component can send a targeted Intent to only one component. For this to happen,
    a component should know the fully qualified name of the target component. An Activity
    in **Application A** sending an explicit Intent to an Activity in **Application
    B** can be shown graphically as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以发送一个特定的Intent，只针对一个组件。为此，组件应知道目标组件的完全限定名称。**应用A**中的Activity向**应用B**中的Activity发送显式Intent，可以图形化表示如下：
- en: '![Explicit Intents](img/5603OT_02_05.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![显式意图](img/5603OT_02_05.jpg)'
- en: 'For example, an Activity can explicitly communicate with an internal Activity
    called `ViewBooksActivity` using the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，活动可以使用以下代码显式地与名为`ViewBooksActivity`的内部活动通信：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If `ViewBooksActivity` is an external Activity, the component name should be
    a fully qualified name of the class. This can be done as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ViewBooksActivity`是一个外部活动，则组件名称应该是类的完全限定名。可以这样操作：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since intents can be intercepted by any application, if the component name is
    available, it is best to call the component explicitly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于意图可以被任何应用拦截，如果组件名称可用，最好显式调用该组件。
- en: Implicit Intent
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式意图
- en: If the fully qualified name of the component is not known, the component can
    be called implicitly by specifying the action that a receiving component needs
    to do with it. The system then identifies components that are best suited to handle
    the Intent by matching the criterion specified in the `Intent` object. An illustration
    of an implicit Intent is shown as follows. An Activity in **Application A** sends
    out an Intent, and the system searches the relevant components (based on their
    Intent Filters and permissions) that can handle such an Intent.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不知道组件的完全限定名，可以通过指定接收组件需要用它执行的动作来隐式调用该组件。然后系统通过匹配`Intent`对象中指定的标准，识别出最适合处理意图的组件。以下是一个隐式意图的说明：**应用A**中的活动发出一个意图，系统搜索可以处理此类意图的相关组件（基于它们的意图过滤器和权限）。
- en: '![Implicit Intent](img/5603OT_02_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![隐式意图](img/5603OT_02_06.jpg)'
- en: 'The following are some examples of implicit Intents:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些隐式意图的示例：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Intent Filter
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意图过滤器
- en: For a component to be resolved by the system, it needs to be declared in the
    manifest file with appropriate identifiers. This task is done using the Intent
    Filters. Intent filters are defined for activities using the `<intent-filter>`
    subtag of the `<activity>`, `<service>`, or `<receiver>` declaration. While resolving
    an appropriate Activity for an Intent, the system considers only three aspects
    of an `Intent` object. These are action, data (both URI and MIME type), and category.
    All these Intent aspects must match for a successful resolution. A component name
    is used only for explicit Intents.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让系统解析组件，需要在清单文件中用适当的标识符声明该组件。这项任务是通过意图过滤器完成的。意图过滤器是为活动使用`<activity>`、`<service>`或`<receiver>`声明中的`<intent-filter>`子标签定义的。在解析意图的适当活动时，系统只考虑`Intent`对象的三个方面：动作、数据（URI和MIME类型）和类别。所有这些意图方面必须匹配才能成功解析。组件名称仅用于显式意图。
- en: Intent Filters must contain the `<action>` subtag and may contain `<category>`
    and `<data>`. Some examples of the `<intent-filter>` declarations are as follows.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 意图过滤器必须包含`<action>`子标签，并且可能包含`<category>`和`<data>`。以下是一些`<intent-filter>`声明的示例。
- en: 'An Activity that is the starting point of the application is identified with
    these tags:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标签标识了应用的启动点活动：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An Activity that lets user request data of the type `book` can be defined as
    follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个允许用户请求`book`类型数据的活动可以定义如下：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Intent Filters are not security boundaries and should not be relied upon for
    security. Intent Filters cannot be secured with permissions. Moreover, any component
    with Intent Filters becomes an exported component and any application can send
    Intents to this component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 意图过滤器不是安全边界，不应依赖它们来保证安全。意图过滤器不能通过权限来保护。此外，具有意图过滤器的任何组件都将成为导出组件，任何应用都可以向这个组件发送意图。
- en: Pending Intent
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待定意图
- en: In case of Intents, the receiving application executes code with its own permission
    as if it is a part of the receiving application. In case of a pending Intent,
    the receiving application uses the original application's identity and permissions
    and executes the code on its behalf.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在意图的情况下，接收应用以其自身的权限执行代码，就如同它是接收应用的一部分。在待定意图的情况下，接收应用使用原始应用的标识和权限，并代表其执行代码。
- en: Thus a pending Intent is a token an application gives to another application
    so that the other application can execute a piece of code with the original application's
    permissions and identity. A pending Intent will execute even if the sending application
    process is killed or destroyed. This property of pending Intents can be used beautifully
    to send notification to the originating application once an event has happened.
    Pending Intents can be either explicit or implicit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，待定意图是应用程序提供给另一个应用程序的令牌，以便另一个应用程序可以以原始应用程序的权限和身份执行一段代码。即使发送应用程序的进程被杀死或销毁，待定意图仍将执行。待定意图的此属性可以很好地用于在事件发生后向原始应用程序发送通知。待定意图可以是显式的也可以是隐式的。
- en: For additional security, so that only one component receives the Intent, a component
    can be baked into the Intent by using the `setComponent()` method. By default,
    a pending Intent cannot be modified by the receiving component. This is good for
    security reasons. The only part that the receiving component can edit is `extras`.
    The sender can, however, set flags to explicitly enable receiving components to
    edit `PendingIntent`. For this to happen, the sender sets rules for using the
    `fillIn(Intent, int)` method. For example, if the sender wants to let the receiver
    overwrite the data field, even if it is set, then the sender can set `FILL_IN_DATA=true`.
    This is a very sensitive operation and should be done with care.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加安全性，使得只有一个组件接收意图，可以使用`setComponent()`方法将组件内嵌到意图中。默认情况下，待定意图（pending Intent）不能被接收组件修改。这对于安全来说是有好处的。接收组件唯一可以编辑的部分是`extras`。然而，发送者可以设置标志，明确允许接收组件编辑`PendingIntent`。为此，发送者需要使用`fillIn(Intent,
    int)`方法的规则。例如，如果发送者希望接收者覆盖数据字段，即使它已经被设置，发送者可以设置`FILL_IN_DATA=true`。这是一个非常敏感的操作，应当谨慎处理。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the four components of an Android system—Activities,
    Services, Content Providers, and Broadcast Receivers, and inter-component communication
    mechanisms—Intents and Binders. Security begins with secure declaration of these
    components. As is the general rule with security, exposing the minimum is always
    a good idea. All Android components are protected by permissions. Intents are
    asynchronous components and should always validate their input. Intent Filters
    are a good way to reduce the attack surface of an application, but an explicit
    Intent can still send Intents to it. Now that we understand the Android components
    and communication mechanism, let's move on to the next chapter to review Android
    permissions in detail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Android系统的四个组件——活动（Activities）、服务（Services）、内容提供者（Content Providers）和广播接收器（Broadcast
    Receivers），以及组件间通信机制——意图（Intents）和绑定器（Binders）。安全性的起点是这些组件的安全声明。按照安全的一般规则，暴露最少的信息总是一个好主意。所有Android组件都通过权限进行保护。意图（Intents）是异步组件，应始终验证其输入。意图过滤器（Intent
    Filters）是减少应用程序攻击面的好方法，但显式意图（Explicit Intent）仍然可以向其发送意图。现在我们了解了Android组件和通信机制，让我们在下一章中详细查看Android权限。
