- en: Chapter 3. Creating and Accessing Content from the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 从云端创建和访问内容
- en: In this chapter, we will learn how to consume content from the Web using our
    application; this content could be a list of items inside an XML or JSON file
    (something that we wish to display), retrieved from the Internet. For instance,
    if we were building an app that shows the current weather conditions, we would
    need to contact an external API to retrieve all the information needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用我们的应用程序从网络上获取内容；这些内容可能是一个XML或JSON文件中的项目列表（我们希望展示的内容），从互联网上获取。例如，如果我们正在构建一个显示当前天气状况的应用程序，我们需要联系外部API以获取所需的所有信息。
- en: We will create our own cloud database in Parse, a service that allows us to
    do this really quickly without the hassle of creating and maintaining our own
    servers. Apart from this, we will populate the database with information to be
    displayed in `MasteringAndroidApp`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Parse中创建自己的云数据库，这项服务允许我们非常快速地完成这一操作，而无需创建和维护自己的服务器。除此之外，我们还将用要在`MasteringAndroidApp`中展示的信息填充数据库。
- en: 'We will also cover best practices regarding network requests with Google Volley,
    using the ultrafast HTTP library, OkHttp, and parsing the requested objects efficiently
    with Gson. We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍与Google Volley网络请求相关的最佳实践，使用超快的HTTP库OkHttp，以及使用Gson高效地解析请求的对象。我们将在本章中介绍以下主题：
- en: Creating your own cloud database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的云数据库
- en: Consuming content from Parse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Parse中消费内容
- en: Google Volley and OkHttp
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Volley和OkHttp
- en: Parsing objects with Gson
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gson解析对象
- en: Creating your own cloud database
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的云数据库
- en: At this stage of the project, we have to start modeling our own version of `MasteringAndroidApp`.
    Feel free to develop your own ideas and use the database for your own data. Follow
    this example as a guide; you don't necessarily have to copy all the lines of code
    exactly as I write them. In fact, if you develop your own example at the end of
    this book, you will have something that you can use. For instance, you can create
    an app for your own personal use, such as a task reminder, travel diary, personal
    photo gallery—or anything else that is suitable for storage in the cloud.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的这个阶段，我们必须开始构建我们自己的版本的`MasteringAndroidApp`。你可以自由地开发自己的思路，并使用数据库存储自己的数据。以本例为指南，你不必严格按照我写的代码逐行复制。实际上，如果你在本书的最后开发出自己的示例，你将得到一个你可以使用的东西。例如，你可以创建一个供个人使用的应用程序，如任务提醒、旅行日记、个人照片画廊，或任何适合在云端存储的东西。
- en: You could also try to monetize this app; in this case, you should try to develop
    something interesting for users. For instance, it can be a news feed reader or
    recipes reader for food; it can be any app where you can submit content to the
    cloud and notify users that new content is available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试将这个应用货币化；在这种情况下，你应该尝试为用户开发一些有趣的东西。例如，它可以是新闻源阅读器或食谱阅读器；它可以是任何可以提交内容到云端并通知用户新内容可用的应用。
- en: During this process, we will explain the importance of the `Application` class,
    which is used to set up Parse in our project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将解释`Application`类的重要性，该类用于在我们的项目中设置Parse。
- en: Parse
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parse
- en: Parse is free if you have less than 30 requests per second. I imagine that if
    you have enough users requesting information from your app 30 times per second,
    which is 1,800 per minute, you can surely afford to upgrade to a paid account
    or even build your own server! This service is a very easy and reliable way to
    have the server side covered for your app. It also provides a push notifications
    service and analytics, that's another point in favor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每秒的请求少于30次，Parse是免费的。我猜想，如果你的应用有足够的用户每秒请求信息30次，即每分钟1,800次，你肯定能负担得起升级到付费账户，甚至构建自己的服务器！这项服务是一种非常简单且可靠的方法，可以为你的应用提供服务器端支持。此外，它还提供推送通知服务和分析，这也是它的一个优点。
- en: We will proceed with creating a new account; after this, we need to name our
    application in Parse. Here, I will use `MasteringAndroid`. Once you name the application,
    you will be on the main page of your account. We need to navigate to **Data Service**
    | **Mobile** | **Android** | **Native Java**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建一个新账户；之后，我们需要在Parse中为我们的应用程序命名。在这里，我将使用`MasteringAndroid`。命名应用程序后，你将进入账户的主页。我们需要导航至**数据服务**
    | **移动端** | **Android** | **原生Java**。
- en: 'The following image shows the data services as a cloud:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了作为云的数据服务：
- en: '![Parse](img/B04887_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Parse](img/B04887_03_01.jpg)'
- en: Adding the Parse SDK to our project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Parse SDK添加到我们的项目中
- en: To access the data service from our app, we need to install the **Parse SDK**
    (**System Development Kit**). For this, Parse refers us to a quick start guide,
    which contains all of the code, including the API Keys for our application, that
    is ready to be copied and pasted into our project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的应用程序访问数据服务，我们需要安装 **Parse SDK**（**系统开发工具包**）。为此，Parse 指引我们查看一个快速入门指南，其中包含所有代码，包括我们应用程序的
    API 密钥，这些代码已准备好复制并粘贴到我们的项目中。
- en: 'Basically, we need to complete two steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要完成两个步骤：
- en: 'The first one is to download a `.jar` library file that we need to copy into
    the `libs` folder in our project. After copying it, we need to tell our build
    system to include this library in our application. To do this, we need to find
    the `build.gradle` file inside our Application folder (be careful, there are two
    `build.gradle` files in our project) and add the following lines:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是下载一个 `.jar` 库文件，我们需要将其复制到项目中的 `libs` 文件夹内。复制后，我们需要告诉我们的构建系统在应用程序中包含这个库。为此，我们需要在
    Application 文件夹内找到 `build.gradle` 文件（注意，我们的项目中有两个 `build.gradle` 文件），并添加以下几行：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the following image, you can see the two files named `build.gradle`; the
    one that is selected is the right one:![Adding the Parse SDK to our project](img/B04887_03_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到两个名为 `build.gradle` 的文件；被选中的是正确的文件：![将 Parse SDK 添加到我们的项目](img/B04887_03_02.jpg)
- en: The second step is to initialize the Parse SDK in our project; for this, we
    can navigate directly to [https://www.parse.com/apps/quickstart?app_id=masteringandroidapp](https://www.parse.com/apps/quickstart?app_id=masteringandroidapp).
    Replace your own app ID in the link or find the link by clicking on your home
    page, as in the following screenshot:![Adding the Parse SDK to our project](img/B04887_03_03.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是在我们的项目中初始化 Parse SDK；为此，我们可以直接导航到[https://www.parse.com/apps/quickstart?app_id=masteringandroidapp](https://www.parse.com/apps/quickstart?app_id=masteringandroidapp)。在链接中替换你自己的应用
    ID，或者通过点击主页找到链接，如下面的截图所示：![将 Parse SDK 添加到我们的项目](img/B04887_03_03.jpg)
- en: After clicking on **quickstart guide**, go to **Data** | **Mobile** | **Android**
    | **Native** | **Existing Project**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **快速入门指南** 后，转到 **数据** | **移动** | **Android** | **原生** | **现有项目**。
- en: It will ask you to add the `INTERNET` and `ACCESS_NETWORK_STATE` permissions
    to your `AndroidManifest.xml` file if they are not already added.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未添加，系统会提示你在 `AndroidManifest.xml` 文件中添加 `INTERNET` 和 `ACCESS_NETWORK_STATE`
    权限。
- en: Android's Application class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 的 Application 类
- en: The next thing we can take note of is that we need to add the code to initialize
    Parse to our `Application` class; however, our `Application` class is not created
    by default in our project. We need to create and understand what the `Application`
    class is and how it works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要注意的一点是，我们需要将初始化 Parse 的代码添加到我们的 `Application` 类中；然而，我们的 `Application`
    类在项目中默认并未创建。我们需要创建并了解 `Application` 类是什么以及它是如何工作的。
- en: To create an Application class, we will right-click on our package and create
    a new Java class called `MAApplication` extending `Application`. Once this extends
    `Application`, we can override the `onCreate` method. Then, we will right-click
    inside our **class** | **Generate.** | **Override Methods** | **onCreate**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Application 类，我们将在包上右键点击并创建一个新的 Java 类，名为 `MAApplication`，继承 `Application`。一旦继承了
    `Application`，我们就可以重写 `onCreate` 方法。然后，我们将在类内部右键点击 | **生成**。 | **重写方法** | **onCreate**。
- en: 'This will override the `onCreate` method, and we will be ready to implement
    our own functionality there. The `onCreate` method is called every time our `Application`
    is created; therefore, it''s the right place to initialize our libraries and third-party
    SDKs. Now, you can copy and paste the Parse initialization lines as seen in quick
    start guide:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重写 `onCreate` 方法，我们将准备好在那里实现我们自己的功能。`onCreate` 方法每次创建我们的 `Application` 时都会被调用；因此，它是初始化我们的库和第三方
    SDK 的正确位置。现在，你可以按照快速入门指南中看到的 Parse 初始化行进行复制和粘贴。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful, this is unique, and for your own account you should have your own
    keys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是唯一的，对于你自己的账户，你应该有自己的密钥。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To finish, we need to tell our app that we have a new `Application` class and
    that that's the one we want to use; if we don't do this, our `Application` class
    won't be recognized and `onCreate` won't be called.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉我们的应用程序有一个新的 `Application` 类，并且我们想要使用这个类；如果我们不这样做，我们的 `Application`
    类将不会被识别，`onCreate` 也不会被调用。
- en: 'In our manifest, inside the `<application>` tag, we need to set the attribute
    name to match our own application. Execute the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的清单文件中，我们需要在 `<application>` 标签内设置属性名称以匹配我们自己的应用程序。执行以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Application class encapsulates everything in our app; the activities are
    contained in the application, and subsequently, the fragments are contained in
    the **Activities**. If we need a global variable in our app that needs to be accessed
    by all Activities/Fragments, this would be the right place to have it. In the
    next chapter, we will see how we can create this global variable. The following
    diagram is the graphic structure of an app:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序类封装了我们应用中的所有内容；活动包含在应用程序中，随后，片段包含在**活动**中。如果我们需要在应用中访问所有活动/片段的全局变量，这将是一个合适的地方。在下一章中，我们将了解如何创建这个全局变量。以下图表是应用程序的图形结构：
- en: '![Android''s Application class](img/B04887_03_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Android的应用程序类](img/B04887_03_04.jpg)'
- en: Creating the database
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: As we know, the example that we will create during this book is an app that
    will have Android-related job offers; therefore, we need to create a database
    to store these job offers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，在本书中我们将创建一个示例应用，该应用将提供与Android相关的职位信息；因此，我们需要创建一个数据库来存储这些职位信息。
- en: The database can be changed during development (this will be more difficult
    to do when the app is released and has users). However, for now we will look at
    the big picture, creating the whole system rather than having a final version
    of the database with all the fields completed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中可以更改数据库（当应用发布并拥有用户时，这将变得更加困难）。但是，现在我们将从大局出发，创建整个系统，而不是拥有一个包含所有字段完成的最终版数据库。
- en: 'To create a table, click on the **Core** section as shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表，请点击如下截图所示的**Core**部分：
- en: '![Creating the database](img/B04887_03_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/B04887_03_05.jpg)'
- en: 'First, create a table by clicking on the **+ Add Class** button and call it
    **JobOffer** with the following attributes, which can be added by clicking on
    the **Col+** button:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过点击**+ 添加类**按钮创建一个表，并将其命名为**JobOffer**，包含以下属性，可以通过点击**Col+**按钮添加：
- en: '`objectId`: This is created by default: `String`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectId`: 这是默认创建的：`String`'
- en: '`title`: This is the job title: `String`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 这是职位名称：`String`'
- en: '`description`: This is the job description: `String`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这是工作描述：`String`'
- en: '`salary`: This indicates the salary or daily rate: `String`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salary`: 这表示薪水或日薪：`String`'
- en: '`company`: This indicates the company offering the job: `String`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`company`: 这表示提供工作的公司：`String`'
- en: '`type`: This indicated the type of employee, which is permanent, contract,
    or freelancer: `String`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 这表示员工的类型，可以是永久、合同或自由职业者：`String`'
- en: '`imageLink`: This is the image of the company: `String`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageLink`: 这是公司的图片：`String`。'
- en: '`Location`: This indicates the location of the job: `String`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Location`: 这表示工作的地点：`String`'
- en: '`createdAt` , `updatedAt`: This is the date of the job; the columns are created
    with a default date'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createdAt`，`updatedAt`: 这是工作的日期；这些列是使用默认日期创建的'
- en: 'To add data to the tables, select the table on the left and click on **+ Row**.
    We only need to complete the columns that we created; the columns created by default,
    such as the ID or date, will be completed automatically. So far, our table should
    look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要向表中添加数据，请在左侧选择表并点击**+ 行**。我们只需要完成我们创建的列；默认创建的列，如ID或日期，将自动完成。到目前为止，我们的表应如下所示：
- en: '![Creating the database](img/B04887_03_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/B04887_03_06.jpg)'
- en: Feel free to add more details, such as the contact person, e-mail, and mobile
    number. You could also add more tables; for instance, a new `JobType` table containing
    the type of job and the field type instead of `String` would be `Relation<JobType>`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加更多详细信息，例如联系人、电子邮件和手机号码。你也可以添加更多表；例如，一个新的`JobType`表，包含工作类型和字段类型，而不是`String`，应为`Relation<JobType>`。
- en: We have what we need for our example; the next thing to do is consume this data
    using our app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有我们示例所需的内容；接下来要做的是使用我们的应用程序消费这些数据。
- en: Storing and consuming content from Parse
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Parse中存储和消费内容
- en: Parse is a very powerful tool that allows us to not only consume content very
    easily but also to store content in the cloud database from our device, which
    is a tedious task to do using the traditional method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Parse是一个非常强大的工具，它不仅允许我们轻松地消费内容，还可以从我们的设备将内容存储在云数据库中，使用传统方法进行这项任务是相当繁琐的。
- en: 'For example, if we wanted to upload an image to a custom server from our device,
    we would have to create a `POST` request and send a form with the right encoding,
    while attaching the picture as a `FileBody` object in `MultiPartEntity` and importing
    the Apache HTTP libraries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从设备上传图片到自定义服务器，我们就需要创建一个`POST`请求，并发送一个带有正确编码的表单，同时将图片作为`FileBody`对象附加在`MultiPartEntity`中，并导入Apache
    HTTP库：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s have a look at the Parse alternative:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Parse的替代方案：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s not forget error handling on Parse. In a very elegant way, you can simply
    write:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记在Parse上处理错误。你可以简单地这样写，非常优雅：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Storing content
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储内容
- en: To elaborate on the simplicity of Parse, we will upload job offers to our Parse
    Cloud from our app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Parse的简便性，我们将从我们的应用程序将职位信息上传到我们的Parse云。
- en: To achieve this, we can create a button inside Contact Fragment, which we will
    set to invisible in the final version of the app as we don't want the users to
    upload job offers themselves.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以在联系人片段中创建一个按钮，在应用程序的最终版本中将其设置为不可见，因为我们不希望用户自己上传职位信息。
- en: 'With this button, we will create `ParseObject`, which is similar to a map.
    We will add the fields that we want to complete, and after this we will call the
    `saveInBackground()` method, which is the method that will upload the object.
    Execute the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个按钮，我们将创建一个类似于地图的`ParseObject`。我们将添加我们想要完成的字段，之后我们将调用`saveInBackground()`方法，这是上传对象的方法。执行以下代码：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If, in your own version of `MasteringAndroidApp`, you want the user to upload
    content, you could display a dialog with `EditText` for every field so that the
    user can write the job offer, press upload, and have you send the `jobOffer` object
    with the fields written by the user.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您自己的`MasteringAndroidApp`版本中，您希望用户上传内容，您可以显示一个带有`EditText`的对话框，让用户编写职位信息，按下上传按钮，然后您将发送带有用户编写字段的`jobOffer`对象。
- en: Run the app, navigate to **Contact**, and click on the button. If the data is
    uploaded correctly, upon opening the Parse Cloud database in a browser, you should
    see an extra row with the job offer just uploaded.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，导航到**联系人**，并点击按钮。如果数据正确上传，在浏览器中打开Parse云数据库时，你应该能看到刚刚上传的职位信息额外的一行。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to add the permissions in `AndroidManifest.xml`, `android.permission.ACCESS_NETWORK_STATE`,
    and `android.permission.INTERNET`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`AndroidManifest.xml`中添加权限，`android.permission.ACCESS_NETWORK_STATE`和`android.permission.INTERNET`。
- en: Consuming content
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费内容
- en: 'Our objects in the Parse Cloud have an object identifier by default; it is
    the `objectId` field. Let''s start retrieving an object by the ID, and after this,
    we can retrieve a list of all the objects with and without filters. Run the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Parse云中的对象默认有一个对象标识符，即`objectId`字段。让我们通过ID开始检索对象，之后，我们可以检索带有和没有过滤器的所有对象列表。运行以下代码：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ParseQuery` object will perform a query over the network asynchronously
    when the network request is finished. The method; `done (the ParseObject object,
    ParseException e)`, which is included in the callback, will be executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络请求完成时，`ParseQuery`对象会在网络上异步执行查询。回调中包含的方法`done (the ParseObject object, ParseException
    e)`将被执行。
- en: A good way to test the result is to print a log; in cases where the exception
    is `null`, it means that everything is okay.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 检验结果的一个好方法是打印日志；在异常为`null`的情况下，意味着一切正常。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We could extract every field from `ParseObject` and create a `JobOffer` class
    in our app with a constructor whose parameters match the fields of the object.
    Use the following snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`ParseObject`中提取每个字段，并在我们的应用程序中创建一个`JobOffer`类，其构造函数的参数与对象的字段相匹配。使用以下代码片段：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, there is a better way to do this. We can create a `JobOffer` class
    that extends `ParseObject` and where all fields will be automatically converted
    into variables in our class. This way, we can use our own class in a very convenient
    way instead of `ParseObject`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种更好的方法可以实现这一点。我们可以创建一个扩展了`ParseObject`的`JobOffer`类，这样所有的字段都会自动转换成我们类中的变量。这样，我们就可以非常方便地使用自己的类，而不是`ParseObject`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Don''t forget to add the `@ParseClassName("Name")` annotation at the top of
    the class to let Parse know which object from the Cloud we want to instantiate
    and to register the subclass before initiating parse in `MAApplication`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在类顶部添加`@ParseClassName("Name")`注解，以让Parse知道我们要实例化云中的哪个对象，并在`MAApplication`中初始化解析之前注册子类：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have our custom class created, it''s even easier to get a list
    with all the job offers. If we want, we can filter it with a parameter. For instance,
    I could retrieve all the permanent jobs with the following query:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自己的自定义类，获取所有职位列表就更加容易了。如果我们愿意，可以用一个参数来过滤它。例如，我可以用以下查询检索所有永久职位：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Displaying content
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示内容
- en: Once the list of objects is retrieved, it is possible to create `ListView` and
    an `Adapter` that receives the objects as the parameters. To finish with Parse,
    we will use another feature that allows us to create an adapter directly from
    the result of the query; so, we don't have to create an `Adapter` class ourselves.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到对象列表，就可以创建`ListView`和一个接收对象作为参数的`Adapter`。为了结束对Parse的使用，我们将使用另一个功能，它允许我们直接从查询结果创建适配器；这样，我们就不必自己创建一个`Adapter`类了。
- en: 'In both cases, we need to create `ListView` and view for the rows of the list.
    For now, just displaying the title and the first line of the description will
    do. We will customize this and add an image in [Chapter 7](ch07.html "Chapter 7. Image
    Handling and Memory Management"), *Image Handling and Memory Management*. Create
    a `row_job_offer.xml` layout as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们需要创建`ListView`和列表行的视图。现在，只需显示标题和描述的第一行即可。我们将在[第7章](ch07.html "第7章.
    图像处理和内存管理")《图像处理和内存管理》中自定义此视图并添加一个图片。按照以下方式创建一个`row_job_offer.xml`布局：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are now ready to create `ParseQueryAdapter` and customize the `getItemView()`
    method. The huge advantage of this adapter is that we don't need to download data
    with a query because it is automatically done; basically, we can show a list of
    items from the cloud creating an adapter. It has never been so easy!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建`ParseQueryAdapter`并自定义`getItemView()`方法。这个适配器的一个巨大优势是我们不需要通过查询下载数据，因为它是自动完成的；基本上，我们可以从云中创建一个适配器来显示项目列表。从未如此简单！
- en: To override a method from a class—in this case, we want to override `getItemView`—we
    could create a subclass, a `MyQueryAdapter` class that extends `ParseQueryAdapter`
    and overrides the method inside this subclass. This is a good solution, especially
    if we want to instantiate the object more than once in our app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖类中的方法——在这种情况下，我们想要覆盖`getItemView`——我们可以创建一个子类，一个扩展`ParseQueryAdapter`的`MyQueryAdapter`类，并在该子类中覆盖方法。这是一个很好的解决方案，特别是如果我们想在应用程序中多次实例化对象。
- en: 'However, there is a way to override methods from a class without having to
    extend it; we can add `{ }` after the object instantiation. For instance, refer
    to the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以在不扩展类的情况下覆盖方法；我们可以在对象实例化后添加`{ }`。例如，参考以下代码：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using this approach, I can create a new `ParseQueryAdapter` and customize `getItemView`,
    as in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我可以创建一个新的`ParseQueryAdapter`并自定义`getItemView`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will now create `ListView` in the layout of our `ListFragment`, find this
    view in `OnCreateView`, set the adapter to the list, and that's all. No more code
    is needed to retrieve the items and display them. If your list is empty, ensure
    that you import `com.packtpub.masteringandroidapp.fragments.ListFragment;` instead
    of `android.support.v4.app.ListFragment` in `MyPagerAdapter`; they are different
    objects, and using the latter would lead to an empty android built-in `ListFragment`
    being displayed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`ListFragment`的布局中创建`ListView`，在`OnCreateView`中找到这个视图，将适配器设置到列表中，这样就完成了。不再需要代码来检索项目并显示它们。如果您的列表为空，请确保在`MyPagerAdapter`中导入`com.packtpub.masteringandroidapp.fragments.ListFragment;`而不是`android.support.v4.app.ListFragment`；它们是不同的对象，使用后者将导致显示一个空的内置`ListFragment`。
- en: '![Displaying content](img/B04887_03_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![显示内容](img/B04887_03_07.jpg)'
- en: Google Volley and OkHttp
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌Volley和OkHttp
- en: To master Android, we can't depend on a solution such as Parse. As developers,
    we must be prepared to face different server-side solutions. We can't always work
    with `ParseObjects` because we need to be able to do an HTTP `Post` request and
    consume the data in the JSON or XML format. However, this doesn't mean that we
    have to do all of this manually; we can use Google's official libraries to help
    us with parsing the data and the network requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要掌握Android，我们不能依赖像Parse这样的解决方案。作为开发者，我们必须准备面对不同的服务器端解决方案。我们不能总是使用`ParseObjects`，因为我们需要能够进行HTTP
    `Post`请求并消费JSON或XML格式的数据。然而，这并不意味着我们必须手动完成所有这些工作；我们可以使用谷歌的官方库来帮助我们解析数据和网络请求。
- en: For this, we will take a look at **Google Volley**, a powerful library, to manage
    our network requests. We will also discuss **OkHttp**, an ultrafast HTTP client,
    and combining the two them to get an amazing solution for network requests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将研究**Google Volley**，这是一个强大的库，用于管理我们的网络请求。我们还将讨论**OkHttp**，这是一个超快的HTTP客户端，并将两者结合以获得网络请求的惊人解决方案。
- en: Google Volley
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Volley
- en: According to the official definition and list of features from [https://developer.android.com/training/volley/index.html](https://developer.android.com/training/volley/index.html),
    "*Volley is an HTTP library that makes networking for Android apps easier and,
    most importantly, faster*".
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方定义和功能列表来自[https://developer.android.com/training/volley/index.html](https://developer.android.com/training/volley/index.html)的说明，"*Volley是一个HTTP库，它使得Android应用的网络通信变得更加简单，最重要的是，更快*”。
- en: 'Volley offers the following benefits:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Volley提供以下好处：
- en: Automatic scheduling of network requests
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求的自动调度
- en: Multiple concurrent network connections
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个并发网络连接
- en: A transparent disk and memory response caching with a standard HTTP cache coherence
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明的磁盘和内存响应缓存，具有标准的HTTP缓存一致性
- en: Support for request prioritization
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持请求优先级
- en: Cancellation of request API; this means that you can cancel a single request,
    or set blocks or scopes of requests to cancel
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求API的取消；这意味着您可以取消单个请求，或设置要取消的请求块或作用域
- en: Ease of customization; for example, for retry and backoff
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于定制；例如，用于重试和退避
- en: Strong ordering, which makes it easy to correctly populate your UI with data
    fetched asynchronously from the network
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的排序功能，这使得可以轻松地用从网络异步获取的数据正确填充UI
- en: Debugging and tracing tools
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和跟踪工具
- en: Before Volley was born, managing network requests in Android was a hard task.
    Almost every application performs network requests. Features such as customizing
    retries—in case a connection fails and we need to try again—and managing concurrent
    network connections usually needed to be implemented manually by the developer.
    Nowadays, we are used to these kinds of libraries, but if we think about the situation
    some years ago, Volley is an excellent solution to this problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Volley诞生之前，在Android中管理网络请求是一项艰巨的任务。几乎每个应用程序都会执行网络请求。诸如定制重试（如果连接失败，我们需要再次尝试）以及管理并发网络连接等功能通常需要开发者手动实现。如今，我们习惯于这类库，但如果我们回想几年前的情景，Volley是解决这一问题的绝佳方案。
- en: 'Before taking a look at how to create a request, we need to understand the
    concept of the Volley request queue object, `RequestQueue`. Every request performed
    by Volley must be added to this queue in order for it to be executed. The idea
    behind this is to have one single request queue in our application where all the
    network requests can be added and accessed by us from any part of our app. We
    will see how we can have an instance of an object that can be accessed globally
    in, [Chapter 4](ch04.html "Chapter 4. Concurrency and Software Design Patterns"),
    *Concurrency and Software Design Patterns*. Take a look at the following request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何创建请求之前，我们需要理解Volley请求队列对象`RequestQueue`的概念。Volley执行的每个请求都必须添加到此队列中，以便执行。这个想法是让我们的应用程序中有一个单一的请求队列，所有的网络请求都可以添加到其中，并且可以从应用程序的任何部分访问。我们将在[第4章](ch04.html
    "第4章. 并发与软件设计模式")，*并发与软件设计模式*中看到如何拥有一个可以全局访问的对象实例。请看以下请求：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This request queue will use the following `HttpURLConnection` or `AndroidHttpClient`
    methods only if the Android version of the device is later than Gingerbread; `HttpURLConnection`
    is unreliable in versions earlier than Gingerbread.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备的Android版本晚于Gingerbread，此请求队列将只使用以下`HttpURLConnection`或`AndroidHttpClient`方法；在Gingerbread之前的版本中，`HttpURLConnection`是不可靠的。
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the request queue is instantiated, we just need to add a request to it.
    For instance, a network requests [https://www.google.com](https://www.google.com),
    which logs the response:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化请求队列时，我们只需向其中添加一个请求。例如，一个网络请求[https://www.google.com](https://www.google.com)，它会记录响应：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The request will be performed, and the `onResponse(…)` or `onErrorResponse(…)`
    method will be called in the application main thread, also known as the UI thread.
    We will explain the threads in Android in more detail in [Chapter 4](ch04.html
    "Chapter 4. Concurrency and Software Design Patterns"), *Concurrency and Software
    Design Patterns*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将被执行，并且在应用程序主线程（也称为UI线程）中调用`onResponse(…)`或`onErrorResponse(…)`方法。我们将在[第4章](ch04.html
    "第4章. 并发与软件设计模式")，*并发与软件设计模式*中更详细地解释Android中的线程。
- en: OkHttp
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OkHttp
- en: OkHttp is an HTTP and SPDY client for Android and Java from the company, Square.
    It is not an alternative to Volley as it doesn't include a request queue. In fact,
    we could use OkHttp as an underlying layer for Volley, as we will see in the next
    section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: OkHttp是来自Square公司的Android和Java的HTTP和SPDY客户端。它不是Volley的替代品，因为它不包括请求队列。实际上，我们可以像下一节将看到的那样，使用OkHttp作为Volley的底层。
- en: According to the official definition, "*HTTP is the way modern applications
    network. It's how we exchange data and media. Doing HTTP efficiently makes your
    stuff load faster and saves bandwidth*".
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方定义，"HTTP是现代应用程序联网的方式。它是我们交换数据和媒体的方法。高效地使用HTTP可以使你的东西加载更快，节省带宽"。
- en: If we don't need to handle requests in a queue, prioritize requests, or schedule
    requests, we could use OkHttp directly in our app; we don't necessarily need Volley.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要处理队列中的请求，优先处理请求或计划请求，我们可以直接在应用程序中使用OkHttp；我们不一定需要Volley。
- en: 'For example, the following method prints the contents of a response from a
    given URL:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法打印给定URL响应的内容：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Apart from being an easier way to do the requests than using `AsyncTask` or
    `HttpUrlConnection`, what convinces us to use OkHttp is the SPDY (**speedy**)
    protocol, which processes, tokenizes, simplifies, and compresses HTTP requests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比使用`AsyncTask`或`HttpUrlConnection`进行请求更简单之外，让我们决定使用OkHttp的是SPDY（**快速**）协议，它处理、标记化、简化和压缩HTTP请求。
- en: A lightning-fast network
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极速网络
- en: If we want to keep the features of Volley to be able to have a flexible and
    manageable queue of requests and have quicker connections using the protocol SPDY,
    we can combine Volley and OkHttp.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想保持Volley的特性，以便拥有灵活可管理的请求队列，并使用SPDY协议实现更快连接，我们可以将Volley和OkHttp结合起来使用。
- en: 'This is really easy to do; while instantiating the request queue, we can specify
    which `HttpStack` method we want:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很简单；在实例化请求队列时，我们可以指定我们想要的`HttpStack`方法：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `OkHttpStack` is a class that we will create ourselves by extending `HurlStack`,
    which will use `OkUrlFactory`. This `OkUrlFactory` will open a URL connection;
    this will be done internally and there is no need to override the `createConnection`
    method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`OkHttpStack`是一个我们自己通过扩展`HurlStack`创建的类，它将使用`OkUrlFactory`。这个`OkUrlFactory`将打开一个URL连接；这将在内部完成，无需重写`createConnection`方法：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: JSON and Gson
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON和Gson
- en: As an Android developer, sooner or later you will have to work with network
    requests in the JSON format. In some cases, you may also find XML, which makes
    it more tedious to translate to an object. It is important to know how to perform
    a network request by sending parameters in JSON and also how to consume data in
    the JSON format.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Android开发者，迟早你将不得不处理JSON格式的网络请求。在某些情况下，你也可能会遇到XML，这使得将其转换为对象更加繁琐。了解如何通过发送JSON格式的参数执行网络请求以及如何消费JSON格式的数据是非常重要的。
- en: 'JSON and GSON are two different things; we need to understand the difference.
    JSON, or JavaScript Object Notation, is an open standard format that uses human-readable
    text to transmit data objects consisting of attribute–value pairs. It is used
    primarily to transmit data between a server and web application as an alternative
    to XML. This is an example of a JSON file; as you can see, we can have different
    types of attributes, and we can have nested JSON structures:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和GSON是两个不同的概念；我们需要了解它们之间的区别。JSON，即JavaScript对象表示法，是一种开放标准格式，它使用人类可读的文本来传输由属性-值对组成的数据对象。它主要用于在服务器和Web应用程序之间传输数据，作为XML的替代方案。下面是一个JSON文件的例子；如你所见，我们可以有不同的属性类型，我们还可以有嵌套的JSON结构：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following are two examples of sending a network request with parameters as
    JSON. These examples cover Volley and OkHttp, which we discussed earlier in this
    chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个使用JSON格式发送带参数的网络请求的例子。这些例子涵盖了本章前面讨论过的Volley和OkHttp：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Gson** (**Google Gson**) is an open source Java library used to serialize
    and deserialize Java objects to (and from) JSON.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gson**（**Google Gson**）是一个开源的Java库，用于将Java对象序列化和反序列化为（或从）JSON。'
- en: 'If we were downloading the job offers for our application from a custom server
    in JSON, it would be in the following format:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从自定义服务器以JSON格式为我们的应用程序下载工作邀请，格式将如下所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, we don't want to create a new object manually and set all the parameters
    by retrieving them from JSON; what we want to do is create a `JobOffer` object
    from JSON. This is called **deserialization**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不想手动创建一个新对象并从JSON中获取所有参数来设置；我们想要做的是从JSON创建一个`JobOffer`对象。这称为**反序列化**。
- en: 'To use this, we need to import the GSON library as a dependency in `build.gradle`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，我们需要在`build.gradle`中导入GSON库作为依赖：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Gson has the `fromJSON` and `toJSON` methods to serialize and deserialize,
    respectively. The `fromJson` method takes the JSON code to convert, and the class
    of the object that we want it to be converted into, as the input. Use the following
    code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Gson提供了`fromJSON`和`toJSON`方法来进行序列化和反序列化操作。`fromJson`方法接收要转换的JSON代码以及我们希望转换成的对象类作为输入。使用以下代码：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If instead of a single object we had a list, which is the typical scenario
    while requesting data, we would need an extra step to get the type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个列表而不是单个对象，这在请求数据时是典型场景，我们需要额外的步骤来获取类型：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To finish, if we want the fields in our class to have a different name than
    the fields of the JSON code to be deserialized, we can use annotations as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们希望类中的字段在反序列化时与JSON代码中的字段名称不同，可以使用如下注解：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the end of this chapter, you should be able to create your own database in
    Parse and consume content from the application. You should also have all the necessary
    knowledge to master network requests using Volley and OkHttp, especially while
    performing network requests and exchanging data in the JSON format.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够自己在Parse中创建数据库并从应用程序中消费内容。你也应该拥有使用Volley和OkHttp进行网络请求的所有必要知识，特别是在执行网络请求和以JSON格式交换数据时。
- en: In the next chapter, we will explain in further detail, some of the patterns
    used in this chapter for the HTTP libraries. For instance, we will understand
    what a callback is and which pattern it follows, as well as other commonly used
    software patterns in Android.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地解释本章中使用的HTTP库的一些模式。例如，我们将了解回调是什么以及它遵循的模式，以及在Android中其他常用的软件模式。
