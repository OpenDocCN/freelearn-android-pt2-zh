- en: Chapter 2. Working with Entities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 使用实体
- en: 'In this chapter, we''re going to start getting into displaying objects on the
    screen and various ways we can work with these objects. The topics include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探讨如何在屏幕上显示对象以及我们可以处理这些对象的多种方式。主题包括：
- en: Understanding AndEngine entities
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 AndEngine 实体
- en: Applying primitives to a layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始图形应用到图层
- en: Bringing a scene to life with sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用精灵为场景注入生命
- en: Applying text to a layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本应用到图层
- en: Using relative rotation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相对旋转
- en: Overriding the `onManagedUpdate` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`onManagedUpdate`方法
- en: Using modifiers and entity modifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用修饰符和实体修饰符
- en: Working with particle systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子系统
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In this chapter, we're going to start working with all of the wonderful entities
    included in AndEngine. Entities provide us with a base foundation that every object
    displayed within our game world will rely on, be it the score text, the background
    image, the player's character, buttons, and everything else. One way to think
    of this is that any object in our game which has the ability to be placed, via
    AndEngine's coordinate system, is an entity at its most basic level. In this chapter,
    we're going to start working with `Entity` objects and many of its subtypes in
    order to allow us to make the most out of them in our own games.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 AndEngine 中包含的所有精彩的实体。实体为我们提供了一个基础，游戏世界中显示的每个对象都将依赖它，无论是分数文本、背景图像、玩家的角色、按钮以及所有其他内容。可以这样想，通过
    AndEngine 的坐标系统，我们游戏中任何可以放置的对象在最基本的层面上都是一个实体。在本章中，我们将开始使用`Entity`对象及其许多子类型，以便在我们的游戏中充分利用它们。
- en: Understanding AndEngine entities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 AndEngine 实体
- en: The AndEngine game engine follows the **entity-component** model. The entity-component
    design is very common in a lot of game engines today, and for a good reason. It's
    easy to use, it's modular, and it is extremely useful in the sense that all game
    objects can be traced back to the single, most basic `Entity` object. The entity-component
    model can be thought of as the "entity" portion referring to the most basic level
    of the game engine's object system. The `Entity` class handles only the most basic
    data that our game objects rely on, such as position, rotation, color, attaching
    and detaching to and from the scene, and more. The "component" portion refers
    to the modular subtypes of the Entity class, such as the `Scene`, `Sprite`, `Text`,
    `ParticleSystem`, `Rectangle`, `Mesh`, and every other object which can be placed
    within our game. The components are meant to handle more specific tasks, while
    the entity is meant to act as a base foundation that all components will rely
    on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 游戏引擎遵循**实体-组件**模型。实体-组件设计在当今许多游戏引擎中非常普遍，这有充分的理由。它易于使用，模块化，并且在所有游戏对象都可以追溯到单一的、最基本的`Entity`对象的程度上非常有用。实体-组件模型可以被认为是游戏引擎对象系统最基本级别的“实体”部分。`Entity`类只处理我们游戏对象依赖的最基本数据，比如位置、旋转、颜色、与场景的附加和分离等。而“组件”部分指的是`Entity`类的模块化子类型，比如`Scene`、`Sprite`、`Text`、`ParticleSystem`、`Rectangle`、`Mesh`以及所有可以放入我们游戏中的其他对象。组件旨在处理更具体的任务，而实体则作为所有组件依赖的基础。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start with the absolute most basic `Entity` method, we will attach an `Entity`
    object to a `Scene` object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从最基础的`Entity`方法开始，我们将一个`Entity`对象附加到`Scene`对象上：
- en: 'Creating and attaching an `Entity` object to the `Scene` object requires only
    the following two lines of code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并将一个`Entity`对象附加到`Scene`对象只需要以下两行代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The two lines of code given here allow us to create and attach a basic `Entity`
    object to our `Scene` object. An `Entity` object that is defined as seen in the
    *How to do it...* section of this recipe will most commonly be used as a layer.
    The purpose of a layer will be discussed in the coming paragraphs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的两行代码允许我们创建一个基本的`Entity`对象并将其附加到我们的`Scene`对象上。正如本食谱中*如何操作...*一节所定义的，一个`Entity`对象通常被用作图层。接下来几段将会讨论图层的用途。
- en: Entities are very important when developing games. In AndEngine, the fact of
    the matter is that all objects displayed on our scenes are derived from entities
    (including the `Scene` object itself!). In most cases, we can assume that the
    entity is either a visually displayed object such as a `Sprite`, `Text`, or `Rectangle`
    object on the scene, or a layer, such as the `Scene` object. Seeing as how broad
    the `Entity` class is, we're going to talk about each of the two uses for entities
    as if they were separate objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实体在游戏开发中非常重要。在 AndEngine 中，事实是，我们场景上显示的所有对象都源自实体（包括`Scene`对象本身！）。在大多数情况下，我们可以假设实体要么是场景上视觉显示的对象，如`Sprite`、`Text`或`Rectangle`对象，要么是一个层，如`Scene`对象。由于`Entity`类的广泛性，我们将分别讨论实体的两种用途，好像它们是不同的对象。
- en: 'The first and arguably most important aspect of an entity is the layering capabilities.
    A layer is a very simple concept in game design; however, due to the amount of
    entities games tend to support during gameplay, things can quickly become confusing
    when first getting to know them. We must think of a layer as an object which has
    one parent and an unlimited amount of children unless otherwise defined. As the
    name suggests, the purpose of a layer is to apply our various entity objects on
    our scene in an organized fashion, which fortunately also gives us the ability
    to perform one action on the layer that will affect all of its children in unison,
    for example, repositioning and applying certain entity modifiers. We can assume
    that if we have a background, a mid-ground, and a foreground, that our game will
    have three separate layers. These three layers would appear in a specific order
    depending on the order they are attached to the scene, as if stacking pieces of
    paper on top of each other. The last piece of paper added to the stack will appear
    in front of the rest if we were to look down on that stack of paper. The same
    rule applies for `Entity` objects attached to a `Scene` object; this is shown
    in the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的第一个，也可能是最重要的方面是分层能力。在游戏设计中，层是一个非常简单的概念；然而，由于游戏在游戏过程中倾向于支持大量的实体，在初次了解它们时，事情可能会很快变得混乱。我们必须将层视为一个具有一个父级和无限数量的子级的对象，除非另有定义。顾名思义，层的目的在于以有组织的方式将我们的各种实体对象应用到场景上，幸运的是，这也使我们能够对层执行一个会影响其所有子级一致的动作，例如，重新定位和施加某些实体修饰符。我们可以假设，如果我们有一个背景、一个中景和一个前景，那么我们的游戏将会有三个独立的层。这三个层将根据它们附加到场景的顺序以特定的顺序出现，就像将纸张堆叠在一起一样。如果我们从上往下看这个堆叠的纸张，最后添加到堆栈中的纸张将出现在其余纸张的前面。对于附加到`Scene`对象的`Entity`对象，同样的规则适用；这在前面的图片中显示：
- en: '![How it works…](img/8987OS_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8987OS_02_01.jpg)'
- en: The previous image depicts a basic game scene consisting of three `Entity` object
    layers. Each of the three layers has a specific purpose, which is to store all
    relative entities in terms of depth. The first layer applied to the scene is the
    background layer, including a sprite, which contains a blue sky and a sun. The
    second layer applied to the scene is the mid-ground layer. On this layer, we would
    find objects which are relative to the player, including the landscape the player
    walks on, collectable items, enemies, and more. Lastly, we have the foreground
    layer, used to display the front-most entities on the device's display. In the
    figure shown, the foreground layer is used to display the user interface, which
    includes a button, and two `Text` objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片描绘了一个由三个`Entity`对象层组成的基本游戏场景。这三个层都有特定的目的，即按照深度存储所有相关实体。首先应用到场景的是背景层，包括一个包含蓝天和太阳的精灵。接着应用到场景的是中景层。在这个层上，我们会找到与玩家相关的对象，包括玩家行走的景观、可收集的物品、敌人等等。最后，我们有了前景层，用于在设备的显示屏上显示最前面的实体。在所展示的图中，前景层用于显示用户界面，包括一个按钮和两个`Text`对象。
- en: 'Let''s take another look at what a scene might look like with layers with child
    entities attached to it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看一个带有子实体附加层的场景可能是什么样子：
- en: '![How it works…](img/8987OS_02_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8987OS_02_03.jpg)'
- en: This figure shows how a scene would display entities on the screen in terms
    of depth/layering. At the bottom of the figure, we've got the device's display.
    We can see that **Background Layer** is attached to the **Scene** first, then
    **Player Layer** is attached. This means that the entities attached to the background
    will be displayed behind the **Player Layer** children. Keeping this in mind,
    the rule applies to the child entities as well. The first child attached to the
    layer will appear behind any subsequently attached object as far as depth goes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了场景如何在屏幕上显示实体的深度/层次。在图的底部，我们有设备的显示。我们可以看到**背景层**首先附属于**场景**，然后是**玩家层**。这意味着附属于背景的实体将位于**玩家层**子实体的后面。记住这一点，这个规则同样适用于子实体。首先附着在层上的子实体在深度上将会位于任何随后附着物体的后面。
- en: 'Finally, one last vital topic relating to general AndEngine entities is Entity
    composition. One thing we should go over before moving on is the fact that *children
    inherit parent values!* This is an area where many new AndEngine developers run
    into issues when setting up multiple layers in their games. Everything from skew,
    scale, position, rotation, visibility, and more are all taken into account by
    child entities when their parent''s properties change. Take a look at the following
    figure, which displays the entity''s **position** composition in AndEngine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于一般 AndEngine 实体的一个最后一个关键主题是实体组合。在继续之前，我们应该了解的一个事实是*子实体继承父实体的值！*这是许多新的 AndEngine
    开发者在设置游戏中的多层时遇到问题的地方。从倾斜、缩放、位置、旋转、可见性等所有属性，当父实体的属性发生变化时，子实体都会考虑在内。查看下面的图，它展示了
    AndEngine 中实体的**位置**组合：
- en: '![How it works…](img/978-1-849518-98-7_02_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/978-1-849518-98-7_02_04.jpg)'
- en: First of all, we should know that in AndEngine's anchor center branch, coordinate
    systems start in the bottom-left corner of an entity. Increasing the x value will
    move the entity position to the right, and increasing the y value will move the
    entity position upward. Decreasing x/y values will have the opposite affect. With
    this in mind, we can see that the bigger rectangle which is attached to the **Scene**
    has its position set to coordinates **(6, 6)** on the **Scene**. Since the smaller
    rectangle is attached to the bigger rectangle, rather than its coordinate system
    being relative to the **Scene**, it is actually using the large rectangle's coordinate
    system. This means that the small rectangle's anchor center position will rest
    directly on position **(0, 0)** of the large rectangle's coordinate system. As
    we can see in the previous image, the **(0, 0)** position on the large rectangle's
    coordinate system is its bottom-left corner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该了解在 AndEngine 的锚点中心分支中，坐标系统是从实体的左下角开始的。增加 x 值会将实体位置向右移动，增加 y 值会将实体位置向上移动。减少
    x/y 值则会产生相反的效果。有了这个概念，我们可以看到附属于**场景**的较大矩形在**场景**上的位置被设定为坐标**（6, 6）**。由于较小矩形附属于较大矩形，而不是相对于**场景**的坐标系统，它实际上是使用大矩形的坐标系统。这意味着小矩形的锚点中心位置将直接位于大矩形坐标系统的**（0,
    0）**位置上。正如我们在前一张图片中看到的，大矩形坐标系统上的**（0, 0）**位置是其左下角。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between the older AndEngine branches and AndEngine's newest
    anchor center branch is the fact that positioning an entity no longer means we
    are setting the upper-left corner of an entity to a position on the coordinate
    system. Rather, the entity's center-point will be placed at the defined position,
    also seen in the previous figure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的 AndEngine 分支与 AndEngine 最新的锚点中心分支之间的主要区别在于，定位实体不再意味着我们将实体的左上角设置在坐标系统上的一个位置。相反，实体的中心点将被放置在定义的位置上，这也在前面的图中有所展示。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Entity` object in AndEngine includes many different methods which affect
    many aspects of the entity. These methods play a vital role in shaping the overall
    characteristics of `Entity` objects regardless of the entity''s subtype. It is
    a good idea to get to know how to manipulate entities in order to take full control
    over how the entities appear, react, store information, and much more. Use the
    following list to familiarize yourself with some of the most important methods
    of the `Entity` object, paired with their corresponding getter methods. Methods
    missing from this list will be covered in more detail in this and the following
    chapters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 中的 `Entity` 对象包含许多不同的方法，这些方法影响实体的许多方面。这些方法在塑造 `Entity` 对象的整体特性方面发挥着至关重要的作用，无论实体的子类型如何。为了完全控制实体的外观、反应、存储信息等，了解如何操作实体是一个好主意。使用以下列表来熟悉
    `Entity` 对象的一些最重要的方法及其相应的获取方法。本章及后续章节将详细介绍此列表中未提及的方法。
- en: '`setVisible(pBoolean)` and `isVisible()`: This method can be used to set whether
    or not the entity is visible on the scene. Setting these methods to `true` will
    allow the entity to render, setting them to `false` will disable rendering.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setVisible(pBoolean)` 和 `isVisible()`: 这个方法可以用来设置实体是否在场景中可见。将这些方法设置为 `true`
    将允许实体渲染，设置为 `false` 将禁用渲染。'
- en: '`setChildrenVisible(pBoolean)` and `isChildrenVisible()`: Similar to the `setVisible(pBoolean)`
    method, except that it defines the visibility of the calling entity''s children
    and not itself.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setChildrenVisible(pBoolean)` 和 `isChildrenVisible()`: 类似于 `setVisible(pBoolean)`
    方法，不同之处在于它定义了调用实体的子实体的可见性，而不是自身。'
- en: '`setCullingEnabled(pBoolean)` and `isCullingEnabled()`: Entity culling can
    be a very promising performance optimization technique. See *Disabling rendering
    with entity culling* in [Chapter 8](ch08.html "Chapter 8. Maximizing Performance"),
    *Maximizing Performance*, for more details.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setCullingEnabled(pBoolean)` 和 `isCullingEnabled()`: 实体剔除可能是一种非常有前景的性能优化技术。更多详情请参见[第8章](ch08.html
    "第8章. 最大化性能")中的*通过实体剔除禁用渲染*，*最大化性能*。'
- en: '`collidesWith(pOtherEntity)`: This method is used to detect when the entity
    that is calling this method collides, or overlaps, with the `Entity` object supplied
    as this method''s parameter. If the entities are colliding, this method returns
    `true`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collidesWith(pOtherEntity)`: 这个方法用于检测调用此方法的实体与作为此方法参数提供的`Entity`对象发生碰撞或重叠时。如果实体正在碰撞，此方法将返回
    `true`。'
- en: '`setIgnoreUpdate(pBoolean)` and `isIgnoreUpdate()`: Ignoring entity updates
    can provide noticeable performance improvements. See *Ignoring entity updates*
    in [Chapter 8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*,
    for more details.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setIgnoreUpdate(pBoolean)` 和 `isIgnoreUpdate()`: 忽略实体更新可以提供明显的性能提升。更多详情请参见[第8章](ch08.html
    "第8章. 最大化性能")中的*忽略实体更新*，*最大化性能*。'
- en: '`setChildrenIgnoreUpdate(pBoolean)` and `isChildrenIgnoreUpdate()`: Similar
    to the `setIgnoreUpdate(pBoolean)` method, except that it only affects the calling
    entity''s children and not itself.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setChildrenIgnoreUpdate(pBoolean)` 和 `isChildrenIgnoreUpdate()`: 类似于 `setIgnoreUpdate(pBoolean)`
    方法，不同之处在于它只影响调用实体的子实体，而不是自身。'
- en: '`getRootEntity()`: This method will iterate through the entity''s parent until
    it reaches the root parent. Once the root parent is found, this method will return
    the root `Entity` object; in most cases, the root being our game''s `Scene` object.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRootEntity()`: 这个方法将遍历实体的父实体，直到找到根父实体。找到根父实体后，此方法将返回根 `Entity` 对象；在大多数情况下，根是我们的游戏
    `Scene` 对象。'
- en: '`setTag(pInt)` and `getTag()`: This method can be used for storing an integer
    value within an entity. Typically used for setting up identification values to
    entities.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTag(pInt)` 和 `getTag()`: 这个方法可以用来在实体中存储整数值。通常用于为实体设置标识值。'
- en: '`setParent(pEntity)` and `hasParent()`: Sets the parent entity to the entity
    calling this method. The `hasParent()` method returns a `true` or `false` value
    depending on whether or not the calling entity has a parent.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setParent(pEntity)` 和 `hasParent()`: 将父实体设置为调用此方法的实体。`hasParent()` 方法根据调用实体是否有父实体返回
    `true` 或 `false` 值。'
- en: '`setZIndex(pInt)` and `getZIndex()`: Set the `Z` index of the calling entity.
    Entities with a greater value will appear in front of entities with a lesser value.
    By default, all entities have a `Z` index of `0`, meaning that they simply appear
    in the order they are attached. See the following `sortChildren()` method for
    more details.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setZIndex(pInt)` 和 `getZIndex()`: 设置调用实体的 `Z` 索引。值较大的实体将出现在值较小的实体前面。默认情况下，所有实体的
    `Z` 索引都是 `0`，这意味着它们将按照附加的顺序出现。更多详情请参见下面的 `sortChildren()` 方法。'
- en: '`sortChildren()`: This method must be called on the parent of an entity or
    group of entities which have had their `Z` index modified before changes take
    effect on the screen.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortChildren()`: 在对实体或实体组的 `Z` 索引进行修改后，必须在它们的父对象上调用此方法，修改后的效果才能在屏幕上显示。'
- en: '`setPosition(pX, pY)` or `setPosition(pEntity)`: This method can be used to
    set the position of an entity to specific x/y values, or it can be used to set
    to another entity''s position. Additionally, we can use the `setX(pX)` and `setY(pY)`
    methods to make changes to only a single axis position.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPosition(pX, pY)` 或 `setPosition(pEntity)`: 此方法用于将实体的位置设置为特定的 x/y 值，或者可以用来设置到另一个实体的位置。此外，我们可以使用
    `setX(pX)` 和 `setY(pY)` 方法仅对单个轴的位置进行更改。'
- en: '`getX()` and `getY()`: These methods are used to obtain the position of an
    entity in local coordinates; that is, relation to its parent.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getX()` 和 `getY()`: 这些方法用于获取实体的本地坐标位置；即相对于其父对象的位置。'
- en: '`setWidth(pWidth)` and `setHeight(pHeight)` or `setSize(pWidth, pHeight)`:
    These methods can be used to set the width and height of the calling entity. Additionally,
    we can use the `getWidth()` and `getHeight()` methods, which return their respective
    values in as a float datatype.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setWidth(pWidth)` 和 `setHeight(pHeight)` 或 `setSize(pWidth, pHeight)`: 这些方法用于设置调用实体的宽度和高度。此外，我们还可以使用
    `getWidth()` 和 `getHeight()` 方法，它们将返回各自值作为浮点数据类型。'
- en: '`setAnchorCenter(pAnchorCenterX, pAnchorCenterY)`: This method can be used
    to set the anchor center of the entity. The anchor center is the position within
    an `Entity` object that it will rotate around, skew from, and scale from. Additionally,
    modifying the anchor center values will relocate the entity''s "positioning" anchor
    from the default center-point. For example, if we move the anchor center position
    to the upper-left corner of an entity, calling `setPosition(0,0)` would place
    the entity''s upper-left corner to position `(0,0)`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAnchorCenter(pAnchorCenterX, pAnchorCenterY)`: 此方法用于设置实体的锚点中心。锚点中心是 `Entity`
    对象内部的一个位置，实体将围绕它旋转、倾斜和缩放。此外，修改锚点中心值将重新定位实体的“定位”锚点，从默认的中心点移动。例如，如果我们把锚点中心位置移动到实体的左上角，调用
    `setPosition(0,0)` 将会把实体的左上角放置在位置 `(0,0)`。'
- en: '`setColor(pRed, pGreen, pBlue)` and `getColor()`: This method can be used to
    set the color of an entity, from values ranging from `0.0f` for no color through
    to `1.0f` for full color.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setColor(pRed, pGreen, pBlue)` 和 `getColor()`: 此方法用于设置实体的颜色，颜色值从 `0.0f`（无颜色）到
    `1.0f`（全颜色）不等。'
- en: '`setUserData(pObject)` and `getUserData(``)`: These two methods are incredibly
    useful when developing games with AndEngine. They allow us to store an object
    of our choice within the entity and modify it or retrieve it at any point in time.
    One possibility for user data storage would be to determine what type of weapon
    a player''s character is holding. Use these methods to the fullest!'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUserData(pObject)` 和 `getUserData()`: 这两个方法在开发 AndEngine 游戏时非常有用。它们允许我们在实体中存储我们选择的任何对象，并在任何时刻修改或检索它。用户数据存储的一个可能用途是确定玩家角色持有什么类型的武器。充分利用这些方法吧！'
- en: Applying primitives to a layer
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将原始图形应用于图层
- en: 'AndEngine''s primitive types include `Line`, `Rectangle`, `Mesh`, and `Gradient`
    objects. In this topic, we''re going to focus on the `Mesh` class. Meshes are
    useful for creating more complex shapes in our games which can have an unlimited
    amount of uses. In this recipe, we''re going to use `Mesh` objects to build a
    house as seen in the the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 的原始类型包括 `Line`、`Rectangle`、`Mesh` 和 `Gradient` 对象。在本主题中，我们将重点关注 `Mesh`
    类。Mesh 对象对于创建游戏中更为复杂的形状非常有用，其应用场景无限广阔。在本教程中，我们将使用 `Mesh` 对象来构建如下所示的房屋：
- en: '![Applying primitives to a layer](img/978-1-849518-98-7_02_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![将原始图形应用于图层](img/978-1-849518-98-7_02_05.jpg)'
- en: Getting ready…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Please refer to the class named `ApplyingPrimitives` in the code bundle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为 `ApplyingPrimitives` 的类。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In order to create a `Mesh` object, we need to do a little bit more work than
    what's required for a typical `Rectangle` or `Line` object. Working with `Mesh`
    objects is useful for a number of reasons. They allow us to strengthen our skills
    as far as the OpenGL coordinate system goes, we can create oddly-shaped primitives,
    and we are able to alter individual vertice positions, which can be useful for
    certain types of animation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个`Mesh`对象，我们需要比典型的`Rectangle`或`Line`对象做更多的工作。使用`Mesh`对象有很多好处。它们可以帮助我们加强OpenGL坐标系统的技能，我们可以创建形状奇特的原始物体，并且能够改变单个顶点的位置，这对于某些类型的动画来说非常有用。
- en: 'The first step involved in creating `Mesh` objects is to create our buffer
    data which is used to specify the points that will make up the shape of the mesh:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Mesh`对象的第一步是创建我们的缓冲数据，这些数据用于指定构成网格形状的点：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the buffer data is configred to our liking, we can go ahead and create
    the `Mesh` object.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦缓冲数据配置完成，我们就可以继续创建`Mesh`对象。
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's break down the process a little bit more in order to find out just how
    we ended up with a house made out of primitive `Mesh` objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分解这个过程，以了解我们是如何使用原始`Mesh`对象制作房屋的。
- en: 'In step one, we''re creating the `baseMesh` object''s buffer data. This buffer
    data is used to store points in 3D space. Every three values stored in the buffer
    data, separated by line-breaks, make up a single vertice in the 3D world. However,
    it should be understood that since we are working with a 2D game engine, the third
    value, which is the `Z` index, is of no use to us. For that reason, we have defined
    the third value for each vertice as the `UNUSED` constant declared within this
    recipe''s class, which is equal to `0`. The points are represented as `(x, y,
    z)` for each triangle, as to not get the order confused. See the following figure
    for a representation of the how the points defined in step one will draw a rectangle
    onto a mesh:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建`baseMesh`对象的缓冲数据。这个缓冲数据用于存储3D空间中的点。缓冲数据中每三个值，由换行符分隔，构成3D世界中的一个顶点。但是，应该明白，由于我们使用的是2D游戏引擎，第三个值，即`Z`索引，对我们来说是没有用的。因此，我们将每个顶点的第三个值定义为该食谱类中声明的`UNUSED`常量，等于`0`。每个三角形的点表示为`(x,
    y, z)`，以避免混淆顺序。请参阅以下图表，了解第一步中定义的点如何绘制到网格上的矩形：
- en: '![How it works…](img/978-1-849518-98-7_02_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![它的工作原理…](img/978-1-849518-98-7_02_06.jpg)'
- en: 'The previous figure represents the `baseMesh` object''s buffer data, or plotted
    points, as seen in the *How to do it...* section''s first step. The black lines
    represent the first set of points:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图表展示了在*如何操作…*部分第一步中看到的`baseMesh`对象的缓冲数据，或者说是绘制点。黑色线条代表第一组点：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second set of points in the `baseMesh` object''s buffer data is represented
    by the grey lines:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseMesh`对象缓冲数据中的第二组点由灰色线条表示：'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since `BASE_HEIGHT` is equal to `200` and `BASE_WIDTH` is equal to `400`, we
    can read that the first triangle's first point, which is `(0, BASE_HEIGHT)`, is
    located in the upper-left corner of the rectangular shape. Moving clockwise, the
    second point for the first triangle is located at position `(BASE_WIDTH, BASE_HEIGHT)`,
    which would be the upper-right corner of the rectangular shape. A triangle is
    obviously made up of three points, so this leaves us with one more vertice to
    plot. The last vertice of our first triangle is located at position `(BASE_WIDTH,
    0)`. As a personal challenge, use the scene graph in the previous figure to find
    out how the grey triangle's plotted points compare to the buffer data!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BASE_HEIGHT`等于`200`且`BASE_WIDTH`等于`400`，我们可以读取到第一个三角形的第一个点`(0, BASE_HEIGHT)`位于矩形形状的左上角。顺时针移动，第一个三角形的第二个点位于`(BASE_WIDTH,
    BASE_HEIGHT)`的位置，这将是矩形形状的右上角。显然，一个三角形由三个点组成，所以这让我们还有一个顶点要绘制。我们第一个三角形的最后一个顶点位于`(BASE_WIDTH,
    0)`的位置。作为一个个人挑战，使用前一个图中的场景图，找出灰色三角形的绘制点与缓冲数据相比如何！
- en: In step two, we are taking our `baseMesh` object's buffer data and using it
    to build the `Mesh` object. The `Mesh` object is a subtype of the `Entity` class,
    so once we have created the `Mesh` object, we can reposition it, scale it, rotate
    it, and and make any other adjustments we need. The parameters, in the order they
    appear in the constructor are as follows; x axis position, y axis position, buffer
    data, vertex count, draw mode, and vertex buffer object manager. The first two
    and last parameters are typical for all entities, but the buffer data, vertex
    count and draw mode are new to us. The buffer data is the array which specifies
    the plotted vertices, which was covered in step one. The vertex count is simply
    the number of vertices that the buffer data contains. Every x, y, and z coordinate
    within our buffer data makes up a single vertice, which is why we are dividing
    the `baseBufferData.length` value by three for this parameter. And finally, `DrawMode`
    defines how the `Mesh` object will interpret the buffer data, which can drastically
    alter the resulting shape of the mesh. The different `DrawMode` types and purposes
    can be found within the *There's more...* section of this topic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们将`baseMesh`对象的缓冲区数据用来构建`Mesh`对象。`Mesh`对象是`Entity`类的一个子类型，因此一旦我们创建了`Mesh`对象，就可以对其进行重新定位、缩放、旋转以及进行其他必要的调整。按照构造函数中出现的顺序，参数如下：x轴位置、y轴位置、缓冲区数据、顶点数量、绘制模式和顶点缓冲对象管理器。前两个参数和最后一个参数对所有实体都是典型的，但缓冲区数据、顶点数量和绘制模式对我们来说是新的。缓冲区数据是数组，它指定了已绘制的顶点，这在第一步中已经介绍过。顶点数量只是缓冲区数据中包含的顶点数。我们缓冲数据中的每一个x、y、z坐标组成一个单独的顶点，这就是为什么我们用`baseBufferData.length`值除以三来得到这个参数。最后，`DrawMode`定义了`Mesh`对象将如何解释缓冲区数据，这可以极大地改变网格的最终形状。不同的`DrawMode`类型和用途可以在本主题的*还有更多...*部分中找到。
- en: 'Before moving on, you may notice that the "door", or rather the blue lines
    that represent the door are not created in the same manner as the roof and base
    `Mesh` objects. Instead, we''ve used lines rather than triangles to draw the outline
    of the door. Take a look at the following code, which is taken from the `doorBufferData`
    array, defining the points in which lines connect:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能会注意到“门”，或者更确切地说，代表门的蓝色线条并不是以与屋顶和基础`Mesh`对象相同的方式创建的。相反，我们使用线条而不是三角形来绘制门的外框。请查看以下代码，它来自`doorBufferData`数组，定义了线条连接的点：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, if we draw a scene graph and plot these points similar to the previous
    figure representing the `baseMesh` object's points, we can actually connect the
    dots and the lines will result in a rectangular shape. It might seem confusing
    at first, especially when trying to create the shapes in our heads. The trick
    to getting started with drawing custom shapes from defined vertices is to keep
    a blank scene graph saved in a favorite document or image editing software. Create
    a scene graph similar to the `baseMesh` object's buffer data representation figure
    and use it to plot points, then simply copy the points to code!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们绘制一个场景图，并像之前代表`baseMesh`对象点的图那样标出这些点，我们实际上可以连接这些点，线条将形成一个矩形形状。一开始可能会让人感到困惑，尤其是在试图在脑海中创建形状时。从定义的顶点开始绘制自定义形状的诀窍是，在您喜欢的文档或图像编辑软件中保存一个空白场景图。创建一个类似于`baseMesh`对象缓冲数据表示图的场景图，并使用它来标出点，然后简单地将点复制到代码中！
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: It is very important to remember that the `(0,0)` position on the previous scene
    graph figure represents the center of the `Mesh` object. Since we are building
    the mesh vertices up and to the right, the anchor center position of the mesh
    will not represent the center of the manually-drawn shapes! This is very important
    to keep in mind when building `Mesh` objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别记住的是，在之前场景图中的`(0,0)`位置代表了`Mesh`对象的中心。由于我们是向上和向右构建网格顶点，网格的锚定中心位置将不代表手动绘制的形状的中心！在构建`Mesh`对象时，这一点非常重要。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Creating meshes can be a pretty daunting subject for beginners, but it''s a
    good idea to get used to them for many reasons. One of the main reasons for AndEngine
    developers is that it can help us to understand how OpenGL draws shapes to a display
    on a lower level, which in turn allows us to grasp the higher-level game development
    functions more easily. The following image contains the various `DrawMode` types
    that AndEngine has conveniently made available for us in order to create `Mesh`
    objects in different ways:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，创建网格可能是一个相当令人畏惧的主题，但有很多原因让我们习惯它们。AndEngine开发者们的一个主要原因是它可以帮助我们理解OpenGL在较低层次上如何将形状绘制到显示上，这反过来又使我们更容易掌握更高层次的游戏开发功能。以下图片包含了AndEngine为我们提供的各种`DrawMode`类型，以便以不同方式创建`Mesh`对象：
- en: '![There''s more...](img/978-1-849518-98-7_02_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/978-1-849518-98-7_02_08.jpg)'
- en: 'The previous figure shows how vertices within our buffer data will be drawn
    to the scene by our `Mesh` object depending on the `DrawMode` type selected. Each
    **p#** in this figure represents a `vertice (x, y, and z value)` within our buffer
    data array. See the following points for an explanation of the image representations
    of each `DrawMode` type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前图展示了我们的缓冲数据中的顶点将如何根据所选的`DrawMode`类型由`Mesh`对象绘制到场景中。此图中的每个**p#**代表我们缓冲数据数组中的`顶点（x，y和z值）`。以下是每个`DrawMode`类型的图像表示的解释：
- en: '`DrawMode.POINTS`: This selection allows us to draw single points for each
    vertice within the mesh''s buffer data. These points will not be connected by
    any lines; they will simply display a dot on the mesh for each point.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.POINTS`：这种选择允许我们在网格的缓冲数据中为每个顶点绘制单独的点。这些点不会由任何线条连接；它们仅仅在网格上为每个点显示一个点。'
- en: '`DrawMode.LINES`: This selection allows us to draw individual lines on the
    mesh. Every two vertices will be connected by a line.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.LINES`：这种选择允许我们在网格上绘制单独的线条。每两个顶点将由线条连接。'
- en: '`DrawMode.LINE_STRIP`: This selection allows us to draw points on the mesh,
    with each point after the first point being connected to the previous point. For
    example, **p1** will be connected to **p0**, **p2** will be connected to **p1**,
    and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.LINE_STRIP`：这种选择允许我们在网格上绘制点，第一个点之后的每个点都连接到前一个点。例如，**p1**将连接到**p0**，**p2**将连接到**p1**，依此类推。'
- en: '`DrawMode.LINE_LOOP`: This selection acts in a similar way to the `DrawMode.LINE_STRIP`
    type, however, the first point and the final point will also be connected by a
    line. This allows us to create closed shapes via lines.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.LINE_LOOP`：这种选择与`DrawMode.LINE_STRIP`类型类似，但是，第一个点与最后一个点也会由线条连接。这允许我们通过线条创建闭合的形状。'
- en: '`DrawMode.TRIANGLES`:– This selection allows us to draw individual triangles
    on the mesh for each three vertices defined within our buffer data. We are required
    to keep our vertices at multiples of three for this draw mode.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.TRIANGLES`：这种选择允许我们在网格上为缓冲数据中定义的每组三个顶点绘制单独的三角形。这种绘制模式要求我们将顶点保持在三的倍数。'
- en: '`DrawMode.TRIANGLE_FAN`: This selection allows us to draw coned or pyramidal-shaped
    meshes. As we can see in the previous figure, we start by specifying a point which
    defines the top-most point of the cone, then continue on to specify any number
    of base points for the shape. This draw mode requires three or more vertices to
    be defined within the buffer data.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.TRIANGLE_FAN`：这种选择允许我们绘制锥形或金字塔形状的网格。正如在之前的图中可以看到的，我们首先指定一个点，定义锥形的顶部点，然后继续指定形状的底部点。这种绘制模式需要定义三个或更多的顶点在缓冲数据中。'
- en: '`DrawMode.TRIANGLE_STRIP`: This selection allows us to easily create customized
    polygonal meshes. Every vertice defined in the buffer data after the third vertice
    of the initial triangle will result in a new triangle, creating a new "strip".
    See the figure representation for an example. This draw mode requires three or
    more vertices to be defined within the buffer data.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawMode.TRIANGLE_STRIP`：这种选择使我们能够轻松创建自定义的多边形网格。在初始化三角形的第三个顶点之后，缓冲数据中定义的每个顶点都会生成一个新的三角形，创建一个新的“带”。请参阅图表示例。这种绘制模式需要定义三个或更多的顶点在缓冲数据中。'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding AndEngine entities* given in this chapter.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中提供的*了解AndEngine实体*。
- en: Bringing a scene to life with sprites
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用精灵为场景带来生机
- en: Here, we come to the topic which might be considered to be the most necessary
    aspect to creating any 2D game. Sprites allow us to display 2D images on our scene
    which can be used to display buttons, characters/avatars, environments and themes,
    backgrounds, and any other entity in our game which may require representation
    by means of an image file. In this recipe, we'll be covering the various aspects
    of AndEngine's `Sprite` entities which will give us the information we need to
    continue to work with `Sprite` objects later on in more complex situations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的可能是创建任何2D游戏最必要的一个方面。精灵（Sprites）允许我们在场景中显示2D图像，这些图像可以用来展示按钮、角色/化身、环境主题、背景以及游戏中可能需要通过图像文件来表示的任何其他实体。在本教程中，我们将介绍AndEngine的`Sprite`实体的各个方面，这将为我们提供在以后更复杂的情况下继续使用`Sprite`对象所需的信息。
- en: Getting ready…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Before we dive into the inner-workings of how sprites are created, we need to
    understand how to create and manage AndEngine's `BitmapTextureAtlas`/`BuildableBitmapTextureAtlas`
    objects as well as the `ITextureRegion` object. For more information, please refer
    to the recipes, *Working with different types of textures* and *Applying texture
    options* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine
    Game Structure*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解精灵如何创建的内部工作机制之前，我们需要了解如何创建和管理AndEngine的`BitmapTextureAtlas`/`BuildableBitmapTextureAtlas`对象以及`ITextureRegion`对象。更多信息，请参考[第1章](ch01.html
    "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的教程，*使用不同类型的纹理*和*应用纹理选项*。
- en: Once these recipes have been covered, create a new empty AndEngine project with
    the `BaseGameActivity` class, provide a PNG formatted image of any size up to
    1024 x 1024 pixels in dimension, naming it as `sprite.png` and place it in the
    `assets/gfx/` folder of the project, then continue to the *How to do it...* section
    of this recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这些教程后，创建一个新的空AndEngine项目，使用`BaseGameActivity`类，提供一个尺寸最大为1024 x 1024像素的PNG格式图像，将其命名为`sprite.png`并放在项目的`assets/gfx/`文件夹中，然后继续本教程的*如何操作...*部分。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Sprites can be created and applied to our `Scene` object in just a few quick
    steps. We must first set up the necessary texture resources that the sprite will
    use, we must create the `Sprite` object, and then we must attach the `Sprite`
    object to our `Scene` object. See the following steps for more detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需几个快速步骤就可以创建并将精灵应用到我们的`Scene`对象中。我们首先必须设置精灵将使用的必要纹理资源，创建`Sprite`对象，然后必须将`Sprite`对象附加到我们的`Scene`对象。以下步骤将提供更多详细信息：
- en: 'We will start by creating the texture resources in the `onCreateResources()`
    method of our `BaseGameActivity` class. Make sure the `mBitmapTextureAtlas` and
    `mSpriteTextureRegion` objects are global variables, so that they can be reached
    throughout the various life cycle methods of our activity:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在`BaseGameActivity`类的`onCreateResources()`方法中创建纹理资源开始。确保`mBitmapTextureAtlas`和`mSpriteTextureRegion`对象是全局变量，这样它们就可以在活动的各种生命周期方法中被访问：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will create the `Sprite` object. We can create and attach the `Sprite`
    object to the `Scene` object in either the `onCreateScene()` or the `onPopulateScene()`
    methods of our activity. The parameters to supply in its constructor include,
    in this order, the sprites initial x coordinate, initial y coordinate, `ITextureRegion`
    object, and finally the `mEngine` object''s vertex buffer object manager:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`Sprite`对象。我们可以在活动的`onCreateScene()`或`onPopulateScene()`方法中创建并附加`Sprite`对象到`Scene`对象。在它的构造函数中需要提供的参数包括，按此顺序，精灵的初始x坐标、初始y坐标、`ITextureRegion`对象，最后是`mEngine`对象的顶点缓冲区管理器：
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: As it might appear in the steps in the previous section, setting up the `mBitmapTextureAtlas`
    and `mSpriteTextureRegion` objects actually require more work than creating and
    setting up the `mSprite` object specifically. For this reason, it is encouraged
    to complete the two recipes mentioned in the *Getting started...* section beforehand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分的步骤所示，实际上设置`mBitmapTextureAtlas`和`mSpriteTextureRegion`对象比专门创建和设置`mSprite`对象需要更多的工作。因此，建议在开始之前先完成*入门...*部分提到的两个教程。
- en: In the first step, we will create our `mBitmapTextureAtlas` and `mSpriteTextureRegion`
    objects, suitable to the needs of our `sprite.png` image. Feel free to use any
    texture options or texture format in this step. It is a very good idea to get
    to know them well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将创建适合我们`sprite.png`图像需求的`mBitmapTextureAtlas`和`mSpriteTextureRegion`对象。在这一步中，请随意使用任何纹理选项或纹理格式。很好地了解它们是非常有想法的。
- en: Once we've our `ITextureRegion` object created and it's ready for use, we can
    move to step two where we will create the `Sprite` object. Creating a sprite is
    a straightforward task. The first two parameters will be used to define the initial
    position of the sprite, relative to its center point. For the third parameter,
    we will pass in the `ITextureRegion` object that we created in step one in order
    to provide the sprite with its appearance as an image on the scene. Finally, we
    pass in the `mEngine.getVertexBufferObjectManager()` method, which is necessary
    for most entity subtypes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`ITextureRegion`对象并且它已经准备好使用，我们可以进入第二步，创建`Sprite`对象。创建一个精灵是一个直接的任务。前两个参数将用于定义精灵的初始位置，相对于其中心点。对于第三个参数，我们将传递在第一步中创建的`ITextureRegion`对象，以便为场景中的精灵提供图像外观。最后，我们传递`mEngine.getVertexBufferObjectManager()`方法，这是大多数实体子类型所必需的。
- en: Once our `Sprite` object is created, we must attach it to the `Scene` object
    before it will be displayed on the device, or we can attach it to another `Entity`
    object which is already attached to the `Scene` object. See the *Understanding
    AndEngine entities* recipe given in this chapter for more information on entity
    composition, placement, and other various must-know aspects of `Entity` objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`Sprite`对象被创建，我们必须在它能在设备上显示之前将它附加到`Scene`对象，或者我们可以将它附加到已经连接到`Scene`对象的另一个`Entity`对象上。关于实体组合、放置以及其他各种必须了解的`Entity`对象方面，请参阅本章中提供的*了解AndEngine实体*食谱。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: No game is complete without some sort of sprite animation. After all, a player
    can only return to a game so many times before getting bored in a game where the
    characters slide around the screen without moving their feet, don't swing their
    weapon when attacking an enemy, or even when a grenade simply disappears rather
    than causing a nice explosion effect. In this day and age, people want to play
    games which look and feel nice, and nothing says, "Nice!", like buttery smooth
    animating sprites, right?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有某种形式的精灵动画，游戏是不完整的。毕竟，玩家只能在游戏中返回这么多次，之后就会对那些角色在屏幕上滑动而不动脚、攻击敌人时不挥舞武器，或者手榴弹只是消失而不是产生漂亮的爆炸效果的游戏感到厌倦。在这个时代，人们想要玩看起来和感觉都很棒的游戏，而像黄油般平滑的动画精灵没有什么能比得上“好极了！”，不是吗？
- en: 'In the *Working with different types of textures* recipe in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*, we''d covered
    how to create a `TiledTextureRegion` object which allows us to import useable
    sprite sheets into our game as a texture. Now let''s find out how we can use that
    `TiledTextureRegion` object with an `AnimatedSprite` object in order to add some
    animation to our game''s sprites. For this demonstration, the code will be working
    with an image of 300 x 50 pixels in dimension. The sprite sheet can be something
    as simple as the following figure, just to get an idea of how to create the animation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中的*使用不同类型的纹理*食谱中，我们介绍了如何创建一个`TiledTextureRegion`对象，该对象允许我们将可用的精灵表作为纹理导入到游戏中。现在让我们找出如何使用`TiledTextureRegion`对象与`AnimatedSprite`对象为游戏的精灵添加动画。在这个演示中，代码将处理一个尺寸为300
    x 50像素的图像。精灵表可以是如图所示的那样简单，以了解如何创建动画：
- en: '![There''s more...](img/978-1-849518-98-7_02_09.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/978-1-849518-98-7_02_09.jpg)'
- en: 'The sprite sheet in the previous figure can be used to create a `TiledTextureRegion`
    object with 12 columns and 1 row. Creating the `BuildableBitmapTextureAtlas` and
    `TiledTextureRegion` objects for this sprite sheet can be done with the following
    code. However, before importing this code, be sure to make a global declaration
    of the texture region—`TiledTextureRegion mTiledTextureRegion`—in your test project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中的精灵表可用于创建一个有12列1行的`TiledTextureRegion`对象。为这个精灵表创建`BuildableBitmapTextureAtlas`和`TiledTextureRegion`对象可以使用以下代码。但是，在导入这段代码之前，请确保在测试项目中全局声明纹理区域—`TiledTextureRegion
    mTiledTextureRegion`。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we''ve got the `mTiledTextureRegion` sprite sheet to play with in
    our project, we can create and animate the `AnimatedSprite` object. If you are
    using a sprite sheet with black circles as seen in the previous figure, don''t
    forget to change the color of the `Scene` object to a non-black color so we can
    see the `AnimatedSprite` object:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的项目中已经有了可以操作的`mTiledTextureRegion`精灵表，我们可以创建并动画化`AnimatedSprite`对象。如果你使用的是如图所示带有黑色圆圈的精灵表，别忘了将`Scene`对象的颜色改为非黑色，这样我们才能看到`AnimatedSprite`对象：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating the `AnimatedSprite` object can be done following the steps in this
    recipe while creating a regular `Sprite` object. Once it's created, we are able
    to set up its animation data, including individual frame duration, first and last
    tile indices to animate through, and whether or not to loop the animation continuously.
    Note that the `frameDuration` array must be equal to the frame count! Failing
    to follow this rule will result in an `IllegalArgumentException` exception. Once
    the data has been set up, we can call the `animate()` method on the `AnimatedSprite`
    object, supplying all of the data and adding an `IAnimationListener` listener
    if we wish. As the comments in the listener suggest, we gain a large portion of
    control over the animations with AndEngine's `AnimatedSprite` class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`AnimatedSprite`对象可以按照本食谱中创建常规`Sprite`对象的步骤进行。一旦创建完成，我们就可以设置其动画数据，包括单个帧的持续时间、要动画化的第一块和最后一块图块索引，以及是否要连续循环动画。注意，`frameDuration`数组必须等于帧数！不遵循此规则将导致抛出`IllegalArgumentException`异常。数据设置完成后，我们可以在`AnimatedSprite`对象上调用`animate()`方法，提供所有数据，并在需要时添加`IAnimationListener`监听器。正如监听器中的注释所示，通过AndEngine的`AnimatedSprite`类，我们对动画的控制能力得到了大幅提升。
- en: Using OpenGL's dithering capability
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OpenGL的抖动功能
- en: When developing visually appealing games on the mobile platform, it is a likely
    scenario that we'll want to include some gradients in our images, especially when
    dealing with 2D graphics. Gradients are great for creating lighting effects, shadows,
    and many other objects we'd otherwise not be able to apply to a full 2D world.
    The problem lies in the fact that we're developing for mobile devices, so we unfortunately
    do not have an unlimited amount of resources at our disposal. Because of this,
    AndEngine down-samples the surface view color format to `RGB_565` by default.
    Regardless of the texture format we define within our textures, they will always
    be down-sampled before being displayed on the device. We could alter the color
    format applied to AndEngine's surface view, but it's likely that the performance-hit
    will not be worth it when developing larger games with many sprites.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动平台上开发视觉上吸引人的游戏时，我们很可能会希望图像中包含一些渐变，特别是在处理2D图形时。渐变非常适合创建光照效果、阴影以及许多其他无法应用于完整2D世界的对象。问题在于，我们是为移动设备开发，因此不幸的是，我们无法使用无限量的资源。因此，AndEngine默认将表面视图的颜色格式下采样为`RGB_565`。无论我们在纹理中定义的纹理格式如何，它们在设备上显示之前总是会被下采样。我们可以更改应用于AndEngine表面视图的颜色格式，但在开发包含许多精灵的大型游戏时，性能损失可能不值得。
- en: Here, we have two separate screenshots of a simple sprite with a gradient texture;
    both textures are using the `RGBA_8888` texture format and `BILINEAR` texture
    filtering (the highest quality).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有两张具有渐变纹理的简单精灵的独立屏幕截图；这两种纹理都使用了`RGBA_8888`纹理格式和`BILINEAR`纹理过滤（最高质量）。
- en: '![Using OpenGL''s dithering capability](img/978-1-849518-98-7_02_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用OpenGL的抖动功能](img/978-1-849518-98-7_02_07.jpg)'
- en: The image on the right-hand side is applied to the `Scene` object without any
    modifications, while the image on the left-hand side has OpenGL's dithering capability
    enabled. The difference between the two otherwise identical images is immediately
    noticeable. Dithering is a great way for us to combat down-sampling applied by
    the surface view without us having to rely on maximum color quality formats. In
    short, by dithering low-levels of randomized noise within our image's colors,
    it results in a smoother finish which is found in the image to the left.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图像未经任何修改就应用到了`Scene`对象上，而左侧的图像启用了OpenGL的抖动功能。这两张其他方面相同的图像之间的差异立即显而易见。抖动是我们对抗表面视图应用的降采样的一种很好的方法，而无需依赖最大颜色质量格式。简而言之，通过在图像颜色中加入低级别的随机噪声，结果得到了更平滑的完成效果，如左侧的图像所示。
- en: 'Enabling dithering is simple to apply to our entities in AndEngine, but as
    with everything, it''s wise to pick and choose which textures apply dithering.
    The algorithm does add a little bit of extra overhead, where if used too often
    could result in a larger performance loss than simply reverting our surface view
    to `RGBA_8888`. In the following code, we are enabling dithering in our `preDraw()`
    method and disabling it in our `postDraw()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在AndEngine中，为我们的实体应用抖动很简单，但与所有事物一样，明智的做法是选择哪些纹理应用抖动。该算法确实增加了一点额外的开销，如果使用过于频繁，可能会导致比简单地将我们的表面视图恢复为`RGBA_8888`更大的性能损失。在以下代码中，我们在`preDraw()`方法中启用抖动，在`postDraw()`方法中禁用它：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Dithering can be applied to any subtype of AndEngine's `Shape` class (`Sprites`,
    `Text`, primitives, and so on.).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 晕染可以应用于AndEngine的`Shape`类的任何子类型（`Sprites`、`Text`、基元等）。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about OpenGL ES 2.0 and how to work with all of the different
    functions, visit the link at [http://www.khronos.org/opengles/sdk/docs/man/](http://www.khronos.org/opengles/sdk/docs/man/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenGL ES 2.0以及如何使用所有不同函数的更多信息，请访问[http://www.khronos.org/opengles/sdk/docs/man/](http://www.khronos.org/opengles/sdk/docs/man/)。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *Working with Entities*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")中*处理不同类型的纹理*，*处理实体*
- en: '*Applying texture options* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game
    Structure"), *Working with Entities*.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")中*应用纹理选项*，*处理实体*。
- en: '*Understanding AndEngine entities* in this chapter.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*了解AndEngine实体*。
- en: Applying text to a layer
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本应用到图层
- en: Text is an important part of game development as it can be used to dynamically
    display point systems, tutorials, descriptions, and more. AndEngine also allows
    us to create text styles which suit individual game types better by specifying
    customized `Font` objects. In this recipe, we're going to create a `Text` object,
    which updates itself with the current system time as well as correct its position
    every time the length of the string grows or shrinks. This will prepare us for
    the use of `Text` objects in cases where we need to display scores, time, and
    other non-specific dynamic string situations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是游戏开发的重要组成部分，因为它可以用来动态显示积分系统、教程、描述等。AndEngine还允许我们通过指定自定义的`Font`对象来创建更适合个别游戏类型的文本样式。在本教程中，我们将创建一个`Text`对象，它会随当前系统时间更新自身，并在字符串长度增长或缩短时调整其位置。这将为我们需要显示分数、时间和其他非特定动态字符串情况下的`Text`对象使用做好准备。
- en: Getting ready…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: Applying `Text` objects to our `Scene` object requires a working knowledge of
    AndEngine's font resources. Please perform the the recipe, Using AndEngine font
    resources in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *Working
    with Entities*, then proceed with the *How to do it...* section of this recipe.
    Refer to the class named `ApplyingText` in the code bundle for this recipe's activity
    in code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Text`对象应用到我们的`Scene`对象需要了解AndEngine的字体资源。请执行[第1章](ch01.html "第1章. AndEngine游戏结构")中的教程，*使用AndEngine字体资源*，然后继续本教程的*如何操作…*部分。参考与此食谱活动代码捆绑中的名为`ApplyingText`的类。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'When applying `Text` objects to our `Scene` object, we are required to create
    a `Font` object which will define the text''s style, and create the `Text` object
    itself. See the folllowing steps for the specific actions we must take in order
    to properly display a `Text` object on our scene:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Text`对象应用到我们的`Scene`对象上时，需要创建一个`Font`对象来定义文本的样式，并创建`Text`对象本身。以下步骤将说明我们必须采取的具体操作，以便在我们的场景上正确显示`Text`对象：
- en: 'The first step to creating any `Text` object is to prepare ourselves a `Font`
    object. The `Font` object will act as the resource which defines the style of
    the `Text` object. Additionally, we need to prepare the letters that we plan for
    the `Text` object to display:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建任何`Text`对象的第一步是为自己准备一个`Font`对象。`Font`对象将作为定义`Text`对象样式的资源。此外，我们还需要准备我们计划让`Text`对象显示的字母：
- en: '[PRE11]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we''re dealing with final strings which may never change, only the first
    two steps need to be covered. However, in this recipe we will need to override
    the `onManagedUpdate()` method of the `Text` entity in order to make adjustments
    to its string over time. In this case, we''re updating the time value of the string
    after every second passed:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们处理的是可能永远不会改变的最终字符串，那么只需要涵盖前两个步骤。然而，在本教程中，我们将需要覆盖`Text`实体的`onManagedUpdate()`方法，以便随时间对其字符串进行调整。在本例中，每经过一秒钟，我们就会更新字符串的时间值：
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By this point, we should already have an understanding of how to create the
    `Font` object as we had discussed it in the first chapter. If creating `Font`
    objects is not yet understood, please visit the recipe, *Using AndEngine font
    resources* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *Working
    with Entities*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该已经了解了如何创建`Font`对象，因为我们在第一章中已经讨论过。如果还不知道如何创建`Font`对象，请访问[第1章](ch01.html
    "第1章. AndEngine游戏结构")中的教程，*使用AndEngine字体资源*，*处理实体*。
- en: In the first step, we are simply creating a basic `Font` object which will create
    a rather generic style for our `Text` object. Once the `Font` object has been
    created, we are preparing only the necessary characters that will be displayed
    throughout the life of the `Text` object with the `mFont.prepareLetters()` method.
    Doing so allows us to avoid garbage collector invocations within the `Font` object.
    The values used in this recipe will obviously range from `0` to `9` as we are
    dealing with time, as well as the individual characters that make up the string,
    `Time:`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们只是创建了一个基本的`Font`对象，它将为我们的`Text`对象创建一个相当通用的样式。创建`Font`对象后，我们只准备`Text`对象在其生命周期内将显示的必要字符，使用`mFont.prepareLetters()`方法。这样做可以避免在`Font`对象内调用垃圾收集器。这个配方中使用的值显然是从`0`到`9`，因为我们处理的是时间，以及组成字符串`Time:`的单个字符。
- en: 'Once step one is completed, we can move onto step two where we create the `Text`
    object. The `Text` object requires that we specify its initial position on the
    screen in x and y coordinates, the `Font` object to use as a style, the initial
    string to display, its maximum character count, and finally the vertex buffer
    object manager as needed by all `Entity` objects. However, since we''re dealing
    with a dynamically-updating `String` value for this `Text` object, which will
    require adjustments on the x axis, the parameters including the x coordinate as
    well as the initial string are not so important as they will be adjusted frequently
    during updates to the `Text` object. The most important parameter is the maximum
    character count. Failing to keep the `Text` object''s maximum character count
    below that of the value specified within this parameter will result in the application
    receiving an `ArrayIndexOutOfBoundsException` exception and will likely require
    termination. For this reason, we are adding up the length of the largest string
    as seen in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一步后，我们可以进入第二步，创建`Text`对象。`Text`对象需要我们指定其在屏幕上的初始位置（x和y坐标），使用的`Font`对象样式，要显示的初始字符串，其最大字符数，以及所有`Entity`对象所需的顶点缓冲对象管理器。然而，由于我们处理的这个`Text`对象有一个动态更新的`String`值，这将需要调整x轴，包括x坐标以及初始字符串在内的参数并不重要，因为它们将在更新`Text`对象时频繁调整。最重要的参数是最大字符数。如果`Text`对象的最大字符数超过了此参数内指定的值，将导致应用程序接收到`ArrayIndexOutOfBoundsException`异常，很可能会需要终止。因此，我们在以下代码片段中累加最大字符串的长度：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the third step, we are overriding the `Text` object's `onManagedUpdate()`
    method in order to apply changes to the `Text` object's string after every second
    passed. At first, we simply obtain the device's current second value, using it
    to compare with the second value in the previous call to the `Text` object's `onManagedUpdate()`
    method. This allows us to avoid updating the `Text` object with the system time
    on every single update. If the previous second that the `Text` object's string
    was updated with is not the same as the new second value, then we continue on
    to obtain the current minute and hour values as well via the `Calendar.getInstance().get(HOUR)`
    method and `MINUTE` variation. Now that we've got all of the values, we build
    a new string containing the updated time, and call `setText(pString)` on the `Text`
    object to change the string it will display on the device.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们覆盖了`Text`对象的`onManagedUpdate()`方法，以便在每秒过去后对`Text`对象的字符串应用更改。首先，我们只需获取设备的当前秒值，用它来与上一次调用`Text`对象的`onManagedUpdate()`方法中的秒值进行比较。这样，我们可以避免在每次更新时都使用系统时间更新`Text`对象。如果`Text`对象字符串上次更新的秒值与新的秒值不同，那么我们继续通过`Calendar.getInstance().get(HOUR)`方法和`MINUTE`变体获取当前的分钟和小时值。现在我们已经获得了所有的值，我们构建了一个包含更新时间的新字符串，并在`Text`对象上调用`setText(pString)`来更改它将在设备上显示的字符串。
- en: However, due to the fact that each individual character width might have a different
    value, we also need to make corrections in the position in order to keep the full
    `Text` object on the screen. By default, the anchor position is set to the center
    of an `Entity` object, so by calling `this.setX(WIDTH - this.getWidth() * 0.5f)`,
    where `this` refers to the `Text` object, we position the entity's center-most
    point at the maximum screen width to the right, and then subtract half of the
    entity's width. This will allow the text to sit right along the edge of the screen
    even after its characters change the width of the `Text` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于每个单独的字符宽度可能具有不同的值，我们也需要调整位置，以保持整个`Text`对象在屏幕上。默认情况下，锚点位置被设置为`Entity`对象的中心，因此通过调用`this.setX(WIDTH
    - this.getWidth() * 0.5f)`（其中`this`指的是`Text`对象），我们将实体最中心的点定位在屏幕最大宽度右侧，然后减去实体宽度的一半。这将允许文本即使在其字符改变了`Text`对象的宽度后，也能沿着屏幕边缘正确显示。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Sometimes our games may require a little bit of formatting to the `Text` object''s
    strings. In cases where we need to adjust the `Text` object''s horizontal alignment,
    apply auto-wrapping to the text if its string exceeds a certain width, or a leading
    space to the text, we can do these with some very easy-to-use methods. The following
    methods can be called directly on the `Text` object; for example, `mText.setLeading(3)`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的游戏可能需要对`Text`对象的字符串进行一些格式化处理。在我们需要调整`Text`对象的水平对齐方式、如果字符串超出一定宽度则对文本应用自动换行，或者在文本前添加一个空格的情况下，我们可以使用一些非常易于使用的方法。以下方法可以直接在`Text`对象上调用；例如，`mText.setLeading(3)`：
- en: '`setAutoWrap(pAutoWrap)`: This method allows us to define whether or not, and
    if so, how a `Text` entity will perform auto-wrapping. The options we have for
    parameters include `AutoWrap.NONE`, `AutoWrap.LETTERS`, `AutoWrap.WORDS`, and
    `AutoWrap.CJK`. With `LETTERS`, line break won''t wait for a whitespace before
    breaking to a new line while `WORDS` will. The `CJK` variant is an option which
    allows auto-wrapping for Chinese, Japanese, and Korean characters. This method
    should be used alongside `setAutoWrapWidth(pWidth)`, where `pWidth` defines the
    maximum width of any single line within the `Text` object''s string, causing line-breaks
    when necessary.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAutoWrap(pAutoWrap)`: 这个方法允许我们定义`Text`实体是否执行自动换行，以及如何执行。我们可以为参数选择的选项包括`AutoWrap.NONE`、`AutoWrap.LETTERS`、`AutoWrap.WORDS`和`AutoWrap.CJK`。使用`LETTERS`时，行中断不会在空白前等待，而`WORDS`会等待。`CJK`变体是允许对中、日、韩字符进行自动换行的选项。这个方法应该与`setAutoWrapWidth(pWidth)`一起使用，其中`pWidth`定义了`Text`对象字符串中任意单行的最大宽度，在需要时导致换行。'
- en: '`setHorizontalAlign(pHorizontalAlign)`: This method allows us to define the
    type of alignment the `Text` object''s string should follow. The parameters include
    `HorizontalAlign.LEFT`, `HorizontalAlign.CENTER`, and `HorizontalAlign.RIGHT`.
    The result is similar to what we''d see when setting alignment within a text editor.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setHorizontalAlign(pHorizontalAlign)`: 这个方法允许我们定义`Text`对象字符串应遵循的对齐类型。参数包括`HorizontalAlign.LEFT`、`HorizontalAlign.CENTER`和`HorizontalAlign.RIGHT`。其结果类似于我们在文本编辑器内设置对齐时看到的效果。'
- en: '`setLeading(pLeading)`: This method allows us to set a leading space at the
    beginning of the `Text` object''s string. The parameter required is a float value,
    which defines the leading width of the sring.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLeading(pLeading)`: 这个方法允许我们在`Text`对象字符串的开始处设置一个前置空间。所需的参数是一个浮点值，它定义了字符串的前导宽度。'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using AndEngine font resources* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *Working with Entities*.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")中*使用AndEngine字体资源*，*处理实体*。
- en: '*Overriding the onManagedUpdate method* in this chapter.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*覆盖onManagedUpdate方法*。
- en: Using relative rotation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相对旋转
- en: 'Rotating entities relative to the position of other entities in 2D space is
    a great function to know. The uses for relative rotation are limitless and always
    seems to be a "hot topic" for newer mobile game developers. One of the more prominent
    examples of this technique being used is in tower-defense games, which allows
    a tower''s turret to aim towards the direction that an enemy, non-playable character
    is walking. In this recipe, we''re going to introduce a method of rotating our
    `Entity` objects in order to point them in the direction of a given x/y position.
    The following image displays how we will create an arrow on the scene, which will
    automatically point to the position of the circle image, wherever it moves to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D空间中相对于其他实体的位置旋转实体是一个很棒的功能。相对旋转的使用是无限的，并且似乎总是移动游戏开发新手中的“热门话题”。这种技术被广泛应用的一个较为突出的例子是在塔防游戏中，它允许塔的炮塔朝向敌人（非玩家角色）行走的方向。在这个示例中，我们将介绍一种旋转我们的`Entity`对象的方法，以便它们指向给定的x/y位置。以下图像展示了我们如何在场景上创建一个箭头，它会自动指向圆形图像的位置，无论它移动到哪里：
- en: '![Using relative rotation](img/978-1-849518-98-7_02_02.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用相对旋转](img/978-1-849518-98-7_02_02.jpg)'
- en: Getting ready…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: We'll need to include two images for this recipe; one named `marble.png` at
    32 x 32 pixels in dimension and another named `arrow.png` at 31 pixels wide by
    59 pixels high. The marble can be any image. We will simply drag this image around
    the scene as we please. The arrow image should be in the shape of an arrow, with
    the arrowhead pointing directly upward on the image. See the screenshot in the
    introduction for an example of the images to include. Include these assets in
    an empty `BaseGameActivity` test project then please refer to the class named
    `RelativeRotation` in the code bundle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例我们需要包含两个图像；一个名为`marble.png`，尺寸为32x32像素，另一个名为`arrow.png`，宽31像素，高59像素。弹珠可以是任何图像，我们只需随意在场景中拖动这个图像。箭头图像应该呈箭头形状，图像上的箭头直接朝上。请参考引言中的屏幕截图以了解需要包含的图像示例。将这些资源包含在空的`BaseGameActivity`测试项目中，然后请参考代码包中的名为`RelativeRotation`的类。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Implement the `IOnSceneTouchListener` listener in the `BaseGameActivity` class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BaseGameActivity`类中实现`IOnSceneTouchListener`监听器：
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set the `Scene` object''s `onSceneTouchListener` in the activity''s `onCreateScene()`
    method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreateScene()`方法中设置`Scene`对象的`onSceneTouchListener`：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Populate the `Scene` object with the marble and arrow sprites. The arrow sprite
    is positioned in the center of the scene, while the marble''s position is updated
    to the coordinates of any touch event location:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用弹珠和小箭头的图像填充`Scene`对象。小箭头图像位于场景中心，而弹珠的位置会更新为任意触摸事件位置的坐标：
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Step four introduces the `onSceneTouchEvent()` method which handles the movement
    of the marble sprite via a touch event on the device''s display:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四步介绍了`onSceneTouchEvent()`方法，它通过设备显示上的触摸事件处理弹珠图像的移动：
- en: '[PRE17]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this class, we're creating a sprite which is represented by an arrow image
    and placing it in the direct center of the screen, automatically pointing to a
    another sprite represented by a marble. The marble is draggable via touch events
    through the use of an `IOnSceneTouchListener` listener implementation within our
    `BaseGameActivity` class. We then register the touch listener to the `mScene`
    object. In situations where an entity rotates according to another entity's position,
    we'll have to include the rotation functionality in some method that is consistently
    updated, otherwise our arrow would not continuously react. We can do this through
    update threads, but in this instance we'll include that functionality in the `onSceneTouchEvent()`
    overridden method as the "target" will not actually move until we touch the scene
    anyway.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们创建了一个由箭头图像表示的精灵，并将其放置在屏幕正中心，自动指向由弹珠表示的另一个精灵。通过在`BaseGameActivity`类中实现`IOnSceneTouchListener`监听器，弹珠可以拖动。然后，我们将触摸监听器注册到`mScene`对象。在实体根据另一个实体的位置进行旋转的情况下，我们不得不在某个持续更新的方法中包含旋转功能，否则我们的箭头不会持续反应。我们可以通过更新线程来实现这一点，但在这个实例中，我们将在重写的`onSceneTouchEvent()`方法中包含该功能，因为直到我们触摸场景，“目标”实际上不会移动。
- en: In the first step, we're allowing our activity to override the `onSceneTouchEvent()`
    method by implementing the `IOnSceneTouchListener` interface. Once we've implemented
    the touch listener, we can take care of step two and allow the `Scene` object
    to receive touch events and respond according to the code situated inside the
    activity's overridden `onSceneTouchEvent()` method. This is done with the `setOnSceneTouchListener(pSceneTouchListener)`
    method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过实现`IOnSceneTouchListener`接口，允许我们的活动重写`onSceneTouchEvent()`方法。一旦我们实现了触摸监听器，就可以进行第二步，让`Scene`对象接收触摸事件，并根据活动重写的`onSceneTouchEvent()`方法中的代码做出响应。这是通过`setOnSceneTouchListener(pSceneTouchListener)`方法完成的。
- en: In step four, the `if(pSceneTouchEvent.isActionMove())` conditional statement
    determines whether a finger is moving over the scene, updating the marble's position,
    and calculating the new rotation for the arrow sprite if the conditional statement
    returns `true`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，`if(pSceneTouchEvent.isActionMove())`条件语句判断是否有一个手指在场景上移动，更新大理石的位置，并在条件语句返回`true`时计算箭头精灵的新旋转。
- en: 'We first start by updating the marble''s position to the location of touch
    through the use of the `setPosition(pX, pY)` method as seen in the following code
    snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下代码段中看到的`setPosition(pX, pY)`方法，将大理石的位置更新到触摸的位置：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we subtract the pointer''s x/y coordinates from the target''s x/y coordinates.
    This gives us the difference between each of the sprites'' coordinates which will
    be used to calculate the angle between the two positions. In this case, the pointer
    is the `mArrowSprite` object and the target is the `mMarbleSprite` object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从目标的x/y坐标中减去指针的x/y坐标。这为我们提供了每个精灵坐标之间的差值，这将用于计算两个位置之间的角度。在这种情况下，指针是`mArrowSprite`对象，目标是`mMarbleSprite`对象：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, since AndEngine''s `setRotation(pRotation)` method uses degrees and
    the `atan2(pY, pX)` method returns radians, we must perform a simple conversion.
    We will use AndEngine''s `MathUtils` class which includes a `radToDeg(pRadian)`
    method to convert our angle value from radians to degrees. Once we obtain the
    correct angle in degrees, we will set the `mArrowSprite` object''s rotation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于AndEngine的`setRotation(pRotation)`方法使用度数，而`atan2(pY, pX)`方法返回弧度，我们必须进行简单的转换。我们将使用AndEngine的`MathUtils`类，其中包括一个`radToDeg(pRadian)`方法，将我们的角度值从弧度转换为度数。一旦我们获得了正确的度数角度，我们将设置`mArrowSprite`对象的旋转：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One last thing to note is that the `DEFAULT_IMAGE_ROTATION` value is an `int`
    value which represents `90` degrees. This value is simply used to offset the rotation
    of the `mArrowSprite` sprite, otherwise we would be required to properly rotate
    the image within our image editing software. If the pointer within our custom
    images is not facing the uppermost point of the image, this value may require
    adjustments in order to properly align the pointer with the target.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的最后一点是，`DEFAULT_IMAGE_ROTATION`值是一个表示`90`度的`int`值。这个值仅用于偏移`mArrowSprite`精灵的旋转，否则我们将需要在我们的图像编辑软件中适当旋转图像。如果自定义图像中的指针没有指向图像的最顶部，这个值可能需要调整，以便将指针与目标对齐。
- en: Overriding the onManagedUpdate method
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写`onManagedUpdate`方法
- en: Overriding an `Entity` object's `onManagedUpdate()` method can be extremely
    useful in all types of situations. By doing so, we can allow our entities to execute
    code every time the entity is updated through the update thread, occuring many
    times per second unless the entity is set to ignore updates. There are so many
    possibilities including animating our entity, checking for collisions, producing
    timed events, and much more. Using our `Entity` objects's `onManagedUpdate()`
    method also saves us from having to create and register new timer handlers for
    time-based events for a single entity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`Entity`对象的`onManagedUpdate()`方法在所有类型的情况下都非常有用。这样做，我们可以让我们的实体在每次通过更新线程更新实体时执行代码，每秒发生多次，除非实体被设置为忽略更新。可能性非常多，包括动画化我们的实体，检查碰撞，产生定时事件等等。使用我们的`Entity`对象的`onManagedUpdate()`方法还可以节省我们为单一实体创建和注册新的定时处理器以处理基于时间的事件。
- en: Getting ready…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: This recipe requires basic knowledge of the `Entity` object in AndEngine. Please
    read through the entire recipe, *Understanding AndEngine entities* given in this
    chapter, then create a new empty AndEngine project with a `BaseGameActivity` class
    and refer to the class named `OverridingUpdates` in the code bundle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要具备对AndEngine中`Entity`对象的基本了解。请阅读本章提供的*了解AndEngine实体*的整个示例，然后创建一个新的空AndEngine项目，包含一个`BaseGameActivity`类，并参考代码包中名为`OverridingUpdates`的类。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we are creating two `Rectangle` objects. One rectangle will
    remain in the center of the scene, rotating consistently. The second rectangle
    will continuously move from left to right and bottom to top on the scene, resetting
    back to the left-hand side when it reaches the right, and resetting back to the
    bottom when it reaches the top of the scene. Additionally, the moving rectangle
    will turn green anytime it collides with the center rectangle. All of these movements
    and conditionals will be applied and executed through the use of each object's
    overridden `onManagedUpdate(pSecondsElapsed)` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建两个`Rectangle`对象。一个矩形将保持场景中心位置，持续旋转。第二个矩形将在场景中从左到右、从下到上连续移动，当到达右侧时重置回左侧，当到达场景顶部时重置回底部。此外，移动的矩形在与中心矩形碰撞时将变为绿色。所有这些移动和条件判断都将通过每个对象重写的`onManagedUpdate(pSecondsElapsed)`方法来应用和执行。
- en: 'Override the first `Rectangle` object''s `onManagedUpdate()` method for continuous
    rotation:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写第一个`Rectangle`对象的`onManagedUpdate()`方法，以实现连续旋转：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Override the second `Rectangle` object''s `onManagedUpdate()` method for continuous
    position updates, conditional checking, and collision detection:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写第二个`Rectangle`对象的`onManagedUpdate()`方法，以实现连续的位置更新、条件检查和碰撞检测：
- en: '[PRE22]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the first `Rectangle` object that we created, we are overriding its `onManagedUpdate(pSecondsElapsed)`
    method to continuously update the rotation to a new value. For the second `Rectangle`
    object, we're moving it from the far left-hand side of the screen to the far right-hand
    side of the screen continuously. Once the second rectangle reaches the far right-hand
    side of the screen, it is repositioned back to the left-hand side and we raise
    the `Rectangle` object on the scene by half of the `Rectangle` object's height.
    Additionally, when the two rectangles overlap, the moving rectangle will change
    its color to green until they are no longer touching.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的第一个`Rectangle`对象中，我们重写其`onManagedUpdate(pSecondsElapsed)`方法，以持续更新旋转到新值。对于第二个`Rectangle`对象，我们使其从屏幕最左侧连续移动到最右侧。当第二个矩形到达屏幕最右侧时，它会被重新定位到左侧，并将场景中的`Rectangle`对象提高半个`Rectangle`对象的高度。此外，当两个矩形重叠时，移动的矩形将改变颜色为绿色，直到它们不再接触。
- en: The code in step one allows us to create an event every time the entity is updated.
    In this specific overridden method, we're calculating a rotation offset for the
    `Rectangle` object based on the seconds passed since it was last updated. Because
    the entity is updated many times per second, depending on the number of frames
    per second the device is able to achieve, we multiply `pSecondsElapsed` by `25`
    in order to increase the rotation speed a bit. Otherwise, we'd be rotating our
    entity along the lines of `0.01` degrees every update which would take quite a
    while for an object to make a full revolution at that rate. We can use the `pSecondsElapsed`
    update to our advantage when dealing with updates in order to make modifications
    to events based on time passed since the last update.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步的代码允许我们在每次实体更新时创建一个事件。在这个特定的重写方法中，我们基于自上次更新以来经过的秒数计算`Rectangle`对象的旋转偏移量。因为实体每秒更新多次，具体取决于设备能够达到的每秒帧数，我们将`pSecondsElapsed`乘以`25`以稍微增加旋转速度。否则，我们每次更新时将使实体沿`0.01`度旋转，那样物体以该速率完成一次完整旋转将需要相当长的时间。我们可以在处理更新时利用`pSecondsElapsed`更新，以便基于自上次更新以来经过的时间对事件进行修改。
- en: Step two is a little bit more robust than the first step. In step two, we are
    overriding the second rectangle's `onManagedUpdate()` method in order to perform
    position-checking, collision-checking, and updating the rectangle's position on
    every update to the entity. To start off, we are declaring variables which will
    contain values such as the current position of the entity, the half width and
    half height values of the entity for proper offsetting from the anchor center,
    and the next update position used for checking the position. Doing so allows us
    to reduce the number of calculations needed throughout the entity's update. Applying
    poorly-optimized code in the update thread can lead to lowered frame rate very
    quickly. It is important to make as method calls and calculations as possible;
    for example, obtaining the `currentX` value five times throughout the `onManagedUpdate()`
    method would be more ideal than calling `this.getX()` five times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步比第一步要复杂一些。在第二步中，我们覆盖了第二个矩形的`onManagedUpdate()`方法，以便在每次实体更新时执行位置检查、碰撞检查以及更新矩形的定位。首先，我们声明了一些变量，这些变量将包含如实体当前位置、实体的半宽和半高值以便从锚点中心正确偏移，以及用于检查位置的下一个更新位置等值。这样做可以减少实体更新过程中所需计算的数量。如果在更新线程中应用了优化不佳的代码，很快就会导致帧率降低。尽可能多地使用方法调用和计算是很重要的；例如，在`onManagedUpdate()`方法中多次获取`currentX`值，比多次调用`this.getX()`更为理想。
- en: Continuing on with the position-checking and updating in step two, we start
    off by determining whether the `Rectangle` object's anchor center plus half its
    width, which is represented by the `maxWidth` variable, is less than or equal
    to the `WIDTH` value that represents the furthest coordinate to the right of the
    display. If true, we proceed to increment the x coordinate of the `Rectangle`
    object by `incrementXValue`, which is equal to 5 pixels. On the other hand, we
    will either reset the `Rectangle` object back to the bottom-left corner of the
    scene if the `nextHeight` value is greater than or equal to our camera's `HEIGHT`
    value, or simply increase the `Rectangle` object's height by half its width and
    return it to the left-hand side of the display if the rectangle has not yet reached
    the top of the display.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 继续第二步中的位置检查和更新，我们首先确定矩形的锚点中心加上其半宽（由`maxWidth`变量表示）是否小于或等于表示显示最右侧坐标的`WIDTH`值。如果为真，我们会将矩形的x坐标增加`incrementXValue`，即5个像素。另一方面，如果`nextHeight`值大于或等于摄像机的`HEIGHT`值，我们会将矩形对象重置回场景的左下角；或者如果矩形还没有到达显示顶部，只需将矩形的宽度增加其半宽并返回到左侧。
- en: Finally, we've got our collision-checking method within the `onManagedUpdate()`
    method of our second `Rectangle` object. By calling `this.collidesWith(mRectangleOne)`,
    we can determine whether or not the `this` object is overlapping with the object
    specified, or in this case, `mRectangleOne`. We will then make one additional
    check to determine whether or not the color is not already equal to the color
    we plan on changing the `Rectangle` object to if collision is detected; setting
    the `Rectangle` object to green if the conditions return `true`. However, `collidesWith()`
    can be a rather expensive collision-checking method if it is being performed by
    multiple `Entity` objects on every update! In this recipe, we're purely using
    this collision-checking method as an example. One option to look into would be
    to perform a lightweight distance detection between the two objects prior to performing
    the collision detection.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第二个`Rectangle`对象的`onManagedUpdate()`方法中拥有了碰撞检查方法。通过调用`this.collidesWith(mRectangleOne)`，我们可以确定`this`对象是否与指定对象（在本例中是`mRectangleOne`）发生重叠。然后我们会进行一个额外的检查，以确定如果检测到碰撞，颜色是否已经等于我们打算将`Rectangle`对象改变成的颜色；如果条件返回`true`，则将`Rectangle`对象设置为绿色。然而，如果每个更新都由多个`Entity`对象执行，`collidesWith()`可能是一个相当昂贵的碰撞检查方法！在这个示例中，我们纯粹是将此碰撞检查方法作为示例。一个可以考虑的选项是在执行碰撞检测之前，对两个对象进行轻量级的距离检测。
- en: There's more…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'As briefly mentioned before, *all children receive the update call from their
    parent*. Child entities in this case also inherit the modified `pSecondsElapsed`
    value of the parent. We can even go as far as slowing our entire `Scene` object,
    including all of its children, by overriding its `onManagedUpdate()` method and
    reducing the `pSecondsElapsed` value like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*所有子对象都会从其父对象接收到更新调用*。在这种情况下，子实体也继承了父级修改后的`pSecondsElapsed`值。我们甚至可以通过重写其`onManagedUpdate()`方法并减少`pSecondsElapsed`值，来减慢整个`Scene`对象及其所有子对象的运行速度，如下所示：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Returning a value equal to half the `pSecondsElapsed` value to the `super` method
    would cause all entities attached to that `Scene` object to slow down by half
    in all aspects. That's just a little something to keep in mind when considering
    options for pausing or creating a slow motion effect for our games.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将等于`pSecondsElapsed`值一半的返回值传递给`super`方法，将导致所有附加到该`Scene`对象的实体在各个方面都减慢一半。这是在考虑游戏暂停或创建慢动作效果选项时需要记住的一点小技巧。
- en: Using modifiers and entity modifiers
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用修改器和实体修改器
- en: AndEngine provides us with what are known as **modifiers** and **entity modifiers**.
    Through the use of these modifiers we can apply neat effects to our entities with
    great ease. These modifiers apply specific changes to an `Entity` object over
    a defined period of time, such as movement, scaling, rotation, and more. On top
    of that, we can include listeners and ease functions to entity modifiers for full
    control over how they work, making them some of the most powerful-to-use methods
    for applying certain types of animation to our `Scene` object in AndEngine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 为我们提供了所谓的**修改器**和**实体修改器**。通过使用这些修改器，我们可以非常轻松地为实体应用整洁的效果。这些修改器在定义的时间范围内对`Entity`对象应用特定的变化，如移动、缩放、旋转等。此外，我们还可以为实体修改器包含监听器和缓动函数，以完全控制它们的工作方式，这使得它们成为在我们的`Scene`对象中应用某些类型动画的最强大方法之一。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before continuing, we should mention that a modifier and an entity modifier
    in AndEngine are two different objects. A modifier is meant to be applied directly
    to an entity, causing modifications to an entity's properties over time, such
    as scaling, movement, and rotation. An entity modifier on the other hand, is meant
    to act as a container for any number of modifiers, which handle the order in which
    a group of modifiers are executed. This will be discussed more in depth throughout
    this recipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该提到 AndEngine 中的修改器和实体修改器是两个不同的对象。修改器是直接应用于实体，随时间修改实体的属性，如缩放、移动和旋转。而实体修改器则用作任何数量的修改器的容器，处理一组修改器的执行顺序。这将在本食谱的后续内容中进一步讨论。
- en: Getting ready…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: This recipe requires basic knowledge of the `Entity` object in AndEngine. Please
    read through the entire recipe, *Understanding AndEngine entities* given in this
    chapter, then create a new empty AndEngine project with a `BaseGameActivity` class
    and then refer to the *How to do it...* section of this recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要了解 AndEngine 中`Entity`对象的基础知识。请阅读本章提供的*了解 AndEngine 实体*的整个食谱，然后创建一个新的空
    AndEngine 项目，包含一个`BaseGameActivity`类，然后参考此食谱中的*如何操作…*部分。
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we''re going to cover AndEngine''s entity modifiers, including
    modifier listeners and ease functions to apply smooth transitional effects to
    the modifiers. If that sounds confusing, have no fear! AndEngine modifiers are
    actually very simple to work with and can be used to apply different types of
    animations to our `Entity` objects in as little as a few steps for basic modifiers.
    The following steps cover setting up an `Entity` object with a movement modifier
    which will ease us into further discussion of entity modifiers. Import the code
    in these steps to the `onPopulateScene()` method of the activity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们将介绍 AndEngine 的实体修改器，包括修改器监听器和缓动函数，以应用平滑的过渡效果。如果这听起来令人困惑，不必害怕！AndEngine
    的修改器实际上非常易于使用，只需几个基本步骤就可以为我们的`Entity`对象应用不同类型的动画。以下步骤涵盖了设置具有移动修改器的`Entity`对象，这将引导我们进一步讨论实体修改器。将这些步骤中的代码导入到活动的`onPopulateScene()`方法中：
- en: 'Create and attach any type of entity to the `Scene` object. We will be applying
    entity modifiers to this entity:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并附加任何类型的实体到`Scene`对象。我们将为这个实体应用实体修改器：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once we''ve got an entity placed on our `Scene` object, we can start to create
    our modifiers. In this step, we''ll be creating a `MoveModifier` object, which
    allows us to apply a positional change to an entity over time. But first, we will
    define its values:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在`Scene`对象上放置了一个实体，我们就可以开始创建我们的修改器了。在这一步中，我们将创建一个`MoveModifier`对象，它允许我们随时间对实体的位置进行更改。但首先，我们将定义其值：
- en: '[PRE25]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we''ve got our `moveModifier` object created and set up as we''d like,
    we can register this modifier to any entity we wish with the following call, which
    will start the movement effect:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建并设置好了`moveModifier`对象，我们可以通过以下调用将此修改器注册到我们希望的任何实体上，这将开始移动效果：
- en: '[PRE26]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是……
- en: The topic of entity modifiers is quite extensive, so we will start by jumping
    in to the steps. From there we will use the steps as a base foundation for us
    to dive deeper into more complex discussions and examples on the use of entity
    modifiers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实体修改器的话题相当广泛，因此我们将从步骤开始深入。从那里，我们将使用这些步骤作为基础，以便进一步深入到关于实体修改器使用更复杂的讨论和示例。
- en: In the first step, we're simply creating our `Entity` object, which is a `Rectangle`
    in this case, that we'll be using as our test subject for applying modifiers to.
    Simply add the code in this step to the `onPopulateScene()` method; this code
    shall remain untouched throughout our upcoming modifier and entity modifier "experiments".
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们只是创建了一个`Entity`对象，在这个案例中是一个`Rectangle`，我们将用它作为应用修改器的测试对象。只需将此步骤中的代码添加到`onPopulateScene()`方法中；在接下来的修改器和实体修改器“实验”中，这段代码将保持不变。
- en: In the second step, we will start to work with one of the most basic modifiers,
    which is of course the `MoveModifier` modifier. This modifier simply allows us
    define a start position for the movement, an ending position for the movement,
    and a duration, in seconds, that it will take to move from the starting point
    to the ending point. This is very simple stuff as we can see and what's most notable
    about modifiers is that, for the most part, this is all it really takes to set
    up most modifiers. All modifiers really require is a "from" value, a "to" value,
    and a duration defining the time in seconds in which "from-to" occurs. Keep that
    in mind and working with modifiers will be an absolute breeze for the most part!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们将开始使用最基本的修改器之一，当然是`MoveModifier`。这个修改器允许我们定义移动的起始位置、结束位置以及从起点到终点移动所需的秒数。正如我们所看到的，这非常简单，修改器最值得注意的是，在大多数情况下，这就是设置大多数修改器所需的全部内容。所有修改器真正需要的是一个“from”值、一个“to”值以及定义“from-to”发生秒数的时长。记住这一点，在大多数情况下，使用修改器将会非常轻松！
- en: Next, in our third step we simply apply our newly created `moveModifier` object
    to our `rectangle` object via the `registerEntityModifier(pModifier)` method.
    This will apply the `moveModifier` effect to the rectangle, first positioning
    it to its "from" coordinate, then move it to the "to" coordinates over a 3 second
    time span.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第三步中，我们只需通过`registerEntityModifier(pModifier)`方法将我们新创建的`moveModifier`对象应用到`rectangle`对象上。这将使`moveModifier`效果应用到矩形上，首先将其定位到“from”坐标，然后在3秒的时间内移动到“to”坐标。
- en: We know that to register a modifier or entity modifier to an `Entity` object,
    we can call `entity.registerEntityModifier(pEntityModifier)`, but we should also
    know that once we are finished with a modifier we should remove it from the `Entity`
    object. We can do this by either calling `entity.unregisterEntityModifier(pEntityModifier)`
    or if we want to remove all entity modifiers attached to an `Entity` object, we
    can call `entity.clearEntityModifiers()`. On the other hand, if a modifier or
    entity modifier runs its full duration and we're not quite ready to remove it
    from the entity, we must call `modifier.reset()` in order to replay the effect.
    Or if we'd like to make a small adjustment to the modifier before replaying the
    effect, we can call `modifier.reset(duration, fromValue, toValue)`. Where the
    parameters in the `reset` method would be relative to the type of modifier we're
    resetting.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，要向`Entity`对象注册修改器或实体修改器，可以调用`entity.registerEntityModifier(pEntityModifier)`，但我们也应该知道，一旦完成修改器，我们应该将其从`Entity`对象中移除。我们可以通过调用`entity.unregisterEntityModifier(pEntityModifier)`来实现，或者如果我们想移除附加到`Entity`对象的所有实体修改器，可以调用`entity.clearEntityModifiers()`。另一方面，如果一个修改器或实体修改器运行了完整的时长，而我们还没有准备好从实体中移除它，我们必须调用`modifier.reset()`以重新播放效果。或者，如果我们想在重新播放效果之前对修改器进行微调，可以调用`modifier.reset(duration,
    fromValue, toValue)`。其中`reset`方法中的参数将相对于我们要重置的修改器类型。
- en: The `moveModifier` object works, but it's dreadfully boring! After all, we're
    just moving a rectangle from the bottom-left corner of our scene to the upper-right
    corner. Fortunately, that's only just scratching the surface of modifier application.
    The following subheading contains a reference, and example where necessary, to
    all of the modifiers that AndEngine is capable of applying to our `Entity` objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveModifier`对象有效，但它非常无聊！毕竟，我们只是在将一个矩形从场景的左下角移动到右上角。幸运的是，这只是修改器应用表面的刮擦。以下小节包含了AndEngine能够应用到我们的`Entity`对象的所有修改器的参考，必要时还提供了示例。'
- en: AndEngine's modifiers
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AndEngine的修改器
- en: 'The following is a collection of all of the AndEngine modifiers that we are
    able to apply to our entities. The more advanced modifiers will be provided with
    a quick example code snippet. Feel free to try them out in your test project as
    we cover them:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以应用到实体上的所有AndEngine修改器的集合。更高级的修改器将提供一个快速示例代码片段。在介绍它们时，请随意在您的测试项目中尝试：
- en: '`AlphaModifier`: Adjust the alpha value of an entity over time with this modifier.
    The parameters for the constructor include duration, from alpha, and to alpha,
    in that order.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlphaModifier`：使用这个修改器，可以随时间调整实体的透明度值。构造函数的参数包括持续时间、起始透明度和结束透明度，依次排列。'
- en: '`ColorModifier`: Adjust the color values of an entity over time with this modifier.
    The parameters for the constructor include duration, from red, to red, from green,
    to green, from blue, and to blue, in that order.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorModifier`：使用这个修改器，可以随时间调整实体的颜色值。构造函数的参数包括持续时间、起始红色、结束红色、起始绿色、结束绿色、起始蓝色和结束蓝色，依次排列。'
- en: '`DelayModifier`: This modifier is meant to be attributed to the entity modifier
    objects in order to provide a delay between one modifier being executed and another
    modifier being executed. The parameter includes duration.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelayModifier`：这个修改器旨在分配给实体修改器对象，以便在一个修改器被执行和另一个修改器被执行之间提供延迟。参数包括持续时间。'
- en: '`FadeInModifier`: Based on the `AlphaModifier` class, the `FadeInModifier`
    modifier changes an entity''s alpha value from `0.0f` to `1.0f` over a defined
    duration, supplied in the constructor.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadeInModifier`：基于`AlphaModifier`类，`FadeInModifier`修改器在定义的持续时间内在构造函数中提供，将实体的透明度值从`0.0f`更改为`1.0f`。'
- en: '`FadeOutModifier`: Similar to `FadeOutModifier`, except the alpha values are
    swapped.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadeOutModifier`：与`FadeOutModifier`类似，只不过透明度值被交换了。'
- en: '`JumpModifier`: This modifier can be used to apply a "jump" motion to an entity.
    The parameters include duration, from x, to x, from y, to y, and jump height.
    These values will define the distance and height that the entity appears to jump
    over the defined duration.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JumpModifier`：这个修改器可以用来向实体应用“跳跃”动作。参数包括持续时间、起始X、结束X、起始Y、结束Y和跳跃高度。这些值将定义在定义的持续时间内在视觉上实体跳跃的距离和高度。'
- en: '`MoveByModifier`: This modifier allows us to offset the position of an entity.
    The parameters include duration, x offset, and y offset, in that order. For example,
    specifying an offset of `-15` will move the entity to the left by 15 units on
    the scene.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveByModifier`：这个修改器允许我们偏移实体的位置。参数包括持续时间、X偏移和Y偏移，依次排列。例如，指定一个偏移量为`-15`将使实体在场景上向左移动15个单位。'
- en: '`MoveXModifier` and `MoveYModifier`: These modifiers, similar to `MoveModifier`,
    allow us to provide movement to an entity. However, these methods apply the movement
    only on a single axis as determined by the method names. The parameters include
    duration, from coordinate, and to coordinate, in that order.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveXModifier`和`MoveYModifier`：这些修改器与`MoveModifier`类似，允许我们向实体提供移动。然而，这些方法只根据方法名称确定在单个轴上应用移动。参数包括持续时间、起始坐标和结束坐标，依次排列。'
- en: '`RotationAtModifier`: This modifier allows us to apply a rotation to the entity
    while offsetting the center of rotation. The parameters include duration, from
    rotation, to rotation, rotation center x, and rotation center y.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationAtModifier`：这个修改器允许我们在偏移旋转中心的同时向实体应用旋转。参数包括持续时间、起始旋转、结束旋转、旋转中心X和旋转中心Y。'
- en: '`RotationByModifier`: This modifier allows us to offset the entity''s current
    rotation value. The parameters include duration and rotation offset value. For
    example, providing a rotation offset value of `90` will rotate the entity ninety
    degrees clockwise.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationByModifier`：这个修改器允许我们偏移实体的当前旋转值。参数包括持续时间和旋转偏移值。例如，提供一个旋转偏移值为`90`将使实体顺时针旋转九十度。'
- en: '`RotationModifier`: This modifier allows us to rotate an entity from a specific
    value, to another specific value. The parameters include duration, from rotation,
    and to rotation.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationModifier`：这个修改器允许我们从一个特定值旋转实体到另一个特定值。参数包括持续时间、起始旋转和目标旋转。'
- en: '`ScaleAtModifier`: This modifier allows us to scale an entity while offsetting
    the center of scaling. The parameters include duration, from scale, to scale,
    scale center x, and scale center y.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleAtModifier`：这个修改器允许我们在缩放时偏移缩放中心来缩放实体。参数包括持续时间、起始缩放、目标缩放、缩放中心x和缩放中心y。'
- en: '`ScaleModifier`: This modifier allows us to scale an entity from a specific
    value, to another specific value. The parameters include duration, from scale,
    and to scale, in that order.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleModifier`：这个修改器允许我们从一个特定值缩放实体到另一个特定值。参数包括持续时间、起始缩放和目标缩放，按此顺序。'
- en: '`SkewModifier`: This modifier allows us to skew an entity''s x and y values
    over time. The parameters include duration, from skew x, to skew x, from skew
    y, and to skew y, in that specific order.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkewModifier`：这个修改器允许我们随时间改变实体的x和y值。参数包括持续时间、起始斜切x、目标斜切x、起始斜切y和目标斜切y，顺序是特定的。'
- en: '`PathModifier`: This modifier is relative to `MoveModifier`, except we are
    able to add as many "to" coordinates as we please. This allows us to create a
    path on the `Scene` object for the entity to follow by specifying pairs of x/y
    coordinates for the `PathModifier` modifier. See the following steps for a walkthrough
    on the topic of creating a `PathModifier` modifier for our entities:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathModifier`：这个修改器相对于`MoveModifier`，不过我们可以添加任意多的“到”坐标。这使得我们可以在`Scene`对象上为实体创建一个路径，通过为`PathModifier`修改器指定x/y坐标对来跟随。在以下步骤中，我们将了解如何为我们的实体创建一个`PathModifier`修改器：'
- en: 'Define the way-points for the path. The way-point arrays for the x and y coordinates
    should have the same number of points, as they will be paired up in order to make
    a single x/y coordinate for `PathModifier`. We must have at least two points set
    in each of the arrays, as we''ll need at least a start and end point:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义路径的航点。x和y坐标的航点数组应该具有相同数量的点，因为它们将按顺序配对以形成`PathModifier`的单个x/y坐标。我们必须在每个数组中至少设置两个点，因为我们需要至少一个起始点和结束点：
- en: '[PRE27]'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `Path` object which we will use to pair the individual points in the
    separate arrays into way-points. We do this by iterating through the arrays and
    calling the `to(pX, pY)` method on the `path` object. Note that every time we
    call this method, we are adding an additional way-point to the `path` object:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Path`对象，我们将使用它将分开数组中的各个点配对成航点。我们通过遍历数组并在`path`对象上调用`to(pX, pY)`方法来实现这一点。请注意，每次我们调用这个方法，我们都在`path`对象中添加一个额外的航点：
- en: '[PRE28]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, once we''ve defined our way-points, we can create the `PathModifier`
    object, supplying a duration as well as our `path` object as the parameters:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们定义了航点，就可以创建`PathModifier`对象，提供持续时间以及我们的`path`对象作为参数：
- en: '[PRE29]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`CardinalSplineMoveModifier`: This is the final modifier we will be discussing.
    This modifier is relatively similar to the `PathModifier` modifier, except we
    are able to apply tension to the `Entity` object''s movement. This allows for
    a more fluid and smooth movement when approaching corners, or reversing direction,
    which looks quite nice actually. See the following steps for a walkthrough on
    the topic of creating a `CardinalSplineMoveModifier` modifier for our entities:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CardinalSplineMoveModifier`：这是我们最后要讨论的修改器。这个修改器与`PathModifier`修改器相对相似，不过我们可以对`Entity`对象的移动施加张力。这允许在接近拐角或改变方向时实现更流畅和平滑的移动，实际上看起来相当不错。在以下步骤中，我们将了解如何为我们的实体创建一个`CardinalSplineMoveModifier`修改器：'
- en: The first step, similar to the `PathModifier` modifier, is to create our point
    arrays. In this example, we can copy the code from `PathModifier` example's first
    step. However, one difference between this modifier and the `PathModifier` object
    is that we require a minimum of 4 individual x and y points.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步与`PathModifier`修改器类似，是创建我们的点数组。在这个例子中，我们可以从`PathModifier`示例的第一步复制代码。然而，这个修改器与`PathModifier`对象的一个区别在于，我们需要至少4个单独的x和y点。
- en: 'The second step is to determine the number of control points, define the tension,
    and create a `CardinalSplineMoveModifierConfig` object. This is the `CardinalSplineMoveModifier`
    modifier''s equivalent of the `PathModifier` modifier''s `Path` object. The tension
    can be between `-1` and `1`, no more and no less. A tension of `-1` will leave
    the `Entity` object''s movement very loose, making extremely loose corners and
    changes in direction while a tension of `1` will react very much like the `PathModifier`
    modifier in the sense that it is very strict in its movements:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是确定控制点的数量，定义张力，并创建一个`CardinalSplineMoveModifierConfig`对象。这是`CardinalSplineMoveModifier`修改器的`PathModifier`修改器中`Path`对象的等价物。张力可以在`-1`到`1`之间，不能多也不能少。张力为`-1`将使`Entity`对象的移动非常松散，在转角和方向变化时非常松散；而张力为`1`将非常像`PathModifier`修改器，在移动上非常严格：
- en: '[PRE30]'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In step three, again very similar to the `PathModifier` modifier, we must pair
    the x/y coordinates within our point arrays, except in this case we''re storing
    them within the `config` object:'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三步中，与`PathModifier`修改器非常相似，我们必须将x/y坐标配对在我们的点数组中，不过在这个情况下，我们是将它们存储在`config`对象中：
- en: '[PRE31]'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we will simply define the duration for the movement, Create the `CardinalSplineMoveModifier`
    modifier, supply the duration and `config` object as parameters, and finally register
    the modifier to the `Entity` object:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需简单地定义移动的持续时间，创建`CardinalSplineMoveModifier`修改器，提供持续时间和`config`对象作为参数，并最终将修改器注册到`Entity`对象上：
- en: '[PRE32]'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that we've got a solid understanding of the individual modifiers that we
    are able to apply to our entities, we will cover the three main entity modifiers
    in AndEngine and what they're used for.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对可以应用到实体上的各个修改器有了深入的理解，我们将介绍AndEngine中的三个主要实体修改器以及它们的用途。
- en: AndEngine's entity modifiers
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AndEngine的实体修改器
- en: AndEngine includes three entity modifier objects which are used for building
    complex animations for our `Entity` objects by combining two or more modifiers
    into a single event or sequence. The three different entity modifiers include
    the `LoopEntityModifier`, `ParallelEntityModifier`, and `SequenceEntityModifier`
    objects. Next, we describe the specifics of these entity modifiers and examples,
    displaying how they can be used to combine multiple modifiers into a single animation
    event.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine包含三种实体修改器对象，用于通过将两个或更多修改器组合成一个单一事件或序列，为我们的`Entity`对象构建复杂的动画。这三种不同的实体修改器包括`LoopEntityModifier`、`ParallelEntityModifier`和`SequenceEntityModifier`对象。接下来，我们将描述这些实体修改器的具体细节和示例，展示如何将它们组合成单一动画事件。
- en: '`LoopEntityModifier`: This entity modifier allows us to loop a specified modifier
    either indefinitely or N number of times if supplied a second `int` parameter.
    This is the simplest of entity modifiers. Once we set up the `LoopEntityModifier`
    modifier, we can apply it directly to the `Entity` object:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoopEntityModifier`：这个实体修改器允许我们无限次数或指定次数（如果提供了第二个`int`参数）循环指定的修改器。这是最简单的实体修改器。一旦我们设置好了`LoopEntityModifier`，就可以直接将其应用于`Entity`对象：'
- en: '[PRE33]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`ParallelEntityModifier`: This entity modifier allows us to combine an unlimited
    number of modifiers into a single animation. The modifiers supplied as parameters
    of this entity modifier will all run on the `Entity` object at the same time.
    This allows us to scale a modifier while rotating it, for example, as seen in
    the following example. Feel free to add more modifiers to the example for some
    practice:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelEntityModifier`：这个实体修改器允许我们将无限数量的修改器组合成一个单一动画。这个实体修改器提供的参数中的修改器将同时运行在`Entity`对象上。这使得我们可以在旋转时缩放修改器，例如，在以下示例中可以看到。欢迎在示例中添加更多修改器进行练习：'
- en: '[PRE34]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`SequenceEntityModifier`: This entity modifier allows us to string together
    modifiers that will be executed sequentially on a single `Entity` object. This
    modifier is ideally the proper entity modifier to use the `DelayModifier` object
    as previously mentioned in the modifiers list. The following example displays
    an `Entity` object which moves from the bottom-left corner to the center of the
    screen, pauses for `2` seconds, then scales down to a scale factor of `0`:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SequenceEntityModifier`：这个实体修改器允许我们将修改器串联起来，在单个`Entity`对象上按顺序执行。这个修改器是在之前提到的修改器列表中使用`DelayModifier`对象的理想实体修改器。以下示例显示了一个从屏幕左下角移动到屏幕中心的`Entity`对象，暂停`2`秒，然后缩小到比例因子为`0`：'
- en: '[PRE35]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What's even more important to know is that we can add a `SequenceEntityModifier`
    modifier to a `ParallelEntityModifier` modifier, a `ParallelEntityModifier` modifier
    to a `LoopEntityModifier` modifier, or any other variation we can think of! This
    makes the possibilities of modifiers and entity modifiers extremely extensive
    and allows us to create incredibly complex animations for our entities with a
    rather significant amount of ease.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是要知道我们可以将`SequenceEntityModifier`修改器添加到`ParallelEntityModifier`修改器中，将`ParallelEntityModifier`修改器添加到`LoopEntityModifier`修改器中，或者是我们能想到的任何其他组合！这使得修改器和实体修改器的可能性变得极其广泛，并允许我们以相当大的便利性为实体创建极其复杂的动画。
- en: There's more…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Before moving on to the next topic, we should take a look at the extra features
    included for entity modifiers. There are two more parameters that we can pass
    to our entity modifiers which we haven't discussed yet; those being modifiers
    listeners and ease functions. These two classes can help to make our modifiers
    even more customized than we've already seen in the *How it works...* section!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个主题之前，我们应该看看为实体修改器包含的额外特性。还有两个参数我们可以传递给实体修改器，我们之前还没有讨论过；那就是修改器监听器和缓动函数。这两个类可以帮助我们使修改器比我们在*如何工作...*部分看到的更加定制化。
- en: The `IEntityModifierListener` listener can be used in order to fire events when
    a modifier starts and when a modifier finishes. In the following snippet, we're
    simply printing logs to logcat which notify us when the modifier has started and
    finished.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEntityModifierListener`监听器可以用来在修改器开始和结束时触发事件。在以下代码段中，我们只是简单地向logcat打印日志，以通知我们修改器何时开始和结束。'
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The previous code shows the skeleton of a modifier listener with basic log outputs.
    In a more relative scenario to game development, we could call `pItem.setVisible(false)`
    once the modifier is finished. For example, this could be useful for handling
    subtle falling leaves or raindrops in a scene that leaves the camera's view. However,
    what we decide to use the listener for is completely up to our own discretion.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了一个带有基本日志输出的修改器监听器的框架。在更接近游戏开发的场景中，一旦修改器完成，我们可以调用`pItem.setVisible(false)`。例如，这可以用于处理场景中细微的落叶或雨滴，这些落叶或雨滴离开了摄像头的视野。然而，我们决定用监听器来做什么完全取决于我们自己的判断。
- en: Finally, we'll quickly discuss the ease functions in AndEngine. Ease functions
    are a great way to add an extra layer of "awesomeness" to our entity modifiers.
    After getting used to modifiers, it is likely that ease functions will really
    grow on you as they give modifiers that extra kick they need to make the perfect
    effects. The best way to explain an ease function is to think about a game where
    the menu buttons fall from the top of the screen and "bounce" into place. The
    bounce in this case would be our ease function taking effect.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将快速讨论AndEngine中的缓动函数。缓动函数是给实体修改器添加额外“酷炫”层次的好方法。习惯了修改器之后，缓动函数可能会真正吸引你，因为它们给修改器带来了所需的额外动力，以产生完美效果。解释缓动函数的最好方法是想象一个游戏，菜单按钮从屏幕顶部落下并“弹跳”到位。这里的弹跳就是我们的缓动函数产生效果的情况。
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see here, applying an ease function to a modifier is as easy as adding
    an extra parameter to the modifier's constructor. Often the hardest part is choosing
    which one to use as the list of ease functions is somewhat large. Take some time
    to look through the various ease functions provided by locating the `org.andengine.util.modifier.ease`
    package. Simply replace `EaseElasticIn` from the previous code with the ease function
    you'd like to test out, and rebuild the project to see it in action!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，给修改器应用缓动函数只需在修改器的构造函数中添加一个额外的参数即可。通常最困难的部分是选择使用哪一个，因为缓动函数列表相当长。花些时间查看`org.andengine.util.modifier.ease`包提供的各种缓动函数。只需将前一段代码中的`EaseElasticIn`替换为你想要测试的缓动函数，然后重新构建项目以查看效果！
- en: Tip
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Ease function reference**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓动函数参考**'
- en: Download the **AndEngine – Examples** application from Google Play to your device.
    Open the application and locate the **Using EaseFunctions** example. While the
    example application is quite outdated compared to the latest AndEngine branch,
    the ease function example is still an absolutely effective tool for determining
    which ease functions best suit our own game's needs!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从Google Play将**AndEngine – Examples**应用程序下载到你的设备上。打开应用程序并找到**Using EaseFunctions**的例子。尽管与最新的AndEngine分支相比，示例应用程序相当过时，但缓动函数示例仍然是一个绝对有效的工具，用于确定哪些缓动函数最适合我们游戏的需求！
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding AndEngine entities* in this chapter.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中*了解AndEngine实体*。
- en: Working with particle systems
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粒子系统
- en: '**Particle systems** can provide our games with very attractive effects for
    many different events in our games, such as explosions, sparks, gore, rain, and
    much more. In this chapter, we''re going to cover AndEngine''s `ParticleSystem`
    classes which will be used to create customized particle effects that will suit
    our every need.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子系统**可以为我们的游戏提供非常吸引人的效果，涵盖游戏中的许多不同事件，如爆炸、火花、血腥、雨等。在本章中，我们将介绍AndEngine的`ParticleSystem`类，这将用于创建定制化的粒子效果，满足我们的各种需求。'
- en: Getting ready…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipes, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*, as well as *Understanding AndEngine entities* given in this chapter.
    Next, create a new empty AndEngine project with a `BaseGameActivity` class and
    import the code from the `WorkingWithParticles` class in the code bundle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要了解AndEngine中`Sprite`对象的基础知识。请阅读[第1章](ch01.html "第1章. AndEngine游戏结构")中的整个食谱，*使用不同类型的纹理*以及本章中给出的*了解AndEngine实体*。接下来，创建一个带有`BaseGameActivity`类的新的空AndEngine项目，并从代码包中的`WorkingWithParticles`类导入代码。
- en: How to do it…
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In order to begin creating particle effects in AndEngine, we require a bare
    minimum of three objects. These objects include an `ITextureRegion` object which
    will represent the individual particles spawned, a `ParticleSystem` object, and
    a `ParticleEmitter` object. Once we have these in place, we can begin to add what
    are known as particle initializers and particle modifiers to our particle system
    in order to create our own personalized effects. See the following steps for a
    walkthrough on how to set up a basic particle system in which we can build on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始在AndEngine中创建粒子效果，我们需要至少三个对象。这些对象包括代表生成的单个粒子的`ITextureRegion`对象，一个`ParticleSystem`对象和一个`ParticleEmitter`对象。一旦我们有了这些，我们就可以开始向我们的粒子系统添加所谓的粒子初始化器和粒子修改器，以创建我们自己的个性化效果。以下步骤将指导如何设置一个基本的粒子系统，以便在此基础上进行构建。
- en: The first step involves deciding the image we'd like our particle system to
    spawn. This can be any image, any color, and any size. Feel free to create an
    image and set up `BuildableBitmapTextureAtlas` and `ITextureRegion` to load the
    image into the test project's resources. For the sake of keeping things simple,
    please keep the image under 33 x 33 pixels in dimension for this recipe.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步涉及决定我们希望粒子系统生成的图像。这可以是任何图像、任何颜色和任何大小。随意创建一个图像，并设置`BuildableBitmapTextureAtlas`和`ITextureRegion`来将图像加载到测试项目的资源中。为了保持事情简单，请将图像的尺寸控制在33x33像素以下以适应本食谱。
- en: 'Create the `ParticleEmitter` object. For now we''ll be using a `PointParticleEmitter`
    object subtype:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ParticleEmitter`对象。现在我们将使用`PointParticleEmitter`对象子类型：
- en: '[PRE38]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the `ParticleSystem` object. We''ll be using the `BatchedSpriteParticleSystem`
    object implementation as it is the latest and greatest `ParticleSystem` object
    subtype included in AndEngine. It allows us to create large amounts of particles
    while greatly reducing overhead of the typical `SpriteParticleSystem` object:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ParticleSystem`对象。我们将使用`BatchedSpriteParticleSystem`对象实现，因为它是AndEngine中包含的最新和最好的`ParticleSystem`对象子类型。它允许我们创建大量粒子，同时大大降低典型`SpriteParticleSystem`对象的开销：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the final step to creating a particle system, we will add any combination
    of particle emitters and particle modifiers and then attach the particle system
    to the `Scene` object:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建粒子系统的最后一步中，我们将添加任意组合的粒子发射器和粒子修改器，然后将粒子系统附加到`Scene`对象上：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It seems that working with particles for many new AndEngine developers is a
    rather difficult subject, but, in fact, it's quite the opposite. Creating particle
    effects in AndEngine is extremely simple, but as always, we should learn to walk
    before we can fly! In this recipe's steps, we're setting up a rather basic particle
    system. As the topic progresses, we will discuss and plug in additional modular
    components of the particle system in order to broaden our knowledge of the individual
    pieces that make up complex particle system effects.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多新的AndEngine开发者来说，处理粒子似乎是一个相当困难的课题，但实际上恰恰相反。在AndEngine中创建粒子效果非常简单，但如往常一样，我们应该学会走再尝试飞！在本食谱的步骤中，我们设置了一个相当基础的粒子系统。随着话题的深入，我们将讨论并插入粒子系统的其他模块化组件，以拓宽我们对构成复杂粒子系统效果各个部分的知识。
- en: In the first step, we need to set up an `ITextureRegion` object to supply our
    particle system. The `ITextureRegion` object will visually represent each individual
    particle that spawns. The texture region can be of any size, but typically they
    will be between 2 x 2 to 32 x 32 pixels. Remember that the particle system is
    meant to spawn a large number of objects, so the smaller the `ITextureRegion`
    object, the better off the performance will be as far as the particle system goes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们需要建立一个`ITextureRegion`对象来为我们的粒子系统提供资源。`ITextureRegion`对象将视觉上代表每个生成的独立粒子。纹理区域可以是任何大小，但通常它们会在2
    x 2到32 x 32像素之间。请记住，粒子系统旨在生成大量的对象，因此`ITextureRegion`对象越小，就粒子系统而言性能会越好。
- en: In the second step, we create our particle emitter and center it on the `Scene`
    object. The particle emitter is the component within a particle system that controls
    where particles will initially spawn. In this recipe, we are using a `PointParticleEmitter`
    object type, which simply spawns all particles in the exact same coordinates on
    the scene as defined by the `particleSpawnCenterX` and `particleSpawnCenterY`
    variables. AndEngine includes four other particle emitter types which will be
    discussed shortly.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建了一个粒子发射器并将其置于`Scene`对象的中心。粒子发射器是粒子系统中的一个组件，它控制着粒子的初始生成位置。在本食谱中，我们使用的是`PointParticleEmitter`对象类型，它会简单地在场景上以`particleSpawnCenterX`和`particleSpawnCenterY`变量定义的相同坐标生成所有粒子。AndEngine还包括其他四种粒子发射器类型，我们稍后会进行讨论。
- en: Once we've got our particle emitter created and set up as we see fit, we can
    move onto the third step and create the `BatchedSpriteParticleSystem` object.
    The parameters that we are required to pass to the `BatchedSpriteParticleSystem`
    object include, in this order, the particle emitter, the minimum spawn rate of
    the particles, the maximum spawn rate, the maximum number of particles that can
    be simultaneously displayed, the `ITextureRegion` object that the particles should
    visually represent, and the `mEngine` object's vertex buffer object manager.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建并适当地设置好粒子发射器后，我们可以进入第三步并创建`BatchedSpriteParticleSystem`对象。我们需要按顺序向`BatchedSpriteParticleSystem`对象传递的参数包括：粒子发射器、粒子的最小生成速率、最大生成速率、可以同时显示的最大粒子数量、粒子应视觉代表的`ITextureRegion`对象，以及`mEngine`对象的顶点缓冲区对象管理器。
- en: Finally, in the fourth step we are adding an `AccelerationParticleInitializer`
    object, which will provide an accelerating movement to the particles so that they're
    not simply sitting where they spawn. We are also adding an `ExpireParticleInitializer`
    object, which is used to destroy particles after a defined amount of time. Without
    some sort of initializer or modifier removing particles, the `BatchedParticleSystem`
    object would eventually reach its maximum particle limit and discontinue particle
    spawning. Lastly, we're adding a `ScaleParticleModifier` object to the particle
    system which will change each particle's scale over time. These particle initializers
    and particle modifiers will be explained more in-depth shortly, for now, just
    know that this is the step where we'd apply them to the particle system. Once
    we've added our initializers and modifiers of choice, we attach the `particleSystem`
    object to the `Scene` object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第四步中，我们添加了一个`AccelerationParticleInitializer`对象，它将为粒子提供加速运动，使它们不仅仅停留在它们产生的地方。我们还添加了一个`ExpireParticleInitializer`对象，用于在定义的时间后销毁粒子。如果没有某种初始化器或修改器移除粒子，`BatchedParticleSystem`对象最终会达到其最大粒子限制，并停止产生粒子。最后，我们向粒子系统添加了一个`ScaleParticleModifier`对象，它将随时间改变每个粒子的缩放比例。这些粒子初始化器和粒子修改器将稍作深入解释，现在只需知道这是我们应用它们到粒子系统的步骤。添加完我们选择的初始化器和修改器后，我们将`particleSystem`对象附加到`Scene`对象上。
- en: After completing these four steps, the particle system will begin to spawn particles.
    However, we may not always want the particles to spawn from a specific particle
    system. To disable particle spawning, we can make the call, `particleSystem.setParticlesSpawnEnabled(false)`,
    or `true` to re-enable particle spawning. Aside from this method, the `BatchedSpriteParticleSystem`
    object contains all of the ordinary functionality and methods of an `Entity` object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这四个步骤后，粒子系统将开始产生粒子。然而，我们可能并不总是希望粒子从特定的粒子系统中产生。要禁用粒子产生，可以调用`particleSystem.setParticlesSpawnEnabled(false)`，或者设置为`true`以重新启用粒子产生。除了这个方法，`BatchedSpriteParticleSystem`对象还包含`Entity`对象的所有普通功能和方法。
- en: For more information on the individual components of a particle system, see
    the following subtopics. These topics include particle emitters, particle initializers,
    and particle modifiers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关粒子系统的各个组成部分的更多信息，请参见以下子主题。这些主题包括粒子发射器、粒子初始化器和粒子修改器。
- en: Particle emitter selection
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子发射器的选择
- en: 'AndEngine includes a selection of five ready-to-use particle emitters which
    can alter the initial placement of particles on the scene, this is not to be confused
    with defining a particle emitter position. See the list of particle emitters for
    details on how each of them work. Please feel free to substitute the particle
    emitter in step two of the recipe with a particle emitter given in the following
    list:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 包含五种可立即使用的粒子发射器，它们可以改变场景上粒子的初始放置，这不应与定义粒子发射器位置混淆。有关每个粒子发射器的工作原理，请查看粒子发射器列表。请随时在步骤二的配方中用以下列表中的粒子发射器替换粒子发射器。
- en: '`PointParticleEmitter`: The most basic particle emitter of the bunch; this
    particle emitter causes all spawning particles to be initially spawned in the
    same defined position on the scene. There will be no variance in the position
    that particles spawn. However, general particle emitter position can change via
    a call to the `pointParticleEmitter.setCenter(pX, pY)` method, where `pX` and
    `pY` define the new coordinates to spawn particles.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointParticleEmitter`：这是最基础的粒子发射器；这种粒子发射器使所有产生的粒子在场景上同一定义的位置产生。粒子产生的位置不会有任何变化。然而，可以通过调用`pointParticleEmitter.setCenter(pX,
    pY)`方法来改变粒子发射器的位置，其中`pX`和`pY`定义了产生粒子的新坐标。'
- en: '`CircleOutlineParticleEmitter`: This particle emitter subtype will cause particles
    to spawn in positions outlining the shape of a circle. The parameters to include
    in this emitter''s constructor include the x coordinate, the y coordinate, and
    a radius which defines the overall size of the circle outline. See the following
    example:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CircleOutlineParticleEmitter`：这种粒子发射器子类型将使粒子在圆形轮廓的位置产生。这个发射器构造函数中需要包含的参数包括x坐标、y坐标和一个定义圆形轮廓整体大小的半径。请看以下示例：'
- en: '[PRE41]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`CircleParticleEmitter`: This particle emitter subtype will allow particles
    to spawn within any area of a circle opposed to just the outlining edge in the
    `CircleOutlineParticleEmitter` object. The `CircleParticleEmitter` object requires
    the same parameters in its constructor as the `CircleOutlineParticleEmitter` object.
    To test this particle emitter subtype, simply refactor the object in the `CircleOutlineParticleEmitter`
    example to use the `CircleParticleEmitter` object instead.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CircleParticleEmitter`：这种粒子发射器子类型允许粒子在`CircleOutlineParticleEmitter`对象仅限于边缘轮廓的圆形区域内任何位置生成。`CircleParticleEmitter`对象在其构造函数中需要与`CircleOutlineParticleEmitter`对象相同的参数。要测试这种粒子发射器子类型，只需将`CircleOutlineParticleEmitter`示例中的对象重构为使用`CircleParticleEmitter`对象即可。'
- en: '`RectangleOutlineParticleEmitter`: This particle emitter subtype will cause
    the particles to spawn from four corners of a rectangle whose size is defined
    by the constructor parameters. Unlike the `CircleOutlineParticleEmitter` object,
    this particle emitter doesn''t allow particles to spawn around the full parameter
    of the rectangle. See the following example:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RectangleOutlineParticleEmitter`：这种粒子发射器子类型将导致粒子从由构造函数参数定义大小的矩形的四个角生成。与`CircleOutlineParticleEmitter`对象不同，这种粒子发射器不允许粒子围绕矩形的整个边缘生成。请参阅以下示例：'
- en: '[PRE42]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`RectangleParticleEmitter`: This particle emitter subtype allows for particles
    to spawn anywhere within the bounding area of a rectangle shape as defined by
    the constructor parameters. To test this particle emitter subtype, simply refactor
    the object in the `RectangleOutlineParticleEmitter` example to use the `RectangleParticleEmitter`
    object instead.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RectangleParticleEmitter`：这种粒子发射器子类型允许粒子在由构造函数参数定义的矩形形状的边界区域内任何位置生成。要测试这种粒子发射器子类型，只需将`RectangleOutlineParticleEmitter`示例中的对象重构为使用`RectangleParticleEmitter`对象即可。'
- en: Particle initializer selection
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子初始化器选择
- en: Particle initializers are of vital importance to particle systems. They provide
    us with the possibility to perform actions on each individual particle that is
    initially spawned. The greatest thing about these particle initializers is that
    they allow us to provide min/max values, giving us the opportunity to randomize
    the properties of spawned particles. Here, find a list of all of the particle
    initializers that AndEngine has to offer as well as examples of their use. Feel
    free to substitute the particle initializers in the recipe with those found in
    this list.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子初始化器对粒子系统至关重要。它们为我们提供了对最初生成的每个单独粒子执行操作的可能性。这些粒子初始化器最棒的一点是，它们允许我们提供最小/最大值，这使我们有机会随机化生成粒子的属性。以下列出了AndEngine提供的所有粒子初始化器及其使用示例。请随意用此列表中的粒子初始化器替换配方中的那些。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following particle initializers can be added with a simple call to `particleSystem.addParticleInitializer(pInitializer)`.
    Additionally, they can be removed via `particleSystem.removeParticleInitializer(pInitializer)`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下粒子初始化器可以通过简单的调用`particleSystem.addParticleInitializer(pInitializer)`添加，此外，还可以通过`particleSystem.removeParticleInitializer(pInitializer)`移除。
- en: '`ExpireParticleInitializer`: We will start off with the most necessary particle
    initializer in the list. The `ExpireParticleInitializer` object provides a means
    of removing particles which have been alive for too long. If we were not to include
    some form of particle expiration, our particle would quickly run out of particles
    to spawn as all particle systems have a limit to the number of particles that
    can be active at any given time. The following example creates an `ExpireParticleModifier`
    object which causes individual particles to expire between `2` and `4` seconds:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpireParticleInitializer`：我们将从列表中最必要的粒子初始化器开始。`ExpireParticleInitializer`对象提供了一种移除存活时间过长的粒子的方法。如果我们不包括某种形式的粒子过期机制，那么随着所有粒子系统在任意给定时间都有可以激活的粒子数量的限制，我们的粒子很快就会没有粒子可以生成。以下示例创建了一个`ExpireParticleModifier`对象，该对象使单个粒子在`2`到`4`秒之间过期：'
- en: '[PRE43]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`AccelerationParticleInitializer`: This initializer allows us to apply movement
    in the form of acceleration, causing the spawned particles to pick up speed before
    reaching the defined velocity. A positive value on the x or y axis will cause
    the particle to move up and to the right, while negative values will move the
    particle down and to the left. In the following example, the particles will be
    given min/max values which will cause particle movement direction to be random:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccelerationParticleInitializer`：这个初始化器允许我们以加速度的形式应用移动，使得生成的粒子在达到定义的速度之前会加速。x轴或y轴上的正值将使粒子向上向右移动，而负值将使粒子向下向左移动。在以下示例中，将为粒子赋予最小/最大值，这将导致粒子的移动方向是随机的：'
- en: '[PRE44]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`AlphaInitializer`: The `AlphaInitializer` object is pretty basic. It simply
    allows us to initialize particles with an undetermined alpha value. The following
    example will cause individual particles to spawn with an alpha value of between
    `0.5f` and `1f`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlphaInitializer`：`AlphaInitializer`对象非常基础。它仅允许我们使用未确定的alpha值初始化粒子。以下示例将导致每个单独的粒子以`0.5f`到`1f`之间的alpha值生成：'
- en: '[PRE45]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`BlendFunctionParticleInitializer`: This particle initializer allows us to
    spawn particles with specific OpenGL blend functions applied to them. For more
    information on blend functions and results, there are many resources that can
    be found online. The following is an example using the `BlendFunctionParticleInitializer`
    object:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlendFunctionParticleInitializer`：这个粒子初始化器允许我们生成应用了特定OpenGL混合函数的粒子。关于混合函数及其结果的更多信息，可以在网上找到许多资源。以下是使用`BlendFunctionParticleInitializer`对象的示例：'
- en: '[PRE46]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ColorParticleInitializer`: The `ColorParticleInitializer` object allows us
    to provide our sprites with colors between min/max values. This allows us to randomize
    the color of each particle spawned. The following example will generate particles,
    each with a completely different random color:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorParticleInitializer`：`ColorParticleInitializer`对象允许我们为精灵提供最小/最大值之间的颜色。这使得我们可以随机化每个生成粒子的颜色。以下示例将生成具有完全不同随机颜色的粒子：'
- en: '[PRE47]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`GravityParticleInitializer`: This particle initializer allows us to spawn
    particles which will act as though they follow the rules of the earth''s gravity.
    The `GravityParticleInitializer` object requires no parameters in its constructor:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GravityParticleInitializer`：这个粒子初始化器允许我们生成像遵循地球重力规则一样的粒子。`GravityParticleInitializer`对象在其构造函数中不需要参数：'
- en: '[PRE48]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`RotationParticleInitializer`: The `RotationParticleInitializer` object allows
    us to define the min/max values for the particle''s rotation when spawned. The
    following example will cause individual particles to spawn anywhere between `0`
    and `359` degrees:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationParticleInitializer`：`RotationParticleInitializer`对象允许我们定义粒子生成时的旋转最小/最大值。以下示例将导致每个单独的粒子以`0`到`359`度之间的任意角度生成：'
- en: '[PRE49]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`ScaleParticleInitializer`: The `ScaleParticleInitializer` object allows us
    to define the min/max values for the particle''s scale when spawned. The following
    example will allow particles to spawn with a scale factor of anywhere between
    `0.5f` and `1.5f`:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleParticleInitializer`：`ScaleParticleInitializer`对象允许我们定义粒子生成时的缩放最小/最大值。以下示例将允许粒子以`0.5f`到`1.5f`之间的任意比例因子生成：'
- en: '[PRE50]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`VelocityParticleInitializer`: This final particle initializer, similar to
    the `AccelerationParticleInitializer` object, allows us to provide movement to
    individual particles when spawned. However, this initializer causes the particles
    to move at a constant speed, and will not increase or decrease velocity over time
    unless manually configured to do so:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VelocityParticleInitializer`：这个最后的粒子初始化器，与`AccelerationParticleInitializer`对象类似，允许我们在生成粒子时为它们提供移动。然而，这个初始化器使粒子以恒定速度移动，并且除非手动配置，否则不会随时间增加或减少速度：'
- en: '[PRE51]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See the following section for a list of AndEngine's particle modifiers.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有关AndEngine的粒子修改器列表，请参阅以下部分。
- en: Particle modifier selection
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子修改器选择
- en: AndEngine's particle modifiers are useful in the development of complex particle
    systems. They allow us to provide changes to individual particles depending on
    how long they've been alive for. Similar to entity modifiers, particle modifiers
    are of the "from time-to time, from value-to value" format. Once again, feel free
    to add any of the particle modifiers in the list to your current test project.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine的粒子修改器在开发复杂的粒子系统时非常有用。它们允许我们根据粒子存活的时间为单个粒子提供变化。与实体修改器类似，粒子修改器是“从时间到时间，从值到值”的格式。再次强调，请随意将列表中的任何粒子修改器添加到您当前测试项目中。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following particle modifiers can be added with a simple call to `particleSystem.addParticleModifier(pModifier)`.
    Additionally, they can be removed via `particleSystem.removeParticleModifier(pModifier)`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下粒子修改器可以通过简单的调用`particleSystem.addParticleModifier(pModifier)`添加，并且可以通过`particleSystem.removeParticleModifier(pModifier)`移除。
- en: '`AlphaParticleModifier`: This modifier allows a particle to shift in alpha
    values between two points in time during a particle''s lifetime. In the following
    example, the modifier will transition from an alpha value of `1` to `0` over a
    duration of `1` second. The modifier will take effect `1` second after the particle
    has spawned:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlphaParticleModifier`：这个修改器允许粒子在其生命周期内，在两个时间点之间改变alpha值。以下示例中，修改器将在`1`秒内从alpha值`1`过渡到`0`。修改器将在粒子生成后`1`秒生效：'
- en: '[PRE52]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ColorParticleModifier`: This modifier will allow a particle to change in color
    between two points in time during a particle''s lifetime. The following modifier
    will cause particles to change from green to red over two seconds, with a from
    time of `0`. This means the transition will begin as soon as a particle is spawned:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorParticleModifier`：这个修改器允许粒子在其生命周期内，在两个时间点之间改变颜色。以下修改器将导致粒子在两秒内从绿色变为红色，从时间`0`开始。这意味着过渡将在粒子生成后立即开始：'
- en: '[PRE53]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`OffCameraExpireParticleModifier`: By adding this modifier to the particle
    system, particles that leave the view of our `Camera` object will be destroyed.
    We can use this as an alternative to the `ExpireParticleInitializer` object, but
    at least one of the two should be active on any particle system. The only parameter
    to supply to this modifier is our `Camera` object:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OffCameraExpireParticleModifier`：将此修改器添加到粒子系统中，离开`Camera`对象视野的粒子将被销毁。我们可以将此作为`ExpireParticleInitializer`对象的替代，但任何粒子系统至少应该激活这两者之一。需要提供给这个修改器的唯一参数是我们的`Camera`对象：'
- en: '[PRE54]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`RotationParticleModifier`: This modifier allows us to change the rotation
    of particles between two points in time during a particle''s lifetime. The following
    example will cause particles to rotate `180` degrees between `1` and `4` seconds
    of a particle''s lifetime:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotationParticleModifier`：这个修改器允许我们在粒子的生命周期内，在两个时间点之间改变粒子的旋转角度。以下示例将导致粒子在其生命周期的`1`到`4`秒之间旋转`180`度：'
- en: '[PRE55]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ScaleParticleModifier`: The `ScaleParticleModifier` object allows us to change
    the scale of a particle between two points in time during a particle''s lifetime.
    The following example will cause particles to grow from a scale of `0.5f` to `1.5f`
    between `1` and `3` seconds of a particle''s lifetime:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleParticleModifier`：`ScaleParticleModifier`对象允许我们在粒子的生命周期内，在两个时间点之间改变粒子的缩放比例。以下示例将导致粒子在其生命周期的`1`到`3`秒之间，从缩放比例`0.5f`增长到`1.5f`：'
- en: '[PRE56]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`IParticleModifier`: Finally, we have the particle modifier interface which
    allows us to create our own modifications to individual particles in the event
    of particle initialization or on every update to a particle via the update thread.
    The following example displays how we can simulate a particle landing on the ground
    by disabling movement on the y axis once a particle reaches less than a value
    of `20` on the `Scene` object''s coordinate system. We can use this interface
    to virtually make any changes we''d like to particles as we see fit:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IParticleModifier`：最后，我们有了粒子修改器接口，它允许我们在粒子初始化时或通过更新线程对每个粒子进行更新时，对单个粒子进行自定义修改。以下示例展示了如何通过在粒子到达`Scene`对象坐标系下`20`以下值时，禁用y轴上的移动来模拟粒子着陆。我们可以使用这个接口，根据需要虚拟地对粒子进行任何更改：'
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now that we've covered all of the particle emitters, particle initializers,
    and particle modifiers, practice making more complex particle systems by combining
    any number of initializers and modifiers you'd like to your own systems!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了所有的粒子发射器、粒子初始化器和粒子修改器，尝试通过组合你想要的初始化器和修改器，创建更复杂的粒子系统吧！
- en: See also
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中*使用不同类型的纹理*。
- en: '*Understanding AndEngine entities* in this chapter.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中的*了解AndEngine实体*。
