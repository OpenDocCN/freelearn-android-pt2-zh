- en: Chapter 1. Instant Android Fragmentation Management How-to
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 即时 Android 碎片化管理指南
- en: Welcome to *Instant Android Fragmentation Management How-to*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎阅读*即时 Android 碎片化管理指南*。
- en: 'One of the biggest challenges Android developers face is the fragmentation
    of the operating system. If we look at the following distribution graph, we can
    see that there are three major versions of the Android OS—Froyo, Gingerbread,
    and Ice Cream Sandwich (ICS)—each with its own look, behavior, and API libraries:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android 开发者面临的最大挑战之一就是操作系统的碎片化。如果我们查看以下分布图，可以看到有三个主要版本的 Android OS——Froyo、Gingerbread
    和 Ice Cream Sandwich (ICS)——每个版本都有自己的外观、行为和 API 库：
- en: '![Instant Android Fragmentation Management How-to](img/0861_01_00.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![即时 Android 碎片化管理指南](img/0861_01_00.jpg)'
- en: Because of these differences between the releases, the effort required in writing
    applications that work seamlessly on all the devices out there can be exhausting.
    This How-to should reduce the stress, providing you with some ready-to-use techniques
    to address these problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各个版本之间存在这些差异，编写能够在所有设备上无缝工作的应用程序可能会非常耗时耗力。本指南将为您提供一些现成的技术手段，以减轻压力，解决这些问题。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您的账户下载您购买的所有 Packt 图书的示例代码，访问地址为[http://www.PacktPub.com](http://www.PacktPub.com)。如果您在别处购买了这本书，可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)注册，我们会将文件直接通过电子邮件发送给您。
- en: Installing the compatibility package (Must know)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装兼容性包（必须知道）
- en: As the name implies, Support Library provides support for the latest APIs on
    older versions of the Android OS. This brings many of the latest features, such
    as Fragments, to the earlier OS releases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，Support Library 支持在旧版本的 Android OS 上使用最新的 API。这使得许多最新功能，例如 Fragments，可以引入到早期的
    OS 版本中。
- en: Additional information can be found in the appropriate section on the official
    Android Developer site at [http://developer.android.com/tools/extras/support-library.html](http://developer.android.com/tools/extras/support-library.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在官方 Android 开发者网站的相应部分找到，地址为[http://developer.android.com/tools/extras/support-library.html](http://developer.android.com/tools/extras/support-library.html)。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before following the next sections you need to install all the tools that allow
    you to write, compile, and install programs into your Android device or emulator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一部分之前，您需要安装所有允许您编写、编译并将程序安装到您的 Android 设备或模拟器中的工具。
- en: The standard way is to install the Android SDK and in particular the Android
    Developer Tool, a plugin for the Eclipse IDE. It provides integration with the
    SDK and a bunch of utilities to help with your development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方式是安装 Android SDK，特别是为 Eclipse IDE 提供的 Android Developer Tool 插件。它提供了与 SDK
    的集成和一整套帮助您开发的实用工具。
- en: In order to install this tool, follow the instructions in the original documentation
    that you can find at [http://developer.android.com/tools/help/adt.html](http://developer.android.com/tools/help/adt.html).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装这个工具，请按照原始文档中的说明操作，您可以在[http://developer.android.com/tools/help/adt.html](http://developer.android.com/tools/help/adt.html)找到。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s install the library:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装这个库：
- en: Launch the Android SDK Manager from Eclipse, selecting **Window** | **Android
    SDK Manager**, as shown in the following screenshot:![How to do it...](img/0861_01_01.jpg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Eclipse 启动 Android SDK 管理器，选择**窗口** | **Android SDK 管理器**，如下截图所示：![如何操作...](img/0861_01_01.jpg)
- en: You will be presented with the list of all available packages (installed or
    not). Scroll down until you reach the **Extras** section and select **Android
    Support Library**; now you can click on the **install packages** button in the
    lower-right corner and wait several minutes (the time depends on the quality of
    your Internet connection):![How to do it...](img/0861_01_02.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个所有可用软件包的列表（无论是否已安装）。向下滚动直到您到达**附加功能**部分，并选择**Android Support Library**；现在您可以点击右下角的**安装软件包**按钮，然后等待几分钟（具体时间取决于您的网络连接质量）：![如何操作...](img/0861_01_02.jpg)
- en: The support library files will be downloaded to the Android SDK folder. The
    JAR file to add to the project is `<AndroidSDK>\extras\android\support\v4\android-support-v4.jar`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 支持库文件将被下载到 Android SDK 文件夹中。要添加到项目的 JAR 文件位于`<AndroidSDK>\extras\android\support\v4\android-support-v4.jar`。
- en: 'Let us reference this library from your Android project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你的安卓项目中引用这个库：
- en: Copy the Support Library into the `libs` directory at the root of your project
    (create it if doesn't exist).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将支持库复制到项目根目录下的`libs`目录中（如果不存在，请创建它）。
- en: Open your project in Eclipse and select the element corresponding to the Support
    Library from **Package explorer**. Right-click and select **Build Path** | **Add
    to build path** from the menu.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开你的项目，从**Package explorer**中选择与支持库对应的元素。右键点击并从菜单中选择**Build Path**
    | **Add to build path**。
- en: 'The final step is to check if the setup is working correctly. To do this, add
    the following import to a project and verify that there are no errors in Eclipse:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是检查设置是否正确。为此，向项目中添加以下导入，并验证Eclipse中是否有错误。
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build the project:![How to do it...](img/0861_01_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目：![如何操作...](img/0861_01_03.jpg)
- en: If there are no build errors, everything is ok.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有构建错误，那么一切正常。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An Android application is first of all a Java application, and like all these
    kinds of applications, it needs to know where to look for the classes used in
    your code; this is simply done by adding the library of your choice to the build
    path. Normally in Java, the libraries' path is indicated by the `JAVAPATH` environmental
    variable, but since Eclipse uses its system, the details are more subtle but the
    concepts are the same.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用程序首先是一个Java应用程序，和这类所有应用程序一样，它需要知道在代码中使用的类在哪里查找；这只需简单地将你选择的库添加到构建路径中即可。在Java中，通常通过`JAVAPATH`环境变量来指定库的路径，但由于Eclipse使用自己的系统，细节更为复杂，但概念是相同的。
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let's talk about some other options, or possibly some pieces of general
    information that are relevant to this task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈其他一些选项，或者可能是一些与这项任务相关的通用信息。
- en: API levels
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API级别
- en: To better understand about the compatibility package, it's helpful to know a
    bit about Android's history.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解兼容性包，了解一些安卓的历史是有帮助的。
- en: The Android platform was born in 2003, as the product of a company which at
    first was known as Android Inc. and which was acquired by Google in 2005\. Its
    direct competitors were and are still today the iOS platform by Apple and the
    RIM, know as Blackberry. Technically speaking, its core is an operating system
    using a Linux Kernel, aimed to be installed on devices with very different hardware
    (mainly mobile devices, but today it is also used in general embedded systems
    like, for example, the game console OUYA that features a modified version of Android
    4.0).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓平台诞生于2003年，最初是由名为Android Inc.的公司开发的，谷歌在2005年收购了这家公司。其直接竞争对手是苹果的iOS平台和RIM的黑莓系统。从技术上来说，其核心是一个使用Linux内核的操作系统，旨在安装在硬件差异很大的设备上（主要是移动设备，但现在也用于一般的嵌入式系统，例如采用修改版安卓4.0的游戏机OUYA）。
- en: 'Like any software that has been around for a while, many changes happened to
    the functionality and many versions came out, each with a name of a dessert:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有存在一段时间的软件一样，功能性发生了很多变化，也推出了许多版本，每个版本都对应一个甜点名称：
- en: Apple Pie (API level 1)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple Pie（API级别1）
- en: Banana Bread (API level 2)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Banana Bread（API级别2）
- en: 1.5 – Cupcake (API level 3)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.5 – Cupcake（API级别3）
- en: 1.6 – Donut (API level 4)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.6 – Donut（API级别4）
- en: 2.0-2.1x – Eclair (API level 5 to 7)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.0-2.1x – Eclair（API级别5至7）
- en: 2.2 – Froyo (API level 8)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.2 – Froyo（API级别8）
- en: 2.3 – Gingerbread (API level 9 and 10)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.3 – Gingerbread（API级别9和10）
- en: 3.0-3.2 – Honeycomb (API level 11 to 13)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.0-3.2 – Honeycomb（API级别11至13）
- en: 4.0 – Ice Cream Sandwich (API level 14 and 15)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.0 – Ice Cream Sandwich（API级别14和15）
- en: 4.1 – Jelly Bean (API level 16)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1 – Jelly Bean（API级别16）
- en: Like in many other software projects, the names, as well as the themes, are
    in alphabetical order (another project that follows this approach is the Ubuntu
    distribution).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他软件项目中，名称以及主题都是按字母顺序排列的（另一个采用这种做法的项目是Ubuntu发行版）。
- en: The **API level** written in the parenthesis is the main point about this compatibility
    package. Each version of software introduces or removes features and bugs. In
    its lifetime, an operating system such as Android aims to add more fantastic innovations
    while avoiding breaking pre-installed applications in older versions, but also
    aims to make available to these older versions the same features with a process
    technically called **backporting**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中写的**API级别**是兼容性包的主要要点。软件的每个版本都会引入或移除功能及漏洞。在其生命周期内，安卓这样的操作系统旨在增加更多惊人的创新，同时避免破坏旧版本中预安装的应用程序，但也旨在通过一种技术过程，即**向后移植**，使这些旧版本也能使用相同的功能。
- en: For more information about the API levels, carefully read the official documentation
    available at [http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels](http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关API级别的更多信息，请仔细阅读官方文档，地址为[http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels](http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels)。
- en: All that you will read in the following sections is thought to address these
    problems, using backporting; in particular, to specifically address the backward
    compatibility issues with version 3.0 of the Android operating system—the version
    named Honeycomb.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你将阅读的部分旨在通过回溯技术解决这些问题，特别是为了解决与Android操作系统3.0版本向后兼容的问题——这个版本名为Honeycomb。
- en: Version 3.0 was first intended to be installed on tablets, and in general, on
    devices with large screens. Android is a platform that from the beginning was
    intended to be used on devices with very different characteristics (think a system
    where an application must be usable on VGA screens, with or without physical keyboards,
    with a camera, and so on); with the release of 3.0, all this was improved with
    specific APIs thought to extend and make developing applications easier, and also
    to create new patterns with the graphical user interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 版本3.0最初旨在安装在平板电脑上，通常是在大屏幕设备上。Android是一个从一开始就旨在用于不同特性设备的平台（想象一个系统，应用程序必须在VGA屏幕上可用，无论有无物理键盘，是否有摄像头等）；随着3.0版本的发布，所有这些功能都通过特定的API得到了改进，旨在扩展并简化应用程序开发，同时也为图形用户界面创建新的模式。
- en: The more important innovation was the introduction of the Fragment class. Earlier,
    the only main class in developing the Android applications was Activity, a class
    that provides the user with a screen in order to accomplish a specific task, but
    that was too coarse grain and not re-usable enough to be used in the applications
    with large screens such as a tablet. With the introduction of the Fragment class
    to be used as the basic block, it is now possible to create responsive mobile
    design; that is, producing content adapting to the context and optimizing the
    block's placement, using reflowing or a combination of each Fragment inside the
    main Activity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的创新是引入了Fragment类。之前，在开发Android应用程序时唯一的主要类是Activity，这个类为用户提供了一个屏幕以完成特定任务，但这粒度太粗，不足以在如平板这样大屏幕的应用程序中重复使用。随着Fragment类作为基本块的引入，现在可以创建响应式的移动设计；也就是说，根据上下文调整内容并优化块的位置，使用重新流动或每个Fragment在主Activity中的组合。
- en: These are concepts inspired by the so called responsive web design, where developers
    build web pages that adapt to the viewport's size; the preeminent book about this
    argument is *Responsive Web Design*, *Ethan Marcotte*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念受到所谓的响应式网页设计的启发，开发者构建的网页能够适应视口的大小；关于这个主题的权威书籍是《响应式网页设计》，作者*Ethan Marcotte*。
- en: If all this seems a bit complicated, allow me to make a simple example using
    a real application. The following image is the composition of two screenshots
    of the same application (Google Play, the Android Market) with two different screen
    resolutions; you can see how the information about the developer and the information
    about the application is placed side by side on the tablet version, where as in
    the phone version they are just shown one below the other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来有些复杂，请允许我举一个简单的例子，使用一个真实的应用程序。以下图片是同一应用程序（谷歌Play，Android市场）的两张不同屏幕分辨率的截图组合；你可以看到关于开发者和应用程序的信息在平板电脑版本中是并排放置的，而在手机版本中则是上下排列的。
- en: '![API levels](img/0861_01_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![API级别](img/0861_01_04.jpg)'
- en: It's not the only possibility to create a so-called multi-paned layout; you
    can stretch, compress, stack, or expand the Fragment depending on your plan. On
    the Android's site, it's available as a guide worth following—in the design section
    of the site. It is available at [http://developer.android.com/design/patterns/multi-pane-layouts.html](http://developer.android.com/design/patterns/multi-pane-layouts.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所谓的多窗格布局并非唯一可能；你可以根据计划拉伸、压缩、堆叠或展开Fragment。在Android的网站上，设计部分有一份值得遵循的指南，地址为[http://developer.android.com/design/patterns/multi-pane-layouts.html](http://developer.android.com/design/patterns/multi-pane-layouts.html)。
- en: Another important element introduced in Google's platform is the UI pattern
    named ActionBar—a piece of interface at the top of an application where the more
    important menu's buttons are visualized in order to be easily accessible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Google 平台引入的另一个重要的 UI 模式是名为 ActionBar 的界面元素——位于应用程序顶部，其中最重要的菜单按钮可视化，以便轻松访问。
- en: '![API levels](img/0861_01_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![API 级别](img/0861_01_05.jpg)'
- en: Also a new contextual menu is available in the action bar. When, for example,
    one or more items in a list are selected (such as, the Gmail application), the
    appearance of the bar changes and shows new buttons related to the actions available
    for the selected items.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作栏中还提供了一个新的上下文菜单。例如，当一个列表中的一个或多个项目被选中（如 Gmail 应用程序）时，栏的外观会发生变化，并显示与所选项目可用的操作相关的新按钮。
- en: '![API levels](img/0861_01_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![API 级别](img/0861_01_06.jpg)'
- en: 'For sake of completeness, let me list other new capabilities introduced with
    Honeycomb (as previously said, look into the official documentation for a better
    understanding of them):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我列举一下 Honeycomb 引入的其他新功能（如前所述，查阅官方文档以更好地理解它们）：
- en: '**Copy and Paste**: A clipboard-based framework'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制和粘贴**：基于剪贴板框架'
- en: '**Loaders**: Load data asynchronously'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载器**：异步加载数据'
- en: '**Drag and Drop**: Permits the moving of data between views'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拖放**：允许在视图之间移动数据'
- en: '**Property animation framework**: Supersedes the old Animation package, allowing
    the animation of almost everything into an application'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性动画框架**：替代了旧的 Animation 包，允许对应用程序中的几乎所有内容进行动画处理'
- en: '**Hardware acceleration**: From API level 11, the graphic pipeline uses dedicated
    hardware when it is present'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件加速**：从 API 级别 11 开始，图形管道在硬件可用时会使用专用的硬件'
- en: Support for encrypted storage
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持加密存储
- en: Not all the things listed here are backported with the Support Library. In particular,
    there is no official way to implement the new animation framework in a backward
    compatible way (libraries that do this do exist though).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是这里列出的所有内容都通过 Support Library 进行向后移植。特别是，没有官方的方法以向后兼容的方式实现新的动画框架（尽管确实存在这样做的库）。
- en: Unfortunately, the Support Library does not support all these features of previous
    versions of the OS. Most notably, the official Google Support Library does not
    support the action bar.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Support Library 并不支持所有这些旧版操作系统的功能。特别是，官方的 Google Support Library 不支持操作栏。
- en: Fortunately, for Android developers, there is an open-source project called
    `ActionBarSherlock`, which does a fantastic job of bringing the ActionBar API
    back to Android 1.6 (API level 4). We will discuss more on this in the *ActionBar*
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于 Android 开发者来说，有一个名为 `ActionBarSherlock` 的开源项目，它出色地将 ActionBar API 带回到了
    Android 1.6（API 级别 4）。我们将在 *ActionBar* 部分对此进行更多讨论。
- en: Fragments (Should know)
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碎片（应该了解）
- en: This is the most important section. Here you will learn how to create an Android
    application designed to be not only backwards compatible with versions down to
    API level 4, but also capable of showing contents depending on the context. In
    a phone with normal-size display, it will only show a list (single-paned configuration),
    but when a larger screen is available, a view with the details of the selection
    is also displayed (multi-paned configuration).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的部分。在这里，你将学习如何创建一个不仅与 API 级别 4 的旧版本向后兼容的 Android 应用程序，而且还能根据上下文显示内容。在正常大小的显示屏手机上，它只显示一个列表（单窗格配置），但是当有更大的屏幕可用时，也会显示所选内容的详细信息视图（多窗格配置）。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's start creating a simple application composed of a single Activity and
    two Fragments. One shows a list of items and the second one shows the data related
    to the selection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个由单个 Activity 和两个 Fragment 组成的简单应用程序。一个显示项目列表，另一个显示与选择相关的数据。
- en: 'Import all the necessary classes:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必要的类：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the Activity that will contain all the code, extending the `FragmentActivity`
    class from the Support Library:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 Activity，包含所有代码，并从 Support Library 的 `FragmentActivity` 类继承：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement its method `onCreate()`, where we are going to set the initial layout
    and do what is necessary in order to manage it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onCreate()`方法，在这里我们将设置初始布局并做必要的管理工作：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the Fragment showing the list of primary options using `ListFragment`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ListFragment` 创建显示主选项列表的 Fragment：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `onActivityCreate()` method for this class, where we set the
    content of the list:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类实现 `onActivityCreate()` 方法，在这里我们设置列表的内容：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the `onListItemClick()` method that shows to the user the selected
    content updating the adjacent fragment or substituting the list:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `onListItemClick()` 方法，该方法向用户显示选定的内容，更新相邻的片段或替换列表：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the definition of the Fragment that will display the details:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加将显示详细信息的片段的定义：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement its `onCreateView()` method, where we simply deflate a layout file
    representing the contents of the Fragment:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `onCreateView()` 方法，我们只需在这里简单展开一个表示片段内容的布局文件：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now it's time to write the layout files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写布局文件了。
- en: 'Create a file with the path `res/layout/main.xml`, declaring the single-paned
    UI:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路径为 `res/layout/main.xml` 的文件，声明单一窗格的 UI：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a file with the path `res/layout-land/main.xml` with the multi-paned
    UI:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路径为 `res/layout-land/main.xml` 的文件，包含多窗格 UI：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The point of the code written in the *How to do it...* section is to create
    a simple application capable of adapting its content from the context, and of
    course, make it launchable from any device with a version of Android starting
    from API level 4.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何实现...* 部分编写的代码的目的是创建一个能够根据上下文调整其内容，并且当然可以从任何装有从 API 级别 4 开始的 Android 版本的设备上启动的简单应用程序。'
- en: This is possible using a specific custom class, made available by the compatibility
    package, named `FragmentActivity`; be aware of this, otherwise the Fragment-related
    stuff won't work properly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用兼容性包提供的特定自定义类 `FragmentActivity` 来实现；注意这一点，否则与片段相关的功能将无法正常工作。
- en: The code creates a single Activity with two Fragments inside. One is a simple
    list of random items taken from a simple array and the other is a very simple
    Fragment containing a constant text. The application chooses how to organize the
    layout using the device's orientation. When the device is in landscape mode, the
    Fragments are displayed side by side, otherwise we start with the application
    showing only the list, and then after selecting one item in the list, we switch
    to the detail replacing the list with the other Fragment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个包含两个片段的单个活动。一个是来自简单数组的随机项目列表，另一个是非常简单的包含常量文本的片段。应用程序根据设备方向来组织布局。当设备处于横屏模式时，片段会并排显示，否则我们从仅显示列表的应用程序开始，然后在选择列表中的一个项目后，我们切换到详细信息，用另一个片段替换列表。
- en: 'It''s the job of the Activity class to manage the Fragments displayed. There
    are two ways to manage the Fragments:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 活动类的职责是管理显示的片段。有两种方法来管理片段：
- en: '**Statically**: By including the Fragment in the XML'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态包含**：在 XML 中包含片段'
- en: '**Dynamically**: By loading the Fragment during runtime with `FragmentManager`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态加载**：在运行时使用 `FragmentManager` 加载片段'
- en: The important point to note here is that a Fragment defined in the XML can't
    be removed with `FragmentManager` during runtime, only Fragments loaded dynamically
    can be removed. This is very important and can result in a very wrong behavior
    or worse; seems to work correctly, but under the hood it introduces some very
    nasty bug (for example, pieces of UI that appear multiple times).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，在 XML 中定义的片段在运行时不能通过 `FragmentManager` 移除，只有动态加载的片段可以被移除。这一点非常重要，可能会导致非常错误的行为或更糟的是；看起来工作正常，但在幕后它引入了一些非常讨厌的
    bug（例如，多次出现的 UI 片段）。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A very useful tool is the Hierarchy Viewer, which is included with the SDK.
    This tool shows the activities in a graphical hierarchical tree while the application
    is running. The `.bat` file can be found at `<SDK_ROOT\tools\hierarchyviewer.bat>`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的工具是 Hierarchy Viewer，它包含在 SDK 中。这个工具在应用程序运行时以图形层次树的形式显示活动。`.bat` 文件可以在
    `<SDK_ROOT\tools\hierarchyviewer.bat>` 找到。
- en: Let me explain how Android works and how it saves the state of the UI between
    state transitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下 Android 的工作原理以及它是如何在状态转换之间保存 UI 状态的。
- en: A state transition happens when an Activity is paused or destroyed, which can
    happen quite frequently, for example during a phone call (remember, the Android
    device may be a phone) or even when the device orientation changes!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动暂停或销毁时，会发生状态转换，这种情况可能相当频繁，例如在电话通话期间（记住，Android 设备可能是电话）或设备方向改变时！
- en: This last case may be a surprise when your application appears to be working
    just fine, but then crashes when the orientation changes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况可能会让人感到惊讶，因为当应用程序看起来运行良好，但方向改变时却崩溃了。
- en: This is because a change in orientation destroys and rebuilds the UI (almost)
    from scratch. The system makes the `onSaveInstanceState()` method available, which
    is called before an Activity may be killed and passes to it a `Bundle` instance
    where we can save all that we think is valuable in order to recreate the actual
    state. The state can be restored in the `onCreate()` method where the system will
    pass back the same `Bundle`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为改变方向几乎会从零开始销毁和重建 UI。系统提供了 `onSaveInstanceState()` 方法，该方法在 Activity 可能被销毁之前调用，并传递一个
    `Bundle` 实例，我们可以在其中保存我们认为有价值以重新创建实际状态的所有内容。可以在 `onCreate()` 方法中恢复状态，系统会将同一个 `Bundle`
    传递回来。
- en: The system saves the state of the UI elements for which an ID has been defined,
    so for example, if we have an `EditText` method defined into the XML with an associated
    ID, any text written into it will survive from a state change.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 系统为已定义 ID 的 UI 元素保存状态，因此例如，如果我们有一个在 XML 中定义了关联 ID 的 `EditText` 方法，任何写入其中的文本都将在状态更改后保留下来。
- en: 'In our code, we have chosen to replace `ListFragment` with the Fragment containing
    the detail, but in order to do so, we must create it programmatically from the
    beginning. But here there is a subtle point; since the container view has an ID
    associated to it, it will have the `ListFragment` saved from the previous state.
    So we must check if we are coming from a previous state and just in case avoid
    reattaching the Fragment; the code used is the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们选择用包含详细信息的 Fragment 来替换 `ListFragment`，但为了做到这一点，我们必须从一开始就程序化地创建它。但这里有一个微妙的要点；由于容器视图与一个
    ID 相关联，它将保存之前状态的 `ListFragment`。因此，我们必须检查我们是否来自之前的状态，并且以防万一避免重新附加 Fragment；使用的代码如下：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If instead we are in portrait mode, without previous instances, we can simply
    attach `ListFragment`, using `FragmentManager` and its methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于竖屏模式，且没有之前的实例，我们可以简单地将 `ListFragment` 附加到 `FragmentManager` 上，并使用其方法。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while with the normal Android's API, `FragmentManager` is returned
    from `getFragmentManager()` and the Support Library must be called with `getSupportFragmentManager()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用普通的 Android API 时，`FragmentManager` 是通过 `getFragmentManager()` 获取的，而支持库必须通过
    `getSupportFragmentManager()` 调用。
- en: 'In order to understand the remaining code, we must master the Fragments'' lifecycle,
    as shown in the following table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解剩余的代码，我们必须掌握 Fragments 的生命周期，如下表所示：
- en: '| Fragment | Activity |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Fragment | Activity |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onAttach()``onCreate()` |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `onAttach()``onCreate()` |   |'
- en: '| `onCreateView()` | `onCreate()` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `onCreateView()` | `onCreate()` |'
- en: '| `onActivityCreated()` |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `onActivityCreated()` |   |'
- en: '| `onStart()` | `onStart()` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `onStart()` | `onStart()` |'
- en: '| `onResume()` | `onResume()` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `onResume()` | `onResume()` |'
- en: '| `onPause()` | `onPause()` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `onPause()` | `onPause()` |'
- en: '| `onStop()` | `onStop()` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `onStop()` | `onStop()` |'
- en: '| `onDestroyView()` |   |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `onDestroyView()` |   |'
- en: '| `onDestroy()` | `onDestroy()` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `onDestroy()` | `onDestroy()` |'
- en: '| `onDetach()` |   |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `onDetach()` |   |'
- en: An Activity and its Fragments have a tight relationship; what is more important
    for us now is the creation time, that is, when the Activity's `onCreate()` method
    is called. As stated previously, the Fragment may be directly placed in the XML
    layout by using a Fragment tag or dynamically loading the Fragment at runtime.
    In all the cases, the `onCreateView()` method of the Fragment must return this
    layout.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Activity 和其 Fragments 有着紧密的关系；现在对我们来说更重要的是创建时间，即 Activity 的 `onCreate()` 方法被调用的时候。如前所述，可以通过使用
    Fragment 标签在 XML 布局中直接放置 Fragment，或者在运行时动态加载 Fragment。在所有情况下，Fragment 的 `onCreateView()`
    方法必须返回此布局。
- en: Notice that only after the Activity's `onCreate()` method has returned can we
    rely on proper initialization of the content view hierarchy. At this point, the
    Fragment's `onActivityCreate()` method is called.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有在 Activity 的 `onCreate()` 方法返回后，我们才能依赖内容视图层次结构的正确初始化。此时，将调用 Fragment 的
    `onActivityCreate()` 方法。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let's talk about some other options, or possibly some pieces of general
    information that are relevant to this task.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈其他一些选项，或者可能是一些与这项任务相关的通用信息。
- en: Creating the context adapting interface
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建适应接口的上下文
- en: When we create the two possible layouts of the Fragments, we choose the landscape
    and portrait orientation as a switch, but this is not completely the correct approach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 Fragments 的两种可能的布局时，我们选择横屏和竖屏作为切换，但这并不是完全正确的方法。
- en: We know well how it is possible to provide various versions of the same resource
    (layouts, images, and so on) by placing it in a directory whose name is appended
    with some specific qualifiers that identify the configuration under which the
    resources must be used (in the previous case, layout-land has been used as the
    directory's name to indicate as configuration to the device in landscape orientation).
    The qualifiers can be mixed together, but only in a specific order.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常清楚，通过将同一资源的不同版本（布局、图片等）放置在目录中，并通过在目录名称后附加一些特定限定符来标识资源必须使用的配置（在前一个示例中，使用layout-land作为目录名称，以指示设备在横屏方向上的配置），限定符可以混合在一起，但只能按照特定的顺序。
- en: 'From API level 13 (that is, version 3.2), two new qualifiers are available:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别13（即版本3.2）开始，有两个新的限定符可用：
- en: '`w<N>dp`: This qualifier specifies a minimum available screen width in dp units
    at which the resource should be used—defined by the `<N>` value. This configuration
    value will change when the orientation changes between landscape and portrait
    to match the current actual width.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w<N>dp`：此限定符指定了资源应使用的最小可用屏幕宽度（以dp为单位），由`<N>`值定义。此配置值将在横屏和竖屏之间切换时改变，以匹配当前的实际宽度。'
- en: '`h<N>dp`: This qualifier specifies a minimum available screen height in dp
    units at which the resource should be used—defined by the `<N>` value. This configuration
    value will change when the orientation changes between landscape and portrait
    to match the current actual height.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h<N>dp`：此限定符指定了资源应使用的最小可用屏幕高度（以dp为单位），由`<N>`值定义。此配置值将在横屏和竖屏之间切换时改变，以匹配当前的实际高度。'
- en: With these qualifiers, it is also possible to use the extended layout on devices
    that have, for example, the screen width on portrait mode large enough to contain
    it. If we decide that the switch happens at 600 dp of screen width, we can place
    our extended layout XML file into a directory named `res/layout-w600dp/`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些限定符，还可以在例如竖屏模式下屏幕宽度足够大的设备上使用扩展布局。如果我们决定在屏幕宽度为600 dp时进行切换，我们可以将扩展布局XML文件放置在名为`res/layout-w600dp/`的目录中。
- en: 'Another trick useful in cases like these is the use of `<include>` and `<merge>`
    tags into your layout. In this way, we can create only one specific layout file
    and reference it from another if we think it must be equal. If we want to use
    `res/layout-w600dp/main.xml` as our real extended layout, we can reference it
    from `res/layout-land/main.xml` with the following piece of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下有用的另一个技巧是在布局中使用`<include>`和`<merge>`标签。这样，我们可以只创建一个特定的布局文件，并从另一个文件中引用它，如果我们认为它应该是相等的。如果我们想使用`res/layout-w600dp/main.xml`作为我们的真实扩展布局，我们可以使用以下代码段从`res/layout-land/main.xml`中引用它：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have renamed it to `skeleton_extended.xml`, the multi-paned layout.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将其重命名为`skeleton_extended.xml`，即多窗格布局。
- en: The final words are about managing themes and making them as version-independent
    as possible. If, for example, we want to use a light theme (the default one is
    dark) and in particular the `Holo` theme (a particular theme included in all Android
    OS starting from Honeycomb that is a compatibility requirement for Android devices
    running Android 4.0 and forward) with devices with an API level equal or greater
    than 11, we need to declare our custom theme. Create two directories, one with
    the path `res/values/` and the other named `res/values-v11/`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于管理主题，并尽可能使它们与版本无关。例如，如果我们想要使用浅色主题（默认为深色），特别是`Holo`主题（从Honeycomb开始包含在所有Android
    OS中的特定主题，对于运行Android 4.0及以上版本的Android设备是兼容性要求），对于API级别等于或大于11的设备，我们需要声明自定义主题。创建两个目录，一个路径为`res/values/`，另一个名为`res/values-v11/`。
- en: 'In the first, create the `styles.xml` file with the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个目录中，创建包含以下内容的`styles.xml`文件：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the other instead write the following content:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个目录中，写入以下内容：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally insert the following code line in the `AndroidManifest.xml` file as
    an attribute of the `<application>` tag:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`AndroidManifest.xml`文件中，将以下代码行作为`<application>`标签的属性插入：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's important to note that these considerations don't help the backward compatibility
    directly, but they avoid the loss of possibilities offered from new devices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些考虑因素并不直接帮助向后兼容，但它们避免了因新设备而失去的可能性。
- en: Menu
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单
- en: Starting with the Honeycomb version, the way the menu is managed is also different.
    Because of `ActionBar`, now it's possible to present some menu options on it so
    that it becomes easily accessible. The ratio to be used in choosing the options
    to place in the ActionBar should follow the FIT scheme—Frequent, Important, or
    Typical.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从Honeycomb版本开始，菜单的管理方式也有所不同。由于`ActionBar`的存在，现在可以将其上的一些菜单选项呈现出来，以便更容易访问。选择放置在ActionBar中的选项应遵循FIT方案——频繁、重要或典型。
- en: So the method used for building the menu, that is, `OnCreateOptionsMenu()`,
    is called—when an action bar is present—at Activity start (on pre-Honeycomb devices,
    this function is activated only by pressing the menu button). For example, we
    can define a simple menu with two options in it, into a file at the `res/menu/main.xml`
    path.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用于构建菜单的方法，即`OnCreateOptionsMenu()`，在存在操作栏的情况下，在Activity启动时被调用（在Honeycomb之前的设备上，这个函数只有在按下菜单按钮时才会被激活）。例如，我们可以在`res/menu/main.xml`路径下的文件中定义一个包含两个选项的简单菜单。
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we have indicated the `ifRoom` value in the `showAsAction` attribute,
    this option will be inserted to the right side of the ActionBar (in case there
    are more options with the same value set, only those that fit into the action
    bar will be displayed, the others will be shown normally by the menu button).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`showAsAction`属性中指定了`ifRoom`值，这个选项将被插入到ActionBar的右侧（如果有更多具有相同设置的选项，只有那些适合放入操作栏的选项才会显示，其余的将正常通过菜单按钮显示）。
- en: In pre-Honeycomb devices without ActionBar, all the options will appear normally
    with the usual menu buttons.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有ActionBar的Honeycomb之前的设备上，所有选项都会通过常规菜单按钮正常显示。
- en: '![Menu](img/0861_02_01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![菜单](img/0861_02_01.jpg)'
- en: Fragments without UI
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有UI的Fragments
- en: Since the Fragments are components at application level and not at UI level,
    it's possible to instance these without associating layout elements to them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fragment是应用程序级别的组件，而不是UI级别的，因此可以实例化这些Fragment，而无需将布局元素关联到它们。
- en: We do this programmatically with the `add(fragment, tag)` function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`add(fragment, tag)`函数以编程方式实现这一点。
- en: This is available with an instance of `FragmentTransaction`. The `tag` parameter
    is a normal string (do not confuse this parameter with the tags used in the `View`
    class) that can then be used to find the Fragment with the `findFragmentByTag()`
    function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`FragmentTransaction`的实例可用的。`tag`参数是一个普通字符串（不要将此参数与`View`类中使用的标签混淆），然后可以使用`findFragmentByTag()`函数找到该Fragment。
- en: If you are wondering why you would want to use a Fragment with no UI, keep in
    mind that in this way Fragments are not destroyed when the UI is recreated (such
    as during orientation changes).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么你要使用一个没有UI的Fragment，请记住，以这种方式，当UI重新创建时（如在屏幕方向改变时），Fragment不会被销毁。
- en: minSdkVersion and targetSdkVersion
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`minSdkVersion`和`targetSdkVersion`'
- en: Since the devil is in the detail, it is important to understand the role of
    the variables in the `<uses-sdk>` tag used in `AndroidManifest.xml`, which expresses
    the application's compatibility with one or more versions of the Android platform.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于细节决定成败，因此了解在`AndroidManifest.xml`中使用的`<uses-sdk>`标签中的变量作用非常重要，它表示应用程序与一个或多个Android平台版本的兼容性。
- en: 'As the meaning of `minSdkVersion` is rather obvious, let me quote an excerpt
    from the documentation of `targetSdkVersion`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`minSdkVersion`的含义相当明显，让我引用一下`targetSdkVersion`的文档摘要：
- en: '*This attribute informs the system that you have tested against the target
    version and the system should not enable any compatibility behaviors to maintain
    your app''s forward-compatibility with the target version. The application is
    still able to run on older versions (down to minSdkVersion).*'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这个属性通知系统你已经针对目标版本进行了测试，系统不应启用任何兼容性行为以保持你的应用程序与目标版本的前向兼容性。应用程序仍然可以在较旧的版本上运行（直至`minSdkVersion`）。*'
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*... if the API level of the platform is higher than the version declared by
    your app''s targetSdkVersion, the system may enable compatibility behaviors to
    ensure that your app continues to work the way you expect. You can disable such
    compatibility behaviors by specifying targetSdkVersion to match the API level
    of the platform on which it''s running.*'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*...如果平台的API级别高于你的应用程序声明的`targetSdkVersion`版本，系统可能会启用兼容性行为，以确保你的应用程序按照预期的方式继续工作。你可以通过指定`targetSdkVersion`以匹配运行它的平台的API级别来禁用这些兼容性行为。*'
- en: 'In our case, we want to create applications installable from devices with API
    level 4, and in particular, we want to use capabilities introduced with Honeycomb
    (that is, API level 11), so finally the `AndroidManifest.xml` file must contain
    the following content:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望创建的应用程序可以从API级别4的设备上安装，并且我们特别希望使用Honeycomb（即API级别11）引入的功能，因此`AndroidManifest.xml`文件必须包含以下内容：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the Eclipse users, it''s possible to set these values initially from the
    Android projects creation wizard:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eclipse用户，可以在创建Android项目向导时最初设置这些值：
- en: '![minSdkVersion and targetSdkVersion](img/0861_02_02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![minSdkVersion 和 targetSdkVersion](img/0861_02_02.jpg)'
- en: The `targetSdkVersion` is **Build SDK** as set in the shown dialog.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`targetSdkVersion`是**构建SDK**，如所示对话框中设置的那样。'
- en: The `maxSdkVersion` must be set manually.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSdkVersion`必须手动设置。'
- en: '![minSdkVersion and targetSdkVersion](img/0861_02_03.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![minSdkVersion 和 targetSdkVersion](img/0861_02_03.jpg)'
- en: Dialog
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对话框
- en: As you can clearly see in the code, there is a special type of Fragment, a `ListFragment`,
    which is a fragment that displays a list of items by binding them to a data source
    and exposes event handlers when the user selects an item.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，你可以清楚地看到一个特殊的片段类型，即`ListFragment`，它通过将项目绑定到数据源来显示项目列表，并在用户选择项目时公开事件处理程序。
- en: 'Support Library also provides the backward compatible implementation of the
    `FragmentDialog` class used to display, obviously, dialog windows. In the documentation,
    it is explained as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 支持库还提供了`FragmentDialog`类的向后兼容实现，用于显示，显然，对话框窗口。在文档中，它是这样解释的：
- en: '*A fragment that displays a dialog window, floating on top of its activity''s
    window. This fragment contains a Dialog object, which it displays as appropriate
    based on the fragment''s state. Control of the dialog (deciding when to show,
    hide, dismiss it) should be done through the API here, not with direct calls on
    the dialog.*'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一个显示对话框窗口的片段，浮在其活动窗口的顶部。这个片段包含一个Dialog对象，它会根据片段的状态适当地显示。对话的控制（决定何时显示、隐藏、关闭它）应该通过这里的API来完成，而不是直接调用对话框。*'
- en: 'Let''s write some example code in order to show how this is supposed to work:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些示例代码，以展示这是如何工作的：
- en: 'Import ordinary classes that are used to create a Dialog:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入用于创建对话框的普通类：
- en: '[PRE18]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a class extending `FragmentDialog`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`FragmentDialog`的类：
- en: '[PRE19]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Override the method that is used to create the Dialog:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写用于创建对话框的方法：
- en: '[PRE20]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add an option in the menu''s resource file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单资源文件中添加一个选项：
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, add the following code snippet in the Activity class'' `onOptionsItemSelected()`
    function to call this Dialog:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在Activity类的`onOptionsItemSelected()`函数中添加以下代码片段，以调用此对话框：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Obviously this is a very simple example and much more could be said, but it's
    left as an exercise for the reader (as, for example, how to embed a dialog into
    an Activity).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这是一个非常简单的例子，还有很多可以说，但这里留给读者作为一个练习（例如，如何将对话框嵌入到Activity中）。
- en: VERSION_CODES
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VERSION_CODES
- en: Not all the possible problems can be addressed with the Support Library, so
    it is necessary to learn some ways to manage the different availability of features
    between versions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有可能的问题都可以通过支持库来解决，因此有必要学习一些方法来管理不同版本间功能的不同可用性。
- en: One solution could be the creation of different APKs, one for each particular
    version of Android, and uploading each one separately on the Android market; this
    is not particularly smart, since it causes a lot of code duplication and is maintainability
    hell.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案可能是创建不同的APK，每个针对特定的Android版本，然后分别上传到Android市场；这并不是特别明智，因为它会导致大量的代码重复，并且维护起来非常困难。
- en: A better solution is to create branches in the interested code, using an `if`
    statement and checking for `VERSION_CODES`. This is accessible from the `android.os.Build`
    package and it presents an enumeration of all versions of Android. To be able
    to check for the actual version at runtime, the `SDK_INT` field must be used in
    the `android.os.Build.VERSION` package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是在感兴趣的代码中创建分支，使用`if`语句并检查`VERSION_CODES`。这可以从`android.os.Build`包中访问，并且它列出了所有Android版本。为了在运行时检查实际版本，必须在`android.os.Build.VERSION`包中使用`SDK_INT`字段。
- en: 'At the end, we should write some code similar to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该编写一些类似于以下的代码：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A more sophisticated approach would be to use the resource system in order
    to set appropriate Boolean variables with values of interest. Suppose we create
    two `values` files, one with the path `res/values/bools.xml` and with the following
    content:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更复杂的方法是使用资源系统，以设置适当的布尔变量和感兴趣的价值。假设我们创建两个`values`文件，一个路径为`res/values/bools.xml`，内容如下：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The other at the path `res/values-v11/bools.xml` with the following content:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在路径`res/values-v11/bools.xml`中，内容如下：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the code, the `isHoneycomb` variable can be referenced with a simple
    piece of code, as shown as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码内部，可以通过简单的代码引用`isHoneycomb`变量，如下所示：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This can be used directly in the code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以直接在代码中使用。
- en: Loader (Should know)
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Loader（应该知道）
- en: 'In this task, we''ll show the use of the class called `Loader`, a class specifically
    intended to do asynchronous work in the background in order to update the application-related
    data; before the introduction of the `Loader` and related classes, the only way
    to manage data was using Cursor with some specific Activity class''s method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将展示一个名为`Loader`的类的使用，这个类专门用于在后台执行异步工作，以更新与应用程序相关的数据；在引入`Loader`和相关类之前，管理数据的唯一方式是使用游标和一些特定Activity类的
    方法：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The problem with this approach is these calls are on the main application thread
    and can make the application non-responsive and potentially cause the dreaded
    ANRs!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题是，这些调用是在主应用线程上进行的，可能会导致应用程序无响应，甚至可能引起可怕的ANRs（应用程序无响应）！
- en: In the following steps, we will show the code of an application that loads the
    RSS from Packt's website by an HTTP request to a web server and obviously this
    can't be instantaneous; here is where the `Loader` class will be used. All of
    this is done with the Support Library; in this way, the application will be compatible
    with the previous Android platforms.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将展示一个应用程序的代码，该程序通过向网页服务器发送HTTP请求从Packt的网站加载RSS，显然这不能是瞬时的；这里就是使用`Loader`类的地方。所有这些都是通过支持库完成的；这样，应用程序将与以前的Android平台兼容。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s list the steps required for completing the task:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出完成该任务所需的步骤：
- en: 'First of all, include the necessary Support Library classes:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包括必要的支持库类：
- en: '[PRE28]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define a class subclassing the `FragmentActivity` class as usual and define
    the `onCreate()` method that creates the GUI for us:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个通常继承`FragmentActivity`类的类，并定义创建GUI的`onCreate()`方法：
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a Fragment that will display the desired data. It''s important that
    it implements `LoaderManager.LoaderCallbacks`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个将显示所需数据的Fragment。重要的是它实现了`LoaderManager.LoaderCallbacks`：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implement the adapter for its own data in its `onActivityCreated()`, and more
    importantly, call Loader by using the `LoaderManager` class'' method named `initLoader()`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`onActivityCreated()`中实现适配器自己的数据，更重要的是，使用`LoaderManager`类的`initLoader()`方法调用Loader：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, it''s time to implement the methods defined in the `LoaderManager.LoaderCallbacks`
    interface:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现`LoaderManager.LoaderCallbacks`接口中定义的方法了：
- en: '[PRE32]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, define the `Loader` subclass (there are two functions, `doGet()` and
    `getNews()`, that will not be shown here; they simply retrieve the XML and manage
    to transform it into an array of strings). In particular, implement the `loadInBackground()`
    method. The reader must note that here we are extending the `AsyncTaskLoader`
    class that is included in the Support Library:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义`Loader`子类（有两个函数`doGet()`和`getNews()`，这里不显示；它们只是检索XML并将其转换成字符串数组）。特别是，实现`loadInBackground()`方法。读者必须注意，这里我们扩展了支持库中包含的`AsyncTaskLoader`类：
- en: '[PRE33]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add a simple layout file:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个简单的布局文件：
- en: '[PRE34]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding code snippet simply facilitates the synchronization between the
    Fragment class instance to which the Loader belongs and the Loader itself. The
    first time the Fragment queries `LoaderManager` by its `initLoader()` method,
    a new Loader is created using `onCreateLoader()` (if a Loader with the given ID
    already exists, simply return the old instance without calling this method).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段仅简化了Fragment类实例（Loader所属）与Loader本身的同步。Fragment首次通过其`initLoader()`方法查询`LoaderManager`时，将使用`onCreateLoader()`创建一个新的Loader（如果已存在具有给定ID的Loader，只需返回旧实例，而无需调用此方法）。
- en: From now on, Loader follows the state of the Fragment (it will be stopped when
    the Fragment will be stopped) and will call the `onLoadFinished()` method when
    the data is ready. In the preceding example, the list is updated with the array
    containing `news` built on `loadInBackground()`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，Loader会跟随Fragment的状态（当Fragment停止时，它也会停止），并在数据准备好时调用`onLoadFinished()`方法。在上述示例中，列表使用在`loadInBackground()`中构建的包含`news`的数组进行更新。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Now let's talk about some other options, or possibly some pieces of general
    information that are relevant to this task.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈一些其他选项，或者可能是一些与这项任务相关的通用信息。
- en: Low level
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低级别
- en: Under the hood, an Android application is not a unique block of instructions
    executed one after the other, but is composed of multiple pipelines of execution.
    The main concepts here are the process and thread. When an application is started,
    the operating system creates a process (technically a Linux process) and each
    component is associated to this process.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，一个Android应用程序并不是一系列逐一执行的唯一指令块，而是由多个执行管道组成。这里的主要概念是进程和线程。当应用程序启动时，操作系统会创建一个进程（从技术上来说是一个Linux进程），每个组件都与这个进程关联。
- en: Together with the process, a thread of execution named `main` is also created.
    This is a very important thread because it is in charge of dispatching events
    to the appropriate user interface elements and receiving events from them. This
    thread is also called **UI Thread**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程一起，还会创建一个名为`main`的执行线程。这是一个非常重要的线程，因为它负责将事件分派到适当的用户界面元素，并从它们接收事件。这个线程也被称为**UI线程**。
- en: It's important to note that the system does not create a separate thread for
    each element, but instead uses the same UI thread for all of them. This can be
    dangerous for the responsiveness of your application, since if you perform an
    intensive or time expensive operation, this will block the entire UI. All Android
    developers fight against the **ANR** (**Application Not Responding**) message
    that is presented when the UI is not responsive for more than 5 seconds.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，系统不会为每个元素创建一个单独的线程，而是为所有元素使用同一个UI线程。这对于应用程序的响应性来说可能是危险的，因为如果你执行一个密集型或耗时的操作，这将阻塞整个UI。所有Android开发者都在努力避免出现**ANR**（**应用程序无响应**）消息，当UI超过5秒没有响应时会出现该消息。
- en: '![Low level](img/0861_03_01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Low level](img/0861_03_01.jpg)'
- en: 'Following Android''s documentation, there are only two rules to follow to avoid
    the ANR:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Android的文档，为了避免ANR，只需遵循两条规则：
- en: Do not block the UI thread
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要阻塞UI线程
- en: Do not access the Android UI toolkit from outside the UI thread
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程外部访问Android UI工具包。
- en: These two rules can seem simple, but there are some particulars that have to
    be clear. First of all, let me show you the simplest way to create a new thread,
    using the class named `Thread`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则看似简单，但有一些细节必须明确。首先，让我向您展示使用名为`Thread`的类创建新线程的最简单方法。
- en: This class implements the `Runnable` interface defined with a single method
    called `run()`; when an instance of a `Thread` calls its own method `start()`,
    it launches in the background the instructions defined in the `run()` method.
    Nothing new for everyone with experience in Java programming; this is plain Java,
    so it is completely available in all API levels.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了定义了一个名为`run()`的单个方法的`Runnable`接口；当一个`Thread`的实例调用其自身的`start()`方法时，它会在后台启动在`run()`方法中定义的指令。这对于有Java编程经验的每个人来说都不是新事物；这是纯Java，所以在所有API级别中都可以使用。
- en: 'For example, if we want to create a simple task that sleeps for 5 seconds,
    without blocking the UI, we can use the following piece of code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个简单的任务，在不阻塞UI的情况下休眠5秒，我们可以使用以下代码段：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All is clear, but in a general case, we would like to interact with the UI,
    in order to update a progress bar, to show an error, or to change the appearance
    of a UI element; using an example from Android''s documentation, we are tempted
    to write a piece of code where we update an `ImageView` by using a remote PNG:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很清楚，但在一般情况下，我们希望与UI交互，比如更新进度条，显示错误，或者更改UI元素的外观；使用Android文档中的一个例子，我们可能会编写一段代码，通过使用远程PNG来更新一个`ImageView`：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All seems ok, but when running this code, it results in an infamous exception
    appearing in the application''s log:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看似正常，但运行这段代码后，会在应用程序的日志中显示一个臭名昭著的异常：
- en: '*Only the original thread that created a view hierarchy can touch its views.*'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*只有创建视图层次结构的原始线程才能触摸其视图。*'
- en: This is because `setImageBitmap()` is executed in the thread created by us and
    not in the UI thread, violating the second rule expressed above (this is not allowed
    since the UI thread is not thread-safe, that is, it is not assured that concurrent
    access to an element doesn't cause problems).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `setImageBitmap()` 是在我们创建的线程中执行的，而不是在 UI 线程中，这违反了上面表达的第二个规则（这是不允许的，因为 UI
    线程不是线程安全的，也就是说，不能保证并发访问一个元素不会导致问题）。
- en: Before we solve this problem, let me show you the innermost structures introduced
    by the Android system to manage threads—the `Looper` and `Handler` classes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解决这个问题之前，让我先向您展示一下 Android 系统引入的用于管理线程的最内层结构——`Looper` 和 `Handler` 类。
- en: An instance of the first class is simply used to run a message loop in a thread
    that will be handled by an instance of the second class. On the other hand, a
    `Handler` instance manages message instances between threads, but its context
    of execution is the thread where it was initially defined.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类的实例简单地用于在一个线程中运行消息循环，该线程将由第二个类的实例处理。另一方面，`Handler` 实例管理线程之间的消息实例，但其执行上下文是它最初定义的线程。
- en: 'In order to understand, it''s better to write a complex example involving two
    threads communicating with messages. Suppose we have a generic Activity class,
    and inside its `onCreate()` method, we define two threads communicating after
    every 5 seconds:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解，最好举一个复杂的例子，涉及两个通过消息进行通信的线程。假设我们有一个通用的 Activity 类，在它的 `onCreate()` 方法内部，我们定义了两个线程每隔5秒进行一次通信：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is how it appears in Eclipse''s thread panel when the code is running:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码运行时在 Eclipse 的线程面板中显示的样子：
- en: '![Low level](img/0861_03_02.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![低级别](img/0861_03_02.jpg)'
- en: The more fascinating thing is that there is also a possibility to queue the
    `Runnable` classes to be executed in the original thread of the `Handler` class.
    Instead of `sendMessage()`, it is possible to use `mFirstHandler.post()` with
    a `Runnable` class's definition as the argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，还有可能将 `Runnable` 类排队在 `Handler` 类的原始线程中执行。除了 `sendMessage()`，还可以使用 `mFirstHandler.post()`，以
    `Runnable` 类的定义作为参数。
- en: The fundamental point to remember in order to use these classes is to call `Looper.prepare()`
    and `Looper.loop()` in the `run()` method of the thread and the code related to
    the `Handler` class in between—that's all.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类，需要记住的一个基本点是，在线程的 `run()` 方法中调用 `Looper.prepare()` 和 `Looper.loop()`，并在它们之间编写与
    `Handler` 类相关的代码——就是这样。
- en: The only thread that has yet a Looper defined is the UI Thread that makes some
    methods available in order to post the `Runnable` class instance in it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一个已经定义了 Looper 的线程是 UI 线程，它提供了一些方法，以便在其内部发布 `Runnable` 类的实例。
- en: Now, back to the earlier problem, let me explain how to solve it using the `Runnable`
    class; we can post the updating UI code by using a utility method available to
    any `View`, such as the `View.post(Runnable)` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到之前的问题，让我解释一下如何使用 `Runnable` 类来解决它；我们可以通过使用任何 `View` 都可用的实用方法来发布更新 UI 的代码，比如
    `View.post(Runnable)` 方法。
- en: 'Now, we can substitute the line causing the problem with the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用以下代码替换导致问题的那一行：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Looper` and `Handler` are important since they are at the core of the system,
    and more importantly, they have been available since API level 1, making them
    good resources for writing the Android applications.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Looper` 和 `Handler` 非常重要，因为它们是系统的核心，更重要的是，它们从 API 级别 1 开始就可用，这使得它们成为编写 Android
    应用程序的良好资源。'
- en: Another important class, available since API level 3, is `AsyncTask`. If you
    have worked on an application using background threads, it is probable that you
    have used it since it is intended for this purpose; to facilitate the managing
    of the threads, and to avoid all the headache and the error-prone code of the
    `Looper` and `Handler` classes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的类，从 API 级别 3 开始可用，是 `AsyncTask`。如果您在后台线程上工作的应用程序中工作过，那么您可能已经使用过它，因为它是为此目的而设计的；它旨在简化线程的管理，避免
    `Looper` 和 `Handler` 类的所有头痛和易出错的代码。
- en: Its definition is particular. It uses generics; that is, there are some parameters
    indicated with `Params`, `Progress`, and `Result` that identify the signature
    of some functions used internally to manage threads.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它的定义很特别。它使用泛型；也就是说，有一些用 `Params`、`Progress` 和 `Result` 表示的参数，它们标识了一些用于内部管理线程的函数签名。
- en: 'In particular, `AsyncTask` has four methods as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`AsyncTask` 有四个方法如下：
- en: '`void onPreExecute()`: Its role is to set up the task.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onPreExecute()`: 它的角色是设置任务。'
- en: '`protected Result doInBackground(Params...)`: This is the core of the `AsyncTask`
    class and your code has to be written here. Just after `onPreExecute()` is terminated,
    a background thread is created for the execution of this function. It''s important
    to remember not to attempt to update the UI from this function. Use the `onProgressUpdate()`
    to post updates back to the UI.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected Result doInBackground(Params...)`：这是`AsyncTask`类的核心，你的代码必须写在这里。在`onPreExecute()`结束后，会创建一个后台线程来执行这个函数。重要的是要记住，不要尝试从这个函数中更新UI。使用`onProgressUpdate()`将更新发布回UI。'
- en: '`onProgressUpdate(Progress...)`: This is used to publish progresses in some
    way.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onProgressUpdate(Progress...)`：这用于以某种方式发布进度。'
- en: '`onPostExecute(Result)`: This receives the result of the `doInBackground()`
    function.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute(Result)`：这接收`doInBackground()`函数的结果。'
- en: All but the `doInBackground()` function are executed in the UI thread, so it's
    important to remember not to perform time-consuming work in them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`doInBackground()`函数之外，所有函数都在UI线程中执行，因此要记住不要在它们中执行耗时的工作。
- en: 'If we want to replicate the code that downloads a remote PNG and updates an
    `ImageView` with it, we should write something, as shown in the following code
    snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要复制下载远程 PNG 并用其更新`ImageView`的代码，我们应该编写如下所示的代码片段：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For where we will want to call it, we have to insert a line, such as the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要调用它的地方，我们必须插入一行，如下所示：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What you may have noted is that in the initial steps, when we defined our Loader,
    we subclassed a class named `AsyncTaskLoader`. It is simply a Loader with an `AsyncTask`
    inside; the only difference here is that it doesn't get three parameters in its
    definition, but only one since it's not supposed by a Loader to return information
    about the status of an operation (for example, no progress bar is shown).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在初始步骤中，当我们定义我们的加载器时，我们继承了一个名为`AsyncTaskLoader`的类。它只是一个带有`AsyncTask`的加载器；这里的唯一区别是它在定义时不是三个参数，而只有一个，因为加载器不需要返回有关操作状态的信息（例如，不显示进度条）。
- en: 'A final note from the documentation about the serial/parallel execution of
    threads:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的串行/并行执行的最后一点说明：
- en: '*When first introduced, AsyncTasks were executed serially on a single background
    thread. Starting with DONUT, this was changed to a pool of threads allowing multiple
    tasks to operate in parallel. Starting with HONEYCOMB, tasks are executed on a
    single thread to avoid common application errors caused by parallel execution.*'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最初引入时，AsyncTasks 在单个后台线程上串行执行。从 DONUT 开始，这被改为一个线程池，允许多个任务并行操作。从 HONEYCOMB
    开始，为了防止常见的应用程序错误，任务在单个线程上执行。*'
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor,
    Object[]) with THREAD_POOL_EXECUTOR.*'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果你确实想要并行执行，可以使用 executeOnExecutor(java.util.concurrent.Executor, Object[])
    和 THREAD_POOL_EXECUTOR。*'
- en: General structure of a Loader
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载器的一般结构
- en: The initial instructions about writing a Loader have used the simple `AsyncTaskLoader`
    that simplifies a lot for the life of a developer, creating for you the correct
    subdivision between background threads and UI threads.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写加载器的初步说明使用了简单的`AsyncTaskLoader`，这大大简化了开发人员的生活，为你创建了后台线程和UI线程之间的正确划分。
- en: This is important, mainly since it avoids wasting your time with little errors,
    and more importantly, makes the code more modular, avoiding the need of reinventing
    the wheel. However, now we are to reinvent the wheel in order to understand how
    to correctly manage the `Loader` classes with your applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，主要是它避免了浪费时间在小的错误上，更重要的是，使代码更加模块化，避免重新发明轮子。然而，现在我们要重新发明轮子，以了解如何正确管理应用程序中的`Loader`类。
- en: The Loader is intended to be used with dynamic data, where it is important to
    be notified for updates in order to refresh the related element of the UI; in
    order to notify our loader that the underlying data is changed, we'll implement
    a class named `RSSObservable` that controls that the XML (representing the RSS)
    is different from the previous version. It's important to note that this is a
    proof of concept and is not intended to be used in the real world. Both the Loader
    and the Observable classes download the RSS, causing the drain of the battery
    (and in some case, you will be billed for the bandwidth).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Loader旨在与动态数据一起使用，其中重要的是要通知更新以便刷新UI的相关元素；为了通知我们的Loader底层数据已更改，我们将实现一个名为`RSSObservable`的类，该类控制XML（表示RSS）与上一个版本不同。需要注意的是，这是一个概念验证，并不打算在实际应用中使用。Loader和Observable类都会下载RSS，这会导致电池耗电（在某些情况下，你将为带宽付费）。
- en: Once you read this code, try to compare it with the original implementation
    of the `AsyncTaskLoader` class that you can find in Android's source code in the
    file `frameworks/base/core/java/android/content/AsyncTaskLoader.java`. Obviously,
    we are not going to implement all the things that you can find there.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 读完这段代码后，尝试将其与`AsyncTaskLoader`类的原始实现进行比较，你可以在Android的源代码文件`frameworks/base/core/java/android/content/AsyncTaskLoader.java`中找到。显然，我们不需要实现那里能找到的所有内容。
- en: 'So let''s implement our custom Loader:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们来实现我们的自定义Loader：
- en: 'Import the required classes:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的类：
- en: '[PRE41]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define our custom loader, extending the `Loader` class and indicating the implementation
    of the `Observer` interface:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的自定义Loader，扩展`Loader`类并指出实现了`Observer`接口：
- en: '[PRE42]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the internal variables that will reference the `Task` and `Observable`
    instances:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义内部变量，它们将引用`Task`和`Observable`实例：
- en: '[PRE43]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Define the constructor where we initialize all the things needed for the class
    to work correctly.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中定义所有需要初始化的内容，以确保类的正确运行。
- en: '[PRE44]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Define a customized `AsyncTask` that returns the data of your choice; in its
    `doInBackground()` method, simply do the same as the previous example. `onPostExecute()`
    warns `LoaderManager` of the concluded task.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个自定义的`AsyncTask`，返回你选择的数据；在其`doInBackground()`方法中，只需像前一个示例中那样操作。`onPostExecute()`通知`LoaderManager`任务已完成。
- en: '[PRE45]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now implement the behavior for the main actions that can be performed on a
    Loader:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现可以在Loader上执行的主要动作的行为：
- en: '[PRE46]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `deliverResult()` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`deliverResult()`方法：
- en: '[PRE47]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Write the callback of the `Observer` interface:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`Observer`接口的回调：
- en: '[PRE48]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write a class representing the `Observable` interface, where we implement the
    code that watches and notifies us of data changes:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个表示`Observable`接口的类，在这里我们实现监控数据变化并通知我们的代码：
- en: '[PRE49]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The more cumbersome part is understanding the underlying flow of the Loader.
    First of all, there are three states in which it can exist. Those are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的一部分是理解Loader的底层流程。首先，它可能存在三种状态，如下所示：
- en: '`STARTED`: Loaders execute their loads and notify the Activity class using
    `onLoadFinished()`.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTED`：Loader执行加载操作，并通过`onLoadFinished()`通知Activity类。'
- en: '`STOPPED`: Loaders continue to monitor for changes, but must not deliver results.
    This state is induced by calling `stopLoading()` from `LoaderManager` when the
    related Activity/Fragment class is being stopped.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPED`：Loader继续监听变化，但不可以交付结果。当相关的Activity/Fragment类停止时，通过`LoaderManager`调用`stopLoading()`来引发此状态。'
- en: '`RESET`: Loaders must not monitor changes, deliver results, and so on. The
    data already collected should be garbage collected.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESET`：Loader不得监听变化、交付结果等。已收集的数据应该被垃圾回收。'
- en: Each of these states can be reached from the others.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态中的每一个都可以从其他状态转换而来。
- en: Since all happens asynchronously, it's possible that a notification of data
    update can reach the `Loader` instance when the state is different from `STARTED`;
    this explains the various checks present in the code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有操作都是异步的，数据更新的通知可能会在状态不是`STARTED`时到达`Loader`实例；这解释了代码中存在的各种检查。
- en: One thing introduced in the preceding code snippet, not mentioned in the `AsyncTaskLoader`
    example, is the Observer/Observable design pattern. The first is defined as an
    interface and the second as a class, both in the `java.util` package (and both
    have been available from API level 1, so do not cause compatibility issues). The
    observer receives notification of updates by the `update()` method, whereas the
    observable registers some observers (by the `addObserver()` method) to be notified
    (by the `notifyObservers()` method) when a change occurs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中引入了一件事，在`AsyncTaskLoader`示例中没有提到，那就是观察者/可观察对象设计模式。第一个被定义为一个接口，第二个作为一个类，两者都在`java.util`包中（从API级别1开始就可用，因此不会引起兼容性问题）。观察者通过`update()`方法接收更新通知，而可观察对象通过`addObserver()`方法注册一些观察者，当发生变化时通过`notifyObservers()`方法通知它们。
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A last note**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后一点说明**'
- en: '`cancelLoad()` is not present in the `Loader` class version of the Compatibility
    Library.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancelLoad()`在兼容性库的`Loader`类版本中不存在。'
- en: ActionBar (Should know)
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActionBar（应该知道）
- en: One thing not addressed by the compatibility package is ActionBar, a new UI
    pattern introduced from Google in the Honeycomb platform. Since this is a very
    important element for integration with the Android ecosystem, some alternatives
    are born, the first one from Google itself, as a simple code sample named ActionBar
    Compatibility that you can find in the `sample/` directory of the Android SDK.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性包没有解决的一个问题是ActionBar，这是从Honeycomb平台开始引入的一种新的UI模式。由于这是与Android生态系统集成的一个非常重要的元素，因此出现了一些替代方案，第一个来自Google本身，是一个名为ActionBar
    Compatibility的简单代码示例，你可以在Android SDK的`sample/`目录中找到。
- en: We will follow a different approach, using a famous open source project, `ActionBarSherlock`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用一种不同的方法，使用一个著名的开源项目，`ActionBarSherlock`。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The code for this library is not available from SDK, so we need to download
    it from its website ([http://actionbarsherlock.com/](http://actionbarsherlock.com/)).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的代码在SDK中不可用，因此我们需要从其网站（[http://actionbarsherlock.com/](http://actionbarsherlock.com/)）下载。
- en: You can also download it from the `github` repository of the author; once the
    archive has been downloaded, you can extract it to a directory of your choice.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从作者的`github`仓库下载；一旦下载了归档文件，你可以将其解压到你选择的目录中。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s include `ActionBarSherlock` as a library in Eclipse and then create
    a simple project using it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Eclipse中将`ActionBarSherlock`作为一个库包含进来，然后创建一个使用它的简单项目：
- en: Open Eclipse and create a new project to import the source files that you can
    find in the `libraries/` directory of the `ActionBarSherlock` source code. This
    can be done by selecting **File** | **New** | **Other...**.![How to do it...](img/0861_04_01.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse并创建一个新项目，导入你可以在`ActionBarSherlock`源代码的`libraries/`目录中找到的源文件。这可以通过选择**文件**
    | **新建** | **其他...**来完成。![如何操作...](img/0861_04_01.jpg)
- en: Open the project where you want to use the library (otherwise create a new one).
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你要使用库的项目（否则创建一个新的）。
- en: Tell Eclipse to use the `ActionBarSherlock` library by selecting the project
    from the Package explorer and then selecting **Project** | **Property** from the
    main menu. A dialog will show up. Now add the library from the **Android** section:![How
    to do it...](img/0861_04_02.jpg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从包浏览器中选择项目，然后从主菜单中选择**项目** | **属性**，告诉Eclipse使用`ActionBarSherlock`库。将弹出一个对话框。现在从**Android**部分添加库：![如何操作...](img/0861_04_02.jpg)
- en: 'In the file containing the main Activity of your project, import the required
    classes:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含项目主Activity的文件中，导入所需的类：
- en: '[PRE50]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the `Activity` class where the ActionBar will be used, extending
    `SherlockFragmentActivity`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Activity`类，这里将使用ActionBar，继承自`SherlockFragmentActivity`：
- en: '[PRE51]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `onCreate()` method of the Activity, configure the ActionBar:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Activity的`onCreate()`方法中，配置ActionBar：
- en: '[PRE52]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the required the following code snippet in order to create the menu options:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下所需的代码片段以创建菜单选项：
- en: '[PRE53]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement `onOptionsItemSelected()` of the `Activity` class with the desired
    behavior (here we have shown only a simple toast notification):'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所需的逻辑（这里我们只展示了一个简单的吐司通知）实现`Activity`类的`onOptionsItemSelected()`：
- en: '[PRE54]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define which menu options you want in the related XML file located at `res/menu/main.xml`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位于`res/menu/main.xml`的相关XML文件中定义你想要的菜单选项：
- en: '[PRE55]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![How to do it...](img/0861_04_03.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/0861_04_03.jpg)'
- en: How it works...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using this external library, we permit our application to have an implementation
    of the ActionBar UI pattern. `ActionBarSherlock` re-implements most of the core
    classes that you can find in the normal Android framework. One simple rule to
    remember is to prepend the word Sherlock to any of the interested classes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个外部库，我们允许应用程序实现ActionBar UI模式。`ActionBarSherlock`重新实现了在普通Android框架中可以找到的大部分核心类。要记住的一个简单规则是将单词Sherlock添加到任何感兴趣类的名称前。
- en: 'Since it can be tricky remembering which classes belong to this library, let
    me list these classes:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记住哪些类属于这个库可能会有些棘手，让我列出这些类：
- en: c`om.actionbarsherlock.ActionBarSherlock`
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.ActionBarSherlock`'
- en: '`com.actionbarsherlock.app.ActionBar`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.ActionBar`'
- en: '`com.actionbarsherlock.app.SherlockActivity`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockActivity`'
- en: '`com.actionbarsherlock.app.SherlockDialogFragment`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockDialogFragment`'
- en: '`com.actionbarsherlock.app.SherlockExpandableListActivity`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockExpandableListActivity`'
- en: '`com.actionbarsherlock.app.SherlockFragment`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockFragment`'
- en: '`com.actionbarsherlock.app.SherlockFragmentActivity`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockFragmentActivity`'
- en: '`com.actionbarsherlock.app.SherlockListActivity`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockListActivity`'
- en: '`com.actionbarsherlock.app.SherlockListFragment`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockListFragment`'
- en: '`com.actionbarsherlock.app.SherlockPreferenceActivity`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.app.SherlockPreferenceActivity`'
- en: '`com.actionbarsherlock.view.ActionMode`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.ActionMode`'
- en: '`com.actionbarsherlock.view.ActionProvider`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.ActionProvider`'
- en: '`com.actionbarsherlock.view.CollapsibleActionView`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.CollapsibleActionView`'
- en: '`com.actionbarsherlock.view.Menu`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.Menu`'
- en: '`com.actionbarsherlock.view.MenuInflater`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.MenuInflater`'
- en: '`com.actionbarsherlock.view.MenuItem`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.MenuItem`'
- en: '`com.actionbarsherlock.view.SubMenu`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.SubMenu`'
- en: '`com.actionbarsherlock.view.Window`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.view.Window`'
- en: '`com.actionbarsherlock.widget.ActivityChooserModel`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.widget.ActivityChooserModel`'
- en: '`com.actionbarsherlock.widget.ActivityChooserView`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.widget.ActivityChooserView`'
- en: '`com.actionbarsherlock.widget.ShareActionProvider`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.actionbarsherlock.widget.ShareActionProvider`'
- en: If some problem occurs, remember to double-check whether you have used the correct
    class and not imported the one from the Support Library or the original framework.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，请记得再次检查您是否使用了正确的类，而不是从支持库或原始框架中导入。
- en: This library tries hard to maintain an API compatibility with the original ActionBar.
    The only difference to remember is to substitute `getActionBar()` with `getSupportActionBar()`
    and to use `getSupportMenuInflater()` instead of `getMenuInflater()`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库努力与原始的ActionBar保持API兼容性。唯一需要记住的不同之处是将`getActionBar()`替换为`getSupportActionBar()`，并使用`getSupportMenuInflater()`代替`getMenuInflater()`。
- en: '`ActionBarSherlock` is built on top of the Support Library, so in order to
    obtain `FragmentManager`, you must use the `getSupportFragmentManager()` function.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBarSherlock`是建立在支持库之上的，因此为了获取`FragmentManager`，您必须使用`getSupportFragmentManager()`函数。'
- en: There's more...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let's talk about some other options, or possibly some pieces of general
    information that are relevant to this task.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈其他一些选项，或者可能是一些与这项任务相关的通用信息。
- en: The ActionBar is not only a *bar*, a visual element, but it's also the gate
    to a bunch of new UI functionalities; in the following sections, we'll show some
    of these functionalities and how to use it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ActionBar不仅仅是一个*栏*，一个视觉元素，它也是通往许多新的UI功能的大门；在以下部分，我们将展示其中一些功能以及如何使用它们。
- en: Home button
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主页按钮
- en: From the start, the Android platform has made available a **Back** button with
    which one can step back during the navigation between activity and applications.
    To allow a more structured navigation, the **Up** button was introduced to permit
    a user to create a new task from an activity that does not belong to the original
    task that created it (it's not completely true, since if the original application
    is the same, no tasks are created).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Android平台就提供了一个**返回**按钮，通过它可以实现在活动与应用程序之间的导航后退。为了允许更结构化的导航，引入了**向上**按钮，允许用户从不属于创建它的原始任务的活动中创建一个新任务（这并不完全正确，因为如果原始应用程序是相同的，则不会创建任务）。
- en: For example, we start a news reader and then we choose a specific news item
    that we want to share with our friends by sending it via e-mail; in order to do
    so, we launch an *Email* application that is started in the same task of the news
    reader. If the *Email* application has an **Up** button, clicking on it will start
    a new task with the *home* Activity of the *Email* application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们启动一个新闻阅读器，然后选择一个特定的新闻条目，通过电子邮件将其发送给我们的朋友进行分享；为此，我们会启动一个与新闻阅读器同一任务中的*电子邮件*应用。如果*电子邮件*应用有一个**向上**按钮，点击它将会以*电子邮件*应用的*主页*
    Activity 开始一个新任务。
- en: What we obtain with the **Up** button is a hierarchical navigation inside the
    active application. Obviously, the **Up** button should not be present in the
    main Activity because there is no upward navigation there.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**向上**按钮，我们在活动应用内获得分层导航。显然，在主 Activity 中不应该出现**向上**按钮，因为那里没有向上的导航。
- en: 'In order to enable the **Up** button in our code, simply activate it by using
    the following code line:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的代码中启用**向上**按钮，只需使用以下代码行激活它：
- en: '[PRE56]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can now write the code that will handle the click on the icon on the left-hand
    side of the ActionBar. This code is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写处理 ActionBar 左侧图标点击的代码。代码如下：
- en: '[PRE57]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember only that the **Up** button is represented on the ActionBar with a
    widget having `android.R.id.home` as an identifier.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**向上**按钮在 ActionBar 上用标识符为 `android.R.id.home` 的控件表示。
- en: Action view
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作视图
- en: 'Another UI pattern from the ActionBar is the **action view**. It is possible
    to associate a particular widget to an action item. A widget here is, a visual
    element that can be expanded to occupy all the available space of the ActionBar;
    in the following code, we will implement a fake search entry—initially on the
    ActionBar there is only the **Search** button:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ActionBar 的另一种 UI 模式是**操作视图**。可以将一个特定的控件关联到一个操作项上。这里的控件是一个可以展开以占据 ActionBar
    所有可用空间的视觉元素；在下面的代码中，我们将实现一个假的搜索条目——最初在 ActionBar 上只有**搜索**按钮：
- en: '![Action view](img/0861_04_04.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![操作视图](img/0861_04_04.jpg)'
- en: 'After selecting this element, it will appear expanded, as shown in the following
    screenshot:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此元素后，它将展开显示，如下面的屏幕截图所示：
- en: '![Action view](img/0861_04_05.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![操作视图](img/0861_04_05.jpg)'
- en: 'Import the required classes:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的类：
- en: '[PRE58]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the method of the `Activity` class used to create the menu:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Activity` 类用于创建菜单的方法：
- en: '[PRE59]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the XML file for the menu with an action view:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义带有操作视图的菜单的 XML 文件：
- en: '[PRE60]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define the layout for the action view into a file placed in `res/layout/action_view.xml`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout/action_view.xml` 文件中定义操作视图的布局：
- en: '[PRE61]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example mimics the example from the Android documentation where the `SearchView`
    class is used instead. This class is not available with `ActionBarSherlock`, but
    is planned to be included (maybe) in future releases.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本例模仿了 Android 文档中的示例，其中使用了 `SearchView` 类。这个类在 `ActionBarSherlock` 中不可用，但计划在将来的版本中可能包含。
- en: For further information about this issue, please follow the discussion on the
    github project page at [https://github.com/JakeWharton/ActionBarSherlock/issues/70](https://github.com/JakeWharton/ActionBarSherlock/issues/70).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此问题的更多信息，请关注 github 项目页面上的讨论：[https://github.com/JakeWharton/ActionBarSherlock/issues/70](https://github.com/JakeWharton/ActionBarSherlock/issues/70)。
- en: ShareActionProvider
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ShareActionProvider
- en: An extension to the concept of action view is the **action provider**—a widget
    that not only controls its appearance, but also extends its controls. An action
    provider available with the Android framework is `ShareActionProvider` that allows
    us to easily share the contents showing a menu with some share target in it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对操作视图概念的扩展是**操作提供者**——一个不仅控制其外观，还扩展其控制的控件。Android 框架中可用的一个操作提供者是 `ShareActionProvider`，它允许我们通过显示带有一些分享目标的菜单轻松分享内容。
- en: 'Since we are interested in maintaining backward compatibility using `ActionBarSherlock`,
    here are the steps necessary to implement this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要使用 `ActionBarSherlock` 保持向后兼容性，以下是实现此功能所需的步骤：
- en: 'Import the required classes:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的类：
- en: '[PRE62]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Attach an `Intent` to the action provider:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Intent` 附加到操作提供者：
- en: '[PRE63]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define the XML file:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 XML 文件：
- en: '[PRE64]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the following screenshot, you can see how the menu item appears:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，你可以看到菜单项的外观：
- en: '![ShareActionProvider](img/0861_04_06.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![分享操作提供者](img/0861_04_06.jpg)'
- en: Contextual ActionBar
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文操作栏
- en: The necessity to make simple and quick actions on specific elements such as
    list items (for example, removing a contact) or copying some selected text into
    the clipboard, makes the employ of the contextual action bar useful. The appearance
    of the bar changes so that it can show the specific menu item for the action desired.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对特定元素（如列表项）进行简单快速操作的需求（例如，删除一个联系人）或将选定的文本复制到剪贴板，使得使用上下文操作栏变得很有用。操作栏的外观会发生变化，以便显示所需操作的特定菜单项。
- en: 'Now, let''s see how to add a contextual action bar with two action items to
    your application:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何向你的应用程序添加带有两个操作项的上下文操作栏：
- en: 'Import all the necessary libraries:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必要的库：
- en: '[PRE65]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement the `Callback` interface of the `ActionMode` class; it will manage
    the lifecycle of the contextual menu:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ActionMode`类的`Callback`接口；它将管理上下文菜单的生命周期：
- en: '[PRE66]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Attach a listener to the desired element that will activate the action mode
    (in this example, we attach it to the `click` event on a list item):'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所需的元素上附加一个监听器，该监听器将激活操作模式（在这个例子中，我们将它附加到列表项的`click`事件上）：
- en: '[PRE67]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In an XML file, define the contextual menu layout such as a normal menu:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XML文件中，像普通菜单一样定义上下文菜单布局：
- en: '[PRE68]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following screenshot shows how the contextual menu will appear:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了上下文菜单将如何出现：
- en: '![Contextual ActionBar](img/0861_04_07.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![上下文ActionBar](img/0861_04_07.jpg)'
- en: Remember that the **OK** button (the button at the very left of the bar) simply
    dismisses the contextual action bar and the system adds it for you.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**确定**按钮（栏中最左边的按钮）只是关闭上下文操作栏，系统会自动为你添加它。
- en: The obvious extension of this mechanism is the possibility to select multiple
    elements and to act on it. This exists and it possibly started from Honeycomb,
    using the `MultiChoiceModeListener` interface that belongs to the `AbsListView`
    class. The only problem is that it is not available with `ActionBarSherlock`,
    so as hinted from the original Android documentation, it is better to fall back
    to a floating contextual menu.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制的明显扩展是可以选择多个元素并对它们进行操作。这个功能是存在的，可能从Honeycomb开始，使用`AbsListView`类中的`MultiChoiceModeListener`接口。唯一的问题是它与`ActionBarSherlock`不兼容，因此如原始Android文档所暗示的，最好是退回到浮动上下文菜单。
- en: ViewPagerIndicator
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewPagerIndicator
- en: Let's explain how to create a more interesting visual layout for your application,
    for example, one UI pattern that we see all the time is the "swipey-tabs" one,
    used in the Android Market.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释如何为你的应用程序创建一个更有趣的视觉布局，例如，我们经常看到的“滑动标签”UI模式，在Android Market中使用。
- en: This UI pattern allows the user to switch between sections of the application,
    simply swiping left/right and having the title on the tab following the swipe
    motion (for more technical information about this design, I advise you to read
    the post from an Android Market designer at [http://www.pushing-pixels.org/2011/08/11/android-tips-and-tricks-swipey-tabs.html](http://www.pushing-pixels.org/2011/08/11/android-tips-and-tricks-swipey-tabs.html)).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这种UI模式允许用户通过简单的左右滑动，并在标签跟随滑动动作时显示标题，来在应用程序的各个部分之间切换（关于这种设计的更多技术信息，我建议你阅读一位Android
    Market设计师在[http://www.pushing-pixels.org/2011/08/11/android-tips-and-tricks-swipey-tabs.html](http://www.pushing-pixels.org/2011/08/11/android-tips-and-tricks-swipey-tabs.html)的帖子）。
- en: In order to do this, we need to download another library from the web page of
    its project, located at [http://viewpagerindicator.com/](http://viewpagerindicator.com/).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要从该项目的网页[http://viewpagerindicator.com/](http://viewpagerindicator.com/)下载另一个库。
- en: The steps required to add this library to our project are the same as those
    shown at the start of this section. Only keep in mind that the path to the library
    is where you have extracted it.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 将此库添加到我们项目的步骤与本章开始时显示的步骤相同。只需记住，库的路径是你提取它的位置。
- en: 'Now, we are ready to add `ViewPageIndicator` to your application:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将`ViewPageIndicator`添加到你的应用程序中：
- en: 'Import the correct classes:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入正确的类：
- en: '[PRE69]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create an Activity class subclassing `SherlockFragmentActivity` and implementing
    the `TabListener` interface:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自`SherlockFragmentActivity`并实现`TabListener`接口的Activity类：
- en: '[PRE70]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the `onCreate()` method where we set the layout and configure the
    ActionBar; since we are creating a tab-driven application, we have to set `NAVIGATION_MODE_TABS`
    as the navigation mode:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中实现设置布局和配置ActionBar；由于我们正在创建一个以标签驱动的应用程序，因此需要将导航模式设置为`NAVIGATION_MODE_TABS`：
- en: '[PRE71]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create a subclass of the `FragmentPageAdapter` class that will bind each tab
    to a specific fragment (here we have used a unique fragment class called `DummyFragment`,
    not implemented, that simply shows a simple text):'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `FragmentPageAdapter` 类的子类，它将每个标签绑定到一个特定的片段（这里我们使用了一个名为 `DummyFragment`
    的独特片段类，未实现，仅显示简单文本）：
- en: '[PRE72]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `TabListener` interface in the Activity class that reacts to
    the events that will happen on tabs:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Activity 类中实现 `TabListener` 接口，以响应将在标签上发生的事件：
- en: '[PRE73]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define a layout with `TitlePageIndicator` (double-check that the fully qualified
    name used as the tag is correctly entered):'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个使用 `TitlePageIndicator` 的布局（仔细检查用作标签的完全限定名称是否正确输入）：
- en: '[PRE74]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'What we obtain is an application where the various Fragments served from the
    `ViewPager` class are inserted, one for each tab, and the `TitlePagerIndicator`
    class furnishes us with a visual effect when the transition between tabs happens.
    The following screenshot shows how the tab part appears in our application (obviously,
    it is not possible to show the animation on paper):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的应用程序是将 `ViewPager` 类提供的不同片段插入到每个标签中，每个标签一个，而 `TitlePagerIndicator` 类在标签间切换时为我们提供了一个视觉特效。以下屏幕截图显示了标签部分在我们的应用程序中的外观（显然，无法在纸上展示动画）：
- en: '![ViewPagerIndicator](img/0861_04_08.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![ViewPager指示器](img/0861_04_08.jpg)'
