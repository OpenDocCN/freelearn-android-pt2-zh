- en: Chapter 9. Web Services with Push Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。带推送通知的 web 服务
- en: Modern mobile applications are defined by their network connectivity. A mobile
    app that does not interact with a web server is both a rare find and potentially
    a boring application. In this book, we'll use the **Windows Azure** cloud platform
    to implement a server-side backend for our XamSnap application. We'll use a feature
    called **Azure Functions**, which is an excellent fit as a simple backend for
    our application and can send push notifications via **Azure Notification Hubs**.
    Once we are done with this chapter, our XamSnap sample application will be much
    closer to being a real application and will allow its users to interact with one
    another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动应用程序以其网络连接性为特征。一个不与 web 服务器交互的移动应用既难得一见，也可能是一个无聊的应用。在本书中，我们将使用**Windows
    Azure**云平台为我们的 XamSnap 应用实现服务器端后端。我们将使用一个名为**Azure Functions**的功能，它非常适合作为我们应用程序的简单后端，并且可以通过**Azure
    Notification Hubs**发送推送通知。完成这一章节后，我们的 XamSnap 示例应用程序将更接近一个真正的应用程序，并允许其用户相互交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节，我们将涵盖以下主题：
- en: The services offered by Windows Azure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Azure 提供的服务
- en: Setting up your Azure account
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的 Azure 账户
- en: Azure Functions as a backend for XamSnap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 作为 XamSnap 的后端
- en: Implementing a real web service for XamSnap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 XamSnap 实现真实的 web 服务
- en: Writing client-side code for calling Azure Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写客户端代码以调用 Azure Functions
- en: Using the Apple Push Notification service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用苹果推送通知服务
- en: Sending notifications with Google Cloud Messaging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Cloud Messaging 发送通知
- en: Learning Windows Azure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Windows Azure
- en: Windows Azure is an excellent cloud platform released by Microsoft in 2010\.
    Azure provides both **Infrastructure as a Service** (**IaaS**) and **Platform
    as a Service** (**PaaS**) for building modern web applications and services. This
    means that it provides you the access directly to virtual machines within which
    you can deploy any operating system or software of your choice. This is known
    as IaaS. Azure also provides multiple platforms for building applications, such
    as **Azure Web Apps** or **SQL Azure**. These platforms are known as PaaS, since
    you deploy your software at a high level and do not have to deal directly with
    virtual machines or manage software upgrades.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Azure 是微软在 2010 年推出的卓越云平台。Azure 提供了**基础设施即服务**（**IaaS**）和**平台即服务**（**PaaS**），用于构建现代的
    web 应用程序和服务。这意味着它可以直接为你提供虚拟机的访问，你可以在其中部署任何你选择的操作系统或软件。这称为 IaaS。Azure 还提供了多个用于构建应用程序的平台，如**Azure
    Web Apps**或**SQL Azure**。这些平台被称为 PaaS，因为你可以在高层次部署软件，并且不需要直接处理虚拟机或管理软件升级。
- en: 'Let''s go over the following more common services provided by Windows Azure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 Windows Azure 提供的以下更常见服务：
- en: '**Virtual Machines**: Azure provides you the access to virtual machines of
    all sizes. You can install practically any operating system of your choice; there
    are many premade distributions to choose from within Azure''s gallery.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机**：Azure 提供各种规模的虚拟机访问。你可以安装几乎任何你选择的操作系统；Azure 图库中有许多预制的发行版可供选择。'
- en: '**Web Apps**: You can deploy any type of website that will run in Microsoft
    **IIS**, from ASP .NET sites to **PHP** or **Node.js**.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Apps**：你可以部署任何类型的网站，这些网站将在 Microsoft **IIS** 中运行，从 ASP .NET 站点到 **PHP**
    或 **Node.js**。'
- en: '**SQL Azure**: This is a cloud-based version of Microsoft SQL Server, which
    is a fully featured **RDMS** (**Regional Database Management System**) for storing
    data.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Azure**：这是基于云的微软 SQL Server 版本，它是一个功能完整的**区域数据库管理系统**（**RDMS**）用于存储数据。'
- en: '**Mobile Apps**: This is a simple platform for building web services for mobile
    apps. It uses **SQL Azure** for backend storage and a simple JavaScript scripting
    system based on Node.js for adding business logic.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动应用**：这是一个用于构建移动应用 web 服务的简单平台。它使用 **SQL Azure** 作为后端存储，并基于 Node.js 的简单
    JavaScript 脚本系统来添加业务逻辑。'
- en: '**Azure Functions**: The first product of Windows Azure supporting the new
    "serverless" architecture that is becoming today''s new buzzword. You can develop
    simple APIs, background jobs, webhooks, and so on in a variety of languages directly
    in the web browser. Azure will automatically scale your function based on incoming
    requests.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Functions**：Windows Azure 推出的首款支持新兴“无服务器”架构的产品，这成为了当今的热门词汇。你可以在浏览器中直接使用多种语言开发简单的
    API、后台作业、web 钩子等。Azure 会根据传入的请求自动扩展你的函数。'
- en: '**Storage**: Azure provides **blob storage**, a method for storing binary files
    and **table storage**, which is a **NoSQL** solution for persisting data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：Azure 提供了**块存储**，用于存储二进制文件，以及**表存储**，这是一种 **NoSQL** 数据持久化解决方案。'
- en: '**Service bus**: This is a cloud-based solution for creating queues to facilitate
    communication between other cloud services. It also includes notification hubs
    as a simple way to provide push notifications to mobile apps.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务总线**（Service bus）：这是一个基于云的解决方案，用于创建队列，以便与其他云服务之间的通信提供便利。它还包括通知中心，作为向移动应用提供推送通知的简单方式。'
- en: '**Notification Hubs**: A simple way to send push notifications to different
    platforms such as Android, iOS, and Windows devices.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知中心**（Notification Hubs）：这是一种向 Android、iOS 和 Windows 设备等不同平台发送推送通知的简单方式。'
- en: '**DocumentDB**: A fully featured NoSQL data storage comparable to other NoSQL
    databases such as **MongoDB**.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DocumentDB**：一个功能完备的 NoSQL 数据存储，与其他 NoSQL 数据库（如**MongoDB**）相当。'
- en: '**HDInsight**: A version of Apache Hadoop running in Windows Azure for managing
    extremely large data sets, which also could be called big data.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDInsight**：在 Windows Azure 中运行的 Apache Hadoop 版本，用于管理极大数据集，这也被称为大数据。'
- en: Apart from these services, there are many more and new ones actively being developed.
    We will use Azure Functions, and also leverage Azure Storage Tables, to build
    our web service for XamSnap. You can visit [http://windowsazure.com](http://windowsazure.com)
    for a full rundown of pricing and services offered.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些服务外，还有许多正在积极开发的新服务。我们将使用 Azure Functions，并利用 Azure Storage Tables，为 XamSnap
    构建我们的 Web 服务。你可以访问[http://windowsazure.com](http://windowsazure.com)了解提供的完整价格和服务列表。
- en: In this book, we chose to demonstrate a solution using Windows Azure as a web
    service backend for XamSnap, since it is complementary with C#, Visual Studio,
    and other Microsoft tools. However, there are many more choices out there besides
    Azure, which you may want to look at. Choosing Xamarin does not limit the types
    of web service your applications can interact with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们选择使用 Windows Azure 作为 XamSnap 的 Web 服务后端进行演示，因为它与 C#、Visual Studio 和其他
    Microsoft 工具相辅相成。但是，除了 Azure 之外，还有许多其他选择，你可能想要看看。选择 Xamarin 并不会限制你的应用程序可以交互的 Web
    服务类型。
- en: 'Here are a few more common ones:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些更常见的服务：
- en: '**Firebase**: This service by Google provides a product similar to that of
    Azure Mobile Apps, complete with data storage and push notifications. You can
    get more information at [https://firebase.google.com](https://firebase.google.com).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firebase**：谷歌提供的这项服务与 Azure Mobile Apps 类似，包括数据存储和推送通知等功能。你可以访问[https://firebase.google.com](https://firebase.google.com)了解更多信息。'
- en: '**Urban airship**: This service provides push notifications for mobile apps
    across multiple platforms. You can get more information at [http://urbanairship.com](http://urbanairship.com).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Urban airship**：这项服务为跨多个平台的移动应用提供推送通知。你可以访问[http://urbanairship.com](http://urbanairship.com)了解更多信息。'
- en: '**Amazon Web Services**: This service is a complete cloud solution that is
    equivalent to Windows Azure. It has everything you need to deploy applications
    in the cloud with total virtual machine support. There is also a feature called
    **AWS Mobile Hub**, tailored specifically for mobile development. You can get
    more information at [http://aws.amazon.com](http://aws.amazon.com).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务**（Amazon Web Services）：这项服务是一个完整的云解决方案，与 Windows Azure 相当。它拥有部署云应用所需的一切，包括完全的虚拟机支持。此外，还有一个名为
    **AWS Mobile Hub** 的功能，专门针对移动开发而定制。你可以访问[http://aws.amazon.com](http://aws.amazon.com)获取更多信息。'
- en: Additionally, you can develop your own web services with on-premises web servers
    or inexpensive hosting services using the languages and technologies of your choice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用本地 Web 服务器或低成本的托管服务，用你选择的语言和技术开发自己的 Web 服务。
- en: Setting up your Azure account
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的 Azure 账户
- en: To start developing with Windows Azure, you can subscribe to a free one-month
    trial along with $200 in free Azure credit. To go along with this, many of its
    services have free tiers that give you lower performance versions. So, if your
    trial expires, you can continue your development at little or no cost, depending
    on the services you are using.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Windows Azure 进行开发，你可以订阅一个月的免费试用，并获得 200 美元的 Azure 信用。与此相伴的是，它的许多服务都有免费层级，为你提供性能较低的版本。因此，如果你的试用期结束，你可以根据所使用的服务，继续开发，费用很少或没有。
- en: 'Begin by navigating to [http://azure.microsoft.com/en-us/free](http://azure.microsoft.com/en-us/free)
    and then carry out the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到[http://azure.microsoft.com/en-us/free](http://azure.microsoft.com/en-us/free)，然后执行以下步骤：
- en: Click on the **Start Free** link.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **开始免费** 链接。
- en: Sign in with a Windows Live ID.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Windows Live ID 登录。
- en: For security purposes, verify your account via your phone or a text message.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于安全考虑，通过你的手机或短信验证你的账户。
- en: Enter the payment information. This is only used if you exceed your spending
    limits. You won't accidentally spend beyond budget by developing your app-it is
    not common to accidentally spend money until real users are interacting with your
    services.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入支付信息。这只在你超出消费限额时使用。在开发你的应用程序时，你不会意外超出预算——通常在真实用户开始与服务互动之前不会意外消费。
- en: Check **I agree** to the policies and click on **Sign Up**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**我同意**政策，并点击**注册**。
- en: Review the final setting and click on **Submit**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最终设置并点击**提交**。
- en: If all the required information is entered correctly, you will now finally have
    access to your Azure account. You can click the **PORTAL** link in the top-right
    corner of the page to access your account. In the future, you can manage your
    Azure services at [http://portal.azure.com](http://portal.azure.com).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有必需的信息都正确输入，你现在终于可以访问你的 Azure 账户了。你可以点击页面右上角的**门户**链接来访问你的账户。将来，你可以在 [http://portal.azure.com](http://portal.azure.com)
    管理你的 Azure 服务。
- en: 'The Azure Portal uses a set of panels named blades, to quickly navigate and
    drill deeper into more detailed information, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 门户使用一组名为 blades 的面板，以便快速导航并深入了解更详细的信息，如下面的屏幕截图所示：
- en: '![Setting up your Azure account](img/image00250.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Azure 账户](img/image00250.jpeg)'
- en: This concludes your sign up for Windows Azure. It is pretty simple compared
    to the Apple and Google Play developer programs. Feel free to play around, but
    don't be too worried about spending money. Azure has free versions of most services
    and also delivers a good amount of bandwidth for free. You can get more information
    on pricing at [http://azure.microsoft.com/en-us/pricing](http://azure.microsoft.com/en-us/pricing).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了你的 Windows Azure 注册。与 Apple 和 Google Play 开发者计划相比，这相当简单。随意尝试，但不必太担心花费问题。Azure
    大多数服务都有免费版本，并且还提供一定量的免费带宽。你可以访问 [http://azure.microsoft.com/en-us/pricing](http://azure.microsoft.com/en-us/pricing)
    获取更多关于定价的信息。
- en: Note that there are a lot of misconceptions about Windows Azure being expensive.
    You can do all of your development for an application on the free tier without
    spending a dime. When putting applications into production, you can easily scale
    up or down on the number of VM instances to keep your costs under control. In
    general, you will not be spending much money if you do not have a lot of users.
    Likewise, you should be earning plenty of revenue if you happen to have lots of
    users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于 Windows Azure 价格昂贵的误解很多。你可以在免费层为应用程序进行所有开发而不花一分钱。将应用程序投入生产时，你可以轻松地增加或减少虚拟机实例的数量，以控制成本。通常，如果你没有很多用户，你不会花很多钱。同样，如果你恰好有很多用户，你应该能赚取足够的收入。
- en: Exploring Azure Functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Azure Functions
- en: For the server side of XamSnap, we'll use Azure Functions along with Azure Storage
    Tables to provide backend storage to the application. Azure Functions is a simple
    solution to accelerate development for server-side applications that can leverage
    all features of Windows Azure. We will use the standard `HttpClient` class found
    in the .NET base class library for interacting with the service from C#.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 XamSnap 的服务器端，我们将使用 Azure Functions 以及 Azure Storage Tables 为应用程序提供后端存储。Azure
    Functions 是加速服务器端应用程序开发的简单解决方案，可以利用 Windows Azure 的所有功能。我们将使用 .NET 基础类库中的标准 `HttpClient`
    类，从 C# 与服务进行交互。
- en: 'A few neat features of Azure Functions are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 的几个亮点如下：
- en: You can write functions in a variety of programming languages such as JavaScript,
    C#, Python, and PHP, as well as some scripting languages such as Batch, Bash,
    and PowerShell
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用多种编程语言编写函数，如 JavaScript、C#、Python、PHP，以及一些脚本语言，如 Batch、Bash 和 PowerShell
- en: Azure Functions integrates with Visual Studio Team Services, Bitbucket, and
    GitHub for **Continuous Integration** (**CI**) scenarios
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 与 Visual Studio Team Services、Bitbucket 和 GitHub 集成，支持**持续集成**（**CI**）场景
- en: You can set up authentication easily with Azure Active Directory, Windows Live
    ID, Facebook, Google, and Twitter
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地使用 Azure Active Directory、Windows Live ID、Facebook、Google 和 Twitter 设置身份验证
- en: Functions can be triggered via HTTP, a schedule or timer, Azure Queue, and so
    on
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以通过 HTTP、计划或定时器、Azure 队列等触发
- en: Azure Functions is truly serverless and can scale dynamically for large volumes
    of data
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 真正实现了无服务器，并且可以动态扩展处理大量数据
- en: You can see why using Azure Functions is a good choice for simple mobile applications.
    The benefits of accelerated development and the many features it provides are
    a great fit for our XamSnap sample application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以了解到为什么Azure Functions对于简单的移动应用程序是一个好的选择。加速开发以及它提供的许多特性非常适合我们的XamSnap示例应用程序。
- en: 'Navigating to your account at [http://portal.azure.com](http://portal.azure.com)
    and perform the following steps to create an Azure Function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://portal.azure.com](http://portal.azure.com)访问你的账户，并执行以下步骤来创建Azure Function：
- en: Click on the plus button in the top-left of the page.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左上角的加号按钮。
- en: Navigate to **Compute** | **Function App** through the menu.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过菜单导航到**计算** | **函数应用**。
- en: Enter a domain URL of your choice, such as `yourname-xamsnap`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你选择的域名，比如`yourname-xamsnap`。
- en: Choose subscription to place the services under.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个订阅，以便将服务放置在下面。
- en: Choose an existing **Resource Group**, or create a new one named `xamsnap`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个现有的**资源组**，或者创建一个新的名为`xamsnap`的资源组。
- en: Choose a **Dynamic****App Service** plan to get started. If you already have
    an App service plan, you can use an existing one with **Classic** mode instead.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个**动态应用服务**计划开始。如果你已经有了一个应用服务计划，可以使用现有以**经典**模式运行的计划。
- en: Choose an existing **Storage Account** or create a new one.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个现有的**存储账户**或创建一个新的。
- en: Review your final settings and hit the **Create** button.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你的最终设置并点击**创建**按钮。
- en: The management portal will display progress, and it could take a few seconds
    to create your Azure Function App instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 管理门户将显示进度，创建你的Azure Function App实例可能需要几秒钟。
- en: 'Let''s create a simple Hello World function to see things working:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Hello World函数来观察其工作情况：
- en: Navigate to your Function App.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的Function App。
- en: Click on **Quickstart**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**快速入门**。
- en: Click **Webhook + API** with C# selected then hit **Create this function**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击选择C#的**Webhook + API**，然后点击**创建此函数**。
- en: The Azure Portal will give you a quick tour, which you can skip if desired.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure门户会提供一个快速浏览，如果需要，你可以跳过。
- en: Scroll down to the bottom and click **Run** to see your Azure Function in action.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到底部，点击**运行**以查看Azure Function的操作。
- en: 'When completed, you should see output in the log window and a successful HTTP
    request with the output of `Hello Azure`. You should see something similar to
    the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应在日志窗口中看到输出，以及带有`Hello Azure`输出的成功HTTP请求。你应该会看到类似于以下截图的内容：
- en: '![Exploring Azure Functions](img/image00251.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![探索Azure Functions](img/image00251.jpeg)'
- en: Creating and calling Azure Functions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和调用Azure Functions
- en: To begin setting up our backend for XamSnap, we need to create a login function.
    We also need to implement the `IWebService` interface used by the rest of the
    application. Because of our MVVM architecture, we should be able to replace the
    fake service that is being used currently without changing any of the layers sitting
    above it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始为XamSnap设置后端，我们需要创建一个登录函数。我们还需要实现由应用程序其他部分使用的`IWebService`接口。由于我们的MVVM架构，我们应该能够替换当前正在使用的假服务，而不需要更改位于其上的任何层。
- en: 'Return to the Azure Portal, select your Function App instance, and perform
    the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Azure门户，选择你的Function App实例，并执行以下步骤：
- en: Click on the **New Function** button.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建函数**按钮。
- en: Choose the **Empty - C#** template.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**空 - C#**模板。
- en: Enter `login` as the function name.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`login`作为函数名称。
- en: Click on the **Create** button.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: Click on the **Integrate** section.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**集成**部分。
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有默认设置的**HTTP**触发器和输出，然后点击**保存**。
- en: Add an **Azure Table Storage** output, change the table name to `users`, and
    hit **Save**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Azure表存储**输出，将表名更改为`users`，然后点击**保存**。
- en: 'Now let''s write some code for our function, switch to the **Develop** section
    and add the following code as a starting point:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的函数编写一些代码，切换到**开发**部分，并添加以下代码作为起点：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we added a reference to the Azure Storage SDK. This is built-in and available
    to Azure Functions, we will be using it later. Next, we added a few using statements
    and a constant. We created a static function that handles the inputs and outputs
    we defined earlier. `req` is the HTTP input and `outputTable` is the Azure table
    output. `log` is a `TraceWriter` available for debugging and logging purposes.
    Finally, we used built-in methods to read the POST data into `username` and `password`
    variables for use in our function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了对 Azure 存储 SDK 的引用。这是内置的，可供 Azure Functions 使用，我们稍后会用到它。接下来，我们添加了一些
    using 语句和一个常量。我们创建了一个静态函数，处理我们之前定义的输入和输出。`req`是 HTTP 输入，`outputTable`是 Azure 表输出。`log`是一个`TraceWriter`，可用于调试和日志记录。最后，我们使用了内置方法将
    POST 数据读取到`username`和`password`变量中，以便在我们的函数中使用。
- en: 'Next, we need to fill in the rest of our functionality. Place this code at
    the bottom of the function we started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要填充我们功能的剩余部分。将此代码放在我们开始的功能的底部：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s summarize what we did in the preceding C#:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们在前面的 C# 中做了什么：
- en: First, we hashed the incoming password with a function we'll add later. Note
    that Azure Functions have built-in authentication features that would be great
    for production apps. For our sample app, we are at least taking a measure to not
    store passwords into our database as plain text.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们用稍后要添加的函数对传入的密码进行哈希处理。请注意，Azure Functions 有内置的身份验证功能，这对于生产应用来说非常棒。对于我们的示例应用，我们至少采取措施，不将密码以明文形式存储到我们的数据库中。
- en: Next, we used the Azure Storage SDK to check for an existing user.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用了 Azure 存储 SDK 来检查现有用户。
- en: If there are no results, we go ahead and create a new user. The partition key
    and row key are concepts in Azure table storage. In most scenarios, you choose
    a key to partition your data, such as a state or zip code, and the row key is
    a unique key. For this sample, we are just using a constant value for the partition
    key.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有结果，我们将继续创建一个新用户。分区键和行键是 Azure 表存储中的概念。在大多数情况下，你会选择一个键来分区你的数据，比如州或邮政编码，而行键是一个唯一的键。对于这个示例，我们只是为分区键使用了一个常量值。
- en: Otherwise, we compare the hashed passwords and return a success.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们比较哈希密码并返回成功。
- en: If the passwords do not match, we return an unauthorized error code.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码不匹配，我们将返回一个未经授权的错误代码。
- en: 'After this, we just need a little more code to define the `Hash` function and
    the `User` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需要一点代码来定义`Hash`函数和`User`类：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We used the built-in SHA-256 hashing algorithm found in the `System.Security`
    namespace. It is at least a bit more secure that the commonly broken MD5 hash.
    We also declared the `User` class as a table entity with one additional column
    containing the hash.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`System.Security`命名空间中内置的 SHA-256 哈希算法。这至少比常见的被破解的 MD5 哈希要安全一些。我们还声明了`User`类作为一个表实体，并带有一个额外的列包含哈希。
- en: 'From here, just make sure you click on the **Save** button to apply your changes.
    Azure Functions also has the option of providing source control for your scripts
    via several source control providers. Feel free to take advantage of this feature
    if you want to make changes to the script in your favorite editor locally instead
    of the website editor. You should be able to test the function passing sample
    JSON as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只需确保点击**保存**按钮以应用你的更改。Azure Functions 还提供了通过几个源代码控制提供程序为你的脚本提供源代码控制的选项。如果你想在本地的你喜欢的编辑器而不是网站编辑器中更改脚本，可以充分利用这个功能。你应该能够通过以下示例
    JSON 测试该功能：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For complete documentation for the Azure Storage SDK, make sure you check out
    MSDN at [https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx](https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Azure 存储 SDK 的完整文档，请确保查看 MSDN：[https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx](https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx)。
- en: Using HttpClient in C#
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C# 中使用 HttpClient
- en: With our server-side changes complete, the next step is to implement our new
    service in our XamSnap iOS and Android applications. Luckily, as we used an interface
    named `IWebService`, all we need to do is implement that interface to get it working
    in our application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 server-side 更改完成后，下一步是在我们的 XamSnap iOS 和 Android 应用程序中实现我们的新服务。幸运的是，由于我们使用了名为`IWebService`的接口，我们只需实现该接口即可在我们的应用程序中使其工作。
- en: 'Now we can start setting up our service in our iOS application by performing
    the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过执行以下步骤，我们可以在 iOS 应用程序中开始设置我们的服务：
- en: Open the `XamSnap.Core` project that we created earlier in the book.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前在书中创建的`XamSnap.Core`项目。
- en: Create an `Azure` folder within the project.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个`Azure`文件夹。
- en: Create a new class named `AzureWebService.cs`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AzureWebService.cs`的新类。
- en: Make the class `public` and implement `IWebService`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为`public`并实现`IWebService`。
- en: Right-click on `IWebService` in your code and select **Refactor** | **Implement
    Interface**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中右键点击`IWebService`，选择**重构** | **实现接口**。
- en: A line will appear; press **Enter** to insert the method stubs.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一行；按**Enter**键以插入方法存根。
- en: 'When this setup is complete, your class will look something like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个设置完成后，你的类看起来会像下面这样：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we need to add a reference to the JSON .NET library. To do this, we will
    use NuGet to add the library. Right-click on the `XamSnap.Core` project and select
    **Add** | **Add Packages** and install Json .NET.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加对JSON .NET库的引用。为此，我们将使用NuGet来添加库。右键点击`XamSnap.Core`项目，选择**添加** | **添加包**，并安装Json
    .NET。
- en: 'Now let''s modify our `AzureWebService.cs` file. We will make the following
    changes to get started:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`AzureWebService.cs`文件。为了开始，我们将进行以下更改：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We defined some using statements and a few variables we will using throughout
    this class. Make sure you fill in the proper URL for your Azure Function App.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些using语句和几个变量，这些将在这个类中用到。请确保你填写了Azure Function App的正确URL。
- en: 'Next, let''s write some helper methods to make calling web requests easier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一些辅助方法，以简化调用网络请求的过程：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of this code is implementing the basics for calling a RESTful endpoint
    in C#. First, we serialize the object to JSON and create a `StringContent` object
    with a header declaring that it is JSON. We format the URL with the `code` parameter,
    which is a simple security mechanism that is on by default for Azure Functions.
    Next, we call a POST request to the server and call `EnsureSuccessStatusCode`
    in order to throw an exception for failed requests. Lastly, we added a second
    method that parses the response from JSON into C# objects. Some of our Azure Functions
    will return data, so we will need this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分是在C#中实现调用RESTful端点的基础。首先，我们将对象序列化为JSON，并创建一个带有头部声明为JSON的`StringContent`对象。我们用`code`参数格式化URL，这是Azure
    Functions默认开启的一个简单安全机制。接下来，我们向服务器发送一个POST请求，并调用`EnsureSuccessStatusCode`，以便对失败的请求抛出异常。最后，我们添加了第二个方法，将JSON响应解析为C#对象。我们的某些Azure
    Functions将返回数据，所以我们需要这个功能。
- en: 'Now let''s implement our first method, `Login`, in the following manner:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实现我们的第一个方法`Login`：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is fairly straightforward, because of the helper methods we've already
    set up. We merely have to pass in our function name, its key, and the object representing
    the JSON we want to pass to the HTTP request. You can find the key needed under
    **Function URL** in the **Develop** section in the Azure Portal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，因为我们已经设置了辅助方法。我们只需要传递我们的函数名称、它的键以及代表我们想要传递给HTTP请求的JSON的对象。你可以在Azure Portal的**开发**部分下的**Function
    URL**找到所需的键。
- en: 'Next, open the `AppDelegate.cs` file to set up our new service and add the
    following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`AppDelegate.cs`文件以设置我们的新服务，并添加以下代码：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now if you compile and run your application upon login, your app should successfully
    call your Azure Function and insert a new user into Azure Table Storage.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在登录时编译并运行你的应用程序，你的应用应该能够成功调用Azure Function，并将新用户插入Azure Table Storage。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示：
- en: If you are looking for a quick way to manage Azure Tables, Microsoft has released
    a free tool called Azure Storage Explorer. It is available for both Mac OS X and
    Windows can be found at [http://storageexplorer.com](http://storageexplorer.com).
    A second option is the **Cloud Explorer** in Visual Studio that is available if
    you install the Azure SDK for .NET.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个快速管理Azure Tables的方法，微软已经发布了一个免费的工具，叫做Azure Storage Explorer。它适用于Mac
    OS X和Windows，可以在[http://storageexplorer.com](http://storageexplorer.com)找到。第二个选择是Visual
    Studio中的**Cloud Explorer**，如果你安装了Azure SDK for .NET，就可以使用。
- en: Adding more Azure Functions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多的Azure Functions。
- en: There are several more methods we need to implement for our `IWebService` implementation.
    Let's begin by adding two more Azure Functions for getting a list of a users'
    friends and adding a friend.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现几个方法，用于我们的`IWebService`实现。让我们从添加两个新的Azure Functions开始，一个用于获取用户朋友列表，另一个用于添加朋友。
- en: 'Return to the Azure Portal and perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Azure Portal，执行以下步骤：
- en: Click on the **New Function** button.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建函数**按钮。
- en: Choose the **Empty - C#** template.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Empty - C#**模板。
- en: Enter `friends` as the function name.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`friends`作为函数名称。
- en: Click on the **Create** button.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: Click on the **Integrate** section.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**集成**部分。
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有默认设置的**HTTP**触发器和输出，然后点击**保存**。
- en: Add an **Azure Table Storage** input, change the table name to `friends`, and
    hit **Save**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Azure Table Storage**输入，将表名更改为`friends`，然后点击**保存**。
- en: Repeat these steps for a second function named `addfriend`, except make **Azure
    Table Storage** an output instead of input.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对名为`addfriend`的第二个函数重复这些步骤，但将**Azure Table Storage**设置为输出而不是输入。
- en: 'Next, let''s implement the `friends` Azure Function with the following C# code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下C#代码实现`friends` Azure Function：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a bit simpler than our `login` function. Azure Functions have the option
    to use different types of parameters than the `CloudTable` we used earlier. When
    using `IQueryable` we can merely write a LINQ expression to pull out the data
    we need for this function: a list of friends for the specified user. We plan on
    storing the user''s name as the `PartitionKey` and the friend''s name as the `RowKey`.
    We then can merely return these values in the HTTP response.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们的`login`函数简单一些。Azure Functions可以选择使用不同于我们之前使用的`CloudTable`的不同类型的参数。当使用`IQueryable`时，我们只需编写LINQ表达式即可提取此函数所需的数据：指定用户的
    friend 列表。我们计划将用户的名字作为`PartitionKey`，朋友的名字作为`RowKey`。然后我们只需在HTTP响应中返回这些值。
- en: 'Now, let''s implement the `addfriend` function with the following C# code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下C#代码实现`addfriend`函数：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just as before with the `login` function, we use a `CloudTable` to add a row
    to an Azure Storage Table. Just as before, we handle the possibility of blank
    input and return the same status code the Azure Storage SDK returns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前使用`login`函数一样，我们使用`CloudTable`向Azure Storage Table添加一行。同样，我们处理空白输入的可能性，并返回Azure
    Storage SDK返回的相同状态码。
- en: 'Finally, let''s modify `AzureWebService.cs`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修改`AzureWebService.cs`：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are calling the helper methods we created earlier in the chapter to easily
    handle HTTP input and output to our Azure Functions. Make sure to use the proper
    key for each Azure Function. You may want to use a tool to insert or seed some
    test data into the `friends` Azure Storage table for our Azure Function to work
    with.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用本章前面创建的帮助方法，以便轻松处理HTTP输入和输出到我们的Azure Functions。确保为每个Azure Function使用正确的密钥。您可能需要使用工具向`friends`
    Azure Storage表插入或填充一些测试数据，以便我们的Azure Function可以处理。
- en: 'Lastly, we need to make three more Azure Functions for handling conversations
    and messages. Return to the Azure Portal and perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建三个更多的Azure Functions来处理对话和消息。返回Azure门户，并执行以下步骤：
- en: Click on the **New Function** button.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建函数**按钮。
- en: Choose the **Empty - C#** template.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Empty - C#**模板。
- en: Enter `conversations` as the function name.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`conversations`作为函数名称。
- en: Click on the **Create** button.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: Click on the **Integrate** section.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**集成**部分。
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有默认设置的**HTTP**触发器和输出，然后点击**保存**。
- en: Add an **Azure Table Storage** input, change the table name to `friends`, and
    hit **Save**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Azure Table Storage**输入，将表名更改为`friends`，然后点击**保存**。
- en: Repeat these steps for a second function named `messages` with a table name
    of `messages`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对名为`messages`的第二个函数重复这些步骤，表名为`messages`。
- en: Repeat these steps for a third function named `sendmessage`, except make **Azure
    Table Storage** an output instead of input.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对名为`sendmessage`的第三个函数重复这些步骤，但将**Azure Table Storage**设置为输出而不是输入。
- en: 'The C# code for the `conversations` function is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`conversations`函数的C#代码如下：'
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is nearly identical to our `friends` function we wrote earlier. However,
    we need to define a `Conversation` class to add an extra column to our table beyond
    the default `RowKey` and `PartitionKey`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与我们之前编写的`friends`函数相同。但是，我们需要定义一个`Conversation`类，以便在表中对默认的`RowKey`和`PartitionKey`之外添加一个额外的列。
- en: 'Next, let''s add the following C# code for the `messages` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为`messages`函数添加以下C#代码：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once again, this should be very straightforward for what we did for our `friends`
    and `conversations` functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于我们为`friends`和`conversations`函数所做的，这应该非常直观。
- en: 'And finally, let''s add the following code for the `sendmessage` function as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们按照以下方式为`sendmessage`函数添加以下代码：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is close to what we did with `addfriend`. Later in the chapter,
    we will send push notifications in this function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与我们处理`addfriend`的方式非常相似。在本章后面，我们将在该函数中发送推送通知。
- en: 'Before going further, let''s implement the rest of our `IWebService` interface.
    It can be done as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们实现`IWebService`接口的其余部分。可以按照以下方式完成：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each method here in our client-side code is pretty simple and very similar
    to what we did to call the other Azure Functions. `SendMessage` is the only thing
    we had to do that was new: generate a unique message ID for new messages.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端代码中的每个方法都非常简单，与我们调用其他Azure函数时所做的类似。`SendMessage`是我们唯一需要新做的一件事：为新的消息生成一个唯一的消息ID。
- en: This completes our implementation of `IWebService`. If you run the application
    at this point, it will function exactly as before with the exception that the
    app is actually talking to a real web server. New messages will get persisted
    in Azure Storage Tables, and our Azure Functions will handle the custom logic
    that we need. Feel free to play around with our implementation; you might discover
    some features of Azure Functions that will work great with your own applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们`IWebService`的实现。如果你在此时运行应用程序，它将和之前一样运行，区别在于实际上应用程序正在与真实的网络服务器通信。新消息将保存在Azure存储表中，我们的Azure函数将处理所需的定制逻辑。请随意尝试我们的实现；你可能会发现一些Azure函数功能，它们与你的应用程序非常契合。
- en: At this point, another good exercise would be to set up `AzureWebService` in
    our Android application. You should be able to swap out the `ServiceContainer.Register`
    call in your `Application` class. Everything will function exactly like on iOS.
    Isn't cross-platform development great?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，另一个好的练习是在我们的Android应用程序中设置`AzureWebService`。你应该能够在你的`Application`类中的`ServiceContainer.Register`调用进行替换。所有功能将完全与iOS相同。跨平台开发不是很好吗？
- en: Using the Apple Push Notification service
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用苹果推送通知服务
- en: Implementing push notifications with Azure Notification Hubs on iOS is very
    simple to set up from Azure's perspective. The most complicated part is working
    through Apple's process of creating certificates and provisioning profiles in
    order to configure your iOS application. Before continuing, make sure you have
    a valid iOS Developer Program account, as you will not be able to send push notifications
    without it. If you are unfamiliar with the concept of push notifications, take
    a look at Apple's documentation at [http://tinyurl.com/XamarinAPNS](http://tinyurl.com/XamarinAPNS).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure的角度来看，使用Azure通知中心在iOS上实现推送通知非常简单。最复杂的部分是完成苹果公司创建证书和配置文件的过程，以便配置你的iOS应用程序。在继续之前，请确保你有一个有效的iOS开发者计划账户，因为没有它你将无法发送推送通知。如果你不熟悉推送通知的概念，请查看苹果的文档，链接为[http://tinyurl.com/XamarinAPNS](http://tinyurl.com/XamarinAPNS)。
- en: 'To send push notifications, you need to set up the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送推送通知，你需要设置以下内容：
- en: An explicit App ID registered with Apple
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册的显式App ID与苹果
- en: A provisioning profile targeting that App ID
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对该App ID的一个配置文件
- en: A certificate for your server to trigger the push notification
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于触发推送通知的服务器证书
- en: Apple provides both a development and production certificate, which you can
    use to send push notifications from your server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了开发和生产两种证书，你可以使用它们从你的服务器发送推送通知。
- en: Setting up your provision profile
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的配置文件
- en: 'Let''s begin by navigating to [http://developer.apple.com/account](http://developer.apple.com/account),
    and carry out the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[http://developer.apple.com/account](http://developer.apple.com/account)开始，执行以下步骤：
- en: Click on the **Identifiers** link.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**标识符**链接。
- en: Click on the plus button in the top-right corner of the window.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右上角的加号按钮。
- en: Enter a description, such as `XamSnap`, for the bundle ID.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为捆绑ID输入描述，例如`XamSnap`。
- en: Enter your bundle ID under the **Explicit App ID** section. This should match
    the bundle ID you set up in your `Info.plist` file, for example, `com.yourcompanyname.xamsnap`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**显式App ID**部分输入你的捆绑ID。这应该与你`Info.plist`文件中设置的捆绑ID相匹配，例如，`com.yourcompanyname.xamsnap`。
- en: Under **App Services**, be sure to check **Push Notifications**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用服务**下，确保勾选了**推送通知**。
- en: Now, click on **Continue**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**继续**。
- en: Review your final settings and hit **Submit**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审核你的最终设置，然后点击**提交**。
- en: 'This will create an explicit app ID similar to what we can see in the following
    screenshot, which we can use for sending push notifications:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个显式App ID，类似于我们可以在以下屏幕截图中看到的ID，我们可以使用它来发送推送通知：
- en: '![Setting up your provision profile](img/image00252.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的配置文件](img/image00252.jpeg)'
- en: 'For push notifications, we have to use a profile with an explicit App ID that
    is not a development certificate. Now let''s set up a provisioning profile:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于推送通知，我们必须使用一个显式App ID的配置文件，这不是一个开发证书。现在让我们设置一个配置文件：
- en: Click on the **Development** link under **Provisioning Profiles** on the right-hand
    side.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧**供应配置文件**下的**开发**链接。
- en: Click on the plus button in the top-right corner.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的加号按钮。
- en: Check **iOS App Development** and click on **Continue**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**iOS应用开发**并点击**继续**。
- en: Select the App ID we just created and click on **Continue**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚刚创建的应用ID并点击**继续**。
- en: Select the developer and click on **Continue**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开发者并点击**继续**。
- en: Select the devices you will be using and click on **Continue**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你将要使用的设备并点击**继续**。
- en: Enter a name for the profile and click on **Generate**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为配置文件输入一个名称并点击**生成**。
- en: Download the profile and install it, or open **XCode** and use the sync button
    in **Preferences** | **Accounts**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载配置文件并安装，或者在**XCode**的**偏好设置** | **账户**中使用同步按钮。
- en: 'When finished, you should arrive at a success web page that looks like the
    following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该会看到一个如下所示的成功的网页：
- en: '![Setting up your provision profile](img/image00253.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的供应配置文件](img/image00253.jpeg)'
- en: Setting up a certificate for push notifications
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置推送通知的证书
- en: 'Next, we perform the following steps to set up the certificate our server needs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行以下步骤来设置服务器需要的证书：
- en: Click on the **Development** link under **Certificates** on the right-hand side.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧**证书**下的**开发**链接。
- en: Click on the plus button in the top-right corner.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的加号按钮。
- en: Enable **Apple Push Notifications service SSL (Sandbox)** and click on **Continue**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**苹果推送通知服务SSL（沙盒）**并点击**继续**。
- en: Select your App ID as before and click on **Continue**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像之前一样选择你的应用ID并点击**继续**。
- en: Create a new certificate signing request as per Apple's instructions. You may
    also refer to [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Deploying and
    Testing on Devices"), *Deploying and Testing on Devices*, or locate the `*.certSigningRequest`
    file from before.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照苹果的说明创建一个新的证书签名请求。你也可以参考[第7章](part0062.xhtml#aid-1R42S2 "第7章. 在设备上部署和测试")，*在设备上部署和测试*，或者找到之前的`*.certSigningRequest`文件。
- en: Next, click on **Continue**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**继续**。
- en: Upload the signing request file and click on **Generate**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传签名请求文件并点击**生成**。
- en: Next, click on **Download**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**下载**。
- en: Open the file to import the certificate into **Keychain**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件，将证书导入**钥匙串**。
- en: Locate the certificate in **Keychain**. It will be titled **Apple Development
    iOS Push Services** and will contain your bundle ID.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**钥匙串**中找到证书。它将被命名为**Apple Development iOS Push Services**，并包含你的捆绑ID。
- en: Right-click on the certificate and export it somewhere on your filesystem. Enter
    a password that you would remember.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击证书并将其导出到你的文件系统的某个位置。输入一个你能记住的密码。
- en: This will create the certificate we need to send push notifications to our users
    from an Azure Notification Hub.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们需要从Azure通知中心向用户发送推送通知的证书。
- en: 'Return to the Azure Portal and perform the following steps to create an Azure
    Notification Hub:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Azure门户，执行以下步骤创建Azure通知中心：
- en: Navigate to the resource group where your **Azure Function App** is located.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到存放你的**Azure Function App**的资源组。
- en: Click on the plus button to add a new service to the resource group.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号按钮，向资源组添加新服务。
- en: Choose a **Notification Hub Name** and **Namespace** such as `xamsnap`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个**通知中心名称**和**命名空间**，例如`xamsnap`。
- en: Make sure the desired data center and resource group are selected and click
    on **Create**.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择了所需的数据中心和资源组并点击**创建**。
- en: 'All that remains is to return to the Azure Portal and upload the certificate
    from your Azure Notification Hub. You can find this setting under **Notification
    Services** | **Apple (APNS)** | **Upload Certificate**, as seen in the following
    screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是回到Azure门户，从你的Azure通知中心上传证书。你可以在**通知服务** | **苹果(APNS)** | **上传证书**中找到这个设置，如下截图所示：
- en: '![Setting up a certificate for push notifications](img/image00254.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![为推送通知设置证书](img/image00254.jpeg)'
- en: This upload concludes the configuration we need from Apple's side.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上传完成了我们需要从苹果方面进行的配置。
- en: Making client-side changes for push notifications
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为推送通知进行客户端侧的更改
- en: Next, let's return to our `XamSnap.iOS` project in Xamarin Studio to make the
    necessary changes on the client side for push notifications. We will need to add
    a few new classes to our shared code to start with.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到Xamarin Studio中的`XamSnap.iOS`项目，进行客户端必要的推送通知更改。我们首先需要在共享代码中添加几个新的类。
- en: 'In our XamSnap PCL project, create a new interface named `INotificationService`
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的XamSnap PCL项目中，创建一个名为`INotificationService`的新接口，如下所示：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to call `Start` after login completes. In `LoginViewModel.cs`,
    add the following lines after a successful login:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在登录完成后调用`Start`。在`LoginViewModel.cs`中，在成功登录后添加以下几行：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let''s implement this interface in a new class in our iOS project named
    `AppleNotificationService` as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在iOS项目中的一个名为`AppleNotificationService`的新类中实现这个接口，如下所示：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We need to define a `CultureInfo` object for use later and need two private
    variables for our notification hub and the name of the currently logged in user.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个`CultureInfo`对象供稍后使用，还需要两个私有变量，分别用于我们的通知中心和当前登录的用户名。
- en: 'Now, let''s implement the `Start` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`Start`方法：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We stored the user's name in a member variable and then called the native iOS
    APIs to set up registration for remote notifications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户名存储在成员变量中，然后调用原生iOS API来为远程通知设置注册。
- en: 'Next, we need to implement the `SetToken` method as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要如下实现`SetToken`方法：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we created a new notification hub if needed. Make sure to replace `yourconnection`
    with a real connection string that only has **Listen** access. This can be found
    in the Azure Portal under **Settings** | **Access Policies** | **DefaultListenSharedAccessSignature**.
    Following that, we declared an iOS template that takes uses the `message` variable
    in the proper format for iOS push notifications. This is a feature of notification
    hubs that enabled cross-platform push notifications. Finally, we registered the
    device token with the notification hub, logging any errors that might occur.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如有需要，我们创建了一个新的通知中心。确保将`yourconnection`替换为只有**监听**权限的真实连接字符串。这可以在Azure门户的**设置**
    | **访问策略** | **DefaultListenSharedAccessSignature**中找到。接下来，我们声明了一个iOS模板，它使用`message`变量以iOS推送通知的正确格式。这是通知中心的一个特性，支持跨平台推送通知。最后，我们将设备令牌与通知中心注册，并记录可能发生的任何错误。
- en: 'Next, we need to make a few iOS-specific changes to `AppDelegate.cs`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对`AppDelegate.cs`进行一些iOS特定的更改：
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We implemented a couple of important methods in the preceding code snippet.
    `DidRegisterUserNotificationSettings` is a callback for when the user accepts
    the iOS permission popup. `RegisteredForRemoteNotifications` will occur when Apple
    successfully returns a device token from its servers. We pass the device token
    through the `INotificationService` to the Azure Notification Hub. We also implemented
    `FailedToRegisterForRemoteNotifications` just to report any errors that might
    occur throughout the process.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了一些重要方法。`DidRegisterUserNotificationSettings`是用户接受iOS权限弹窗时的回调。`RegisteredForRemoteNotifications`将在Apple成功从其服务器返回设备令牌时发生。我们将设备令牌通过`INotificationService`传递给Azure通知中心。我们还实现了`FailedToRegisterForRemoteNotifications`，以报告整个过程中可能发生的任何错误。
- en: 'Finally, we need to add a small modification to register our `INotificationService`
    implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个小修改来注册我们的`INotificationService`实现：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sending push notifications from the server-side
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器端发送推送通知
- en: Since we have successfully configured iOS for push notifications, it is now
    time to actually send them from our `sendmessage` Azure Function. Azure Functions
    support notification hubs out of the box, but at the time of writing it was not
    possible to use them as an output and specify a tag targeting a specific user.
    Luckily, Azure Functions are just C# code, so we can easily leverage the Azure
    Notification Hub SDK to manually send push notifications from code. Let's switch
    to the Azure Portal and make the remaining changes on the server side.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经成功为iOS配置了推送通知，现在是从我们的`sendmessage` Azure Function实际发送它们的时候了。Azure Functions开箱即支持通知中心，但在撰写本文时，无法将它们作为输出使用，并指定针对特定用户的标签。幸运的是，Azure
    Functions只是C#代码，因此我们可以轻松利用Azure通知中心SDK从代码手动发送推送通知。让我们切换到Azure门户，并在服务器端进行剩余的更改。
- en: 'First, let''s add a few statements at the top to include the Azure Notification
    Hub SDK:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在顶部添加几条语句以包含Azure通知中心SDK：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s add a quick method for sending push notifications:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个快速发送推送通知的方法：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make sure to replace `yourconnection` with a valid connection string with both
    **Send** and **Listen** permissions. By default, you can use the one named **DefaultFullSharedAccessSignature**
    in the Azure Portal.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`yourconnection`替换为具有**发送**和**监听**权限的有效连接字符串。默认情况下，您可以在Azure门户中使用名为**DefaultFullSharedAccessSignature**的那个。
- en: 'Lastly, we need to actually send the push notification when the Azure Function
    is invoked:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 Azure 函数被调用时实际发送推送通知：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To test push notifications, deploy the application and log in with the secondary
    user. After logging in, you can just background the app with the home button.
    Next, log in with the primary user on your iOS simulator and send a message. You
    should receive a push notification, as shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试推送通知，请部署应用程序并使用辅助用户登录。登录后，你可以使用主页按钮将应用程序后台运行。接下来，在你的 iOS 模拟器上以主要用户身份登录并发送消息。你应该会收到推送通知，如下面的截图所示：
- en: '![Sending push notifications from the server-side](img/image00255.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![从服务器端发送推送通知](img/image00255.jpeg)'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are having some trouble getting things working, try sending test notifications
    from the Azure Portal under your notification hub and then **TroubleShooting**
    | **Test Send**. You can send test notifications with the native format or the
    custom template format we use in this chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一些问题，尝试从 Azure 门户下的通知中心发送测试通知，然后点击**故障排除** | **测试发送**。你可以使用本章中使用的原生格式或自定义模板格式发送测试通知。
- en: Implementing Google Cloud Messaging
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Google Cloud Messaging
- en: Since we have already set up everything we need in the shared code and on Azure,
    setting up push notifications for Android will be a lot less work at this point
    of time. To continue, you will need a Google account with a verified e-mail address;
    however, I would recommend using an account registered with **Google Play**, if
    you have one. You can refer to the full documentation on **Google Cloud Messaging**
    (**GCM**) at [https://developers.google.com/cloud-messaging/](https://developers.google.com/cloud-messaging/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在前面的共享代码和 Azure 上设置好了所需的一切，此时为 Android 设置推送通知将少很多工作。继续操作，你需要一个带有验证电子邮件地址的
    Google 帐户；不过，如果你有的话，我建议使用在**Google Play**注册的账户。你可以参考关于 **Google Cloud Messaging**
    (**GCM**) 的完整文档，地址是 [https://developers.google.com/cloud-messaging/](https://developers.google.com/cloud-messaging/)。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that Google Cloud Messaging requires that Google APIs be installed on the
    Android device and that the Android OS be at least Version 2.2.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Google Cloud Messaging 需要Android设备上安装了 Google APIs，并且 Android 操作系统至少是版本
    2.2。
- en: 'Begin by navigating to [http://cloud.google.com/console](http://cloud.google.com/console),
    then and perform the following steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问 [http://cloud.google.com/console](http://cloud.google.com/console)，然后执行以下步骤：
- en: Click on the **Create Project** button.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建项目**按钮。
- en: Enter an appropriate project name, such as `XamSnap`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个适当的项目名称，如`XamSnap`。
- en: Agree to the **Terms of Service**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同意**服务条款**。
- en: Click on the **Create** button.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: When creating your first project, you may have to verify the mobile number associated
    with your account.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建你的第一个项目时，你可能需要验证与你的账户关联的手机号码。
- en: Note the **Project Number** field on the **Overview** page. We will need this
    number later.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意**概述**页面上的**项目编号**字段。我们稍后需要这个数字。
- en: 'The following screenshot shows our project widget on the **Dashboard** tab:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们的项目小部件在**仪表盘**标签上的样子：
- en: '![Implementing Google Cloud Messaging](img/image00256.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![实现 Google Cloud Messaging](img/image00256.jpeg)'
- en: 'Now we can continue with our setup as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下步骤继续我们的设置：
- en: Click on the **Use Google APIs** widget.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**使用 Google APIs**小部件。
- en: Click on **Library** and search for **Google Cloud Messaging for Android**.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**库**，搜索**Google Cloud Messaging for Android**。
- en: Click on the **Enable** button at the top to enable the service. You may have
    to accept another agreement.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的**启用**按钮以启用服务。你可能需要接受另一个协议。
- en: Click on **Go to Credentials** that will appear in a warning tip at the top.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部警告提示中出现的**前往凭据**。
- en: Click on the **What credentials do I need?** button.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**我需要哪些凭据？**按钮。
- en: Click on **Restrict Key**, choose **IP Addresses**, and enter **0.0.0.0/0**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**限制密钥**，选择**IP 地址**，并输入**0.0.0.0/0**。
- en: Copy the key to your clipboard for later and click **Save.**
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制密钥到剪贴板以备后用，并点击**保存**。
- en: Switch to the Azure Portal and navigate to the **Notification Services** | **Google
    (GCM)** section in your Azure Notification Hub instance.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Azure 门户，导航到你的 Azure 通知中心实例中的**通知服务** | **Google (GCM)**部分。
- en: Paste the API key in the **API Key** field and click on **Save**. Note that
    the first time, it may take the Google Console up to five minutes for the key
    to be valid.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**API 密钥**字段中粘贴 API 密钥，并点击**保存**。请注意，第一次，Google 控制台可能需要长达五分钟的时间密钥才能生效。
- en: This completes our set up on Azure's side. We will need to get a couple open-source
    libraries for Xamarin.Android apps. First, install **Xamarin.Azure.NotificationHubs.Android**
    from NuGet, and then install **Google Cloud Messaging Client** from the Xamarin
    Component store.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们在 Azure 方面的设置。我们需要为 Xamarin.Android 应用获取几个开源库。首先，从 NuGet 安装 **Xamarin.Azure.NotificationHubs.Android**，然后从
    Xamarin 组件商店安装 **Google Cloud Messaging Client**。
- en: 'Next, create a new class called `Constants.cs` as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `Constants.cs` 的新类，如下所示：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Fill out the `ProjectId` value with the project number found earlier on the
    **Overview** page of your Google Cloud Console. `ConnectionString` and `HubName`
    should be the exact same as what was entered for iOS.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前在 Google 云控制台 **概览** 页面找到的项目编号填写 `ProjectId` 值。`ConnectionString` 和 `HubName`
    应该与为 iOS 输入的内容完全相同。
- en: 'Next, we need to set up some permissions to support push notifications in our
    application. Above the namespace declaration in this file, add the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置一些权限以支持我们应用中的推送通知。在这个文件中的命名空间声明之上，添加以下内容：
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You could also make these changes in our `AndroidManifest.xml` file; however,
    using C# attributes can be better since it gives the ability to use code completion
    while typing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在我们的 `AndroidManifest.xml` 文件中进行这些更改；然而，使用 C# 属性可能更好，因为它在输入时提供了代码补全的能力。
- en: 'Next, create another new class named `PushBroadcastReceiver.cs` as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个名为 `PushBroadcastReceiver.cs` 的新类，如下所示：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `PushBroadcastReceiver.cs` class sets up `BroadcastReceiver`, which is Android's
    native way for different applications to talk with one another. For more information
    on the topic, checkout the Android documentation on the subject at [http://developer.android.com/reference/android/content/BroadcastReceiver.html.](http://developer.android.com/reference/android/content/BroadcastReceiver.html)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushBroadcastReceiver.cs` 类设置了 `BroadcastReceiver`，这是安卓应用之间通信的原生方式。关于这个主题的更多信息，请查看安卓文档中的相关内容：[http://developer.android.com/reference/android/content/BroadcastReceiver.html.](http://developer.android.com/reference/android/content/BroadcastReceiver.html)'
- en: 'Next, create one last class named `PushHandlerService.cs` as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建最后一个名为 `PushHandlerService.cs` 的类，如下所示：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, right-click on `GcmServiceBase` and choose **Refactor** | **Implement
    abstract members**. Next, let''s implement each member one by one:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键点击 `GcmServiceBase` 并选择 **重构** | **实现抽象成员**。接下来，让我们逐个实现每个成员：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This preceding code is very similar to what we did on iOS. We merely have to
    send the `registrationId` value to `INotificationService`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们之前在 iOS 上的操作非常相似。我们只需将 `registrationId` 值发送给 `INotificationService`。
- en: 'Next, we have to write the following code when the message is received:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当接收到消息时，我们需要编写以下代码：
- en: '[PRE31]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code will actually pull out the values from the notification and display
    them in the notification center of the Android device. We used the built-in resource
    for `SymActionEmail` to display an e-mail icon in the notification.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上会从通知中提取值，并在安卓设备的消息中心显示它们。我们使用了内置资源 `SymActionEmail` 来在通知中显示一个电子邮件图标。
- en: 'Next, we just need to implement two more abstract methods. For now, let''s
    just use `Console.WriteLine` to report these events, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要实现两个更多的抽象方法。现在，我们只需使用 `Console.WriteLine` 来报告这些事件，如下所示：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Down the road, you should consider removing registrations from Azure when `OnUnRegistered`
    is called. Occasionally, a user's `registrationId` will change, so this is the
    place where your application is notified of this.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的开发中，你应该考虑在调用 `OnUnRegistered` 时从 Azure 移除注册。有时，用户的 `registrationId` 会发生变化，因此这里是应用程序得到通知的地方。
- en: 'Next, we need to implement `INotificationService` for Android. Begin by creating
    a new file named `GoogleNotificationService.cs` and add the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为安卓实现 `INotificationService`。首先创建一个名为 `GoogleNotificationService.cs`
    的新文件，并添加以下代码：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, open `Application.cs` and add the following line to register our new
    service:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `Application.cs` 并添加以下行来注册我们的新服务：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now if you repeat the steps for testing push notifications on iOS, you should
    be able to send a push notification to our Android app. Even better, you should
    be able to send push notifications across platforms, since an iOS user could send
    a message to an Android user:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重复在 iOS 上测试推送通知的步骤，你应该能够向我们的安卓应用发送一个推送通知。甚至更好，你应该能够跨平台发送推送通知，因为 iOS 用户可以向安卓用户发送消息：
- en: '![Implementing Google Cloud Messaging](img/image00257.jpeg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![实现 Google 云消息传递](img/image00257.jpeg)'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we went over what Windows Azure provides: Infrastructure as
    a Service and Platform as a Service. We set up a free Windows Azure account and
    set up an Azure Function App instance. We implemented the client-side code for
    making requests against our Azure Functions. Lastly, we implemented push notifications
    for iOS using Azure Notification Hubs to consolidate messages going to iOS devices
    via the Apple Push Notification service and Android via Google Cloud Messaging.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Windows Azure 提供的服务：基础设施即服务和平台即服务。我们注册了一个免费的 Windows Azure 账户并设置了一个
    Azure Function App 实例。我们实现了客户端代码，以便针对我们的 Azure Functions 发起请求。最后，我们使用 Azure 通知中心为
    iOS 实现了推送通知，以通过 Apple 推送通知服务和 Google 云消息将消息集中发送到 iOS 和 Android 设备。
- en: Using Azure Functions, we were able to get by without writing too much server-side
    code. In the next chapter, we'll explore how to use third-party libraries with
    Xamarin. This includes everything from the Xamarin Component Store to using native
    Objective-C or Java libraries.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure Functions，我们可以在不编写太多服务器端代码的情况下完成任务。在下一章中，我们将探讨如何使用 Xamarin 使用第三方库。这包括从
    Xamarin 组件商店到使用本地 Objective-C 或 Java 库的所有内容。
