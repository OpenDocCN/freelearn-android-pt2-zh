- en: Chapter 3. Developing with Specialized Android Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 使用专用 Android 控件进行开发
- en: '*Along with the many generic widgets such as buttons, text fields, and checkboxes,
    Android also includes a variety of more specialized widgets. While a button is
    fairly generic, and has use in many situations, a gallery-widget for example,
    is far more targeted. In this chapter we will start looking at the more specialized
    Android widgets, where they appear, and how best they can be used.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了许多通用控件，如按钮、文本字段和复选框外，Android 还包括各种更专业的控件。虽然按钮相当通用，在许多情况下都有用途，但例如图库控件则更为针对性。在本章中，我们将开始研究更专业的
    Android 控件，它们的出现位置以及最佳使用方法。*'
- en: 'Although these are very specialized `View` classes, they are very important.
    As mentioned earlier (and it really can''t be stressed enough) one of the cornerstones
    of good user interface design is **consistency** . An example is the `DatePicker`
    widget. It''s certainly not the prettiest date-selector in the world. It''s not
    a calendar widget, so it''s sometimes quite difficult for the user to select exactly
    which date they want (most people think in terms of "next week Tuesday", and not
    "Tuesday the 17th"). However, the `DatePicker` is standard! So the user knows
    exactly how to use it, they don''t have to work with a broken calendar implementation.
    This chapter will work with Android''s more specialized `View` and layout classes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些是非常专业的`View`类，但它们非常重要。如前所述（这一点真的非常重要）良好用户界面设计的一个基石是**一致性**。例如`DatePicker`控件。它绝对不是世界上最漂亮的日期选择器。它不是一个日历控件，因此用户有时很难选择确切的日期（大多数人会想到“下周二”，而不是“17号星期二”）。然而，`DatePicker`是标准的！所以用户确切知道如何使用它，他们不必使用一个有问题的日历实现。本章将使用
    Android 更专业的`View`和布局类：
- en: '`Tab` layouts'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tab`布局'
- en: '`TextSwitcher`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextSwitcher`'
- en: '`Gallery`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gallery`'
- en: '`DatePicker`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePicker`'
- en: '`TimePicker`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimePicker`'
- en: '`RatingBar`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RatingBar`'
- en: These classes have very specialized purposes, and some have slight quirks in
    the way they are implemented. This chapter will explore how and where to use these
    widgets, and where you need to be careful of their implementation details. We'll
    also discuss how best to incorporate these elements into an application, and into
    a layout.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类具有非常特殊的目的，其中一些在实现方式上略有不同。本章将探讨如何以及在何处使用这些控件，以及在使用它们的实现细节上需要小心。我们还将讨论如何将这些元素最佳地融入到应用程序和布局中。
- en: Creating a restaurant review application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个餐厅评论应用程序
- en: 'In the previous chapter, we built an ordering-in application. In this chapter,
    we''re going to take a look at reviewing restaurants. The application will allow
    the user to view other people''s opinions on the restaurant, a gallery of photos
    of the restaurant, and finally a section for making an online reservation. We
    will divide the application into three sections:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个外卖应用程序。在本章中，我们将要看看餐厅评论。该应用程序将允许用户查看其他人对餐厅的看法，一个餐厅照片的图库，以及最终在线预订的部分。我们将应用程序分为三个部分：
- en: '**Review**: Review and ratings information for this restaurant'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回顾**：此餐厅的评论和评分信息'
- en: '**Photos**: A photo gallery of the restaurant'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**照片**：餐厅的照片图库'
- en: '**Reservation**: Request a reservation with the restaurant'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订**：向餐厅提出预订请求'
- en: When building an application where all three of these sections need to be quickly
    available to the user, the most sensible option available is to place each of
    the sections in a tab on the screen. This allows the user to switch between the
    three sections without having all of them on the screen at the same time. This
    also saves screen real estate giving us more space for each section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个需要快速向用户展示这三个部分的应用程序时，最合理的选择是将每个部分放在屏幕上的一个标签页中。这样用户可以在三个部分之间切换，而无需同时将它们全部显示在屏幕上。这还节省了屏幕空间，为每个部分提供更多的空间。
- en: The **Review** tab will include a cycling list of comments that people have
    made about the restaurant being viewed, and an average "star" rating for the restaurant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**回顾**标签将包括人们对正在查看的餐厅的循环评论列表，以及餐厅的平均“星级”评分。'
- en: Displaying photographs of the restaurant is the job of the **Photos** tab. We'll
    provide the user with a thumbnail "track" at the top of the screen, and a view
    of the selected image consuming the remaining screen space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 展示餐厅的照片是**照片**标签的工作。我们将在屏幕顶部为用户提供一个缩略图“轨道”，并使用剩余的屏幕空间显示所选图像。
- en: For the **Reservation** tab, we will want to capture the user's name and when
    they would like the reservation to be (date and time). Finally we also need to
    know for how many people the reservation will be made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**预订**标签，我们希望捕获用户的名字以及他们希望预订的时间（日期和时间）。最后，我们还需要知道预订将是为多少人。
- en: Time for action – creating the robotic review project structure
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建机器人评审项目结构
- en: To start this example we'll need a new project with a new `Activity`. The new
    layout and `Activity` will be a little different from the structures in the previous
    two chapters. We will need to use the `FrameLayout` class in order to build a
    tabbed layout. So to begin, we'll create a new project structure and start off
    with a skeleton that will later become our tab layout structure. This can be filled
    with the three content areas.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，我们需要一个带有新的`Activity`的新项目。新的布局和`Activity`将与前两章的结构略有不同。为了构建标签式布局，我们需要使用`FrameLayout`类。因此，首先，我们将创建一个新的项目结构，并从一个框架开始，这个框架最终将成为我们的标签布局结构。这可以填充三个内容区域。
- en: 'Create a new Android project using the Android command-line tool:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Android 命令行工具创建一个新的 Android 项目：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the `res/layout/main.xml` file in an editor or IDE.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或 IDE 中打开`res/layout/main.xml`文件。
- en: Clear out the default code (leaving in the XML header).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除默认代码（保留 XML 头）。
- en: 'Create a root `FrameLayout` element:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个根`FrameLayout`元素：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the new `FrameLayout` element, add a `vertical LinearLayout`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`FrameLayout`元素内，添加一个`垂直 LinearLayout`：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the `LinearLayout`, add another empty `LinearLayout` element:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinearLayout`之后，添加另一个空的`LinearLayout`元素：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, after the second `LinearLayout` element, add an empty `ScrollView`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在第二个`LinearLayout`元素之后，添加一个空的`ScrollView`：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `FrameLayout` will be used by the Android tab structures as a content area,
    each of the child elements will become the contents of a tab. In the preceding
    layout, we've added in two `LinearLayout` elements for the **Review** and **Photos**
    sections, and a `ScrollView` for the **Reservation** tab.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`将被 Android 标签结构用作内容区域，每个子元素都将成为一个标签的内容。在上面的布局中，我们为**评审**和**照片**部分添加了两个`LinearLayout`元素，并为**预订**标签添加了一个`ScrollView`。'
- en: '*What just happened?*'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We've just started the "restaurant review" application, building a skeleton
    for the user interface. There are several key parts of this `main.xml` file which
    we should walk through before continuing the example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开始“餐厅评审”应用程序，为用户界面构建了一个框架。在继续示例之前，我们应该先浏览一下这个`main.xml`文件的几个关键部分。
- en: First, our root element is a `FrameLayout`. The `FrameLayout` anchors all of
    its children to its own top-left corner. In effect, the two occurrences of `LinearLayout`
    and the `ScrollView` will overlap each other. This structure can be used to form
    something like a Java AWT `CardLayout`, which will be used by the `TabHost` object
    to display these objects when their relative tab is active.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的根元素是一个`FrameLayout`。`FrameLayout`将其所有子元素锚定在自己的左上角。实际上，两个`LinearLayout`和`ScrollView`将相互重叠。这种结构可以用来形成类似于
    Java AWT `CardLayout`的东西，`TabHost`对象将使用它来在相应标签处于激活状态时显示这些对象。
- en: Second, each of the `LinearLayout` and the `ScrollView` have an ID. In order
    to identify them as tab roots, we need to be able to easily access them from our
    Java code. Tab structures may be designed in XML, but they need to be put together
    in Java.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，每个`LinearLayout`和`ScrollView`都有一个 ID。为了将它们标识为标签根，我们需要能够从 Java 代码轻松访问它们。标签结构可能在
    XML 中设计，但它们需要在 Java 中组合。
- en: Building a TabActivity
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 TabActivity
- en: In order to continue, we need our `Activity` class to set up the three tab content
    elements we declared in our `main.xml` file as tabs. By preference, all tabs in
    Android should have an icon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续，我们需要我们的`Activity`类来设置我们在`main.xml`文件中声明为标签的三个标签内容元素。按偏好，Android 中的所有标签都应该有一个图标。
- en: 'The following is a screenshot of the tabs without their icons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是去掉图标的标签页的截图：
- en: '![Building a TabActivity](img/4484_03_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![构建 TabActivity](img/4484_03_01.jpg)'
- en: 'The following is a screenshot of the tabs with the icons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有图标的标签页的截图：
- en: '![Building a TabActivity](img/4484_03_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![构建 TabActivity](img/4484_03_02.jpg)'
- en: Creating tab icons
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签图标
- en: Android applications have a specific look and feel defined by the default widgets
    provided by the system. In order to keep all applications consistent for users,
    there are a set of user interface guidelines that application developers should
    follow. While it's important to have your application stand out, users will often
    get frustrated with applications that are not familiar or look out of place (this
    is one of the reasons why automatically ported applications are often very unpopular).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用程序具有由系统提供的默认控件定义的特定外观和感觉。为了使所有应用程序对用户保持一致，应用开发者应遵循一系列的用户界面指南。虽然让应用程序脱颖而出很重要，但用户经常会因为应用程序不熟悉或看起来不协调而感到沮丧（这也是自动移植的应用程序通常非常不受欢迎的原因之一）。
- en: Android tabs and icons
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓的标签和图标
- en: 'When selecting tab icons for your application, it''s considered a good practice
    to include several different versions of the icon for different screen sizes and
    densities. The anti-aliased corners that look so good on a high-density screen,
    look terrible on low-density screens. You can also provide entirely different
    icons for very small screens, instead of loosing all of your icons details. Android
    tabs appear raised when they are selected, and lowered in the background when
    they are not selected. The Android tab icons should appear in the "opposite" etching
    effect to the tab that they are placed in, that is, lowered when they are selected
    and raised when they are not selected. The icons therefore have two primary states:
    selected and unselected. In order to switch between these two states, a tab-icon
    will generally consist of three resource files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序选择标签图标时，最好实践是包含几个不同版本，以适应不同的屏幕大小和密度。在高密度屏幕上看起来很好的抗锯齿角，在低密度屏幕上看起来会很糟糕。对于非常小的屏幕，你也可以提供完全不同的图标，而不是丢失所有图标细节。当安卓标签被选中时，它们会显得凸起，而在未选中时则降低到背景中。安卓标签图标应该具有与它们所在标签相反的“雕刻”效果，即选中时降低，未选中时凸起。因此，图标主要有两种状态：选中状态和未选中状态。为了在这两种状态之间切换，标签图标通常由三个资源文件组成：
- en: The selected icon image
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选中图标的图像
- en: The unselected icon image
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未选中图标的图像
- en: An XML file describing the icon in terms of its two states
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述图标两种状态的 XML 文件
- en: Tab icons are generally simple shapes while the image size is squared (generally
    at a maximum of 32 x 32 pixels). Different variations of the image should be used
    for screens of different pixel densities (see [Chapter 1](ch01.html "Chapter 1. Developing
    a Simple Activity"), *Developing a Simple Activity* for "Resource Selection" details).
    Generally you will use a dark outset image for the selected state, since when
    a tab is selected, the tab background is light. For the unselected icon, the opposite
    is true and a light inset image should be used instead.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标签图标通常是简单的形状，而图像大小是正方形（通常最大为 32 x 32 像素）。对于不同像素密度的屏幕，应使用图像的不同变体（详见[第1章](ch01.html
    "第1章. 开发一个简单的活动")，*开发一个简单的活动*关于“资源选择”的细节）。通常，对于选中状态，你会使用深色外凸图像，因为当标签被选中时，标签背景是浅色的。对于未选中的图标，正好相反，应该使用浅色内凹图像。
- en: 'The bitmap images in an Android application should always be in the PNG format.
    Let''s call the selected icon for the **Review** tab `res/drawable/ic_tab_selstar.png`,
    and name the unselected icon file `res/drawable/ic_tab_unselstar.png`. In order
    to switch states between these two images automatically, we define a special `StateListDrawable`
    as an XML file. Hence the **Review** icon is actually in a file named `res/drawable/review.xml`,
    and it looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用程序中的位图图像应始终为 PNG 格式。我们将**评论**标签的选中图标命名为 `res/drawable/ic_tab_selstar.png`，未选中图标文件命名为
    `res/drawable/ic_tab_unselstar.png`。为了自动在这两张图像之间切换状态，我们定义了一个特殊的 `StateListDrawable`
    作为 XML 文件。因此，**评论**图标实际上在一个名为 `res/drawable/review.xml` 的文件中，其看起来像这样：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the `android:constantSize="true"` of the `<selector>` element. By default,
    Android will assume that each state in the resulting `StateListDrawable` object
    will cause the image to be of a different size, which in turn may cause the user
    interface to re-run its layout calculations. This can be fairly expensive, so
    it's a good idea to declare that each of your states is exactly of the same size.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<selector>` 元素的 `android:constantSize="true"` 属性。默认情况下，安卓会假定 `StateListDrawable`
    对象中的每个状态都会导致图像大小不同，进而可能导致用户界面重新运行布局计算。这可能会相当耗时，所以最好声明你的每个状态都是完全相同的大小。
- en: 'For this example, we''ll be using three tab icons, each with two states. The
    icons are named `review`, `photos`, and `book`. Each one is composed of three
    files: A PNG for the selected icon, a PNG for the unselected icon, and an XML
    file defining the state-selector. From our application, we will only make direct
    use of the state-selector XML files, leaving the Android APIs to pickup the actual
    PNG files.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用三个标签图标，每个图标有两种状态。这些图标分别名为`review`、`photos`和`book`。每个图标都由三个文件组成：一个用于选中状态的PNG文件，一个用于未选中状态的PNG文件，以及一个定义状态选择器的XML文件。从我们的应用程序中，我们只需要直接使用状态选择器的XML文件，实际的PNG文件由Android
    API来加载。
- en: Implementing the ReviewActivity
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ReviewActivity
- en: 'As usual, we will want to have localized text in our `strings.xml` file. Open
    the `res/values/strings.xm`l file and copy the following code into it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们希望在我们的`strings.xml`文件中有本地化的文本。打开`res/values/strings.xml`文件，并复制以下代码到它里面：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Time for action – writing the ReviewActivity class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时刻——编写ReviewActivity类
- en: As already said, we will need to set up our tabbed-layout structure in our Java
    code. Fortunately, Android provides a very useful `TabActivity` class that does
    much of the heavy lifting for us, providing us with a ready-made `TabHost` object
    with which we can construct the `Activity` tab structure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要在Java代码中设置我们的标签布局结构。幸运的是，Android提供了一个非常实用的`TabActivity`类，它为我们完成了大部分繁重的工作，提供了一个现成的`TabHost`对象，我们可以用这个对象构建`Activity`的标签结构。
- en: Open the `ReviewActivity.java` file generated earlier in an editor or IDE.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前生成的`ReviewActivity.java`文件，在编辑器或IDE中。
- en: 'Instead of extending `Activity`, change the class to inherit `TabActivity`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要扩展`Activity`，将类改为继承`TabActivity`：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `onCreate` method, remove the `setContentView(R.layout.main)` line (generated
    by the `android create project` utility) completely.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，完全移除`setContentView(R.layout.main)`这一行（由`android create project`工具生成）。
- en: 'Now start by fetching the `TabHost` object from your parent class:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从你的父类中获取`TabHost`对象：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we inflate our layout XML into the content view of the `TabHost`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将布局XML文件加载到`TabHost`的内容视图中：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll need access to our other application resources:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要访问我们应用程序的其他资源：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we define a `TabSpec` for the **Review** tab:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为**Review**标签定义一个`TabSpec`：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Define two more `TabSpec` variables for the **Photos** and **Reservation** tabs
    using the preceding pattern.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的模式为**Photos**和**Reservation**标签定义另外两个`TabSpec`变量。
- en: 'Add each of the `TabSpec` objects to our `TabHost`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个`TabSpec`对象添加到我们的`TabHost`中：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This concludes the creation of the tab structure for the `ReviewActivity` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`ReviewActivity`类的标签结构的创建。
- en: '*What just happened?*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We built a very basic tabbed-layout for our new `ReviewActivity`. When working
    with tabs, we didn't simply use the `Ac` `tivity.setContentView` method, instead
    we inflated the layout XML file ourselves. Then we made use of the `TabHost` object
    provided by the `TabActivity` class to create three `TabSpec` objects. A `TabSpec`
    is a builder object that enables you to build up the content of your tab, similar
    to the way you build up text with a `StringBuilder`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的新`ReviewActivity`构建了一个非常基本的标签布局。在使用标签时，我们并没有简单地使用`Activity.setContentView`方法，而是自己加载了布局XML文件。然后我们使用了`TabActivity`类提供的`TabHost`对象创建了三个`TabSpec`对象。`TabSpec`是一个构建器对象，它允许你构建你的标签内容，类似于使用`StringBuilder`构建文本的方式。
- en: The content of a `TabSpec` is the content-view that will be attached to the
    tab on the screen (assigned using the `setContent` method). In this example, we
    opted for the simplest option and defined the tab content in our `main.xml` file.
    It's also possible to lazy-create the tab content using the `TabHost.TabContentFactory`
    interface, or even to put an external `Activity` (such as the dialer or browser)
    in the tab by using `setContent(Intent)`. However, for the purposes of this example
    we used the simplest option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabSpec`的内容是将会附加到屏幕上标签的内容视图（通过`setContent`方法分配）。在这个例子中，我们选择了最简单的选项，在`main.xml`文件中定义了标签内容。也可以通过使用`TabHost.TabContentFactory`接口懒加载标签内容，或者甚至通过使用`setContent(Intent)`将外部`Activity`（如拨号器或浏览器）放入标签中。但是，为了这个例子的目的，我们使用了最简单的选项。'
- en: You'll notice that the `TabSpec` (much like the `StringBuilder` class) supports
    chaining of method calls, making it easy and flexible to either set up a tab in
    a "single shot" approach (as done previously), or build up the `TabSpec` in stages
    (that is, while loading from an external service).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`TabSpec`（类似于`StringBuilder`类）支持方法调用的链式操作，这使得以“单次设置”方法（如之前所做的）或分阶段构建`TabSpec`（即在从外部服务加载时）变得简单且灵活。
- en: The `indicator` we assigned to the `TabSpec` is what will appear on the tab.
    In the previous case, a string of text and our icon. As of API level 4 (Android
    version 1.6) it's possible to use a `View` object as an `indicator`, allowing
    complete customization of the tab's look and feel. To keep the example simple
    (and compatible with earlier versions) we've supplied a `String` resource as the
    `indicator`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给`TabSpec`的`indicator`是将在标签上显示的内容。在前一个案例中，是一段文本和我们的图标。从API级别4（Android版本1.6）开始，可以使用`View`对象作为`indicator`，允许完全自定义标签的外观和感觉。为了保持示例简单（并与早期版本兼容），我们提供了一个`String`资源作为`indicator`。
- en: Time for action – creating the Review layout
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建评论布局
- en: We've got a skeleton tab structure, but there's nothing in it yet. The first
    tab is titled **Review**, and this is where we are going to start. We've just
    finished enough Java code to load up the tabs and put them on the screen. Now
    we go back to the `main.xml` layout file and populate this tab with some widgets
    that supply the user with review information.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个标签结构的框架，但里面还没有内容。第一个标签标题为**评论**，这就是我们将要开始的地方。我们已经完成了足够的Java代码以加载标签并将它们显示在屏幕上。现在我们回到`main.xml`布局文件，用一些提供用户评论信息的部件填充这个标签。
- en: Open `res/layout/main.xml` in an editor or IDE.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`res/layout/main.xml`。
- en: 'Inside the `<LayoutElement>` that we named `review`, add a new `TextView` that
    will contain the name of the restaurant:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们命名为`review`的`<LayoutElement>`内，添加一个新的`TextView`，它将包含餐厅的名称：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Below the new `TextView`, add a new `RatingBar`, where we will display how
    other people have rated the restaurant:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`TextView`下方，添加一个新的`RatingBar`，我们将在这里显示其他人对餐厅的评分：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Keeping this first tab simple, we add a `TextSwitcher` where we can display
    other people''s comments about the restaurant:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持这个第一个标签简单，我们添加了一个`TextSwitcher`，我们可以在其中显示其他人对餐厅的评论：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The **Review** tab only has three widgets in this example, but more could easily
    be added to allow the user to input their own reviews.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**评论**标签只有三个小部件，但可以轻松添加更多，让用户输入自己的评论。
- en: '*What just happened*'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: We just put together the layout for our first tab. The `RatingBar` that we created
    has a width of `wrap_content`, which is really important. If you use `fill_parent`,
    then the number of stars visible in the `RatingBar` will simply be as many as
    can fit on the screen. If you want control over how many stars appear on your
    `RatingBar`, stick to `wrap_content`, but also make sure that (at least on portrait
    layouts) the `RatingBar` has its own horizontal line. If you install the `Activity`
    in the emulator now, you won't see anything in either the `TextView` or the `TextSwitcher`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为第一个标签组合了布局。我们创建的`RatingBar`具有`wrap_content`的宽度，这非常重要。如果你使用`fill_parent`，则`RatingBar`中可见的星星数量将尽可能多地适应屏幕。如果你想控制`RatingBar`上显示的星星数量，请坚持使用`wrap_content`，但还要确保（至少在竖屏布局上）`RatingBar`有自己的水平线。如果你现在在模拟器中安装`Activity`，你将不会在`TextView`或`TextSwitcher`中看到任何内容。
- en: The `TextSwitcher` has no default animations, so we specify the "in" animation
    as the default `fade_in` as provided by the `android` package, while the "out"
    animation will be `fade_out`. This syntax is used to access resources that can
    be found in the `android.R` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextSwitcher`没有默认动画，因此我们将“进入”动画指定为`android`包提供的默认`fade_in`，而“退出”动画将是`fade_out`。这种语法用于访问可以在`android.R`类中找到的资源。'
- en: Working with switcher classes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切换器类
- en: The `TextSwitcher` we've put in place is used to animate between different `TextView`
    objects. It's really useful for displaying things like changing stock-prices,
    news headlines, or in our case, reviews. It inherits from `ViewSwitcher` which
    can be used to animate between any two generic `View` objects. `ViewSwitcher`
    extends `ViewAnimator` which can be used as a sort of animated `CardLayout`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经放置的`TextSwitcher`用于在不同的`TextView`对象之间进行动画切换。它非常适合显示像股票价格变化、新闻标题或在我们的案例中，评论这样的内容。它继承自`ViewSwitcher`，后者可以用于在任意两个通用`View`对象之间进行动画切换。`ViewSwitcher`扩展了`ViewAnimator`，后者可以用作一种动画`CardLayout`。
- en: We want to display a series of comments from past customers, fading between
    each of them with a short animation. `TextSwitcher` needs two `TextView` objects
    (which it will ask us to create dynamically), for our example. We want these to
    be in a resource file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望展示一系列来自过去客户的评论，并通过简短动画使它们之间渐变。`TextSwitcher` 需要两个 `TextView` 对象（它会要求我们动态创建），在我们的示例中。我们希望这些对象在资源文件中。
- en: 'For the next part of the example, we''ll need some comments. Instead of using
    a web service or something similar to fetch real comments, this example will load
    some comments from its application resources. Open the `res/values/strings.xml`
    file and add `<string-array name="comments">` with a few likely comments in it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了示例的下一部分，我们需要一些评论。而不是使用网络服务或类似的东西来获取真实的评论，这个示例将从其应用程序资源中加载一些评论。打开 `res/values/strings.xml`
    文件，并添加带有一些可能评论的 `<string-array name="comments">`：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Time for action – turning on the TextSwitcher
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——开启 TextSwitcher
- en: We want the `TextSwitcher` to display the next listed comment every five seconds.
    For this we'll need to employ new resources, and a `Handler` object. A `Handler`
    is a way for Android applications and services to post messages between threads,
    and can also be used to schedule messages at a point in the future. It's a preferred
    structure to use over a `java.util.Timer` since a `Handler` object will not allocate
    a new `Thread`. In our case, a `Timer` is overkill, as there is only one task
    we want to schedule.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `TextSwitcher` 每5秒钟显示下一个列出的评论。为此，我们将需要使用新的资源和一个 `Handler` 对象。`Handler`
    是 Android 应用程序和服务之间在线程之间发布消息的方式，也可以用于在将来的某个时间点安排消息。它比 `java.util.Timer` 更受推荐的结构，因为
    `Handler` 对象不会分配新的 `Thread`。在我们的情况下，`Timer` 过于复杂，因为只有一个任务我们想要安排。
- en: Create a new XML file in your `res/layout` directory named `review_comment.xml`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `res/layout` 目录中创建一个名为 `review_comment.xml` 的新 XML 文件。
- en: 'Copy the following code into the new `review_comment.xml` file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到新的 `review_comment.xml` 文件中：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Open the `ReviewActivity.java` file in your editor or IDE.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或 IDE 中打开 `ReviewActivity.java` 文件。
- en: We'll need to be able to load the `review_comment` resources for the `TextSwitcher`,
    so `ReviewActivity` needs to implement the `ViewSwitcher.ViewFactory` interface.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够加载 `TextSwitcher` 的 `review_comment` 资源，所以 `ReviewActivity` 需要实现 `ViewSwitcher.ViewFactory`
    接口。
- en: In order to be update the `TextSwitcher`, we need to interact with a `Handler`,
    and the easiest way to do that here is to also implement `Runnable`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新 `TextSwitcher`，我们需要与一个 `Handler` 交互，在这里最简单的方法是也实现 `Runnable`。
- en: 'At the top of the `ReviewActivity` class, declare a `Handler` object:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ReviewActivity` 类的顶部，声明一个 `Handler` 对象：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll also want to hold a reference to the `TextSwitcher` for our `run()`
    method when we switch comments:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在我们的 `run()` 方法中保留对 `TextSwitcher` 的引用，当我们切换评论时：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to display the comments, we''ll need an array of them, and an index
    to keep track of which comment the `TextSwitcher` is displaying:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示评论，我们将需要一个评论数组，以及一个索引来跟踪 `TextSwitcher` 正在显示哪个评论：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, in the `onCreate` method, after you add the `TabSpec` objects to the `TabHost`,
    read the `comments` string-array from the `Resources`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `onCreate` 方法中，将 `TabSpec` 对象添加到 `TabHost` 之后，从 `Resources` 中读取 `comments`
    字符串数组：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, find the `TextSwitcher` and assign it to the `switcher` field:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到 `TextSwitcher` 并将其分配给 `switcher` 字段：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Tell the `TextSwitcher` that the `ReviewActivity` object will be its `ViewFactory`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 `TextSwitcher`，`ReviewActivity` 对象将是它的 `ViewFactory`：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to comply with the `ViewFactory` specification, we need to write a
    `makeView` method. In our case it''s really simple—inflate the `review_comment`
    resource:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了符合 `ViewFactory` 的规范，我们需要编写一个 `makeView` 方法。在我们的例子中这非常简单——只需膨胀 `review_comment`
    资源：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Override the `onStart` method so that we can post the first timed event on
    the `Handler` object declared earlier:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onStart` 方法，以便我们可以发布之前声明的 `Handler` 对象上的第一个定时事件：
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, override the `onStop` method to cancel any future callback:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，重写 `onStop` 方法以取消任何未来的回调：
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, the `run()` method alternates the comments in the `TextSwitcher`,
    and in the `finally` block, posts itself back onto the `Handler` queue in five
    seconds:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`run()` 方法在 `TextSwitcher` 中交替评论，并在 `finally` 块中，在5秒后将自身重新发布到 `Handler` 队列中：
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using `Handler` objects instead of creating `Thread` objects means all of the
    timed tasks can share the main user interface thread instead of each allocating
    a separate thread. This reduces the amount of memory and CPU load your application
    places on the device, and has a direct impact on the application performance and
    battery life.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Handler`对象而不是创建`Thread`对象意味着所有定时任务可以共享主用户界面线程，而不是各自分配一个单独的线程。这减少了应用程序在设备上占用的内存和CPU负载，对应用程序性能和电池寿命有直接影响。
- en: '*What just happened?*'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么?*'
- en: We just built a simple timer structure to update the `TextSwitcher` with a rotating
    array of comments. The `Handler` class is a convenient way to post messages and
    actions between two application threads. In Android, as with Swing, the user interface
    is not thread-safe, so inter-thread communication becomes very important. A `Handler`
    object attempts to bind itself to the thread it's created in (in the preceding
    case, the `main` thread).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个简单的定时器结构，用旋转的评论数组更新`TextSwitcher`。`Handler`类是在两个应用程序线程之间发布消息和操作的一种便捷方式。在Android中，与Swing一样，用户界面不是线程安全的，因此线程间通信变得非常重要。`Handler`对象试图将自己绑定到创建它的线程（在前面的情况下，是`main`线程）。
- en: It's a prerequisite that a thread which creates a `Handler` object must have
    an associated `Looper` object. You can set this up in your own thread by either
    inheriting the `HandlerThread` class, or using the `Looper.prepare()` method.
    Messages sent to a `Handler` object will be executed by the `Looper` associated
    with the same thread. By sending our `ReviewActivity` (which implements `Runnable`)
    to the `Handler` object that we had created in the `main` thread, we know that
    the `ReviewActivity.run()` method will be executed on the `main` thread, regardless
    of which thread posted it there.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Handler`对象的线程必须有一个关联的`Looper`对象，这是前提条件。你可以在自己的线程中通过继承`HandlerThread`类或使用`Looper.prepare()`方法来设置这个。发送到`Handler`对象的消息将由与同一线程关联的`Looper`执行。通过将我们的`ReviewActivity`（实现了`Runnable`）发送到我们在`main`线程中创建的`Handler`对象，我们知道无论哪个线程发布它，`ReviewActivity.run()`方法都将在`main`线程上执行。
- en: In the case of long-running tasks (such as fetching a web page or a long-running
    calculation), Android provides a class that bares a striking resemblance to the
    `SwingWorker` class, named `AsyncTask`. `AsyncTask` (like `Handler`) can be found
    in the `android.os` package, and you make use of it by inheritance. `AsyncTask`
    is used to allow interaction between a background task and the user interface
    (in order to update a progress bar or similar requirements).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的任务（例如获取网页或长时间的计算），Android提供了一个与`SwingWorker`类惊人相似的类，名为`AsyncTask`。`AsyncTask`（与`Handler`一样）可以在`android.os`包中找到，你可以通过继承来使用它。`AsyncTask`用于允许后台任务与用户界面之间的交互（以更新进度条或类似需求）。
- en: '![What just happened?](img/4484_03_03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_03_03.jpg)'
- en: Creating a simple photo gallery
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的照片画廊
- en: The use of the word `Gallery` is a little misleading, it's really a horizontal
    row of items with a "single item" selection model. For this example we'll be using
    the `Gallery` class for what it does best, displaying thumbnails. However, as
    you'll see, it's capable of displaying scrolling lists of almost anything. Since
    a `Gallery` is a spinner, you work with it in much the same way as a `Spinner`
    object or a `ListView`, that is, with an `Adapter`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gallery`这个词的使用有点误导人，它实际上是一个具有“单选项目”选择模型的水平行项目。在这个例子中，我们将使用`Gallery`类做它最擅长的事情，即显示缩略图。但是，正如你将看到的，它能够显示几乎任何内容的滚动列表。由于`Gallery`是一个微调器，你可以以与`Spinner`对象或`ListView`相同的方式使用它，即使用`Adapter`。'
- en: Time for action – building the Photos tab
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——构建照片标签
- en: Before we can add images to a `Gallery`, we need the `Gallery` object on the
    screen. To start this exercise, we'll add a `Gallery` object and an `ImageView`
    to `FrameLayout` of our tabs. This will appear under the **Photos** tab that we
    created at the beginning of the chapter. We'll stick to a fairly traditional photo
    gallery model of the sliding thumbnails at the top of the screen, with the full
    view of the selected image below it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将图像添加到`Gallery`之前，我们需要在屏幕上有一个`Gallery`对象。为了开始这个练习，我们将向我们的标签中的`FrameLayout`添加一个`Gallery`对象和一个`ImageView`。这将在本章开始时创建的**Photos**标签下显示。我们将坚持使用相对传统的照片画廊模型，在屏幕顶部滑动缩略图，在下面显示选定图像的完整视图。
- en: Open `res/layout/main.xml` in your editor or IDE.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`res/layout/main.xml`。
- en: 'Inside the second `LinearLayout`, with `android:id="@+id/photos"`, add a new
    `Gallery` element to hold the thumbnails:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个`LinearLayout`中，使用`android:id="@+id/photos"`，添加一个新的`Gallery`元素以容纳缩略图：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Gallery` objects, by default, squash their contents together, which really
    doesn''t look great in our case. You can add a little padding between the items
    by using the `spacing` attribute of `Gallery` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`Gallery`对象会将内容挤压在一起，这在我们的案例中看起来并不好。你可以通过使用`Gallery`类的`spacing`属性，在项目之间添加一点内边距：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also have tabs directly above the `Gallery`, and we''ll have an `ImageView`
    directly below it. Again, there won''t be any padding, so add some using a margin:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Gallery`正上方也有标签页，并且在它下面会直接放置一个`ImageView`。同样，这里不会有任何内边距，所以我们需要使用外边距来添加一些空间：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now create an `ImageView` which we can use to display the full-sized image:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个`ImageView`，我们可以用它来显示全尺寸的图片：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to ensure that the full display is scaled correctly, we need to specify
    the `scaleType` on the `ImageView`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保全屏显示能正确缩放，我们需要在`ImageView`上指定`scaleType`：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Gallery` element provides us with the thumbnail track at the top of the
    screen. The image selected in the `Gallery` will be displayed at full-size in
    the `ImageView` widget.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gallery`元素在屏幕顶部为我们提供了缩略图轨道。在`Gallery`中选择的图片将在`ImageView`小部件中以全尺寸显示。'
- en: '*What just happened?*'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just populated the second tab with the standard widgets required for a basic
    photo gallery. This structure is very generic, but is also well known and understood
    by users. The `Gallery` class will handle the thumbnails, scrolling, and selection.
    However, you will need to populate the main `ImageView` with the selected image,
    and provide the `Gallery` object with the thumbnail widgets to display on the
    screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用基本照片画廊所需的标准小部件填充了第二个标签页。这个结构非常通用，但用户也非常熟悉和理解。`Gallery`类将处理缩略图、滚动和选择。但是，你需要将选定的图片填充到主`ImageView`中，并提供`Gallery`对象要在屏幕上显示的缩略图小部件。
- en: The spacing attribute on the `Gallery` element will add some whitespace, which
    serves as a simple separator between thumbnails. You could also add a border into
    each of the thumbnail images, border each `ImageView` widget you return for a
    thumbnail, or use a custom widget to create a border.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gallery`元素上的间距属性将添加一些空白，这作为缩略图之间的简单分隔符。你也可以在每个缩略图图像中添加边框，为返回的每个缩略图`ImageView`小部件添加边框，或者使用自定义小部件创建边框。'
- en: Creating a thumbnail widget
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个缩略图小部件
- en: 'In order to display the thumbnails in the `Gallery` object, we will need to
    create an `ImageView` object for each thumbnail. We could easily do this in Java
    code, but as usual, it is preferable to build even the most basic widgets using
    an XML resource. In this case, create a new XML resource in the `res/layout` directory.
    Name the new file `gallery_thn.xml` and copy the following code into it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`Gallery`对象中显示缩略图，我们需要为每个缩略图创建一个`ImageView`对象。我们可以在Java代码中轻松完成，但像往常一样，即使是最基本的小部件，也最好使用XML资源构建。在这种情况下，在`res/layout`目录中创建一个新的XML资源。将新文件命名为`gallery_thn.xml`，并将以下代码复制到其中：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That's right, it has just two lines of XML, but to reiterate, this allows us
    to customize this widget for many different configurations without editing the
    Java code. While editing the code might not seem like a problem (the resource
    needs to be recompiled anyway), you also don't want to end up with a long series
    of `if` statements to decide on exactly how you should create the `ImageView`
    objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，它只有两行XML，但重申一遍，这允许我们为许多不同的配置自定义此小部件，而无需编辑Java代码。虽然编辑代码可能看起来不是问题（资源需要重新编译），但你也同样不希望最终得到一系列长长的`if`语句来决定如何确切地创建`ImageView`对象。
- en: Implementing a GalleryAdapter
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个 GalleryAdapter
- en: For the example, we'll stick to using application resources to keep things simple.
    We'll have two arrays of resource IDs, thumbnails, and the full-size images. An
    `Adapter` implementation is expected to provide an identifier for each of the
    items. In this next example, we're going to provide an identifier as the resource
    identifier of the full-size image, which gives us easy access to the full-size
    image in classes outside of the `Adapter` implementation. While this is an unusual
    contract, it provides a convenient way for us to pass the image resource around
    within an already defined structure.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，本例我们将继续使用应用资源。我们将有两个资源ID数组，一个是缩略图，另一个是完整尺寸的图片。`Adapter`实现期望为每个项目提供一个标识符。在下一个示例中，我们将提供完整尺寸图像的资源ID作为标识符，这样我们在`Adapter`实现之外的类中可以轻松访问完整尺寸的图像。虽然这是一个不寻常的约定，但它为我们提供了一种在已定义结构内传递图像资源的便捷方式。
- en: In order to display your gallery, you'll need some images to display (mine are
    sized 480 x 319 pixels). For each of these images, you'll need a thumbnail image
    to display in the `Gallery` object. Generally, these should simply be a scaled-down
    version of the actual image (mine are scaled to 128 x 84 pixels).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示你的图库，你需要一些图像进行展示（我的尺寸为480 x 319像素）。对于这些图像中的每一个，你都需要在`Gallery`对象中显示一个缩略图。通常，这些应该是实际图像的缩小版本（我的缩小到128
    x 84像素）。
- en: Time for action – the GalleryAdapter
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——GalleryAdapter
- en: Creating the `GalleryAdapter` is much like the `ListAdapter` classes we created
    in [Chapter 2](ch02.html "Chapter 2. Presenting Data for Views"), *Presenting
    Data for Views*. The `GalleryAdapter` however, will use `ImageView` objects instead
    of `TextView` objects. It also binds two lists of resources together instead of
    using an object model.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`GalleryAdapter`与我们在[第2章](ch02.html "第2章. 为视图提供数据")中创建的`ListAdapter`类非常相似。但是，`GalleryAdapter`将使用`ImageView`对象而不是`TextView`对象。它还将两个资源列表绑定在一起，而不是使用对象模型。
- en: Create a new Java class in your project root package named `GalleryAdapter`.
    It should extend the `BaseAdapter` class.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根包中创建一个新的Java类，名为`GalleryAdapter`。它应该扩展`BaseAdapter`类。
- en: 'Declare an integer array to hold the thumbnail resource IDs:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个整数数组来保存缩略图资源的ID：
- en: '[PRE35]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare an integer array to hold the full-size image resource IDs:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个整数数组来保存完整尺寸图像资源的ID：
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `getCount()` method is simply the length of the `thumbnails` array:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getCount()`方法仅仅是`thumbnails`数组的长度：'
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `getItem(int)` method returns the full-size image resource ID:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getItem(int)`方法返回完整尺寸图像资源的ID：'
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As mentioned earlier, the `getItemId(int)` method returns the full-size image
    resource ID (almost exactly the way that `getItem(int)` does):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，`getItemId(int)`方法返回完整尺寸图像资源的ID（几乎与`getItem(int)`完全一样）：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the `getView(int, View, ViewGroup)` method uses a `LayoutInflater`
    to read and populate the `ImageView` which we created in the `gallery_thn.xml`
    layout resource:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`getView(int, View, ViewGroup)`方法使用`LayoutInflater`读取并填充我们在`gallery_thn.xml`布局资源中创建的`ImageView`：
- en: '[PRE40]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Gallery` class is a subclass of `AdapterView` and so functions in the same
    way as a `ListView` object. The `GalleryAdapter` will provide the `Gallery` object
    with `View` objects to display the thumbnails in.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gallery`类是`AdapterView`的子类，因此其功能与`ListView`对象相同。`GalleryAdapter`将为`Gallery`对象提供`View`对象以显示缩略图。'
- en: '*What just happened*'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: Much like the `Adapter` classes built in the last chapter, the `GalleryAdapter`
    will attempt to reuse any `View` object specified in its `getView` method. A primary
    difference however, is that this `GalleryAdapter` is entirely self-contained,
    and will always display the same list of images.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章构建的`Adapter`类类似，`GalleryAdapter`将尝试重用其`getView`方法中指定的任何`View`对象。然而，一个主要的区别是，这个`GalleryAdapter`是完全自包含的，并且总是显示相同的图像列表。
- en: This example of a `GalleryAdapter` is extremely simple. You could also build
    a `GalleryAdapter` that held bitmap objects instead of resource ID references.
    You'd then make use of the `ImageView.setImageBitmap` method instead of `ImageView.setImageResource`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`GalleryAdapter`的示例非常简单。你也可以构建一个持有位图对象而不是资源ID引用的`GalleryAdapter`。然后你会使用`ImageView.setImageBitmap`方法，而不是`ImageView.setImageResource`。
- en: You could also eliminate the thumbnail images by having the `ImageView` scale
    the full-size images into thumbnails. This would just require a modification to
    the `gallery_thn.xml` resource file in order to specify the required size of each
    thumbnail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过让`ImageView`将全尺寸图片缩放成缩略图来消除缩略图。这将只需要修改`gallery_thn.xml`资源文件，以指定每个缩略图所需的大小。
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `adjustViewBounds` attribute tells the `ImageView` to adjust its own size
    in a way such that it maintains the aspect ratio of the image it contains. We
    also change the `scaleType` attribute to `centerInside`, which will also retain
    the aspect ratio of the image when it scales. Finally, we set a maximum width
    for the `ImageView`. Using the standard `layout_width` or `layout_height` attributes
    is ignored by the `Gallery` class, so we instead specify the desired thumbnail
    size to the `ImageView` (the `layout_width` and `layout_height` attributes are
    handled by the `Gallery`, while the `maxWidth` and `maxHeight` are handled by
    the `ImageView`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjustViewBounds`属性告诉`ImageView`调整自身大小，以保持其中图片的宽高比。我们还改变了`scaleType`属性为`centerInside`，当图片缩放时，这也会保持图片的宽高比。最后，我们为`ImageView`设置了最大宽度。使用标准的`layout_width`或`layout_height`属性会被`Gallery`类忽略，因此我们改为向`ImageView`指定所需缩略图的大小（`layout_width`和`layout_height`属性由`Gallery`处理，而`maxWidth`和`maxHeight`由`ImageView`处理）。'
- en: This would be a standard speed/size trade-off. Having the thumbnail images takes
    up more application space, but having the `ImageView` perform the scaling makes
    the application slower. The scaling algorithm in `ImageView` will also not be
    as high-quality as the scaling performed in an image-manipulation application
    such as Adobe Photoshop. In most cases this won't be a problem, but if you have
    high detail images, you often get "scaling artifacts" with simpler scaling algorithms.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个标准的速度/大小权衡。拥有缩略图会占用更多的应用空间，但让`ImageView`执行缩放会使应用变慢。`ImageView`中的缩放算法也不会像Adobe
    Photoshop这样的图像处理应用中的缩放那样高质量。在大多数情况下这不会是问题，但如果你有高细节的图片，通常使用更简单的缩放算法会出现“缩放失真”。
- en: Time for action – making the gallery work
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——让图库工作起来
- en: Now that we've got the `GalleryAdapter` working, we need to connect the `Gallery`,
    the `GalleryAdapter`, and the `ImageView` together, so that when a thumbnail is
    selected, the full-view of that image is displayed in the `ImageView` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经让`GalleryAdapter`工作起来了，我们需要将`Gallery`、`GalleryAdapter`和`ImageView`连接起来，以便当选择了一个缩略图时，可以在`ImageView`对象中显示该图片的全视图。
- en: Open the `ReviewActivity` source code in your editor or IDE.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`ReviewActivity`源代码。
- en: Add `AdapterView.OnItemSelectedListener` to the interfaces that the `ReviewActivity`
    implements.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReviewActivity`实现的接口中添加`AdapterView.OnItemSelectedListener`。
- en: 'Below the declaration of the `TextSwitcher`, declare a reference to the `ImageView`
    which will hold the full-size image:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextSwitcher`声明下方，声明一个对`ImageView`的引用，该`ImageView`将用于显示全尺寸的图片：
- en: '[PRE42]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At the end of the `onCreate` method, find the `ImageView` named `photo` and
    assign it to the reference you just declared:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法的末尾，找到名为`photo`的`ImageView`并将其分配给你刚刚声明的引用：
- en: '[PRE43]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now fetch the `Gallery` object as declared in the `main.xml` layout resource:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取在`main.xml`布局资源中声明的`Gallery`对象：
- en: '[PRE44]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a new `GalleryAdapter` and set it on the `Gallery` object:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GalleryAdapter`并将其设置在`Gallery`对象上：
- en: '[PRE45]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set the `OnItemSelectedListener` of the `Gallery` object to `this`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Gallery`对象的`OnItemSelectedListener`设置为`this`：
- en: '[PRE46]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the end of the `ReviewActivity` class, add the `onItemSelected` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReviewActivity`类的末尾，添加`onItemSelected`方法：
- en: '[PRE47]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`OnItemSelectedListener` requires an `onNothingSelected` method as well, but
    we don''t need it to do anything for this example.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnItemSelectedListener`还需要一个`onNothingSelected`方法，但对于这个例子，我们不需要它做任何事情。'
- en: The `GalleryAdapter` provides the `ReviewActivity` with the resource to load
    for the full view of the photo through the `id` parameter. The `id` parameter
    could also be used as an index or identifier for a URL if the image was located
    on a remote server.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GalleryAdapter`通过`id`参数为`ReviewActivity`提供加载照片全视图所需的资源。如果图片位于远程服务器上，`id`参数也可以用作索引或标识符。'
- en: '*What just happened?*'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We've now connected the `Gallery` object to the `ImageView` where we will display
    the full-size image instead of the thumbnail. We've used the item ID as a way
    to send the resource ID of the full-size image directly to the event listener.
    This is a fairly strange concept since you'd normally use an object model. However,
    an object model in this example wouldn't just introduce a new class, it would
    also require another method call (in order to fetch the image object from the
    `Adapter` when the event is triggered).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将`Gallery`对象连接到`ImageView`，我们将在其中显示全尺寸图片，而不是缩略图。我们使用了项目ID作为将全尺寸图片的资源ID直接发送到事件监听器的方式。这是一个相当奇怪的概念，因为你通常会使用对象模型。然而，在这个例子中，引入一个对象模型不仅仅会带来一个新类，它还需要在事件触发时从`Adapter`获取图片对象的另一个方法调用。
- en: When you specify an `Adapter` on an `AbsSpinner` class like `Gallery`, it will
    by default attempt to select the first item returned from its new `Adapter`. This
    in turn notifies the `OnItemSelectedListener` object if one has been registered.
    However, because of the single-threading model used by the Android user interface
    objects, this event doesn't get fired immediately, but rather some time after
    we return from the `onCreate` method. When we call `setAdapter(new GalleryAdapter())`
    on the `Gallery` object, it schedules a selection change event, which we then
    receive. The event causes the `ReviewActivity` class to display the first photo
    in the `GalleryAdapter` object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在像`Gallery`这样的`AbsSpinner`类上指定一个`Adapter`时，它会默认尝试选择从其新`Adapter`返回的第一个项目。这进而会通知已注册的`OnItemSelectedListener`对象。然而，由于Android用户界面对象使用的单线程模型，这个事件不会立即触发，而是在我们从`onCreate`方法返回后一段时间触发。当我们在`Gallery`对象上调用`setAdapter(new
    GalleryAdapter())`时，它会安排一个选择变更事件，然后我们收到这个事件。该事件导致`ReviewActivity`类显示`GalleryAdapter`对象中的第一张照片。
- en: If you now reinstall the application in your emulator, you'll be able to go
    to the **Photos** tab and browse through a `Gallery` of all the images that you
    had populated the `GalleryAdapter` with.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在模拟器中重新安装应用程序，你将能够转到**照片**标签，浏览你用`GalleryAdapter`填充的所有图片的`Gallery`。
- en: '![What just happened?](img/4484_03_04.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/4484_03_04.jpg)'
- en: Pop quiz
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: What would happen in the previous example if you substituted `OnItemSelectedListener`
    with `OnItemClickListener` (as done in the `ListView` examples)?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在前一个例子中，你将`OnItemSelectedListener`替换为`OnItemClickListener`（像在`ListView`示例中所做的那样），会发生什么？
- en: The full size won't appear anymore.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全尺寸图片不再出现。
- en: The `Gallery` will not rotate the thumbnails when they are touched.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当触摸缩略图时，`Gallery`不会旋转它们。
- en: The full-size photo won't appear until a thumbnail is clicked.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当点击缩略图时，全尺寸照片才会出现。
- en: What is the primary difference between the `ScaleType` values `fitXY` and `centerInside`?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ScaleType`值`fitXY`和`centerInside`之间的主要区别是什么？'
- en: The `fitXY` type will anchor the picture to the top-left, while `centerInside`
    will center the picture in the `ImageView`.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fitXY`类型会将图片锚定到左上角，而`centerInside`会在`ImageView`中居中图片。'
- en: '`fitXY` will cause the picture to distort to the size of the `ImageView`, while
    `centerInside` will maintain the picture''s aspect ratio.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fitXY`会使图片扭曲到`ImageView`的大小，而`centerInside`将保持图片的宽高比。'
- en: '`centerInside` will cause the larger axis to be cropped in order to fit the
    picture into the `ImageView`, while `fitXY` will scale the picture so that the
    larger axis is of the same size as the `ImageView`.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`centerInside`会使较大的轴被裁剪，以使图片适应`ImageView`，而`fitXY`会缩放图片，使较大轴的大小与`ImageView`相同。'
- en: What dictates the size of a `Gallery` object containing `ImageView` objects
    when using the `wrap_content` attribute?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`wrap_content`属性时，什么决定了包含`ImageView`对象的`Gallery`对象的大小？
- en: The width and height of the `ImageView` objects, as dictated by the size of
    their content image, or their `maxWidth` and `maxHeight` parameters.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ImageView`对象的宽度和高度，由其内容图片的大小，或者它们的`maxWidth`和`maxHeight`参数决定。'
- en: The `itemWidth` and `itemHeight` parameters on the `Gallery` object.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Gallery`对象上的`itemWidth`和`itemHeight`参数。'
- en: The `LayoutParams` set on the `ImageView` objects (either with the `setLayoutParams`
    method, or `layout_width`/`layout_height` attributes).
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置在`ImageView`对象上的`LayoutParams`（通过`setLayoutParams`方法，或者`layout_width`/`layout_height`属性）。
- en: Have a go hero – animations and external sources
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——动画和外部资源
- en: Now that you have the basic example working, try improving the user experience
    a bit. When you touch the images, they should really animate instead of undergoing
    an instant change. They should also come from an external source instead of application
    resources.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经让基本示例运行起来，尝试稍微改善一下用户体验。当你触摸图像时，它们应该真正地动画显示，而不是立即改变。它们也应该来自外部资源，而不是应用程序资源。
- en: Change the `ImageView` object of full-size images to an `ImageSwitcher`, use
    the standard Android fade-in/fade-out animations.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全尺寸图像的`ImageView`对象更改为`ImageSwitcher`，使用标准的Android淡入/淡出动画。
- en: Remove the thumbnail images from the project, and use the `ImageView` declared
    in the `gallery_thn.xml` file to scale the images.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目中移除缩略图，并使用在`gallery_thn.xml`文件中声明的`ImageView`来缩放图像。
- en: Change from a list of application resource IDs to a list of `Uri` objects so
    that the images are downloaded from an external website.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序资源ID列表更改为`Uri`对象列表，以便从外部网站下载图像。
- en: Building the reservation tab
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建预定标签
- en: 'While the **Review** and **Photos** tabs of this example have been concerned
    with displaying information, the **Reservation** tab will be concerned with capturing
    the details of a reservation. We really only need three pieces of information:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子的**评论**和**照片**标签关注的是信息的展示，但**预定**标签将关注于捕获预定的详细信息。我们实际上只需要三部分信息：
- en: The name under which the reservation needs to be made
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定需要用到的名字
- en: The date and time of the reservation
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定的日期和时间
- en: How many people the reservation is for
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定的人数
- en: 'In this part of the example we''ll create several widgets which have formatted
    labels. For example, **How Many People: 2**, which will update the number of people
    as the user changes the value. In order to do this simply, we specify that the
    widget''s text (as specified in the layout file) will contain the format to use
    for display. As part of the initialization procedure, we read the text from the
    `View` object and use it to create a format structure. Once we have a format,
    we populate the `View` with its initial value.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的这部分，我们将创建几个具有格式化标签的小部件。例如，**人数：2**，这将随着用户更改值而更新人数。为了简单地进行这个操作，我们指定小部件的文本（在布局文件中指定）将包含用于显示的格式。作为初始化过程的一部分，我们从`View`对象读取文本，并使用它来创建一个格式结构。一旦有了格式，我们就可以用它的初始值填充`View`。
- en: Time for action – implementing the reservation layout
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——实现预定布局
- en: In our `main.xml` layout resource, we need to add the `View` objects which will
    form the **Reservation** tab. Currently it consists only of an empty `ScrollView`,
    which enables vertically-long layouts to be scrolled by the user if the entire
    user interface doesn't fit on the screen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.xml`布局资源中，我们需要添加将形成**预定**标签的`View`对象。目前它仅包含一个空的`ScrollView`，如果整个用户界面不适合屏幕，这将使用户能够垂直滚动布局。
- en: Open the `main.xml` file in your editor or IDE.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`main.xml`文件。
- en: 'Inside the `<ScrollView>` we had created for the `Reservation` tab earlier.
    Declare a new vertical `LinearLayout` element:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前为`Reservation`标签创建的`<ScrollView>`内。声明一个新的垂直`LinearLayout`元素：
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the new `LinearLayout` element, create a `TextView` to ask the user
    under what name the reservation should be made:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`LinearLayout`元素内，创建一个`TextView`以询问用户预定应使用什么名字：
- en: '[PRE49]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the `TextView` label, create an `EditText` to allow the user to input
    the name under which reservation is to be made:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextView`标签后，创建一个`EditText`以允许用户输入预定的名字：
- en: '[PRE50]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create another `TextView` label to ask the user how many people will be going.
    This includes a format element where we will place the number:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`TextView`标签，询问用户将有多少人参加。这包括一个格式元素，我们将在其中放置数字：
- en: '[PRE51]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a `SeekBar` with which the user can tell us about how many people are going:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`SeekBar`，用户可以通过它告诉我们将有多少人参加：
- en: '[PRE52]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use another `TextView` to ask the user what date the reservation will be on:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一个`TextView`询问用户预定将在哪一天：
- en: '[PRE53]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a `Button` to display the date for which the reservation is made. When
    the user taps this `Button`, we will ask him to select a new date:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Button`以显示预定日期。当用户点击这个`Button`时，我们会请他选择一个新的日期：
- en: '[PRE54]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create another `TextView` label to ask the time of reservation:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`TextView`标签来询问预定时间：
- en: '[PRE55]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add another `Button` to display the time, and allow the user to change it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个`Button`以显示时间，并允许用户更改它：
- en: '[PRE56]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally add a `Button` to make the reservation, and add some margin to separate
    it from the rest of the inputs in the form:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个`Button`以完成预订，并为表单中的其余输入添加一些边距：
- en: '[PRE57]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Several of the preceding widgets include the format of their labels instead
    of the label literal, the actual label will be generated and set in the Java code.
    This is because these labels are subject to change when the user changes date,
    time, or the number of people expected for the reservation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的几个小部件包含了标签的格式而非标签文本，实际的标签将在Java代码中生成和设置。这是因为当用户更改日期、时间或预期预订的人数时，这些标签可能会发生变化。
- en: '*What just happened?*'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In the **Reservation** tab, we ask the user how many people the reservation
    is for, and in order to capture their answer, we make use of a `SeekBar` object.
    The `SeekBar` works in much the same way as a `JSlider` in Swing, and provides
    the user with a way of selecting the number of people for the reservation, as
    long as that number is within a range that we define. `SeekBar` in Android is
    actually built on top of the `ProgressBar` class, and so inherits all of its XML
    attributes, which will seem a little strange at times. Unfortunately, unlike a
    `JSlider` or `JProgressBar`, the `SeekBar` class has no minimum value, and since
    you can't make a reservation for 0 people, we work around this by always adding
    1 to the selected value of the `SeekBar` before display. This means that the default
    value is `1` (setting the displayed value to 2 people).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在**预订**标签中，我们询问用户预订的人数，为了获取他们的答案，我们使用了`SeekBar`对象。`SeekBar`的工作方式与Swing中的`JSlider`非常相似，并为用户提供了一种选择预订人数的方式，只要这个数字在我们定义的范围内即可。Android中的`SeekBar`实际上是建立在`ProgressBar`类之上的，因此继承了其所有XML属性，有时这可能显得有些奇怪。不幸的是，与`JSlider`或`JProgressBar`不同，`SeekBar`类没有最小值，由于你不能为0人预订，我们通过在显示前始终将`SeekBar`的选择值加1来解决这个问题。这意味着默认值是`1`（将显示的值设置为2人）。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most people would make a restaurant reservation for two people, hence the default
    value of `1`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能会为两个人预订餐厅，因此默认值为`1`。
- en: In the **How Many People:** label, we put in a `%d`, which is a `printf` marker
    for where we will put the number of people the reservation is being made for.
    When the `SeekBar` is manipulated by the user, we'll update the label with the
    number the user selects using `String.format`. In the "date" and "time" `Button`
    labels, we want to display the currently selected date and time for the reservation.
    We set the label in the XML file to the format that we want to display this data
    in, and we'll parse it later with a standard `java.text.SimpleDateFormat`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在**人数：**标签中，我们加入了一个`%d`，这是一个`printf`标记，用于放置用户预订的人数。当用户操作`SeekBar`时，我们将使用`String.format`更新标签为用户选择的数字。在“日期”和“时间”`Button`标签中，我们希望显示当前为预订选择的日期和时间。我们在XML文件中设置了要显示此数据的格式，稍后我们将使用标准的`java.text.SimpleDateFormat`解析它。
- en: 'What about internationalization in our previous example? Shouldn''t we have
    put the labels in the `strings.xml` file so that the layout doesn''t need to change?
    The answer is: Yes, if you want to internationalize your user interface. Later,
    make sure you have all of your display text in an application resource file. However,
    I strongly recommend fetching the format strings directly from the layout, since
    it allows you to decouple the format data one additional level.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例中的国际化怎么办？我们不应该把标签放在`strings.xml`文件中，这样布局就不需要改变吗？答案是：是的，如果你想国际化用户界面。稍后，请确保你的所有显示文本都在应用程序资源文件中。然而，我强烈建议直接从布局中获取格式字符串，因为它允许你将格式数据解耦到一个额外的层次。
- en: 'In the preceding layout, you created `Button` widgets to display the date and
    time. Why not use a `DatePicker` and `TimePicker` object directly? The answer
    is: They unfortunately don''t fit well into normal layouts. They take up a large
    amount of vertical space, and don''t scale horizontally. If we placed a `DatePicker`
    and `TimePicker` inline in this user interface, it would look like the following
    screenshot on the left, while the actual user interface is the screenshot on the
    right.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的布局中，你创建了用于显示日期和时间的`Button`小部件。为什么不直接使用`DatePicker`和`TimePicker`对象呢？答案是：不幸的是，它们不适合正常的布局。它们占用了大量的垂直空间，并且不能水平缩放。如果我们在这个用户界面中内联放置一个`DatePicker`和`TimePicker`，它看起来将像左边的截图，而实际的用户界面是右边的截图。
- en: '![What just happened?](img/4484_03_05b.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_03_05b.jpg)'
- en: As you can see, the `Button` objects give a much cleaner user interface. Thankfully,
    Android provides us with a `DatePickerDialog` and `TimePickerDialog` for just
    this sort of situation. When the user taps on one of the `Button` widgets, we'll
    pop up the appropriate dialog and then update the selected `Button` label when
    he approves.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Button`对象提供了一个更整洁的用户界面。值得庆幸的是，Android为我们提供了`DatePickerDialog`和`TimePickerDialog`，正好适用于这种情况。当用户点击其中一个`Button`小部件时，我们会弹出适当的对话框，并在他确认后更新所选`Button`的标签。
- en: While the use of a `Button` and `Dialog` adds at least two more touches to the
    user interface, it dramatically improves the look and feel of the application.
    User interfaces that are not properly aligned will irritate users, even if they
    can't tell why it's irritating. Screens that users find annoying or irritating
    are screens that they will avoid, or worse—simply uninstall.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`Button`和`Dialog`至少增加了用户界面的两次触摸操作，但它极大地改善了应用程序的外观和感觉。如果界面没有正确对齐，用户会感到烦恼，即使他们无法说出为什么感到烦恼。用户觉得讨厌或烦恼的屏幕是他们将避免的，或者更糟的是——直接卸载。
- en: Time for action – initializing the reservation tab
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——初始化预订标签
- en: In the **Reservation** tab we made use of formatted labels. These labels shouldn't
    be displayed to the user as-is, but need to be populated with data before we let
    the user see them. For this, we need to go to our Java code again and build some
    functionality to remember the format, and populate the label.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在**预订**标签中我们使用了格式化的标签。这些标签不应直接显示给用户，但在让用户看到之前需要用数据填充它们。为此，我们需要再次回到Java代码中，构建一些功能来记住格式，并填充标签。
- en: Open the `ReviewActivity` Java source in your editor or IDE.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`ReviewActivity`的Java源文件。
- en: 'Below of all the fields you''ve declared so far, we need to add some more for
    the **Reservations** tab. Declare a `String` to remember the formatting of the
    **How Many People:** label:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你迄今为止声明的所有字段下方，我们需要为**预订**标签添加一些内容。声明一个`String`来记住**人数**标签的格式：
- en: '[PRE58]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then declare a reference to the **How Many People:** label:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后声明一个对**人数**标签的引用：
- en: '[PRE59]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Declare a `SimpleDateFormat` object for the format of the `date Button`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`date Button`的格式声明一个`SimpleDateFormat`对象：
- en: '[PRE60]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare a reference to the `date Button`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明对`date Button`的引用：
- en: '[PRE61]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add another `SimpleDateFormat` for the format of the `time Button`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`time Button`的格式添加另一个`SimpleDateFormat`：
- en: '[PRE62]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, declare a `Button` reference for the `time Button` object:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为`time Button`对象声明一个`Button`引用：
- en: '[PRE63]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At the end of the `onCreate` method, we need to initialize the **Reservations**
    tab. Start by assigning out the `peopleLabel` and fetching the `peopleLabelFormat`
    using the `TextView.getText()` method:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法的末尾，我们需要初始化**预订**标签。首先使用`TextView.getText()`方法分配`peopleLabel`并获取`peopleLabelFormat`：
- en: '[PRE64]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then fetch the `date Button` reference and its label format:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后获取`date Button`的引用及其标签格式：
- en: '[PRE65]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Do the same for the `time Button` and its label format:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`time Button`及其标签格式做同样的操作：
- en: '[PRE66]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we need to populate the `Button` objects with a default date and time,
    and for this we need a `Calendar` object:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要用默认日期和时间填充`Button`对象，为此我们需要一个`Calendar`对象：
- en: '[PRE67]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If it''s later than 4:00p.m., it''s likely that the reservation should be made
    for the next day, so we add one day to the `Calendar` if this is the case:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在是下午4点以后，那么预订很可能应该是在下一天，所以如果这种情况，我们会在`Calendar`中加一天：
- en: '[PRE68]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we set the default time of day for a reservation on the `Calendar` object:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们设置`Calendar`对象上的预订默认时间：
- en: '[PRE69]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Set the label for the `date` and `time` button from the `Calendar` object:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Calendar`对象设置`date`和`time`按钮的标签：
- en: '[PRE70]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we need the `SeekBar` so that we can fetch its default value (as declared
    in the layout application resource):'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要`SeekBar`以便获取其默认值（如布局应用程序资源中声明的那样）：
- en: '[PRE71]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then we can use the label format, and the `SeekBar` value to populate the **How
    Many People** label:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用标签格式和`SeekBar`值来填充**人数**标签：
- en: '[PRE72]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now we have the various formats in which the labels need to be displayed on
    the user interface. This allows us to regenerate the labels when the user changes
    the reservation parameters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了标签需要显示在用户界面上的各种格式。这允许我们在用户更改预订参数时重新生成标签。
- en: '*What just happened?*'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The **Reservations** tab will now be populated with the default data for a reservation,
    and all the formatting in the labels has disappeared. You will probably have noticed
    the many calls to `toString()` in the previous code. Android `View` classes generally
    accept any `CharSequence` for labels. This allows for much more advanced memory
    management than the `String` class, as the `CharSequence` may be a `StringBuilder`,
    or may facade a `SoftReference` to the actual text data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**预订**标签现在将用预订的默认数据填充，并且所有标签中的格式都已消失。你可能已经注意到在之前的代码中有许多对`toString()`的调用。Android的`View`类通常接受任何`CharSequence`作为标签。这比`String`类允许更高级的内存管理，因为`CharSequence`可以是`StringBuilder`，或者可以是实际文本数据的`SoftReference`的门面。'
- en: However, most traditional Java APIs expect a `String`, not a `CharSequence`,
    so we use the `toString()` method to make sure we have a `String` object. If the
    underlying `CharSequence` is a `String` object, the `toString()` method is a simple
    `return this;` (which will act as a type cast).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数传统的Java API期望得到一个`String`，而不是一个`CharSequence`，因此我们使用`toString()`方法以确保我们有一个`String`对象。如果底层的`CharSequence`是一个`String`对象，`toString()`方法就是一个简单的`return
    this;`（这将起到类型转换的作用）。
- en: Again, to work around the fact that the `SeekBar` doesn't have a minimum value,
    we add `1` to its current value in the last line, when we populate the `peopleLabel`.
    While the `date` and `time` formats are stored as a `SimpleDateFormat`, we store
    the `peopleLabelFormat` as a `String` and will run it through `String.format`
    when we need to update the label.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了解决`SeekBar`没有最小值的事实，我们在填充`peopleLabel`的最后一行时，将其当前值加`1`。虽然`date`和`time`格式被存储为`SimpleDateFormat`，但我们将`peopleLabelFormat`存储为`String`，并在需要更新标签时通过`String.format`运行它。
- en: '![What just happened?](img/4484_03_07.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_03_07.jpg)'
- en: Time for action – listening to the SeekBar
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——监听SeekBar
- en: The user interface is now populated with the default data. However, it's not
    interactive at all. If you drag the `SeekBar` the **How Many People:** label will
    remain at its default value of **2**. We need an event listener to update the
    label when the `SeekBar` is used.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 界面现在已用默认数据填充。但是，它根本不具备交互性。如果你拖动`SeekBar`，**人数：**标签将保持在其默认值**2**。我们需要一个事件监听器，在`SeekBar`被使用时更新标签。
- en: Open the `ReviewActivity` Java source in your editor or IDE.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`ReviewActivity`的Java源文件。
- en: Add `SeekBar.OnSeekBarChangeListener` to the interfaces that `ReviewActivity`
    implements.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SeekBar.OnSeekBarChangeListener`添加到`ReviewActivity`实现的接口中。
- en: 'In `onCreate`, after fetching the `SeekBar` with `findViewById`, set its `OnSeekBarChangeListener`
    to `this`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`中，使用`findViewById`获取`SeekBar`之后，将其`OnSeekBarChangeListener`设置为`this`：
- en: '[PRE73]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `onProgressChanged` method to update `peopleLabel`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onProgressChanged`方法以更新`peopleLabel`：
- en: '[PRE74]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Implement an empty `onStartTrackingTouch` method:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个空的`onStartTrackingTouch`方法：
- en: '[PRE75]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Implement an empty `onStopTrackingTouch` method:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个空的`onStopTrackingTouch`方法：
- en: '[PRE76]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `String.format` method is a common method of placing parameters in a localized
    string in Android. While this is rather different to the normal `java.text.MessageFormat`
    class, it's the preferred method in Android (although `MessageFormat` is still
    supported).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.format`方法是Android中在本地化字符串中放置参数的常用方法。虽然这与普通的`java.text.MessageFormat`类有所不同，但在Android中首选这种方法（尽管仍然支持`MessageFormat`）。'
- en: '*What just happened?*'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: When you reinstall the application in the emulator, you'll now be able to use
    `SeekBar` to select the number of people that the reservation is to be made for.
    While we didn't implement the `onStartTrackingTouch` or `onStopTrackingTouch`
    methods, they can be extremely useful if you hide the actual status value by default.
    For example, you could use a `Dialog` containing icons of people to inform the
    user how many people the reservation is for. When they touch the `SeekBar`—display
    the `Dialog`, and then when they release the `SeekBar`—hide the `Dialog` again.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器中重新安装应用程序时，你现在可以使用`SeekBar`来选择预订的人数。尽管我们没有实现`onStartTrackingTouch`或`onStopTrackingTouch`方法，但如果你默认隐藏实际状态值，它们会非常有用。例如，你可以使用一个包含人员图标的`Dialog`来告知用户预订的人数。当他们触摸`SeekBar`时——显示`Dialog`，然后当他们释放`SeekBar`时——再次隐藏`Dialog`。
- en: '![What just happened?](img/4484_03_08.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/4484_03_08.jpg)'
- en: Time for action – selecting date and time
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——选择日期和时间
- en: We've made the `SeekBar` work as expected, but what about the `date` and `time
    Button` widgets? When the users touch them, they expect to be able to select a
    different date or time for their reservation. For this we'll need a good old `OnClickListener`,
    the `DatePickerDialog` and `TimePickerDialog` classes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经让`SeekBar`按预期工作，但`date`和`time Button`控件呢？当用户触摸它们时，他们希望能够为预订选择不同的日期或时间。为此，我们需要一个古老的`OnClickListener`，以及`DatePickerDialog`和`TimePickerDialog`类。
- en: Open the `ReviewActivity` Java source in your editor or IDE again.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在编辑器或IDE中打开`ReviewActivity` Java源文件。
- en: 'Add `View.OnClickListener`, `DatePickerDialog.OnDateSetListener`, and `TimePickerDialog.OnTimeSetListener`
    to the interfaces that `ReviewActivity` implements. Your class declaration should
    now look something like this:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`View.OnClickListener`、`DatePickerDialog.OnDateSetListener`和`TimePickerDialog.OnTimeSetListener`添加到`ReviewActivity`实现的接口中。你的类声明现在应该看起来像这样：
- en: '[PRE77]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Implement a utility method to parse a `CharSequence` into a `Calendar` object
    with a specified `SimpleDateFormat`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个实用方法，用指定的`SimpleDateFormat`将`CharSequence`解析为`Calendar`对象：
- en: '[PRE78]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Open a `try` block to allow handling of parse errors if the `CharSequence` is
    not formatted according to the `SimpleDateFormat`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个`try`块，以便在`CharSequence`不符合`SimpleDateFormat`格式时处理解析错误：
- en: 'Parse the `CharSequence` into a `Date` object:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CharSequence`解析为`Date`对象：
- en: '[PRE79]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then create a new `Calendar` object:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的`Calendar`对象：
- en: '[PRE80]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Set the time on the `Calendar` object to the time in the `Date` object:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Calendar`对象的时间设置为`Date`对象中的时间：
- en: '[PRE81]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Return the parsed `Calendar` object:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回解析后的`Calendar`对象：
- en: '[PRE82]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You''ll need to `catch(ParseException)` in this method. I recommend wrapping
    it in a `RuntimeException` and re-throwing it:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，你需要`捕获(ParseException)`。我建议将其包装在`RuntimeException`中并重新抛出：
- en: '[PRE83]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the `onCreate` method, after setting the labels of the `date` and `time
    Button` widgets, set their `OnClickListener` to `this`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，设置`date`和`time Button`控件的标签后，将它们的`OnClickListener`设置为`this`：
- en: '[PRE84]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Implement the `onClick` method to listen for when the user taps the `date`
    or `time Button`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onClick`方法，以监听用户点击`date`或`time Button`的操作：
- en: '[PRE85]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use the `View` parameter to determine if the clicked `View` is the `date Button`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`View`参数确定点击的`View`是否是`date Button`：
- en: '[PRE86]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If so, use the `parseCalendar` method to parse the current value of the `date
    Button` widget''s label:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，使用`parseCalendar`方法解析`date Button`控件的标签当前值：
- en: '[PRE87]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a `DatePickerDialog` and populate it with the date in the `Calendar`,
    then `show()` the `DatePickerDialog`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`DatePickerDialog`并用`Calendar`中的日期填充它，然后`显示()``DatePickerDialog`：
- en: '[PRE88]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now check if the user has clicked on `View Button` instead of `date`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查用户是否点击了`View Button`而不是`date`：
- en: '[PRE89]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If so, parse a `Calendar` using the `time Button` widget''s label value:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，使用`time Button`控件的标签值解析一个`Calendar`：
- en: '[PRE90]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now create a `TimePickerDialog` with the selected time, then `show()` the new
    `TimePickerDialog` to the user:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个以选定时间为准的`TimePickerDialog`，然后向用户`显示()`新的`TimePickerDialog`：
- en: '[PRE91]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now implement the `onDateSet` method to listen for when the user accepts the
    `DatePickerDialog` with a new date selected:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`onDateSet`方法，以监听用户在选择新日期后接受`DatePickerDialog`的操作：
- en: '[PRE92]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a new `Calendar` instance to populate the date into:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Calendar`实例来填充日期：
- en: '[PRE93]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Set the year, month, and day on the Calendar:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Calendar`上设置年、月和日：
- en: '[PRE94]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Set the label of the `date Button` to the formatted `Calendar`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`date Button`的标签设置为格式化的`Calendar`：
- en: '[PRE95]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Implement the `onTimeSet` method to listen for when the user accepts the `TimePickerDialog`
    after selecting a new time:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onTimeSet`方法，以监听用户在选择新时间后接受`TimePickerDialog`的操作：
- en: '[PRE96]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create a new `Calendar` instance:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Calendar`实例：
- en: '[PRE97]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Set the `Calendar` object''s `hour` and `minute` fields according to the parameters
    given by the `TimePickerDialog`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`TimePickerDialog`给出的参数设置`Calendar`对象的`hour`和`minute`字段：
- en: '[PRE98]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Set the label of the `time Button` by formatting the `Calendar` object:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过格式化`Calendar`对象来设置`time Button`的标签：
- en: '[PRE99]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Having stored the format for the `date` and `time` objects, we can now display
    the values selected by the user in the `Button` widgets. When the user has selected
    a new date or time we update the `Button` labels to reflect the new selections.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 存储了`date`和`time`对象的格式后，我们现在可以在`Button`控件中显示用户选择的值。当用户选择新的日期或时间时，我们更新`Button`标签以反映新的选择。
- en: '*What just happened*'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: If you install and run the application in the emulator, you can now tap on either
    the `date` or `time Button` widgets, and you will be greeted by a modal `Dialog`
    allowing you to select a new value. Beware of overusing modal `Dialog` widgets,
    because they block access to the rest of your application. You should avoid using
    them for displaying status messages as they effectively render the rest of the
    application useless during that time. If you do display a modal `Dialog`, ensure
    that there is some way for the user to dismiss the `Dialog` without any other
    interaction (that is, a **Cancel** button or something similar).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在模拟器中安装并运行应用程序，现在你可以点击`date`或`time Button`组件，你会看到一个模态`Dialog`，允许你选择一个新值。注意不要过度使用模态`Dialog`组件，因为它们会阻止访问应用程序的其他部分。你不应该使用它们来显示状态消息，因为它们在显示期间实际上会使应用程序的其他部分变得无用。如果你确实显示了模态`Dialog`，请确保用户有某种方式可以不进行任何其他交互就关闭`Dialog`（即一个**取消**按钮或类似的东西）。
- en: The first advantage to using a `DatePickerDialog` and `TimePickerDialog` comes
    from the fact that both include **Set** and **Cancel** buttons. This allows the
    user to manipulate the `DatePicker` or `TimePicker`, and then cancel the changes.
    If you used an inline `DatePicker` or `TimePicker` widget, you could provide a
    **Reset** button, but this would take up additional screen space, and generally
    would seem out-of-place (until it's actually needed).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DatePickerDialog`和`TimePickerDialog`的第一个优点在于，两者都包含**设置**和**取消**按钮。这让用户可以操作`DatePicker`或`TimePicker`，然后取消更改。如果你使用内联的`DatePicker`或`TimePicker`组件，你可以提供一个**重置**按钮，但这会占用额外的屏幕空间，并且通常看起来不合适（直到实际需要它）。
- en: Another advantage of the `DatePickerDialog` over the `DatePicker` widget is
    that the `DatePickerDialog` displays a long-format of the selected date in it's
    title area. This long-format date generally includes the day of the week that
    the user has currently selected. The "day of the week" is a field that is noticeably
    missing from the `DatePicker` widget, which makes it surprisingly difficult to
    use. Most people think in terms of "next Thursday", instead of "the 2nd of August,
    2010." Having the day of the week visible makes the `DatePickerDialog` a much
    better choice for date selection than an inline `DatePicker`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePickerDialog`与`DatePicker`组件相比的另一个优点是，`DatePickerDialog`在其标题区域以长格式显示选定的日期。这种长格式的日期通常包括用户当前选择的星期几。从`DatePicker`组件中明显缺失的“星期几”字段，使得它出人意料地难以使用。大多数人会想到“下个星期四”，而不是“2010年8月2日”。让星期几可见使得`DatePickerDialog`比内联的`DatePicker`更适合日期选择。'
- en: '![What just happened](img/4484_03_09b.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么](img/4484_03_09b.jpg)'
- en: Creating complex layouts with Include, Merge, and ViewStubs
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Include、Merge和ViewStubs创建复杂布局
- en: In this chapter we've built a single layout resource with three different tabs
    in it. As a result of this, the `main.xml` file has become quite large and hence,
    more difficult to manage. Android provides several ways in which you can break
    up large layout files (such as this one) into smaller chunks.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个包含三个不同标签的单个布局资源。因此，`main.xml`文件变得相当大，因此更难以管理。Android提供了几种方法，你可以用这些方法将大布局文件（如这个）分解成更小的部分。
- en: Using Include tags
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Include标签
- en: 'The `include` tag is the simplest one to work with. It''s a straight import
    of one layout XML file into another. For our previous example, we could separate
    each tab out into its own layout resource file, and then `include` each one in
    the `main.xml`. The `include` tag has only one mandatory attribute: `layout`.
    This attribute points to the layout resource to be included. This tag is not a
    static or compile-time tag, and so the included layout file will be selected through
    the standard resource selection process. This allows you to have a single `main.xml`
    file, but then add a special `reviews.xml` file (perhaps for Spanish).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`标签是最简单的操作标签。它直接将一个布局XML文件导入另一个。对于我们之前的示例，我们可以将每个标签分离到它自己的布局资源文件中，然后在`main.xml`中`include`每个文件。`include`标签只有一个必填属性：`layout`。这个属性指向要包含的布局资源。这个标签不是静态或编译时的标签，因此包含的布局文件将通过标准的资源选择过程来选择。这允许你有一个单一的`main.xml`文件，但随后可以添加一个特殊的`reviews.xml`文件（可能是西班牙语的）。'
- en: The `layout` attribute on the include tag is **not** prefixed with the `android`
    XML namespace. If you attempt to use the `layout` attribute as `android:layout`,
    you won't get any compile-time errors, but your application will strangely fail
    to run.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`标签上的`layout`属性**不**带有`android` XML命名空间前缀。如果你尝试将`layout`属性用为`android:layout`，你不会得到编译时错误，但你的应用程序将奇怪地无法运行。'
- en: 'The `include` element can also be used to assign or override several attributes
    of the root included element. These include the element `android:id`, and any
    of the `android:layout` attributes. This allows you to reuse the same layout file
    in several parts of your application, but with different layout attributes and
    a different ID. You can even `include` the same layout file several times on the
    same screen, but with a different ID for each instance. If we were to change our
    `main.xml` file to include each of the tabs from other layout resources, the file
    would look something more like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`元素还可以用来分配或覆盖所包含根元素的多个属性。这些属性包括元素`android:id`以及任何`android:layout`属性。这允许你在应用程序的多个部分重用同一个布局文件，但具有不同的布局属性和不同的ID。你甚至可以在同一屏幕上多次`include`同一个布局文件，但每个实例都有一个不同的ID。如果我们更改`main.xml`文件以包含来自其他布局资源的每个标签，文件看起来会更像这样：'
- en: '[PRE100]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Merging layouts
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并布局
- en: The `include` element is very fine and well when you want to include a single
    `View` or `ViewGroup` into a larger layout structure. However, what if you want
    to include multiple elements into a larger layout structure, without implying
    the need for a root element in the included structure? In our example each tab
    needs a single root `View` in order that each tab carries a single and unique
    ID reference.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将单个`View`或`ViewGroup`包含到更大的布局结构中时，`include`元素是非常好用的。但是，如果你想在不暗示所包含结构中需要根元素的情况下，将多个元素包含到更大的布局结构中呢？在我们的示例中，每个标签都需要一个单一的根`View`，以便每个标签携带单一且唯一的ID引用。
- en: 'However, having an additional `ViewGroup` just for the sake of an `include`
    can adversely affect the performance of large layout trees. In this case, the
    `merge` tag comes to the rescue. Instead of declaring the root element of a layout
    as a `ViewGroup`, you can declare it as `<merge>`. In this case, each of `View`
    objects in the included layout XML will become direct children of the `ViewGroup`
    that includes them. For example, if you had a layout resource file named `main.xml`,
    with a `LinearLayout` that included a `user_editor.xml` layout resource, then
    the code would look something like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅为了`include`而增加一个额外的`ViewGroup`可能会对大型布局树的性能产生不利影响。在这种情况下，`merge`标签可以提供帮助。你可以将布局的根元素声明为`<merge>`，而不是声明为`ViewGroup`。在这种情况下，所包含布局XML中的每个`View`对象都会成为包含它们的`ViewGroup`的直接子项。例如，如果你有一个名为`main.xml`的布局资源文件，其中包含一个`LinearLayout`，该`LinearLayout`又包含了`user_editor.xml`布局资源，那么代码看起来会像这样：
- en: '[PRE101]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The simple implementation of the `user_editor.xml` looks something like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_editor.xml`的简单实现看起来像这样：'
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'However, when this is included into the `main.xml` file, we embed the `user_editor.xml
    LinearLayout` into the `main.xml LinearLayout`, resulting in two `LinearLayout`
    objects with identical layout attributes. Obviously it would be much better to
    simply put the `TextView` and `EditView` from `user_editor.xml` directly into
    the `main.xml LinearLayout` element. This is exactly what the `<merge>` tag is
    used for. If we now re-write the `user_editor.xml` file using the `<merge>` tag
    instead of a `LinearLayout`, it looks like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这个被包含进`main.xml`文件时，我们将`user_editor.xml`的`LinearLayout`嵌入到`main.xml`的`LinearLayout`中，导致有两个具有相同布局属性的`LinearLayout`对象。显然，直接将`user_editor.xml`中的`TextView`和`EditView`放入`main.xml`的`LinearLayout`元素中会更好。这正是`<merge>`标签的用途。如果我们现在使用`<merge>`标签而不是`LinearLayout`来重写`user_editor.xml`文件，它看起来会像这样：
- en: '[PRE103]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that we no longer have the `LinearLayout` element, instead the `TextView`
    and `EditView` will be added directly to the `LinearLayout` in the `main.xml`
    file. Beware of layouts that have too many nested `ViewGroup` objects, as they
    are almost certain to give trouble (more than about ten levels of nesting is likely
    to cause your application to crash!). Also be careful with layouts that have too
    many `View` objects. Again, more than 30 is very likely to cause problems or make
    your application crash.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不再有`LinearLayout`元素，取而代之的是`TextView`和`EditView`将直接添加到`main.xml`文件中的`LinearLayout`。要小心那些嵌套了过多`ViewGroup`对象的布局，因为它们几乎肯定会引起问题（超过大约十级嵌套很可能会导致你的应用程序崩溃！）。同时也要注意那些含有过多`View`对象的布局。同样，超过30个很可能会引起问题或使你的应用程序崩溃。
- en: Using the ViewStub class
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ViewStub 类
- en: When you load a layout resource that includes another layout, the resource loader
    will immediately load the included layout into the memory, in order to attach
    it to the layout you've requested. When `main.xml` is read in by the `LayoutInflator`,
    so are the `reviews.xml`, `photos.xml`, and `reservations.xml` files. In situations
    with very large layout structures, this can consume a huge amount of your application
    memory, and even cause your application to crash. The Android API includes a specialized
    `View` named `ViewStub` which allows lazy-loading of layout resources.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载包含另一个布局的布局资源时，资源加载器会立即将包含的布局加载到内存中，以便将其附加到你请求的布局中。当 `main.xml` 被 `LayoutInflator`
    读取时，`reviews.xml`、`photos.xml` 和 `reservations.xml` 文件也会被读取。在具有非常大型布局结构的情况下，这可能会消耗大量的应用程序内存，甚至可能导致应用程序崩溃。Android
    API 包含一个名为 `ViewStub` 的专用 `View`，它允许延迟加载布局资源。
- en: A `ViewStub` is by default a zero-by-zero sized empty `View`, and when it's
    specialized, `inflate()` method is invoked. It loads the layout resource and replaces
    itself with the loaded `View` objects. This process allows the `ViewStub` to be
    garbage-collected as soon as its `inflate()` method has been called.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ViewStub` 是一个零大小（0x0）的空 `View`，当调用其专门的 `inflate()` 方法时，它会加载布局资源并替换为加载的
    `View` 对象。这个过程允许一旦调用了 `inflate()` 方法，`ViewStub` 就可以被垃圾回收。
- en: If we were to make use of a `ViewStub` in the example, you would need to lazy-initialize
    the content of a tab when it is selected by the user. This also means that none
    of the `View` objects in a tab would exist until that tab has been selected. While
    using a `ViewStub` is a bit more work than a straight `include`, it can allow
    you to work with much larger and more complex layout structures than would otherwise
    be possible.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的示例中使用 `ViewStub`，那么当用户选择一个标签页时，你需要延迟初始化该标签页的内容。这也意味着，在标签页被选中之前，该标签页中的任何
    `View` 对象都不存在。虽然使用 `ViewStub` 比直接使用 `include` 要多做一些工作，但它可以让你处理比其他情况下更大的、更复杂的布局结构。
- en: 'Any layout attributes set on a `ViewStub` will be passed on to its inflated
    `View` object. You can also assign a separate ID to the inflated layout. If we
    wanted to include each of our tabs in a `ViewStub`, the `main.xml` file would
    look something like this:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewStub` 上设置的任何布局属性都将传递给其展开的 `View` 对象。你也可以为展开的布局分配一个单独的ID。如果我们想在每个标签页中使用
    `ViewStub`，那么 `main.xml` 文件看起来会像这样：
- en: '[PRE104]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note that unlike the `include` tag, the `ViewStub` requires the `android` XML
    namespace for its `layout` attribute. After you `inflate()` one of the `ViewStub`
    objects, it will no longer be available by its original `android:id` reference.
    Instead, you will be able to access the inflated layout object using the `android:inflatedId`
    reference.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `include` 标签不同，`ViewStub` 需要使用 `android` XML 命名空间为其 `layout` 属性。当你对一个 `ViewStub`
    对象执行 `inflate()` 操作后，它将不再可以通过原来的 `android:id` 引用访问。相反，你可以使用 `android:inflatedId`
    引用来访问被展开的布局对象。
- en: Have a go hero – separate the tabs
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战英雄——分离标签页
- en: Extract each of the tabs into its own layout resource file, and use the `include`
    tag to load each of them. This shouldn't require any changes to the Java source
    code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个标签页提取到自己的布局资源文件中，并使用 `include` 标签加载它们。这不需要对 Java 源代码进行任何更改。
- en: For more of a challenge, try using `ViewStub` objects instead of the `include`
    tag. This will require you to break up the `onCreate` method and listen for when
    tabs are clicked. For this you'll need to use `TabHost.OnTabChangeListener` to
    know when to load a specific tab's content.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具挑战性，尝试使用 `ViewStub` 对象代替 `include` 标签。这将要求你分解 `onCreate` 方法，并监听标签页被点击的时候。为此，你需要使用
    `TabHost.OnTabChangeListener` 来知道何时加载特定标签页的内容。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Tabs are a great way of breaking an `Activity` into different areas of work.
    With limited screen real estate, they are a great way to make an `Activity` more
    accessible to the user. They also have a performance impact since only one tab
    is rendered on the screen at a time.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 标签页是将 `Activity` 分割成不同工作区域的好方法。在屏幕空间有限的情况下，它们是使 `Activity` 对用户更具可访问性的好方法。由于一次只渲染一个标签页，它们也具有性能影响。
- en: The `RatingBar` and `SeekBar` are two different methods of capturing, or displaying
    numeric data to the user. While they are closely related, and both function in
    the same way, each class is used to address different types of data. Keep in mind
    the limitations of both of these, before deciding whether and where to use them.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`RatingBar` 和 `SeekBar` 是两种不同的捕获或向用户显示数值数据的方法。尽管它们密切相关，并且功能方式相同，但每个类用于处理不同类型的数据。在决定是否以及在哪里使用它们之前，要考虑到这两个类的局限性。'
- en: The `Gallery` class is brilliant for allowing the user to view a large number
    of different objects. While in this example we used it to simply display thumbnails,
    it could be used as a replacement for tabs in a web browser by displaying a list
    of page thumbnails above the actual browser view. All you need to do to customize
    its function is to change the `View` objects returned from the `Adapter` implementation.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gallery` 类非常出色，允许用户查看大量不同的对象。尽管在这个例子中我们仅用它来显示缩略图，但它可以用作网页浏览器中标签的替代品，通过在浏览器视图上方显示页面缩略图列表。要自定义其功能，你所需要做的就是更改从
    `Adapter` 实现中返回的 `View` 对象。'
- en: When it comes to date and time capturing, try to stick to using the `DatePickerDialog`
    and `TimePickerDialog` instead of their inline counterparts (unless you have good
    reason). The use of these `Dialog` widgets helps you conserve screen space and
    improve the user experience. When they open a `DatePickerDialog` or `TimePickerDialog`,
    they have better access to the editor than you can generally provide as part of
    your user interface (especially on a device with a small screen).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到日期和时间捕获时，尽量坚持使用 `DatePickerDialog` 和 `TimePickerDialog`，而不是它们内联的对应物（除非你有充分的理由）。使用这些
    `Dialog` 小部件可以帮助你节省屏幕空间并提升用户体验。当他们打开 `DatePickerDialog` 或 `TimePickerDialog` 时，他们可以比你在用户界面中通常提供的编辑器更好地访问编辑器（特别是在屏幕较小的设备上）。
- en: In the next chapter, we'll take a closer look at `Intent` objects, the activity
    stack, and the lifecycle of an Android application. We'll investigate how `Intent`
    objects and the activity stack can be used as a way to keep applications more
    usable. Also, we shall learn about improving the reuse of `Activity` classes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地了解 `Intent` 对象、活动堆栈以及 Android 应用程序的生命周期。我们将研究如何使用 `Intent` 对象和活动堆栈作为一种使应用程序更具可用性的方法。同时，我们也将学习如何提高
    `Activity` 类的重用性。
