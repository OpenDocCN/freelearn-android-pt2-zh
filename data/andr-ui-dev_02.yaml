- en: Chapter 2. Presenting Data for Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。视图的数据展示
- en: '*In the first chapter we covered the basic creation of a project, and how to
    put together a simple user interface. We backed our first `Activity` with enough
    code to dynamically generate some buttons that the user can use to answer our
    multiple-choice questions.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在第1章中，我们介绍了如何创建一个项目，以及如何构建一个简单的用户界面。我们为第一个`Activity`编写了足够的代码，以动态生成用户可以用来回答我们的多项选择题的按钮。*'
- en: '*So now we can capture some data, but what about displaying data? One large
    advantage of software is its ability to present and filter very large volumes
    of data quickly and in an easy-to-read format. In this chapter we will look at
    a series of Android widgets that are designed exclusively for presenting data.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在我们已经可以捕获一些数据了，但如何显示数据呢？软件的一大优势是它能快速并以易于阅读的格式呈现和筛选大量数据。在本章中，我们将介绍一系列专门用于展示数据的安卓控件。*'
- en: Most Android data-centric classes are built on top of `Adapter` objects, and
    thus extend the `AdapterView` . An `Adapter` can be thought of as a cross between
    a Swing Modelclass, and a renderer (or presenter). An `Adapter` object is used
    to create `View` objects for data objects that your software needs to display
    to the user. This pattern allows the software to maintain and work with a data-model
    and only create a graphical `View` for each of the data objects when one is actually
    needed. This doesn't just help conserve memory, but it is also more logical from
    a development point of view. As a developer you work with your own data objects
    instead of trying to keep your data in graphical widgets (which are often not
    the most robust of structures).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数以数据为中心的安卓类都是建立在`Adapter`对象之上的，因此扩展了`AdapterView`。可以将`Adapter`视为Swing Model类和渲染器（或呈现器）之间的交叉。`Adapter`对象用于为软件需要向用户显示的数据对象创建`View`对象。这种模式允许软件维护并处理数据模型，并且只在需要时为每个数据对象创建图形`View`。这不仅有助于节省内存，而且从开发角度来看也更合逻辑。作为开发者，您处理自己的数据对象，而不是试图将数据保存在图形小部件中（这些小部件通常不是最健壮的结构）。
- en: 'The most common `AdapterView` classes you''ll encounter are: `ListView`, `Spinner`
    , and `GridView` . In this chapter we''ll introduce the `ListView` class and `GridView`,
    and explore the various ways they can be used and how they can be styled.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您最常遇到的`AdapterView`类有：`ListView`，`Spinner`和`GridView`。在本章中，我们将介绍`ListView`类和`GridView`，并探讨它们的各种使用方式和样式设置。
- en: Listing and selecting data
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和选择数据
- en: The `ListView` class is probably the most common way to display lists of data.
    It's backed by a `ListAdapter` object, which is responsible for both holding the
    data and rendering the data objects in a `View`. A `ListView` includes built-in
    scrolling, so there's no need to wrap it in a `ScrollView`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`类可能是显示数据列表的最常见方式。它由`ListAdapter`对象支持，后者负责保存数据并渲染数据对象在`View`中的显示。`ListView`内置了滚动功能，因此无需将其包裹在`ScrollView`中。'
- en: ListView choice modes
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ListView选择模式
- en: 'The `ListView` class allows for three basic modes of item selection, as defined
    by its constants: `CHOICE_MODE_NONE`, `CHOICE_MODE_SINGLE`, and `CHOICE_MODE_MULTIPLE`.
    The mode for a `ListView` can be set by using the `android:choiceMode` attribute
    in your layout XML file, or by using the `ListView.setChoiceMode` method in Java.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`类支持三种基本的项选择模式，由其常量定义：`CHOICE_MODE_NONE`，`CHOICE_MODE_SINGLE`和`CHOICE_MODE_MULTIPLE`。可以通过在布局XML文件中使用`android:choiceMode`属性，或者在Java中使用`ListView.setChoiceMode`方法来设置`ListView`的选择模式。'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Choice modes and items**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择模式和项目**'
- en: The choice mode of a `ListView` changes the way the `ListView` structure behaves,
    but not the way it looks. The look of a `ListView` is defined mostly by the `ListAdapter`,
    which provides `View` objects for each of the items that should appear in the
    `ListView`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`的选择模式改变了`ListView`结构的行为方式，但不会改变其外观。`ListView`的外观主要由`ListAdapter`定义，后者为应该出现在`ListView`中的每个项目提供`View`对象。'
- en: No selection mode – CHOICE_MODE_NONE
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无选择模式 - CHOICE_MODE_NONE
- en: On a desktop system, this would make no sense—a list that doesn't allow the
    user to choose anything? However, it's the default mode of an Android `ListView`.
    The reason is it makes sense when your user is navigating by touch. The default
    mode of a `ListView` allows the user to tap on one of the elements, and trigger
    an action. As a result of this behavior, there's no need for a "Next" button,
    or anything similar. So the default mode for a `ListView` is to act like a menu.
    The following screenshot is a default `ListView` object displaying a list of different
    strings from a `String` array Java object, taken from one of the default `ApiDemos`
    examples in Android SDK.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面系统中，这种情况没有意义——一个不允许用户选择任何内容的列表？然而，这是Android `ListView` 的默认模式。原因是当用户通过触摸导航时，这很有意义。`ListView`
    的默认模式允许用户点击其中一个元素，并触发一个动作。这种行为的结果是，无需“下一步”按钮或类似的东西。因此，`ListView` 的默认模式是表现为一个菜单。以下截图显示了一个默认的
    `ListView` 对象，它从一个默认的 `ApiDemos` 示例中的 `String` 数组 Java 对象中展示不同的字符串列表。
- en: '![No selection mode – CHOICE_MODE_NONE](img/4484_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![无选择模式 —— CHOICE_MODE_NONE](img/4484_02_01.jpg)'
- en: Single selection mode – CHOICE_MODE_SINGLE
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单选模式 —— CHOICE_MODE_SINGLE
- en: In this mode, the `ListView` acts more like a desktop `List` widget. It has
    the notion of the current selection, and tapping on a list item does nothing more
    than selecting it. This behavior is nice for things like configuration or settings,
    where the user expects the application to remember his or her current selection.
    Another place a single selection list becomes useful is when there are other interactive
    widgets on the screen. However, be careful not to put too much information in
    a single `Activity`. It's quite common for a `ListView` to occupy almost an entire
    screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式下，`ListView` 更像是一个桌面 `List` 小部件。它有当前选择的概念，点击列表项仅仅会选中它，不会再有其他动作。这种行为对于配置或设置等操作很合适，用户希望应用程序记住他们当前的选择。单选列表在屏幕上有其他交互式小部件时也很有用。但是，要注意不要在单个
    `Activity` 中放置太多信息。`ListView` 占据几乎整个屏幕是很常见的。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Single-choice selection: It doesn''t directly change the way your list items
    appear. The look and feel of your list items is defined entirely by the `ListAdapter`
    object.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单选模式：它不会直接改变你的列表项的外观。你的列表项的外观完全由 `ListAdapter` 对象定义。
- en: 'Android does, however, provide a collection of sensible defaults in the system
    resources. In the `android` package you will find an `R` class. It''s a programmatic
    way to access the system''s default resources. If you wanted to create a single-choice
    `ListView` with a `<string-array>` of colors in it, you could use the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Android确实在系统资源中提供了一系列合理的默认值。在 `android` 包中，你会发现一个 `R` 类。这是访问系统默认资源的编程方式。如果你想创建一个带有
    `<string-array>` 颜色列表的单选 `ListView`，你可以使用以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case we use the provided `ArrayAdapter` class from the `android.widget`
    package. In the second parameter we referenced the Android layout resource named
    `simple_list_item_single_choice`. This resource is defined by the Android system
    as a default way to display items in a `ListView` with `CHOICE_MODE_SINGLE`. Most
    typically this is a label with a `RadioButton` for each object in the `ListAdapter`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们使用了 `android.widget` 包中提供的 `ArrayAdapter` 类。在第二个参数中，我们引用了名为 `simple_list_item_single_choice`
    的Android布局资源。这个资源被Android系统定义为在 `CHOICE_MODE_SINGLE` 模式下显示 `ListView` 项的默认方式。通常这是一个带有
    `RadioButton` 的标签，对应 `ListAdapter` 中的每个对象。
- en: '![Single selection mode – CHOICE_MODE_SINGLE](img/4484_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![单选模式 —— CHOICE_MODE_SINGLE](img/4484_02_02.jpg)'
- en: Multiple selection mode – CHOICE_MODE_MULTIPLE
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多选模式 —— CHOICE_MODE_MULTIPLE
- en: 'In multi-selection mode, the `ListView` replaces the radio buttons of single-selection
    mode with normal checkboxes. This design structure is often used on desktops and
    web-based systems as well. Checkboxes are easily recognized by users, and make
    it easy to go back and turn options off again. If you wish to use a standard `ListAdapter`,
    Android provides you with the `android.R.layout.simple_list_item_multiple_choice`
    resource as a useful default: A label with a `CheckBox` for each object in the
    `ListAdapter`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在多选模式下，`ListView` 用普通的复选框替换单选模式中的单选按钮。这种设计结构在桌面和基于Web的系统中也经常使用。复选框容易被用户识别，也便于返回并关闭选项。如果你希望使用标准的
    `ListAdapter`，Android为你提供了 `android.R.layout.simple_list_item_multiple_choice`
    资源作为有用的默认选项：每个 `ListAdapter` 中的对象都有一个带有 `CheckBox` 的标签。
- en: '![Multiple selection mode – CHOICE_MODE_MULTIPLE](img/4484_02_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![多选模式 —— CHOICE_MODE_MULTIPLE](img/4484_02_03.jpg)'
- en: Adding header and footer widgets
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加头部和底部控件
- en: 'Headers and footers in a `ListView` allow you to put additional widgets at
    the top and bottom of the `List`. The header and footer widgets are by default
    treated as though they are items in a list (as though they come from your `ListAdapter`).
    This means that you will be able to select them as though they are data elements
    in the `List` structure. A very simple example of a header item could be:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`中的头部和底部允许你在列表的顶部和底部放置额外的控件。默认情况下，头部和底部控件被视为列表中的项（就像它们来自你的`ListAdapter`一样）。这意味着你可以像选择`List`结构中的数据元素一样选择它们。一个简单的头部项示例可能是：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Often you don''t want your headers and footers to be items in the `ListView`,
    but instead a label or group of labels identifying parts of the `ListView`, or
    providing other information. In this case you need to tell the `ListView` that
    your header or footer views are not selectable list items. This can be done by
    using the extended implementation of `addHeaderView` or `addFooterView`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不想让`ListView`中的头部和底部成为列表项，而是一个标签或一组标签，标识`ListView`的各个部分，或提供其他信息。在这种情况下，你需要告诉`ListView`，你的头部或底部视图不是可选的列表项。这可以通过使用`addHeaderView`或`addFooterView`的扩展实现来完成：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ListView` class integrates headers and footers so tightly into the list
    structure that you can also provide an `Object` that it will return from the `Ad`
    `apterView.getItemAtPosition(index)` method. In our previous example we have provided
    `null`. Each header item will offset the index of subsequent views by one (as
    though you are adding new items to the `ListView`). The third parameter tells
    the `ListView` whether the header or footer should be counted as a selectable
    list item (in our previous example it shouldn't).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`类将头部和底部与列表结构紧密集成，因此你也可以提供一个`Object`，它将通过`AdapterView.getItemAtPosition(index)`方法返回。在我们之前的示例中，我们提供了`null`。每个头部项都会将后续视图的索引偏移一个（就像你向`ListView`添加新项一样）。第三个参数告诉`ListView`是否应将头部或底部视为可选择的列表项（在我们之前的示例中不应该）。'
- en: If you are used to desktop widgets, the header and footer widgets on an Android
    `ListView` will have a bit of a surprise for you. They will scroll with the rest
    of the list items, and won't stay attached to the top and bottom of the `ListView`
    object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了桌面控件，那么Android `ListView`上的头部和底部控件可能会让你有点惊讶。它们会随着列表中的其他项一起滚动，而不会固定在`ListView`对象的顶部和底部。
- en: Creating a simple ListView
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的ListView
- en: To introduce the `ListView` class, we'll start a new example which will be enhanced
    by various subsequent sections of this chapter. The first `Activity` we will create
    will use a simple `ListView` populated from a `<string-array>` resource.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍`ListView`类，我们将开始一个新示例，该示例将通过本章的后续各个部分进行增强。我们将创建的第一个`Activity`将使用从`<string-array>`资源填充的简单`ListView`。
- en: Time for action – creating a fast food menu
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建快餐菜单
- en: To continue with the food and eating theme, let's build a simple application
    that allows us to order various types of fast food, and get it delivered! The
    user will first select where they want to order from, and then select the various
    foodstuffs that they want to eat.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的食物与饮食主题，让我们构建一个简单的应用程序，允许我们订购各种类型的快餐，并送到家！用户首先会选择他们想订购的餐厅，然后选择他们想吃的各种食物。
- en: 'Create a new `android` project using the Android command-line tool:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android命令行工具创建一个新的`android`项目：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the `/res/values/strings.xml` file in your favorite editor or IDE.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器或IDE打开`/res/values/strings.xml`文件。
- en: 'Create a string-array structure listing the various fast-food restaurants our
    users can order from:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串数组结构，列出用户可以订购的各种快餐餐厅：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the `/res/layout/main.xml` file in your favorite editor or IDE.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器或IDE打开`/res/layout/main.xml`文件。
- en: Remove any widget that is inside the default `LinearLayout`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除默认`LinearLayout`中的任何控件。
- en: Add a new `<ListView>` element.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`<ListView>`元素。
- en: 'Assign the `<ListView>` element an ID of `restaurant`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`<ListView>`元素的ID设置为`restaurant`：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assign the width and height of the `ListView` to `fill_parent`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ListView`的宽度和高度设置为`fill_parent`：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we have a string-array resource of the content we want to populate the
    `ListView` with, we can reference it directly in our layout XML file:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有一个包含我们想要填充`ListView`内容的字符串数组资源，我们可以在布局XML文件中直接引用它：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you''ve completed the specified steps, you should have a `main.xml` layout
    file that looks like the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成指定步骤后，你应该会得到一个看起来像下面的`main.xml`布局文件：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened*'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: If you install your application into the emulator, and run it, you'll be presented
    with a screen where you can select from the list of restaurants specified in your
    string-array resource. Notice that the `choiceMode` on the `ListView` is left
    as `CHOICE_MODE_NONE`, making this into a more direct menu where the user selects
    their restaurant and is instantly transported to its menu.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用程序安装到模拟器中并运行它，你将看到一个屏幕，你可以从中选择在你字符串数组资源中指定的餐厅列表。请注意，`ListView`上的`choiceMode`设置为`CHOICE_MODE_NONE`，这使得它更像是一个直接菜单，用户选择餐厅后，可以立即跳转到该餐厅的菜单。
- en: '![What just happened](img/4484_02_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么](img/4484_02_04.jpg)'
- en: In this example, we used the `android:entries` attribute in the layout XML file
    to specify a reference to a string-array resource with our desired list items
    in it. Normally, using an `AdapterView` requires you to create an `Adapter` object
    to create `View` objects for each of the data objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在布局XML文件中使用了`android:entries`属性，指定了一个引用字符串数组资源的引用，其中包含我们想要的列表项。通常，使用`AdapterView`需要你创建一个`Adapter`对象，为每个数据对象创建`View`对象。
- en: 'Using the `android:entries` attribute allows you to specify the data contents
    of the `ListView` from your layout resource, instead of requiring you to write
    the normal Java code associated with an `AdapterView`. It, however, does have
    two disadvantages to be aware of:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`android:entries`属性允许你从布局资源中指定`ListView`的数据内容，而不是要求你编写与`AdapterView`相关的正常Java代码。然而，它有两个需要注意的缺点：
- en: The `View` objects created by the generated `ListAdapter` will always be the
    system-specified defaults, and so cannot be easily themed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由生成的`ListAdapter`创建的`View`对象将始终是系统指定的默认值，因此不容易进行主题设置。
- en: You cannot define data objects that will be represented in the `ListView`. Since
    string-arrays are easily localized, your application will rely on the index locations
    of items to determine what they indicate.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能定义将在`ListView`中表示的数据对象。由于字符串数组容易本地化，你的应用程序将依赖于项目索引位置来确定它们表示的内容。
- en: 'You may notice that at the top of the screenshot, the label `Where should we
    order from?` is not the application default. The label for an `Activity` is defined
    in the `AndroidManifest.xml` file as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到截图顶部，标签`Where should we order from?`不是应用程序的默认设置。`Activity`的标签在`AndroidManifest.xml`文件中定义如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Styling the standard ListAdapters
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置标准ListAdapter的样式
- en: The standard `ListAdapter` implementations require each item be represented
    in a `TextView` item. The default single-choice and multiple-choice items are
    built using a `CheckedTextView`, and while there are plenty of other `TextView`
    implementations in Android, it does limit our options a bit. However, the standard
    `ListAdapter` implementations are very convenient and provide solid implementations
    for the most common listing requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`ListAdapter`实现要求每个项目在`TextView`项中表示。默认的单选和多选项目是使用`CheckedTextView`构建的，尽管Android中有许多其他的`TextView`实现，但它确实限制了一些我们的选择。然而，标准的`ListAdapter`实现非常方便，并为最常见的列表需求提供了可靠的实现。
- en: Since a `ListView` with `CHOICE_MODE_NONE` is a lot like a menu, wouldn't it
    be nice to change the items into `Button` objects instead of normal `TextView`
    items? Technically, a `ListView` can contain any widget that extends `TextView`.
    However, some implementations are more suitable than others (for example, a `ToggleButtonView`
    won't maintain the specified text-value when the user touches it).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于带有`CHOICE_MODE_NONE`的`ListView`与菜单非常相似，如果将项目改为`Button`对象而不是普通的`TextView`项，岂不是很好吗？从技术上讲，`ListView`可以包含任何扩展`TextView`的小部件。然而，有些实现比其他的更适合（例如，`ToggleButtonView`在用户触摸它时不会保持指定的文本值）。
- en: Defining standard dimensions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义标准尺寸
- en: In this example we'll be creating various menus for the application. In order
    to maintain a consistent look and feel, we should define a set of standard dimensions
    which will be used in each of our layout files. This way we can redefine the sizes
    for different types of screens. There's nothing more frustrating for a user than
    only being able to see a partial item because it's been sized bigger than their
    screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将为应用程序创建各种菜单。为了保持一致的外观和感觉，我们应该定义一组标准尺寸，这些尺寸将用于我们的每个布局文件中。这样我们可以为不同类型的屏幕重新定义尺寸。对于用户来说，没有比只能看到部分项目更沮丧的了，因为它的尺寸比他们的屏幕还要大。
- en: 'Create a new resource file to contain the dimensions. The file should be named
    `res/values/dimens.xml`. Copy the following code into the new XML file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的资源文件来包含尺寸。该文件应命名为`res/values/dimens.xml`。将以下代码复制到新的XML文件中：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We declare two height dimensions for the list items: `item_outer_height` and
    `item_inner_height`. The `item_outer_height` will be the height of the list items,
    while the `item_inner_height` is the height of any `View` object contained inside
    the list item.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为列表项声明了两个高度尺寸：`item_outer_height`和`item_inner_height`。`item_outer_height`将是列表项的高度，而`item_inner_height`是列表项中包含的任何`View`对象的高度。
- en: The `padding` dimension at the end of the file is used to define a standard
    amount of whitespace between two visual elements. This is defined as `dp` so it
    will remain constant based on the DPI of the screen (instead of scaling according
    to the font size preferences of the user).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾的`padding`尺寸用于定义两个视觉元素之间的标准空白量。这被定义为`dp`，因此它会根据屏幕的DPI保持不变（而不是根据用户的字体大小偏好进行缩放）。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Sizing of interactive items**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互项目的大小调整**'
- en: In this styling, you'll notice that the `item_outer_height` and `menu_item_height`
    are `48sp` and `52sp`, which makes the items in the `ListView` rather large. The
    standard size of a list view item in Android is `48sp`. The height of a list item
    is critical. If your users have large fingers, they will struggle to tap on their
    target list item if you make them too small.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个样式设置中，你会注意到`item_outer_height`和`menu_item_height`是`48sp`和`52sp`，这使得`ListView`中的项目相当大。Android中列表视图项的标准大小是`48sp`。列表项的高度至关重要。如果你的用户手指较大，而你把项目设置得太小，他们将很难点击目标列表项。
- en: This is a general "good practice" for Android user interface design. If the
    user needs to touch it, make it big.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一般针对安卓用户界面设计的“良好实践”。如果用户需要触摸操作，那么请把它设计得大一些。
- en: Time for action – improving the restaurant list
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——改善餐厅列表
- en: The list of restaurants we put together earlier is nice, but it's a menu. In
    order to further emphasize the menu, the text should stand out more. In order
    to style a `ListView` with a standard `ListAdapter` implementation, you will need
    to specify the `ListAdapter` object in your Java code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前整理的餐厅列表很棒，但它是一个菜单。为了进一步强调菜单，文本应该更加突出。为了使用标准`ListAdapter`实现来设置`ListView`的样式，你需要在你的Java代码中指定`ListAdapter`对象。
- en: Create a new file in the `res/layout` directory named `menu_item.xml`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`目录中创建一个名为`menu_item.xml`的新文件。
- en: 'Create the root XML element as a `TextView`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根XML元素创建为`TextView`：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import the Android resource XML namespace:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Android资源XML命名空间：
- en: 'Center the text in the `TextView` widget by setting its gravity:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`TextView`小部件的gravity属性来使文本居中：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We assign the `textSize` of the `TextView` to our standard `item_text_size`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`TextView`的`textSize`赋值为我们的标准`item_text_size`：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The default color of the text of `TextView` is a bit gray, we want it to be
    white:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TextView`文本的默认颜色有点灰，我们希望它是白色：'
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We want the width of the `TextView` to be the same as the `ListView` that contains
    it. Since this is for our main menu, its height is `menu_item_height`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`TextView`的宽度与包含它的`ListView`相同。因为这是我们的主菜单，所以它的高度是`menu_item_height`：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have a styled `TextView` resource, we can incorporate it into our
    menu. Open the `SelectRestaurantActivity.java` file.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个样式化的`TextView`资源，我们可以将它整合到我们的菜单中。打开`SelectRestaurantActivity.java`文件。
- en: 'In the `onCreate` method, after you use `setContentView`, we need a reference
    to the `ListView` we created earlier in `main.xml`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，使用`setContentView`之后，我们需要获取之前在`main.xml`中创建的`ListView`的引用：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set the restaurants `ListAdapter` to a new `ArrayAdapter` containing the string-array
    of restaurants we created in our `values.xml` file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将餐厅的`ListAdapter`设置为一个包含我们在`values.xml`文件中创建的字符串数组的新`ArrayAdapter`：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*What just happened*'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: 'We first created a new layout XML resource containing the styled `TextView`
    that we wanted to be used for each list item in our restaurant''s `ListView`.
    The `menu_item.xml` file you wrote should contain the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个新的布局XML资源，其中包含我们想要用于餐厅`ListView`中每个列表项的样式化`TextView`。你编写的`menu_item.xml`文件应该包含以下代码：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike our previous layout resources, `menu_item.xml` contained no `ViewGroup`
    (such as `LinearLayout`). This is due to the fact that the `ArrayAdapter` will
    attempt to cast the root `View` of the `menu_item.xml` file to a `TextView`. So,
    if we nested the `TextView` in a `ViewGroup` of some sort, we'd get a `ClassCastException`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的布局资源不同，`menu_item.xml`不包含任何`ViewGroup`（如`LinearLayout`）。这是因为`ArrayAdapter`将尝试将`menu_item.xml`文件的根`View`转换为`TextView`。因此，如果我们以某种方式将`TextView`嵌套在`ViewGroup`中，我们将得到一个`ClassCastException`。
- en: 'We also created an `ArrayAdapter` instance to reference both our `menu_item`
    XML resource, and the string-array of restaurants we created earlier. This action
    eliminates the use of the `android:entries` attribute on the `ListView` in the
    `main.xml` layout XML resource. If you want, you can remove that attribute. Your
    `onCreate` method in `SelectRestaurantActivity` should now look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`ArrayAdapter`实例，以引用我们之前创建的`menu_item` XML资源以及餐厅字符串数组。这个操作消除了在`main.xml`布局XML资源中的`ListView`上使用`android:entries`属性。如果你愿意，可以删除该属性。现在，你在`SelectRestaurantActivity`中的`onCreate`方法应如下所示：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Try re-installing the application into the emulator with Apache Ant, and you''ll
    now be greeted by a screen that looks a lot more like a menu:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Apache Ant将应用程序重新安装到模拟器中，现在你将看到一个看起来更像菜单的屏幕：
- en: '![What just happened](img/4484_02_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么](img/4484_02_05.jpg)'
- en: Have a go hero – developing a multiple-choice question application
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——开发一个多选题应用程序。
- en: 'Try going back to the multiple-choice question application we wrote in [Chapter
    1](ch01.html "Chapter 1. Developing a Simple Activity"), *Developing a Simple
    Activity*. It uses `LinearLayout` and `Button` objects to display the possible
    answers to the questions, but it also uses string-arrays for the answers. Try
    modifying the application to:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回到我们在[第1章](ch01.html "第1章. 开发一个简单的活动")中编写的多选题应用程序，*Developing a Simple Activity*。它使用`LinearLayout`和`Button`对象来显示问题的可能答案，但它也使用字符串数组作为答案。尝试修改应用程序以：
- en: Use a `ListView` instead of a `LinearLayout`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListView`代替`LinearLayout`。
- en: Style the `ListView` with `Button` objects, as we styled our restaurant menu
    with `TextView` objects
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Button`对象为`ListView`设置样式，就像我们使用`TextView`对象为餐厅菜单设置样式一样。
- en: Make sure you have some margin between the `Button` list items so that they're
    not too close to each other
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在`Button`列表项之间有一定的间距，使它们不会过于紧密。
- en: Creating custom adapters
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义适配器。
- en: When we want to order food, we often want to order more than one of the same
    item. The `ListView` implementation, and the standard `ListAdapter` implementations
    allow for us to select a **Cheese Burger** item, but not for us to request **3
    Cheese Burgers**. In order to display a menu of different foods that the user
    can order in multiple quantities, we need a customized `ListAdapter` implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要点餐时，我们通常想要订购一个项目的多个数量。`ListView`的实现以及标准的`ListAdapter`实现允许我们选择一个**Cheese
    Burger**项目，但并不允许我们请求**3 Cheese Burgers**。为了显示用户可以以多个数量订购的不同食品的菜单，我们需要一个自定义的`ListAdapter`实现。
- en: Creating a menu for The Burger Place
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为“The Burger Place”创建菜单。
- en: For each restaurant in our main menu, we are going to build a separate `Activity`
    class. In reality, this is not a great idea, but it allows us to investigate different
    ways of organizing and displaying the menu data. Our first stop is **The Burger
    Place**, for which we present the user with a list of burgers, and let them tap
    the ones they want on the screen. Each time they tap a list item, they order another
    burger. We will display the number of burgers they are ordering in bold to the
    left of the burger's name. Next to burgers that they aren't ordering, there should
    be no number (this allows the user to see what they are ordering at a quick glance).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主菜单中的每家餐厅，我们将构建一个单独的`Activity`类。实际上，这不是一个好主意，但它允许我们研究组织和展示菜单数据的不同方式。我们的第一站是**The
    Burger Place**，我们向用户展示一个汉堡列表，让他们在屏幕上点击他们想要的汉堡。每次点击列表项时，他们都会再点一个汉堡。我们将在汉堡名称左侧以粗体显示他们正在订购的汉堡数量。对于他们没有订购的汉堡旁边，则不显示数字（这使得用户可以快速查看他们正在订购的内容）。
- en: The Burger class
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 汉堡类。
- en: 'In order to display the menu, we need a simple `Burger` data object. The `Burger`
    class will hold a name to be displayed in the menu, and the number of `Burger`
    the user is ordering. Create a `Burger.java` file in the root package of your
    project with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示菜单，我们需要一个简单的`Burger`数据对象。`Burger`类将保存要在菜单中显示的名称，以及用户正在订购的`Burger`数量。在项目的根包中创建一个`Burger.java`文件，并使用以下代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You'll notice that there are no getters and setters in the preceding code, and
    that both the `name` and `count` fields are declared as package-protected. In
    versions of Android prior to 2.2, methods incurred a heavy expense when compared
    to a straight field lookup. Since this class will be a small part of the rendering
    procedure (we will be extracting data from it for display), we should make sure
    we incur as little expense as possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前面的代码中没有getter和setter方法，而且`name`和`count`字段都声明为包保护的。在Android 2.2之前的版本中，与直接字段查找相比，方法会产生较大的开销。由于这个类将只是渲染过程的一小部分（我们将从中提取数据以显示），我们应该确保开销尽可能小。
- en: Time for action – creating a Burger item layout
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建汉堡项布局
- en: The first thing to do in order to create a nice looking menu for **The Burger
    Place** is to design the menu items. This is done in much the same way as the
    styling of the restaurant list with a layout XML resource. However, since we will
    be building the `ListAdapter` ourselves this time, we are not forced to use a
    single `TextView`, but can instead build a more complex layout.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为**汉堡店**设计一个好看的菜单，首先要做的是设计菜单项。这与使用布局XML资源的餐厅列表样式设计非常相似。然而，由于这次我们将自己构建`ListAdapter`，因此不必使用单个`TextView`，而是可以构建更复杂的布局。
- en: Create a new XML file in the `res/layout` directory named `burger_item.xml`.
    This file will be used for each burger in the `ListView`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`目录中创建一个名为`burger_item.xml`的新XML文件。这个文件将用于`ListView`中的每个汉堡项。
- en: 'Declare the root of the layout as a `horizontal LinearLayout` (note the height,
    which will be the height of each item in the `ListView`):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局的根声明为`horizontal LinearLayout`（注意高度，这将是`ListView`中每个项目的高度）：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, declare a `TextView`, which we will use as a `counter` for the number
    of burgers being ordered. We will later access this through its ID:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个`TextView`，我们将用它作为订购汉堡数量的`counter`。我们稍后可以通过其ID访问这个`TextView`：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `counter` text size is exactly the same as all of the other list items
    in the application. However, it should be `bold`, so it can be easily identified
    and read:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`counter`的文本大小与应用程序中所有其他列表项完全相同。然而，它应该是加粗的，这样就可以轻松识别和阅读：'
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also want the `counter` to be square, so set the width and height exactly
    the same:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望`counter`是正方形的，因此将宽度和高度设置得完全相同：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also want to center the text inside the `counter`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望文本在`counter`内居中：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll also need a text space to display the name of the burger:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个文本空间来显示汉堡的名字：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The text size is standard:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本大小是标准的：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We want a little bit of space between the `counter` and the `text` label:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`counter`和`text`标签之间有一点空间：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The label''s width should fill the `ListView`, but we want the size of both
    `TextView` objects to be the same:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签的宽度应填满`ListView`，但我们希望两个`TextView`对象的大小相同：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The text of the label should be centered vertically, to match the location
    of the `counter`. However, the label should be left-aligned:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签文本应垂直居中，以匹配`counter`的位置。然而，标签应该是左对齐的：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You''ve just built a very nice `LinearLayout ViewGroup` which will be rendered
    for each of the burgers we sell from **The Burger Place**. Since the `counter
    TextView` is a separate object from the label, it can be independently styled
    and managed. This makes things much more flexible going forward if we want to
    apply additional styles to them independently. Your complete `burger_item.xml`
    file should now appear as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚构建了一个非常不错的`LinearLayout ViewGroup`，这将为我们从**汉堡店**销售的每个汉堡渲染。由于`counter TextView`与标签是分开的对象，因此可以独立地进行样式设计和管理。如果我们想独立地为它们应用额外的样式，这将使事情变得更加灵活。现在你的`burger_item.xml`文件应该如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Time for action – presenting Burger objects
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——展示汉堡对象
- en: The standard `ListAdapter` classes work well if your data objects are either
    strings or easily represented as strings. In order to display our `Burger` objects
    nicely on the screen, we need to write a custom `ListAdapter` class. Fortunately,
    Android provides us with a nice skeleton class for `ListAdapter` implementations
    named `BaseAdapter`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据对象是字符串或者很容易表示为字符串，标准的`ListAdapter`类工作得很好。为了在屏幕上美观地显示我们的`Burger`对象，我们需要编写一个自定义的`ListAdapter`类。幸运的是，Android为我们提供了一个名为`BaseAdapter`的很好的`ListAdapter`实现框架类。
- en: 'Create a new class named `BurgerAdapter`, and have it extend from the `android.widget.BaseAdapter`
    class:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BurgerAdapter`的新类，并让它继承自`android.widget.BaseAdapter`类：
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An `Adapter` is part of the presentation layer, but is also the underlying
    model of the `ListView`. In the `BurgerAdapter` we store an array of `Burger`
    objects which we assign in the constructor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Adapter`是表示层的一部分，但也是`ListView`的底层模型。在`BurgerAdapter`中，我们存储了一个`Burger`对象的数组，我们在构造函数中分配它：'
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the `Adapter.getCount()` and `Adapter.getItem(int)` methods directly
    on top of the array of `Burger` objects:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在`Burger`对象数组上实现`Adapter.getCount()`和`Adapter.getItem(int)`方法：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An `Adapter` is also expected to provide identifiers for the various items,
    we will just return their index:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还期望`Adapter`为各个项目提供标识符，我们将仅返回它们的索引：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When an `Adapter` is asked for a `View` of a list item, it may be given an
    existing `View` object that could be reused. We will implement a simple method
    to handle this case, and if required, inflate the `burger_item.xml` file we wrote
    earlier using the `LayoutInflator` class from the `android.view` package:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Adapter`被请求提供一个列表项的`View`时，它可能会接收到一个可复用的现有`View`对象。我们将实现一个简单的方法来处理这种情况，如果需要，将使用`android.view`包中的`LayoutInflator`类来填充我们之前编写的`burger_item.xml`文件：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The most important method for us in the `BurgerAdapter` is the `getView` method.
    This is where the `ListView` will ask us for a `View` object to represent each
    list item it needs to display:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BurgerAdapter`中，对我们来说最重要的方法是`getView`方法。这是`ListView`请求我们提供一个`View`对象的地点，以表示它需要显示的每个列表项：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to fetch the correct `View` for a given item, you''ll first need to
    use the `getViewGroup` method to ensure you have the `burger_item.xml ViewGroup`
    to display the `Burger` item in:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取给定项目的正确`View`，你首先需要使用`getViewGroup`方法以确保你有`burger_item.xml ViewGroup`来显示`Burger`项：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ll be populating these two `TextView` objects with the data from the `Burger`
    object at the requested `index`. The `counter` widget needs to be hidden from
    the user if the current `count` is zero:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用请求的`index`位置上的`Burger`对象的数据来填充这两个`TextView`对象。如果当前的`count`为零，则需要从用户界面隐藏`counter`小部件：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just wrote a custom `Adapter` class to present an array of `Burger` objects
    to the user in a `ListView`. When a `ListView` invokes the `Adapter.getView` method,
    it will attempt to pass in the `View` object that was returned from a previous
    call to `Adapter.getView`. A `View` object will be created for each item in the
    `ListView`. However, when the data displayed by the `ListView` changes, the `ListView`
    will ask the `ListAdapter` to reuse each of the `View` objects it generated the
    first time around. It's important to try and honor this behavior, since it has
    a direct impact on the responsiveness of your application. In our preceding example,
    we implemented the `getViewGroup` method so that it would take this requirement
    into account.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了一个自定义的`Adapter`类，用于在`ListView`中向用户展示一系列`Burger`对象。当`ListView`调用`Adapter.getView`方法时，它会尝试传入之前调用`Adapter.getView`返回的`View`对象。将为`ListView`中的每个项目创建一个`View`对象。然而，当`ListView`显示的数据发生变化时，`ListView`将要求`ListAdapter`重用第一次生成的每个`View`对象。尽量遵循这一行为非常重要，因为它直接影响到应用程序的响应性。在我们之前的示例中，我们实现了`getViewGroup`方法，以便考虑到这一要求。
- en: 'The `getViewGroup` method is also used to inflate the `burger_item.xml` file
    we wrote. We do this using a `LayoutInflator` object, which is exactly how the
    `Activity.setContentView(int)` method loads XML layout resources. The `Context`
    object which we fetch from our `parent ViewGroup` (which will generally be the
    `ListView`) defines where we will load the layout resource from. If the user hasn''t
    selected a `Burger`, we hide the counter `TextView` using the `View.setVisibility`
    method. In AWT and Swing, the `setVisible` method takes a `Boolean` parameter,
    whereas in Android, `setVisibility` takes an `int` value. The reason for this
    is that Android treats visibility as part of the layout process. In our case we
    want the `counter` to disappear, but still take up its space in the layout, which
    will keep the `text` labels left-aligned with each other. If we wanted the counter
    to vanish and take up no space, we could use:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`getViewGroup`方法也用于加载我们编写的`burger_item.xml`文件。我们使用`LayoutInflator`对象来完成此操作，这正是`Activity.setContentView(int)`方法加载XML布局资源的方式。我们从`parent
    ViewGroup`获取的`Context`对象（通常是`ListView`）定义了我们将从哪里加载布局资源。如果用户没有选择“汉堡”，我们使用`View.setVisibility`方法隐藏计数器`TextView`。在AWT和Swing中，`setVisible`方法接受一个`Boolean`参数，而在Android中，`setVisibility`接受一个`int`值。这样做的原因是Android将可见性视为布局过程的一部分。在我们的例子中，我们希望`counter`消失，但仍然在布局中占据其空间，这将使`text`标签保持左对齐。如果我们希望计数器消失且不占用空间，我们可以使用：'
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`ListView` objects will automatically handle the highlighting of a selected
    item. This includes when the user holds their finger on the item, and when they
    use a track-pad or directional buttons to navigate the `ListView`. When an item
    is highlighted, its background generally changes color, according to standard
    UI conventions.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`对象将自动处理选中项目的突出显示。这包括用户在项目上按住手指，以及他们使用轨迹板或方向键导航`ListView`时。当一个项目被突出显示时，其背景通常会根据标准的UI约定改变颜色。'
- en: However, using widgets in a `ListView` that in some way directly captures user
    input (that is, a `Button` or `EditText`) will cause the `ListView` to stop showing
    the selection highlighting for that widget. In fact, it will stop the `ListView`
    from registering `OnItemClick` events completely.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`ListView`中使用某些直接捕获用户输入的小部件（例如，`Button`或`EditText`）会导致`ListView`不再为该小部件显示选中高亮。实际上，这将阻止`ListView`完全注册`OnItemClick`事件。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Custom separators in a ListView**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**在ListView中自定义分隔符**'
- en: If you override the `isEnabled(int index)` method of `ListAdapter`, you can
    strategically disable specified items in the `ListView`. A common use of this
    is to turn certain items into logical separators. For example, a section separator
    in an alphabetically sorted list, containing the first letter of all items in
    the next "section".
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重写`ListAdapter`的`isEnabled(int index)`方法，你就可以策略性地禁用`ListView`中的指定项目。这种做法的一个常见用途是将某些项目设置为逻辑分隔符。例如，在按字母排序的列表中的部分分隔符，包含下一“部分”所有项目首字母。
- en: Creating TheBurgerPlaceActivity class
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建TheBurgerPlaceActivity类
- en: In order to put the `Burger` menu on the screen, and to allow the user to order
    items, we need a new `Activity` class. We need to know when the user touches the
    items in the list, for which we will need to implement the `OnItemClickListener`
    interface. When a specific event occurs (in this case the user touches a specific
    item in the `ListView`), objects registered as listeners will have a related method
    invoked with the details of the event that occurred. Android provides a simple
    `ListActivity` class to provide some default layout and utility methods for this
    scenario.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上显示“汉堡”菜单，并允许用户订购项目，我们需要一个新的`Activity`类。我们需要知道用户何时触摸列表中的项目，为此我们将需要实现`OnItemClickListener`接口。当发生特定事件时（在本例中是用户在`ListView`中触摸特定项目），作为监听器注册的对象将调用与发生的事件相关的相应方法。Android
    提供了一个简单的`ListActivity`类，为这种情况提供一些默认布局和实用方法。
- en: Time for action – implementing TheBurgerPlaceActivity
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——实现TheBurgerPlaceActivity
- en: In order to present a `ListView` of `Burger` objects with the `BurgerAdapter`
    class, we will need to create an `Activity` implementation for **The Burger Place**.
    The new `Activity` will also be responsible for listening to "touch" or "click"
    events on the items in the `ListView`. When the user touches one of the items,
    we need to update the model and `ListView` to reflect that the user has ordered
    another `Burger`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `BurgerAdapter` 类展示 `Burger` 对象的 `ListView`，我们将需要创建一个 **The Burger Place**
    的 `Activity` 实现。新的 `Activity` 还将负责监听 `ListView` 中项目的“触摸”或“点击”事件。当用户触摸其中一个项目时，我们需要更新模型和
    `ListView`，以反映用户又订购了一个 `Burger`。
- en: 'Create a new class in the root package of your project named `TheBurgerPlaceActivity`,
    and make sure it extends `ListActivity`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个名为 `TheBurgerPlaceActivity` 的新类，并确保它继承自 `ListActivity`：
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Override the `Activity.onCreate` method.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `Activity.onCreate` 方法。
- en: Invoke the `super.onCreate` to allow normal Android startup.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `super.onCreate` 以允许正常的 Android 启动过程。
- en: 'Create an instance of `BurgerAdapter` with some `Burger` objects, and set it
    as the `ListAdapter` for the `ListActivity` code to use:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些 `Burger` 对象创建 `BurgerAdapter` 的实例，并将其设置为 `ListActivity` 代码要使用的 `ListAdapter`：
- en: '[PRE42]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, implement the `onListItemClicked` method with the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下代码实现 `onListItemClicked` 方法：
- en: '[PRE43]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*What just happened?*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This implementation of `TheBurgerPlaceActivity` has a simple hard-coded list
    of `Burger` objects to display to the user and creates a `BurgerAdapter` to turn
    these objects into the `burger_item View` objects which we created earlier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `TheBurgerPlaceActivity` 的实现有一个简单的硬编码 `Burger` 对象列表供用户显示，并创建了一个 `BurgerAdapter`
    来将这些对象转换为之前创建的 `burger_item View` 对象。
- en: When the user taps a list item, we increment the `count` of the related `Burger`
    object in the `onItemClick` method. We then call `notifyDataSetInvalidated()`
    on the `BurgerAdapter`. This method will inform the `ListView` that the underlying
    data has changed. When the data changes, the `ListView` will re-invoke the `Adapter.getView`
    method for each item in the `ListView`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击列表项时，我们在 `onItemClick` 方法中增加相关 `Burger` 对象的 `count`。然后我们调用 `BurgerAdapter`
    上的 `notifyDataSetInvalidated()`。此方法将通知 `ListView` 底层数据已更改。当数据更改时，`ListView` 将重新调用
    `Adapter.getView` 方法，针对 `ListView` 中的每个项目。
- en: The items in a `ListView` are represented by effectively static `View` objects.
    This means that the `Adapter` must be allowed to update or recreate that `View`
    when the data model is updated. A common alternative is to fetch the `View` representing
    your updated data, and update it directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 中的项目由实际上是静态的 `View` 对象表示。这意味着当数据模型更新时，适配器必须允许更新或重新创建该 `View`。一种常见的替代方法是获取表示你更新数据的
    `View`，并直接更新它。'
- en: Registering and starting TheBurgerPlaceActivity
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册并启动 TheBurgerPlaceActivity
- en: 'In order to start the new `Activity` class from our restaurant menu, you will
    need to register it in the `AndroidManifest.xml` file. First, open the `AndroidManifest.xml`
    file in an editor or IDE, and copy the following `<activity>` code into the `<application>...</application>`
    block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的餐厅菜单启动新的 `Activity` 类，你需要在 `AndroidManifest.xml` 文件中注册它。首先，在编辑器或 IDE 中打开
    `AndroidManifest.xml` 文件，并将以下 `<activity>` 代码复制到 `<application>...</application>`
    块中：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To start the `Activity`, you''ll need to go back to `SelectRestaurantActivity`
    and implement the `OnItemClickListener` interface. After setting the `Adapter`
    on the `restaurants ListView`, set `SelectRestaurantActivity` as the `OnItemClickListener`
    of the `restaurants ListView`. You can start `TheBurgerPlaceActivity` using an
    `Intent` object in the `onItemClick` method. Your `SelectRestaurantActivity` class
    should now look like the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动 `Activity`，你将需要回到 `SelectRestaurantActivity` 并实现 `OnItemClickListener`
    接口。在 `restaurants ListView` 上设置 `Adapter` 之后，将 `SelectRestaurantActivity` 设置为
    `restaurants ListView` 的 `OnItemClickListener`。你可以在 `onItemClick` 方法中使用 `Intent`
    对象启动 `TheBurgerPlaceActivity`。现在你的 `SelectRestaurantActivity` 类应该看起来像以下代码片段：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you reinstall the application and start it up in the emulator, you'll be
    able to navigate to **The Burger Place** and place an order for burgers. Pressing
    the hardware "Back" button in **The Burger Place** menu will take you back to
    the restaurant menu.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新安装应用程序并在模拟器中启动它时，你将能够导航到 **The Burger Place** 并为汉堡包下订单。在 **The Burger Place**
    菜单中按下硬件“返回”按钮将带你回到餐厅菜单。
- en: '![Registering and starting TheBurgerPlaceActivity](img/4484_02_06.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![注册并启动 TheBurgerPlaceActivity](img/4484_02_06.jpg)'
- en: Pop quiz
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: 'Setting the choice mode on a `ListView` object to `CHOICE_MODE_SINGLE` will:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ListView` 对象的选择模式设置为 `CHOICE_MODE_SINGLE` 将：
- en: Add a `RadioButton` to each item.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向每个项目添加一个`RadioButton`。
- en: Do nothing (this is the default).
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不执行任何操作（这是默认行为）。
- en: Make the `ListView` track a "selected" item.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`ListView`跟踪一个“选中”的项目。
- en: A `ListAdapter` defines how a `ListView` displays its items. When will it be
    asked to reuse a `View` for an item object?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ListAdapter`定义了`ListView`如何显示其项目。它将在何时被要求重用一个`View`来显示一个项目对象？'
- en: When the data model is invalidated or changed.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据模型无效或更改时。
- en: On every item, for rubber-stamping.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个项目上，用于橡皮图章。
- en: When the `ListView` redraws itself.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`ListView`重新绘制自身时。
- en: 'When a `ListView` is scrollable, header and footer objects will be positioned:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`ListView`可以滚动时，头部和底部对象将被定位：
- en: Above and below the scrolling items.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在滚动项目之上和之下。
- en: Horizontally alongside each other, above and below the scrolling items.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平并排显示，在滚动项目之上和之下。
- en: Scrolling with the other items.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他项目一起滚动。
- en: Using the ExpandableListView class
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ExpandableListView`类
- en: The `ListView` class is great for displaying small to medium amounts of data,
    but there are times when it will flood your user with far too much information.
    Think about an email application. If your user is a heavy email user, or subscribes
    to a few mailing lists, they may well have several hundred emails in a folder.
    Even though they may not need to scroll beyond the first few, seeing the scrollbar
    shrink to a few pixels in size doesn't have a good psychological effect on your
    user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`类非常适合显示中小量的数据，但有时它会向用户展示过多的信息。考虑一个电子邮件应用程序。如果你的用户是重度电子邮件用户，或者订阅了几个邮件列表，他们可能会在文件夹中有数百封电子邮件。即使他们可能不需要滚动超过前几封，看到滚动条缩小到只有几像素大小，对用户的心理影响并不好。'
- en: 'In desktop mail clients, you will often group the email list by time: Today,
    yesterday, this week, this month, and forever (or something similar). Android
    includes the `ExpandableListView` for this type of grouping. Each item is nested
    inside a group, and a group can be displayed or hidden by the user. It''s a bit
    like a tree view, but always nested to exactly one level (you can''t display an
    item outside a group).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面邮件客户端中，你经常会按时间将邮件列表分组：今天、昨天、本周、本月以及更早（或类似）。Android提供了`ExpandableListView`以实现这种类型的分组。每个项目嵌套在一个组内，用户可以显示或隐藏组。这有点像树形视图，但始终只嵌套一个层级（你不能将项目显示在组外）。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Massive ExpandableListView groups**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**大量的`ExpandableListView`组**'
- en: There are times where even an `ExpandableListView` will not be enough to keep
    the amount of data to a reasonable length. In these cases, consider giving your
    user the first few items in the group and adding a special **View More** item
    at the end. Alternatively, use a `ListView` for the groups, and a separate `Activity`
    for the nested items.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时即使是`ExpandableListView`也可能不足以将数据量保持在合理长度。在这些情况下，考虑为用户提供组中的前几个项目，并在最后添加一个特殊的**查看更多**项目。或者，对组使用`ListView`，对嵌套项目使用单独的`Activity`。
- en: Creating ExpandableListAdapter implementations
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`ExpandableListAdapter`实现
- en: 'Since the `ExpandableList` class includes two levels of detail, it can''t work
    against a normal `ListAdapter` which only handles a single level. Instead, it
    includes the `ExpandableListAdapter` which uses two sets of methods: one set for
    the group level and another set for the item level. When implementing a custom
    `ExpandableListAdapter`, it''s generally easiest to have your `ExpandableListAdapter`
    implementation inherit from the `BaseExpandableListAdapter`, as it provides implementations
    for event registration and triggering.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ExpandableList`类包含两个详细级别，它不能与只处理单一级别的普通`ListAdapter`一起工作。相反，它包含了`ExpandableListAdapter`，后者使用两组方法：一组用于组级别，另一组用于项目级别。在实现自定义`ExpandableListAdapter`时，通常最简单的方法是让你的实现继承自`BaseExpandableListAdapter`，因为它提供了事件注册和触发的实现。
- en: 'The `ExpandableListAdapter` will place an arrow pointer on the left side of
    each group item to indicate whether the group is open or closed (much like a drop-down/combobox).
    The arrow is rendered on top of the group''s `View` object as returned by the
    `ExpandableListAdapter`. To stop your group label from being partly obscured by
    this arrow, you''ll need to add padding to your list item `View` structures. The
    default padding for a list item is available as the theme parameter `expandableListPreferredItemPaddingLeft`,
    which you can make use of:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExpandableListAdapter` 会在每个组项的左侧放置一个箭头指针，以指示组是打开还是关闭（类似于下拉/组合框）。箭头是在由 `ExpandableListAdapter`
    返回的组 `View` 对象上方渲染的。为了防止你的组标签被这个箭头部分遮挡，你需要为列表项 `View` 结构添加填充。列表项的默认填充可以通过主题参数
    `expandableListPreferredItemPaddingLeft` 获取，你可以使用它：'
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In order to keep your `ExpandableListView` looking consistent, it's a good idea
    to add the same amount of padding to the normal (child) items of the `ExpandableListView`
    (to keep their text aligned with that of their parent group), unless you are putting
    an item on the left-hand side, such as an icon or checkbox.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持 `ExpandableListView` 的外观一致性，建议你为 `ExpandableListView` 的普通（子）项目添加相同数量的填充（以保持它们的文本与父组对齐），除非你在左侧放置一个项目，如图标或复选框。
- en: Have a go hero - ordering customized pizzas
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 - 订购定制比萨
- en: For the `Mick's Pizza` example, we're going to create a menu of categorized
    pizza toppings. Each topping consists of a name, whether it's 'on' or 'off' the
    pizza, or 'extra' (for example, extra cheese). Use two `TextView` objects arranged
    horizontally for each item. The right `TextView` can hold the name of the topping.
    The left `TextView` can be empty when toppings are not included, `On` when toppings
    are included, and `Extra` for toppings that the user wants more than the usual
    amount.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Mick's Pizza` 示例中，我们将创建一个分类的比萨配料菜单。每个配料包括一个名称，以及它是否在比萨上（'on' 或 'off'），或者需要'extra'（例如，额外芝士）。每个项目使用两个水平排列的
    `TextView` 对象。右侧的 `TextView` 可以显示配料名称。当不包含配料时，左侧的 `TextView` 为空，包含配料时为 `On`，用户想要比通常更多配料时为
    `Extra`。
- en: Create an object model with `ToppingCatagory` objects, containing a name and
    an array of `PizzaTopping` objects. You'll want to store some state whether each
    topping is ordered, and in what quantity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个对象模型，包含 `ToppingCatagory` 对象，其中包含一个名称和 `PizzaTopping` 对象数组。你需要记录每个配料是否被点单以及数量。
- en: You'll also want to implement a `PizzaToppingAdapter` class, extending the `BaseExpandableListAdapter`
    class. Make use of the default Android `simple_expandable_list_item_1` layout
    resource for the group label, and a new customized layout resource for the item
    labels.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要实现一个 `PizzaToppingAdapter` 类，扩展 `BaseExpandableListAdapter` 类。为组标签使用默认的Android
    `simple_expandable_list_item_1` 布局资源，为项目标签使用一个新的定制布局资源。
- en: 'When the user taps on a pizza topping, it changes its status between the three
    values: **Off**, **On**, and **Extra**.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击一个比萨配料时，它的状态会在三个值之间变化：**Off**，**On**，和 **Extra**。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `ListView.getAdapter()` method will not return your `ExpandableListAdapter`
    implementation, but a wrapper instead. To fetch the original `ExpandableListAdapter`,
    you will need to use the `getExpandableListAdapter()` method. You will also want
    to make use of the `ExpandableListView. OnChildClickListener` interface to receive
    click events.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ListView.getAdapter()` 方法不会返回你的 `ExpandableListAdapter` 实现，而是一个包装器。要获取原始的
    `ExpandableListAdapter`，你需要使用 `getExpandableListAdapter()` 方法。你还需要使用 `ExpandableListView.OnChildClickListener`
    接口来接收点击事件。
- en: 'When your new `Activity` is complete, you should have a screen which looks
    something like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的新 `Activity` 完成时，你应该有一个看起来像以下的屏幕：
- en: '![Have a go hero - ordering customized pizzas](img/4484_02_07.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![尝试英雄 - 订购定制比萨](img/4484_02_07.jpg)'
- en: Using the GridView class
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GridView 类
- en: A `GridView` is a `ListView` with a fixed number of columns, arranged left-to-right,
    top-to-bottom. The standard (un-themed) Android application menu is arranged like
    a `GridView`. The `GridView` class makes use of a `ListAdapter` in the exact same
    format as `ListView`. However, because of its fixed column count, a `GridView`
    is very well suited for lists of icons.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 是一个具有固定列数的 `ListView`，从左到右，从上到下排列。标准的（未定主题的）Android应用程序菜单像 `GridView`
    一样排列。`GridView` 类使用与 `ListView` 完全相同的 `ListAdapter` 格式。然而，由于其固定的列数，`GridView`
    非常适合图标列表。'
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using GridViews effectively**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效使用 GridViews**'
- en: A `GridView` can display significantly more information on a single screen than
    a `ListView`, at the expense of not being able to show as much text information.
    From a usability point of view, icons are often easier to work with than text.
    Icons can be recognized more quickly than text, thanks to their colors. When you
    have information that can be represented using icons, it's a good idea to display
    it as such. However, remember that icons need to be unique within a single screen
    preferably within the entire application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ListView`相比，`GridView`可以在单个屏幕上显示更多的信息，但代价是显示的文本信息较少。从可用性的角度来看，图标通常比文本更容易操作。由于它们的颜色，图标可以比文本更快地被识别。当您有可以使用图标表示的信息时，以这种方式显示它是一个好主意。但是，请记住，图标需要在单个屏幕内保持唯一性，最好是在整个应用程序内。
- en: For our next example, we're going to build the **Four Buckets 'o Fruit** menu,
    using `GridView`. The `GridView` will have an icon for each item on the menu,
    and the name of the item below the icon. So, when complete, it will look much
    like the standard Android application menu. This next example will focus less
    on the implementation of the `ListAdapter`, since it's largely the same as the
    `ListAdapter` we built for **The Burger Place**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用`GridView`构建**四桶水果**菜单。`GridView`将为菜单上的每个项目提供一个图标，以及图标下方的项目名称。因此，完成后，它看起来将非常像标准的Android应用程序菜单。下一个示例将重点介绍`ListAdapter`的实现，因为它与我们为**汉堡店**构建的`ListAdapter`大致相同。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Icons on touchscreen devices**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**触摸屏设备上的图标**'
- en: It's important to think about icons on a touchscreen device. They need to be
    even more self-explanatory than usual, or be accompanied by some text. With a
    touchscreen, it's very hard to provide any sort of contextual help, such as a
    tool-tip. If the user is touching the object, it's often obscured by their finger
    and/or hand, making the icon and tool-tip invisible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸屏设备上考虑图标非常重要。它们需要比平时更具自解释性，或者需要伴随一些文本。使用触摸屏很难提供像工具提示这样的上下文帮助。如果用户正在触摸对象，它通常会被他们的手指和/或手遮住，使得图标和工具提示不可见。
- en: Time for action – creating the fruit icon
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建水果图标的时间到了。
- en: In order to display the various types of fruits as icons, we will need to create
    a layout XML file. Each icon in the `GridView` will be represented as an instance
    of this layout, in exactly the same way as list items are represented in a `ListView`.
    We create each item as an `ImageView` for the icon, with a `TextView` below it
    for the label.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将各种类型的水果显示为图标，我们将需要创建一个布局XML文件。`GridView`中的每个图标都将作为此布局的一个实例表示，与`ListView`中表示列表项目的方式完全相同。我们为图标创建每个项目作为`ImageView`，并在其下方为标签创建一个`TextView`。
- en: Create a file in the `res/layout` directory named `fruit_item.xml`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`目录中创建一个名为`fruit_item.xml`的文件。
- en: 'Declare the root element of the icon as a vertical `LinearLayout`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图标的根元素声明为垂直的`LinearLayout`：
- en: '[PRE47]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `ImageView` element that will serve as our icon:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将作为我们图标的`ImageView`元素：
- en: '[PRE48]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, create the `TextView` element that will serve as the label:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建将作为标签的`TextView`元素：
- en: '[PRE49]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*What just happened?*'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `fruit_item.xml` file is a very simple layout for our menu icons, and could
    be used for many other types of icons represented as a grid. `ImageView` objects
    will, by default, attempt to scale their content to their size. In our previous
    example, the root `LinearLayout` has the width and height defined as `fill_parent`.
    When placed in a `GridView` as a single item, using `fill_parent` as a size will
    cause the `LinearLayout` to fill the space provided for that grid item (not the
    entire `GridView`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`fruit_item.xml`文件是我们菜单图标的非常简单的布局，也可以用于许多其他类型的图标，表现为网格形式。`ImageView`对象默认会尝试将其内容缩放到其尺寸。在我们之前的示例中，根`LinearLayout`的宽度和高度定义为`fill_parent`。当在`GridView`中作为单个项目放置时，使用`fill_parent`作为大小将导致`LinearLayout`填充为该网格项目提供的空间（不是整个`GridView`）。'
- en: Displaying icons in a GridView
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`GridView`中显示图标
- en: We need an object model and `ListAdapter` in order to display the fruits to
    the user in a `GridView`. The adapter is fairly straightforward at this point.
    It's a normal `ListAdapter` implementation built on top of an item class and the
    layout XML we defined for the icons.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对象模型和`ListAdapter`，以便在`GridView`中将水果显示给用户。此时，适配器相当直接。它是在一个项目类和为图标定义的布局XML之上构建的正常`ListAdapter`实现。
- en: 'For each item of fruit, we will need an object holding both the fruit''s name
    and icon. Create a `FruitItem` class in the root package with the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种水果，我们需要一个同时保存水果名称和图标的对象。在根包中创建一个 `FruitItem` 类，并使用以下代码：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we referenced the icon image for the fruit as an integer.
    When we reference application resources and IDs in Android, it's always with an
    integer. For this example we're assuming that all of the different types of fruit
    each have an icon as an application resource. Another option would be to hold
    a reference to a `Bitmap` object in each `FruitItem`. However, this would have
    meant holding the full image in memory when the `FruitItem` is potentially not
    on the screen.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将水果的图标图像作为一个整数引用。在Android中引用应用程序资源和ID时，总是使用整数。在这个例子中，我们假设所有不同类型的水果都有一个作为应用程序资源的图标。另一个选项是每个
    `FruitItem` 持有一个对 `Bitmap` 对象的引用。然而，这意味着当 `FruitItem` 可能不在屏幕上时，需要将完整的图像保存在内存中。
- en: In order for the Android Asset Packaging Tool to recognize and store the icons,
    you will need to put them in the `res/drawable` directory.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Android Asset Packaging Tool识别并存储图标，你需要将它们放在 `res/drawable` 目录中。
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Android Image Resources**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**安卓图像资源**'
- en: Generally, it's considered a good practice in Android to store bitmap images
    as PNG files. Since you will be accessing these files from your code, make sure
    they have Java-friendly filenames. The PNG format (unlike JPG) is lossless, can
    have various different color depths, and correctly handles transparency. This
    generally makes it a great image format on the whole.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Android中，将位图图像存储为PNG文件被认为是一个好习惯。由于你将要从代码中访问这些文件，请确保它们具有Java友好的文件名。PNG格式（与JPG不同）是无损的，可以具有不同的颜色深度，并且正确处理透明度。这使得它整体上成为一个很棒的图像格式。
- en: Time for action – building the fruit menu
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——构建水果菜单
- en: For the **Four Buckets 'o Fruit** menu, we're going to need a `ListAdapter`
    implementation to render the `FruitItem` objects into the `fruit_item.xml` layout
    resources. We'll also need a layout resource for the `GridView` which we will
    load in our new `Activity` class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **四个水果桶菜单**，我们需要一个 `ListAdapter` 实现，以将 `FruitItem` 对象渲染到 `fruit_item.xml`
    布局资源中。我们还需要一个 `GridView` 的布局资源，我们将在新的 `Activity` 类中加载它。
- en: Create a new class named `FruitAdapter` extending `BaseAdapter` in the root
    package of the project.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个名为 `FruitAdapter` 的类，继承自 `BaseAdapter`。
- en: '`FruitAdapter` needs to hold and represent an array of `FruitItem` objects.
    Implement the class using the same structure as the `BurgerAdapter`.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FruitAdapter` 需要保存并代表一个 `FruitItem` 对象数组。使用与 `BurgerAdapter` 相同的结构实现该类。'
- en: 'In the `ListAdapter.getView` method, set the label and icon as defined in the
    `fruit_item.xml` layout resource:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ListAdapter.getView` 方法中，按照 `fruit_item.xml` 布局资源中定义的标签和图标进行设置：
- en: '[PRE51]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a new layout resource to hold the `GridView` that we will use for the
    **Four Buckets 'o Fruit** menu, and name it `res/layout/four_buckets.xml`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布局资源，用于保存我们将用于 **四个水果桶菜单** 的 `GridView`，并将其命名为 `res/layout/four_buckets.xml`。
- en: 'Populate the new layout resource with a three column `GridView`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三列 `GridView` 填充新的布局资源：
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*What just happened?*'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The new `four_buckets.xml` layout resource has nothing but a `GridView`. This
    is unlike the other layout resources we've written so far, especially since the
    `GridView` has no ID. For this example, the fruit menu `Activity` will contain
    nothing but the `GridView`, so there's no need for an ID reference or layout structure.
    We also specified horizontal and vertical spacing of `5dip`. A `GridView` object's
    default is to have no spacing between its cells, which makes for fairly squashed
    content. In order to space things out a bit, we ask for some whitespace between
    each of the cells.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `four_buckets.xml` 布局资源中只有一个 `GridView`。这与我们迄今为止编写的其他布局资源不同，尤其是 `GridView`
    没有ID。对于这个例子，水果菜单 `Activity` 将只包含 `GridView`，因此无需ID引用或布局结构。我们还指定了水平和垂直间距为 `5dip`。`GridView`
    对象的默认设置是在其单元格之间没有间距，这使得内容相当紧凑。为了使内容之间稍微有些间隔，我们要求在各个单元格之间有一些空白。
- en: Time for action – creating the FourBucketsActivity
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建 FourBucketsActivity
- en: Since we are working with a layout resource with only a `GridView`, and no ID
    reference, we're going to walk through the creation of the `Activity` step-by-step.
    Unlike previous `Activity` implementations, we will need a direct reference to
    the `GridView` defined in `four_buckets.xml`, and this means loading it manually.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是只有一个`GridView`的布局资源，并且没有ID引用，我们将逐步创建`Activity`。与之前的`Activity`实现不同，我们需要直接引用在`four_buckets.xml`中定义的`GridView`，这意味着需要手动加载它。
- en: 'Start by creating a new class in your project''s root package:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从在你的项目的根包中创建一个新类开始：
- en: '[PRE53]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Override the `onCreate` method, and invoke the super implementation:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onCreate`方法，并调用父类实现：
- en: '[PRE54]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Get the `LayoutInflator` instance for your `Activity` object:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的`Activity`对象获取`LayoutInflator`实例：
- en: '[PRE55]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inflate the `four_buckets.xml` resource and cast its contents directly to a
    `GridView` object:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 充气`four_buckets.xml`资源，并将其内容直接转换为`GridView`对象：
- en: '[PRE56]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Set the `ListAdapter` of the `view` object to a new instance of the `FruitAdapter`
    class, and populate the new `FruitAdapter` with some `FruitItem` objects:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`view`对象的`ListAdapter`设置为新`FruitAdapter`类的实例，并用一些`FruitItem`对象填充新的`FruitAdapter`：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use `setContentView` to make the `GridView` your root `View` object:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setContentView`使`GridView`成为你的根`View`对象：
- en: '[PRE58]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Register your `FourBucketsActivity` class in your `AndroidManifest.xml`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`AndroidManifest.xml`中注册你的`FourBucketsActivity`类。
- en: Add a case to the `SelectRestaurantActivity` to start the new `FourBucketsActivity`
    when the user selects it.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`SelectRestaurantActivity`添加一个案例，当用户选择时启动新的`FourBucketsActivity`。
- en: '*What just happened?*'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You just completed the **Four Buckets 'o Fruit** menu. If you re-install the
    application into your emulator, you'll now be able to go and order fruits (just
    be careful to have the 16 ton weight ready in case the delivery guy attacks you).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了**四桶水果**菜单。如果你将应用程序重新安装到你的模拟器中，你现在将能够去订购水果（只需小心准备好16吨的重量，以防送货员攻击你）。
- en: If you look through the `Activity` documentation, you'll notice that while there's
    a `setContentView` method, there's no corresponding `getContentView` method. Take
    a closer look and you will notice the `addContentView` method. An `Activity` object
    may have any number of `View` objects attached to it as "content". This precludes
    any useful implementation of a `getContentView` method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Activity`文档，你会注意到虽然有一个`setContentView`方法，但没有相应的`getContentView`方法。仔细查看，你会注意到`addContentView`方法。`Activity`对象可以有任意数量的“内容”`View`对象附加到它上面。这使得任何有用的`getContentView`方法的实现变得不可能。
- en: In order to get around this limitation, we inflated the layout ourselves. The
    `getLayoutInflator()` method used is simply a shortcut for `LayoutInflator.from(this)`.
    Instead of using an ID and `findViewById`, we simply cast the `View` returned
    directly to a `GridView`, since that's all that our `four_buckets.xml` file contains
    (much the same way the `ArrayAdapter` class works with `TextView` objects). If
    we wanted to make things a little more abstract, we could have cast it to an `AdapterView<ListAdapter>`,
    in which case we could have swapped in implementation in the file with a `ListView`.
    However, this wouldn't have been very useful for this example.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个限制，我们自己充气了布局。使用的`getLayoutInflator()`方法只是`LayoutInflator.from(this)`的简写。我们没有使用ID和`findViewById`，而是直接将返回的`View`转换为`GridView`，因为我们的`four_buckets.xml`文件只包含这个（与`ArrayAdapter`类处理`TextView`对象的方式类似）。如果我们想要更抽象一点，我们可以将其转换为`AdapterView<ListAdapter>`，在这种情况下，我们可以将文件中的实现替换为`ListView`。然而，这对于这个例子来说并没有太大帮助。
- en: 'If you now re-install and run the application, your new `FourBucketsActivity`
    will present you with a screen similar to the following one:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在重新安装并运行应用程序，你的新`FourBucketsActivity`将展示一个类似以下的屏幕：
- en: '![What just happened?](img/4484_02_08.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_02_08.jpg)'
- en: Have a go hero – Sam's Sushi
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——山姆寿司
- en: 'The last restaurant on the menu is `Sam''s Sushi`. Try using the `Spinner`
    class along with a `GridView` to create a composite sushi menu. Place the spinner
    at the top of the screen, with options for different types of sushi:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单上的最后一家餐厅是`Sam's Sushi`。尝试使用`Spinner`类和`GridView`创建一个复合寿司菜单。将下拉菜单放在屏幕顶部，提供不同类型寿司的选项：
- en: Sashimi
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刺身
- en: Maki Roll
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麻辣卷
- en: Nigiri
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寿司
- en: Oshi
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 押寿司
- en: California Roll
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加州卷
- en: Fashion Sandwich
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时尚三明治
- en: Hand Roll
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手卷
- en: 'Below the `Spinner`, use a `GridView` to display icons for each different type
    of fish that the user can order. Here are some suggestions:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Spinner`下方，使用`GridView`显示用户可以订购的每种不同类型鱼的图标。以下是一些建议：
- en: Tuna
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金枪鱼
- en: Yellowtail
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄尾鱼
- en: Snapper
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲷鱼
- en: Salmon
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲑鱼
- en: Eel
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鳗鱼
- en: Sea Urchin
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海胆
- en: Squid
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鱿鱼
- en: Shrimp
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虾
- en: The `Spinner` class makes use of the `SpinnerAdapter` instead of a `ListAdapter`.
    The `SpinnerAdapter` includes an additional `View` object which represents the
    drop-down menu. This is most typically a reference to the `android.R.layout.simple_dropdown_item_1line`
    resource. However, for this example, however, you can probably make use of the
    `android:entries` attribute on the `Spinner` XML element.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spinner` 类使用了 `SpinnerAdapter` 而不是 `ListAdapter`。`SpinnerAdapter` 包含了一个额外的
    `View` 对象，它表示下拉菜单。这通常是指向 `android.R.layout.simple_dropdown_item_1line` 资源的引用。然而，对于这个例子，你或许可以使用
    `Spinner` XML 元素上的 `android:entries` 属性。'
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Data display is one of the most common requirements of a mobile application,
    and Android has many different options available. The `ListView` is probably one
    of the most commonly used widgets in the standard Android suite, and styling it
    allows it to be used to display varying amounts of data, from one line menu items
    to multi-line to-do notes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 数据展示是移动应用程序最常见的要求之一，Android 有许多不同的选项可用。`ListView` 可能是标准 Android 套件中最常用的控件之一，对其样式进行设置可以使其用来显示不同数量的数据，从单行菜单项到多行的待办事项笔记。
- en: The `GridView` is effectively a tabular version of `ListView`, and is well suited
    for presenting the user with icon views. Icons have enormous advantages over text,
    since they can be recognized much more quickly by the user. Icons can also take
    up significantly less space, and in a `GridView`, you could easily fit four to
    six icons in a portrait screen without making the user interface cluttered or
    more difficult to work it. This also frees up precious screen space for other
    items to be displayed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 实际上是 `ListView` 的表格版本，非常适合向用户展示图标视图。图标比文本有巨大的优势，因为用户可以更快地识别它们。图标还可以占用更少的空间，在
    `GridView` 中，你可以在竖屏屏幕上轻松地放置四到六个图标，而不会让用户界面显得杂乱或难以操作。这也为其他项目显示释放了宝贵的屏幕空间。'
- en: Building custom `Adapter` classes not only allows you to take complete control
    over the styling of the `ListView`, but also determine where the data comes from,
    and how it's loaded. You could, for example, load the data directly from a web
    service by using an `Adapter` which generates dummy `View` objects until the web
    service responds with actual data. Take a good look at the default `Adapter` implementations,
    they will generally serve your requirements, especially when coupled with a custom
    layout resource.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义 `Adapter` 类不仅允许你完全控制 `ListView` 的样式，还可以决定数据来源以及如何加载数据。例如，你可以通过使用在 Web
    服务响应实际数据之前生成虚拟 `View` 对象的 `Adapter` 直接从 Web 服务加载数据。仔细查看默认的 `Adapter` 实现，它们通常可以满足你的需求，尤其是与自定义布局资源结合使用时。
- en: In the next chapter, we will take a look at some less generic, more specialized
    `View` classes that Android provides. As with almost everything in Android, the
    defaults may be specific, but they can be customized in any number of ways to
    fit some very unusual purposes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看 Android 提供的一些不那么通用、更加专业的 `View` 类。与 Android 中的几乎所有事物一样，默认值可能很具体，但它们可以通过多种方式定制，以适应一些非常特殊的需求。
