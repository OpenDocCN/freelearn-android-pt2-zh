- en: Chapter 12. Mastering the Tool Chain
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十二章. 掌握工具链
- en: 'So far, we have taken a deep dive into the code and policies that drive SE
    for Android technologies, but the build system and tools are often overlooked.
    Mastering the tool chain will help you improve your development practices. In
    this chapter, we will look at all the components of the SE for Android build and
    how they work. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经深入探讨了推动SE for Android技术的代码和政策，但构建系统和工具常常被忽视。掌握工具链将帮助你提高开发实践。在本章中，我们将了解SE
    for Android构建的所有组件及其工作原理。我们将涵盖以下主题：
- en: Building specific targets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建特定目标
- en: The sepolicy `Android.mk` file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sepolicy `Android.mk` 文件
- en: Custom build policy configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义构建策略配置
- en: 'Build tools:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具：
- en: '`check_seapp`'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_seapp`'
- en: '`insertkeys.py`'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertkeys.py`'
- en: '`checkpolicy`'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkpolicy`'
- en: '`checkfc`'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkfc`'
- en: '`sepolicy-check`'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepolicy-check`'
- en: '`sepolicy-analyze`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepolicy-analyze`'
- en: Building subcomponents – targets and projects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建子组件——目标和项目
- en: So far, we have run some magical commands such as `mm`, `mmm`, and `make bootimage`
    to actually build various portions of the SE for Android code. Google officially
    describes some of these tools in the documents at [https://source.android.com/source/building-running.html](https://source.android.com/source/building-running.html),
    but most commands are not listed. Nonetheless, [http://elinux.org/Android_Build_System](http://elinux.org/Android_Build_System)
    has a write up that is more comprehensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经运行了一些神奇的命令，如 `mm`、`mmm` 和 `make bootimage`，实际上构建了SE for Android代码的各个部分。谷歌在文档
    [https://source.android.com/source/building-running.html](https://source.android.com/source/building-running.html)
    中正式描述了其中一些工具，但大多数命令并未列出。尽管如此，[http://elinux.org/Android_Build_System](http://elinux.org/Android_Build_System)
    有一个更全面的相关编写。
- en: In Google's "building and running" documentation, they describe the target as
    the device, which is ultimately what you lunch for. When building Android, the
    `lunch` command sets up environment variables for the `make` command you execute
    later. It sets up the build system to output the correct configuration for the
    target device. This concept of a target is *not* what will be discussed in this
    chapter. Instead, when `target` is mentioned herein, it means a specific `make`
    target. However, in the event of needing to mention the target device, the complete
    phrase "`target device`" will be used. While somewhat confusing, this terminology
    is standard and will be understood by engineers in the field.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌的“构建和运行”文档中，他们将目标描述为设备，这最终是你启动的目标。在构建Android时，`lunch` 命令为稍后执行的 `make` 命令设置环境变量。它设置构建系统以输出目标设备的正确配置。本章将不会讨论这种目标概念。相反，当提到
    `target` 时，它指的是一个特定的 `make` 目标。然而，在需要提及目标设备的情况下，将使用完整的短语“`target device`”。虽然有些令人困惑，但这种术语是标准的，现场的工程师将会理解。
- en: We have issued `make` a few times, optionally providing a target as an argument
    and an option, for example the `-j16` option. Something like `make` or `make -j16`
    essentially builds all of Android. Optionally, you can specify a target or list
    of targets as command arguments. An example of this is when `boot.img` was built.
    The `boot.img` file can be built and rebuilt by specifying the `bootimage` target.
    The command we use for this purpose is `make bootimage`. It helps to expedite
    builds by rebuilding only the portions of the system that are needed. But what
    if you only need to rebuild a particular file? Perhaps, you only want to rebuild
    `sepolicy`. You can specify that as the target to build, as in `make sepolicy`.
    This leads to the question, "What about the other files such as `mac_permissions.xml`,
    `seapp_contexts`, and so on?" They can be built in the same way. The more intriguing
    question is, "How does one know what the target name is? Is it always the file
    output name?"
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次运行了 `make` 命令，可选地提供一个目标作为参数和选项，例如 `-j16` 选项。像 `make` 或 `make -j16` 这样的命令本质上构建了整个Android。可选地，你可以指定一个或多个目标作为命令参数。例如，当构建
    `boot.img` 时，可以通过指定 `bootimage` 目标来构建和重新构建 `boot.img` 文件。我们为此目的使用的命令是 `make bootimage`。它通过仅重建系统中需要的部分来加快构建速度。但如果你只需要重新构建一个特定文件呢？或许，你只想重新构建
    `sepolicy`。你可以将其指定为构建目标，如 `make sepolicy`。这引出了一个问题：“其他文件如 `mac_permissions.xml`、`seapp_contexts`
    等怎么办？”它们也可以以同样的方式构建。更有趣的问题是：“一个人如何知道目标名称是什么？它总是输出文件的名称吗？”
- en: 'Android''s build system is constructed on top of GNU `make` ([http://www.gnu.org/software/make/](http://www.gnu.org/software/make/)).
    The core of the Android build system''s makefiles system can be found in `build/core`,
    and the documentation can be found in the NDK ([https://developer.android.com/tools/sdk/ndk/index.html](https://developer.android.com/tools/sdk/ndk/index.html)).
    The major take away from that reading is that a typical `Android.mk` file defines
    something called `LOCAL_MODULE := mymodulename`, and something called `mymodulename`
    is built. The target names are defined by these `LOCAL_MODULE` statements. Let''s
    look at the `Android.mk` for external sepolicy, and focus on the sepolicy portion
    of it, as there are other local modules or targets defined in that `Makefile`.
    The following is an example from Android 4.3:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android的构建系统是建立在GNU `make`之上的（[http://www.gnu.org/software/make/](http://www.gnu.org/software/make/)）。Android构建系统的核心makefile系统可以在`build/core`中找到，而文档可以在NDK中找到（[https://developer.android.com/tools/sdk/ndk/index.html](https://developer.android.com/tools/sdk/ndk/index.html)）。从阅读中可以得出的主要结论是，一个典型的`Android.mk`文件定义了称为`LOCAL_MODULE
    := mymodulename`的东西，以及构建名为`mymodulename`的东西。目标名称由这些`LOCAL_MODULE`语句定义。让我们查看外部sepolicy的`Android.mk`，关注其中sepolicy部分，因为在该`Makefile`中还定义了其他本地模块或目标。以下是从Android
    4.3的一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One can find all the modules for within an `Android.mk` file by just looking
    for lines that begin with `LOCAL_MODULE` declarations and are whole word matches:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要查找以`LOCAL_MODULE`声明开始的行，并且是全词匹配，就可以在`Android.mk`文件中找到所有模块：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Regular expressions dictate that ^ is the beginning of the line, and the `grep`
    man page states that `-w` provides whole word search.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式规定，`^`表示行的开始，而`grep`的手册页指出`-w`提供全词搜索。
- en: The preceding list is comprehensive for the version of Android we are using
    on the UDOO. However, you should run the command on your exact version of the
    `Makefile` to get an idea of what things can be built.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表对于我们目前在UDOO上使用的Android版本来说是很全面的。但是，你应该在你的`Makefile`的确切版本上运行命令，以了解可以构建哪些内容。
- en: Android has some additional tools that are separate from building targets and
    get added to your environment when you use `source build/envsetup.sh`. These are
    `mm` and `mmm`. They both perform the same task, which is to build all the targets
    specified in an `Android.mk` file, however, differing that they do not build any
    of their dependencies. The two commands only differ in where they source the location
    of the `Android.mk` to scour for build targets. The `mm` command uses the current
    working directory, whereas `mmm` uses a supplied path. Also, a great option for
    either command is `-B`, which forces a rebuild. An engineer can save a lot of
    time by using the `mm(m)` commands over `make <target>`. The full `make` command
    wastes a lot of time figuring out the dependency tree, so executing `mmm path/to/project`
    on a previously built source tree (if you know that all your changes are within
    a project) can save a few minutes. However, since it doesn't build the dependencies,
    you'll need to ensure that they are already built and have no dependent changes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Android还有一些额外的工具，这些工具与构建目标分开，并在你使用`source build/envsetup.sh`时添加到你的环境中。这些工具是`mm`和`mmm`。它们执行相同的任务，即构建`Android.mk`文件中指定的所有目标，但不同之处在于它们不构建任何依赖项。这两个命令的区别仅在于它们查找构建目标所在的`Android.mk`的位置。`mm`命令使用当前工作目录，而`mmm`使用提供的路径。此外，这两个命令的一个很好的选项是`-B`，它强制重新构建。工程师使用`mm(m)`命令而不是`make
    <target>`可以节省大量时间。完整的`make`命令在确定依赖关系树上浪费了很多时间，所以如果在之前构建的源代码树（如果你知道你的所有更改都在一个项目中）上执行`mmm
    path/to/project`可以节省几分钟。但是，由于它不构建依赖项，你需要确保它们已经构建并且没有依赖性更改。
- en: Exploring sepolicy's Android.mk
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索sepolicy的Android.mk
- en: The project located at `external/sepolicy` uses an `Android.mk` file, like any
    other Android project, to build their outputs. Let's dissect this file and see
    what it does.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`external/sepolicy`的项目与其他Android项目一样，使用`Android.mk`文件来构建它们的输出。让我们剖析这个文件，看看它都做了些什么。
- en: Building sepolicy
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建sepolicy
- en: 'We''ll start in the middle by looking at the target for `sepolicy`. It starts
    off with fairly boilerplate `Android.mk` stuff:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从中间开始，查看针对`sepolicy`的目标。它以相当标准化的`Android.mk`内容开始：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next portion is a bit more like standard `make`. It starts off by declaring
    a target file that gets built into the `intermediates` location. The `intermediates`
    location is defined by the Android build system. It then assigns the values of
    `MLS_SENS` and `MLS_CATS` to some local variables for later use. The last line
    is the most interesting. It uses a `make` function, called `build_policy`, and
    takes filenames as arguments:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分有点类似于标准的`make`。它首先声明一个目标文件，该文件会被构建到`intermediates`位置。`intermediates`位置是由Android构建系统定义的。然后它将`MLS_SENS`和`MLS_CATS`的值赋给一些局部变量以供后续使用。最后一条语句是最有趣的。它使用了一个名为`build_policy`的`make`函数，并接受文件名作为参数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we define the recipe for building this intermediate target, `policy.conf`.
    The interesting bits of the recipe are the `m4` command and the `sed` command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了构建此中间目标`policy.conf`的recipe。recipe中有趣的部分是`m4`命令和`sed`命令。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: For more information on `m4`, see [http://www.gnu.org/software/m4/manual/m4.html](http://www.gnu.org/software/m4/manual/m4.html),
    and for more information on `sed`, refer to [https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`m4`的更多信息，请参见[http://www.gnu.org/software/m4/manual/m4.html](http://www.gnu.org/software/m4/manual/m4.html)，有关`sed`的更多信息，请参考[https://www.gnu.org/software/sed/manual/sed.html](https://www.gnu.org/software/sed/manual/sed.html)。
- en: 'SELinux policy files get processed using `m4`. `m4` is a macro processor language
    that is often used as a frontend to a compiler. The `m4` command takes some of
    the values such as `PRIVATE_MLS_SENS` and `PRIVATE_MLS_CATS` and passes them through
    as macro definitions. This is analogous to the `gcc -D` option. It then takes
    the dependencies for the target as input via the `make` expansion, `$^`, and outputs
    them to the target name using the `make` expansion of `$@`. It also takes that
    output and generates a `.dontaudit` version. That version has all of the `dontaudit`
    lines deleted from the policy file using `sed`. The MLS values tell SELinux how
    many categories and sensitivities to generate. These must be statically defined
    in the policy blob that is loaded into the kernel, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux策略文件是通过`m4`处理的。`m4`是一种通常被用作编译器前端的宏处理器语言。`m4`命令取一些值，如`PRIVATE_MLS_SENS`和`PRIVATE_MLS_CATS`，并将它们作为宏定义传递。这类似于`gcc
    -D`选项。然后它通过`make`扩展`$^`获取目标的依赖项，并使用`make`扩展`$@`将它们输出到目标名称。它还取该输出并生成一个`.dontaudit`版本。该版本使用`sed`从策略文件中删除所有`dontaudit`行。MLS值告诉SELinux生成多少类别和敏感性。这些必须在加载到内核的策略块中静态定义，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next portion defines the recipe for building the actual target, named from
    `LOCAL_MODULE_POLICY`, even if this is not obvious. `LOCAL_BUILT_MODULE` expands
    to the intermediate file to be built, `sepolicy` in this case. It finally gets
    copied by the Android build system as `LOCAL_INSTALLED_MODULE` behind the scenes.
    This target depends on the intermediate `policy.conf` file and on `checkpolicy`.
    It uses `checkpolicy` to transform the `m4` expanded `policy.conf` and `policy.conf.dontaudit`
    into two sepolicy files, `sepolicy` and `sepolicy.dontaudit`. The actual tool
    that is used to compile the SELinux statements in binary form to load to the kernel
    is `checkpolicy`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分定义了构建实际目标recipe，该目标名为`LOCAL_MODULE_POLICY`，即使这一点并不明显。`LOCAL_BUILT_MODULE`扩展为要构建的中间文件，在这种情况下是`sepolicy`。最后，它由Android构建系统在幕后作为`LOCAL_INSTALLED_MODULE`复制。此目标依赖于中间`policy.conf`文件和`checkpolicy`。它使用`checkpolicy`将`m4`扩展的`policy.conf`和`policy.conf.dontaudit`转换为两个sepolicy文件，`sepolicy`和`sepolicy.dontaudit`。实际用于将SELinux语句编译成二进制形式以加载到内核的工具是`checkpolicy`，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, it ends by setting a local variable, `built_policy`, for use elsewhere
    within the `Android.mk` file, and clears `policy.conf` to avoid polluting the
    global namespace of `make`, as shown:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它通过设置局部变量`built_policy`供`Android.mk`文件中的其他地方使用，并清除`policy.conf`以避免污染`make`的全局命名空间，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Additionally, building `sepolicy` also depends on the `POLICYVERS` variable,
    which is conditionally assigned a value of `26` if not set. This is the policy
    version number used by `checkpolicy`, and as we saw earlier in the book, we had
    to override this for our UDOO.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构建`sepolicy`还依赖于`POLICYVERS`变量，如果未设置，则条件赋值为`26`。这是`checkpolicy`使用的策略版本号，正如我们在本书前面看到的，我们不得不为我们的UDOO覆盖这一点。
- en: Controlling the policy build
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制策略构建
- en: We saw that the `sepolicy` statement calls the `build_policy` function. We also
    see its use in that `Android.mk` file for building `sepolicy`, `file_contexts`,
    `seapp_contexts`, `property_contexts`, and `mac_permissions.xml`, so it reasons
    that it is fairly important. This function outputs a list of fully resolved paths
    used for policy files. The function takes as inputs a variable argument list of
    filenames and includes regular expression support (note `*.te` in the `build_policy`
    for target sepolicy). Internally, that function uses some magic to allow you to
    override or append to the current policy build without modifying the `external/sepolicy`
    directory directly. This is meant for OEMs and device builders to be able to augment
    policy to cover their specific devices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`sepolicy`语句调用了`build_policy`函数。我们还在`Android.mk`文件中看到它的用途，用于构建`sepolicy`、`file_contexts`、`seapp_contexts`、`property_contexts`和`mac_permissions.xml`，因此可以推断这个函数相当重要。该函数输出用于策略文件的完全解析路径列表。该函数以变量参数列表的文件名为输入，并支持正则表达式（注意`build_policy`中的`*.te`用于目标sepolicy）。在内部，该函数使用一些技巧，允许你覆盖或追加当前策略构建，而无需直接修改`external/sepolicy`目录。这是为了使OEM和设备构建者能够增加策略，以覆盖其特定设备。
- en: 'When building a policy, you can set the following `make` variables, typically
    in the device''s `Makefile`, to control the resulting build. The variables are
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建策略时，你可以在设备的`Makefile`中设置以下`make`变量，以控制生成的构建结果。这些变量如下：
- en: '`BOARD_SEPOLICY_DIRS`: This is the search path for potential policy files'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_SEPOLICY_DIRS`：这是潜在策略文件的搜索路径。'
- en: '`BOARD_SEPOLICY_UNION`: This is a policy file of name to append to all files
    with the same name'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_SEPOLICY_UNION`：这是一个要附加到所有同名文件的策略文件。'
- en: '`BOARD_SEPOLICY_REPLACE`: This is a policy file used to override the base `external/sepolicy`
    policy file'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_SEPOLICY_REPLACE`：这是一个用于覆盖基础`external/sepolicy`策略文件的策略文件。'
- en: '`BOARD_SEPOLICY_IGNORE`: This is used to remove a particular policy file from
    the build, given a repository''s relative path'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_SEPOLICY_IGNORE`：这是用于从构建中移除特定策略文件，给定仓库的相对路径。'
- en: 'Using the UDOO as an example, the proper way to author a policy was never to
    modify `external/sepolicy` but to create a directory in `device/fsl/udoo/sepolicy`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以UDOO为例，编写策略的正确方式是永远不要修改`external/sepolicy`，而是在`device/fsl/udoo/sepolicy`中创建一个目录：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we modify the `BoardConfig.mk`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们修改`BoardConfig.mk`： '
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we add the following lines:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加以下几行：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be very careful with `+=` as opposed to `:=`. In large project trees, some of
    these variables may be set higher in the build tree by common `BoardConfigs`,
    and you could wipe out their settings. Typically, the safest bet is `+=`. For
    further details, see *Variable Assignment* in the GNU make manual, at [http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`+=`与`:=`时要非常小心。在大型项目树中，这些变量可能会在构建树的更高位置被常见的`BoardConfigs`设置，而你可能会覆盖它们的设置。通常，最安全的选择是`+=`。有关详细信息，请参阅GNU
    make手册中的*变量赋值*部分，在[http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html)。
- en: This will tell the `build_policy()` function in `Android.mk` to search not only
    `external/sepolicy` but also `device/fsl/udoo/sepolicy` for policy files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉`Android.mk`中的`build_policy()`函数不仅搜索`external/sepolicy`目录，还要搜索`device/fsl/udoo/sepolicy`目录下的策略文件。
- en: Next, we can create a `file_contexts` file in this directory, and move our changes
    for labeling to this directory by creating a new `file_contexts` file in `device/fsl/udoo/sepolicy`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在该目录中创建一个`file_contexts`文件，并通过在该目录中创建一个新的`file_contexts`文件，将我们对标签的更改移动到`device/fsl/udoo/sepolicy`目录。
- en: 'After this, we need to instruct the build system to combine, or union, our
    `file_contexts` file with the one in `external/sepolicy`. We accomplish this by
    adding the following statement to the `BoardConfig.mk` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要指导构建系统将我们的`file_contexts`文件与`external/sepolicy`中的文件进行合并或联合。我们通过在`BoardConfig.mk`文件中添加以下声明来实现这一点：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can do this for any policy file, even custom files. It does a match on
    the filename by basename only (no directories). For instance, if you had a `watchdog.te`
    rules file you wanted to add to the base `watchdog.te` rules file, you could just
    add `watchdog.te`, as shown:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对任何策略文件执行此操作，甚至是自定义文件。它仅通过文件名（不包括目录）进行匹配。例如，如果你有一个名为`watchdog.te`的规则文件，你想将其添加到基础的`watchdog.te`规则文件中，你可以像下面这样只添加`watchdog.te`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This produces a new `watchdog.te` file during the build that unions your new
    rules with the ones found in `external/sepolicy/watchdog.te`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在构建过程中生成一个新的`watchdog.te`文件，将你的新规则与在`external/sepolicy/watchdog.te`中找到的规则进行联合。
- en: 'Also note that you add new files into the build with `BOARD_SEPOLICY_UNION`,
    so to add a `.te` file for a custom domain, such as `custom.te`, you could:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，你可以使用`BOARD_SEPOLICY_UNION`将新文件添加到构建中，因此要为自定义域（如`custom.te`）添加一个`.te`文件，你可以：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s say you want to override the `external/sepolicy watchdog.te` file with
    your own. You can add it to `BOARD_SEPOLICY_REPLACE`, as shown:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想用你自己的文件覆盖`external/sepolicy watchdog.te`。你可以将其添加到`BOARD_SEPOLICY_REPLACE`中，如下所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that you can't replace a file that does not exist in the base policy. Also,
    you can't have the same file appear in `UNION` and `REPLACE`, as it's ambiguous.
    You can't have more than one specification of `BOARD_SEPOLICY_REPLACE` on the
    same policy file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能替换在基础策略中不存在的文件。同时，你不能让同一个文件在`UNION`和`REPLACE`中出现，因为这是模棱两可的。在同一个策略文件上不能有超过一个的`BOARD_SEPOLICY_REPLACE`规范。
- en: Suppose we have a hierarchical build occurring for two fictitious devices, device
    X and device Y. The two devices, device X and device Y, both inherit `BoardConfigCommon.mk`
    from device A. Device A is not a real device, but since X and Y share commonalities,
    the common bits are kept in device A.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为两个虚构的设备（设备 X 和设备 Y）进行分层构建。这两个设备，设备 X 和设备 Y，都从设备 A 继承了`BoardConfigCommon.mk`。设备
    A 不是一个真实的设备，但由于 X 和 Y 有共同点，因此将共同的部分保存在设备 A 中。
- en: 'Suppose the `BoardConfigCommon.mk` for device A contains these statements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设设备 A 的`BoardConfigCommon.mk`包含以下语句：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Suppose that device X''s `BoardConfig.mk` contains:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设设备 X 的`BoardConfig.mk`包含以下内容：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, suppose device Y''s `BoardConfig.mk` contains:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设设备 Y 的`BoardConfig.mk`包含以下内容：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting policy sets used to build device X and device Y are the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建设备 X 和设备 Y 的结果策略集如下：
- en: 'Device X policy set:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 设备 X 策略集：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Device Y also contains:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设备 Y 也包含以下内容：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a common scenario, you might not want the resulting policy set for device
    Y to contain `device/OEM/A/custom.te`. This is a use case for `BOARD_SEPOLICY_IGNORE`.
    You can use this to filter out specific policy files. However, you have to be
    specific and use the repository''s relative path. For example, in device Y''s
    `BoardConfig.mk`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个常见场景中，你可能不希望设备 Y 的结果策略集包含`device/OEM/A/custom.te`。这是`BOARD_SEPOLICY_IGNORE`的一个用例。你可以用它来过滤特定的策略文件。但是，你必须具体指明并使用仓库的相对路径。例如，在设备
    Y 的`BoardConfig.mk`中：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when you build a policy for device Y, the policy set will not include that
    file. `BOARD_SEPOLICY_IGNORE` can also be used with `BOARD_SEPOLICY_REPLACE`,
    allowing multiple uses in the device hierarchy, but only one `BOARD_SEPOLICY_REPLACE`
    statement takes effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你为设备 Y 构建策略时，策略集将不会包括那个文件。`BOARD_SEPOLICY_IGNORE`也可以与`BOARD_SEPOLICY_REPLACE`一起使用，允许在设备层次结构中多次使用，但只有一个`BOARD_SEPOLICY_REPLACE`语句生效。
- en: Digging deeper into build_policy
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入挖掘 build_policy
- en: Now that we have seen how to use some new mechanisms to control the policy build,
    let's actually dissect where in the build process happens. As stated earlier,
    the policy build is controlled by the `Android.mk` file. We encountered calls
    to the `build_policy()` function earlier, and this is precisely where the magic
    happens with respect to all of the `BOARD_SEPOLICY_*` variables we set. Examining
    the `build_policy` function, we see references to the `sepolicy_replace_paths`
    variable, so let's start by looking at that variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用一些新的机制来控制策略构建，让我们实际剖析构建过程发生在哪里。如前所述，策略构建由`Android.mk`文件控制。我们之前遇到了对`build_policy()`函数的调用，这正是与我们所设置的所有的`BOARD_SEPOLICY_*`变量相关的魔法发生的地方。检查`build_policy`函数，我们看到它引用了`sepolicy_replace_paths`变量，所以让我们从查看这个变量开始。
- en: 'The `sepolicy_replace_paths` variable begins life by getting evaluated when
    the `Makefile` is evaluated. In other words, it is executed unconditionally. The
    code starts off by looping over all the `BOARD_SEPOLICY_REPLACE` files and checks
    whether any are in `BOARD_SEPOLICY_UNION`. If one is found, an error is printed
    and the build fails, showing `Ambiguous request for sepolicy $(pf). Appears in
    both BOARD_SEPOLICY_REPLACE and BOARD_SEPOLICY_UNION`, where `$(pf)` is expanded
    to the offending policy file. After that, it expands the `BOARD_SEPOLICY_REPLACE`
    entries with those found on the search paths set by `BOARD_SEPOLICY_DIRS`, thus
    resulting in full relative paths from the root of the Android tree. Then it filters
    these entries against `BOARD_SEPOLICY_IGNORE`, dropping anything that should be
    ignored. It then ensures that only one file candidate for replacement is found.
    Otherwise, it issues the appropriate error message. Lastly, it ensures that the
    file exists in the `LOCAL_PATH` or base policy, and if none of the two is found,
    it issues an error message:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy_replace_paths`变量在`Makefile`执行时进行评估，换句话说，它会无条件执行。代码首先遍历所有的`BOARD_SEPOLICY_REPLACE`文件，检查是否存在于`BOARD_SEPOLICY_UNION`中。如果发现一个，就会打印错误信息，构建失败，显示`Ambiguous
    request for sepolicy $(pf). Appears in both BOARD_SEPOLICY_REPLACE and BOARD_SEPOLICY_UNION`，其中`$(pf)`会被扩展为有问题的策略文件。之后，它用`BOARD_SEPOLICY_DIRS`设置的搜索路径中找到的条目来扩展`BOARD_SEPOLICY_REPLACE`，从而得到从Android树的根目录开始的完整相对路径。然后它将这些条目与`BOARD_SEPOLICY_IGNORE`进行过滤，删除任何应该被忽略的内容。接着确保只找到一个替换的文件候选。否则，它会发出适当的错误信息。最后，它会确保文件存在于`LOCAL_PATH`或基础策略中，如果两者都找不到，它会发出错误信息：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After this, calls to build policy can use `replace_paths` as an expanded list
    of files that will be replaced during the build.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，构建策略的调用可以使用`replace_paths`作为在构建期间将被替换的文件的扩展列表。
- en: 'The arguments of the `build_policy` function are the filenames you wish to
    expand into their Android root-relative path names, using the power provided by
    the `BOARD_SEPOLICY_*` family of variables. For instance, a call to `$(build_policy,
    file_contexts)` in the context of our devices A, X, and Y would result in this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_policy`函数的参数是您希望使用`BOARD_SEPOLICY_*`系列变量的提供的功能扩展到它们的Android根相对路径名称的文件名。例如，在我们的设备A、X和Y的上下文中调用`$(build_policy,
    file_contexts)`将导致如下结果：'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `build_policy` function is a bit tricky to read. Many nested function calls
    result in the deepest indents running first. However, like all code, we read it
    from top to bottom and left to right, so the explanation will begin there. The
    function starts by looping through all the files passed as arguments. It then
    expands them against the `BOARD_SEPOLICY_DIRS` once for replace and once for a
    union. The `sepolicy_replace_paths` variable is error checked to ensure a file
    does not appear in both locations, replace and union. For the replace path expansion,
    it checks whether the expanded path is in `sepolicy_replace_dirs`, and if it is,
    replaces it. For the union portion, it just expands them. The results of these
    expansions are then fed through a filter on `BOARD_SEPOLICY_IGNORE`, thus dropping
    any of the explicitly ignored paths:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_policy`函数的阅读有点棘手。许多嵌套的函数调用导致最深的缩进首先运行。然而，像所有代码一样，我们从上到下，从左到右阅读，因此解释将从这里开始。该函数首先遍历作为参数传递的所有文件。然后针对`BOARD_SEPOLICY_DIRS`进行一次替换和一次联合的扩展。检查`sepolicy_replace_paths`变量以确保文件没有同时出现在替换和联合的位置。对于替换路径的扩展，它会检查扩展后的路径是否在`sepolicy_replace_dirs`中，如果是，则替换它。对于联合部分，它只是进行扩展。这些扩展的结果随后通过`BOARD_SEPOLICY_IGNORE`的过滤器，从而删除任何明确忽略的路径：'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Building mac_permissions.xml
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建mac_permissions.xml
- en: The `mac_permissions.xml` build is a bit tricky, as we saw in [Chapter 10](ch10.html
    "Chapter 10. Placing Applications in Domains"), *Placing Applications in Domains*.
    First, `mac_permissions.xml` can be used with all the `BOARD_SEPOLICY_*` variables
    introduced thus far. The end result is one XML file adhering to the rules of those
    variables. Additionally, the raw XML files are processed by a tool called `insertkeys.py`,
    located in `sepolicy/tools`. The `insertkeys.py` tool uses `keys.conf` to map
    tags in the XML file signature stanza with `.pem` files containing the certificate.
    The `keys.conf` file is also subject to use in `BOARD_SEPOLICY_*` variables. The
    build recipe first calls `build_policy` on `keys.conf` and uses `m4` to concatenate
    the results. Thus, `m4` declarations in `keys.conf` will be respected. However,
    this has not been used. The initial intention was to use the `m4 -s` sync lines
    so that you can follow the inclusion chain in the `keys.conf` file when concatenated
    by `m4` processing. On the other hand, sync lines are provided by `m4` when concatenating
    many files, and they provide commented lines adhering to the `#line NUM "FILE"'`
    lines. These are useful because `m4` takes multiple input files and combines them
    into a single, expanded output file. There will be sync lines indicating the beginning
    of each of those files, and they can help you track down issues. Continuing back
    to the `mac_permissions.xml` build, after expansion of `keys.conf` by `m4`, this
    file, along with all the `mac_permissions.xml` files from a call to `build_policy()`
    are finally fed to `insertkeys.py`. The `insertkeys.py` tool then uses the `keys.conf`
    file to replace all matching `signature=<TAG>` lines with an actual hex-encoded
    X509 from the PEM file, that is, `signature=308E3600`. Additionally, the `insertkeys.py`
    tool combines the XML files into one file, and strips whitespace and comments
    to reduce its size on disk. This has no build dependencies on the other major
    files such as `sepolicy`, `seapp_contexts`, `property_contexts`, and `mac_permissions.xml`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第10章](ch10.html "第10章. 将应用置于域中")《将应用置于域中》所见，`mac_permissions.xml`的构建有点棘手。首先，`mac_permissions.xml`可以与迄今为止引入的所有`BOARD_SEPOLICY_*`变量一起使用。最终结果是生成一个符合这些变量规则的XML文件。此外，原始XML文件由位于`sepolicy/tools`目录下的一个名为`insertkeys.py`的工具处理。`insertkeys.py`工具使用`keys.conf`将XML文件签名区域的标签与包含证书的`.pem`文件进行映射。`keys.conf`文件同样适用于`BOARD_SEPOLICY_*`变量。构建配方首先对`keys.conf`调用`build_policy`，并使用`m4`连接结果。因此，`keys.conf`中的`m4`声明将被尊重。然而，这尚未被使用。最初的意图是使用`m4
    -s`同步行，以便在`m4`处理连接`keys.conf`文件时，您可以跟随包含链。另一方面，当连接多个文件时，`m4`会提供同步行，并提供符合`#line
    NUM "FILE"'`格式的注释行。这些很有用，因为`m4`将多个输入文件合并成一个扩展的输出文件。将会有指示每个文件开头的同步行，它们可以帮助您追踪问题。回到`mac_permissions.xml`的构建，经过`m4`对`keys.conf`的扩展后，该文件以及通过调用`build_policy()`获取的所有`mac_permissions.xml`文件最终被传递给`insertkeys.py`。`insertkeys.py`工具然后使用`keys.conf`文件将所有匹配的`signature=<TAG>`行替换为来自PEM文件的十六进制编码的实际X509，即`signature=308E3600`。此外，`insertkeys.py`工具将XML文件合并为一个文件，并去除空格和注释以减少其在磁盘上的大小。这不会对其他主要文件如`sepolicy`、`seapp_contexts`、`property_contexts`和`mac_permissions.xml`产生构建依赖。
- en: Building seapp_contexts
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建seapp_contexts
- en: The `seapp_contexts` file is also subject to all the `BOARD_SEPOLICY_*` variables.
    All of the `seapp_contexts` files from a resultant call to `build_policy()` are
    also fed through `m4 -s` to get a single `seapp_contexts` file that contains sync
    lines. Again, like `mac_permissions.xml` file's build of `keys.conf`, `m4` hasn't
    been used other than for the synclines. This resulting, concatenated `seapp_contexts`
    file is then fed into `check_seapp`. This tool is authored in the C programming
    language and built into an executable during the build. The source can be found
    in `tools/check_seapp`. This tool reads the `seapp_contexts` file and checks its
    syntax. It verifies that there are no invalid key value pairs, that `levelFrom`
    is a valid identifier, and that the type and domain fields are valid for a given
    `sepolicy`. This build is dependent on `sepolicy` for the strict type checking
    of domain and type fields against the policy file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`seapp_contexts`文件也受所有`BOARD_SEPOLICY_*`变量的影响。来自`build_policy()`调用结果的所有`seapp_contexts`文件也通过`m4
    -s`处理，以获得包含同步行的单个`seapp_contexts`文件。同样，类似于`mac_permissions.xml`文件的`keys.conf`构建，除了用于synclines之外，没有使用`m4`。这个结果，连接的`seapp_contexts`文件随后被输入到`check_seapp`中。这个工具是用C编程语言编写的，并在构建过程中编译成可执行文件。源代码可以在`tools/check_seapp`中找到。此工具读取`seapp_contexts`文件并检查其语法。它验证没有无效的键值对，`levelFrom`是一个有效的标识符，并且对于给定的`sepolicy`，类型和域字段是有效的。此构建依赖于`sepolicy`，以对策略文件中的域和类型字段进行严格类型检查。'
- en: Building file_contexts
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建file_contexts
- en: The `file_contexts` file is also subject to all of the `BOARD_SEPOLICY_*` variables.
    The resulting set is passed through `m4 -s`, and the single output is run through
    the `checkfc` tool. The `checkfc` tool checks the grammar and syntax of the file
    and also verifies that the types exist in the built `sepolicy`. Because of this,
    it is dependent on the `sepolicy` build.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_contexts`文件也受所有`BOARD_SEPOLICY_*`变量的影响。生成的集合通过`m4 -s`处理，单一输出通过`checkfc`工具运行。`checkfc`工具检查文件的语法和句法，并验证在构建的`sepolicy`中存在这些类型。因此，它依赖于`sepolicy`构建。'
- en: Building property_contexts
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建property_contexts
- en: The `property_contexts` behaves exactly like the `file_contexts` build, except
    that it checks a `property_contexts` file. It also uses `checkfc`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`property_contexts`的行为与`file_contexts`构建完全一样，只不过它检查一个`property_contexts`文件。它也使用`checkfc`。'
- en: Current NSA research files
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前国家安全局的研究文件
- en: Additionally, work on Enterprise Operations (`eops`) is already underway at
    the NSA. As this feature hasn't been merged into mainstream Android and is likely
    to change wildly, it won't be covered here. However, the best place for the bleeding
    edge is always the source and NSA Bitbucket repositories. The `selinux-network.sh`
    also falls under this category; it hasn't seen mainstream adoption yet, and will
    likely be dropped from AOSP ([https://android-review.googlesource.com/#/c/114380/](https://android-review.googlesource.com/#/c/114380/)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，国家安全局已经在企业运营（`eops`）方面开始了工作。由于此功能尚未合并到主流Android中，并且可能会发生巨大变化，因此这里不会介绍。然而，对于追求前沿技术的最佳地点始终是源代码和国家安全局的Bitbucket仓库。`selinux-network.sh`也属于这一类；它尚未被主流采用，并且可能会从AOSP中删除（[https://android-review.googlesource.com/#/c/114380/](https://android-review.googlesource.com/#/c/114380/)）。
- en: Standalone tools
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立工具
- en: There are also some standalone tools built for Android policy evaluation that
    you may find useful. We will explore some of them and their usages. Most of the
    standard desktop tools you'll find in other references still work on SE for Android
    SELinux policy. Note that if you run any of the following tools and get a segmentation
    fault, you will likely need to apply the patch from the thread at [http://marc.info/?l=seandroid-list&m=141684060409894&w=2](http://marc.info/?l=seandroid-list&m=141684060409894&w=2).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些为Android策略评估构建的独立工具，你可能会觉得有用。我们将探讨其中一些及其用途。大多数在其他参考资料中找到的标准桌面工具仍然适用于SE for
    Android SELinux策略。请注意，如果你运行以下任何工具并遇到段错误，你可能需要应用来自[thread at http://marc.info/?l=seandroid-list&m=141684060409894&w=2](http://marc.info/?l=seandroid-list&m=141684060409894&w=2)的补丁。
- en: sepolicy-check
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sepolicy-check
- en: 'This tool allows you to see whether a given allow rule exists in a policy file.
    The basic syntax of its command is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具允许你查看策略文件中是否存在给定的允许规则。其命令的基本语法如下：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For instance, if you want to see whether `system_app` can write to `system_data_file`
    for class file, you can execute:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想查看`system_app`是否可以写入`system_data_file`的class文件，你可以执行：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: sepolicy-analyze
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sepolicy-analyze
- en: This is a good tool to check for common issues in SELinux development and it
    catches some of the common pitfalls of new SELinux policy writers. It can check
    for equivalent domains, duplicate allow rules. It can also perform policy type
    difference checks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查SELinux开发中常见问题的好工具，它捕捉到了一些新的SELinux策略编写者容易犯的常见陷阱。它可以检查等价域、重复的允许规则。它还可以执行策略类型差异检查。
- en: 'The domain equivalence check feature is very helpful. It shows you domains
    you may (in theory) want to be different, even though they converged in the implementation.
    These types would be ideal candidates to coalesce. However, it might have also
    shown an issue in the design of the policy that should be corrected. In other
    words, you didn''t expect these domains to be equivalent. Invoking the command
    is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 域等价性检查功能非常有帮助。它能显示你可能（从理论上讲）希望不同的域，尽管在实际实现中它们可能已经收敛。这些类型的域将是合并的理想候选者。然而，它也可能揭示了政策设计中应该修正的问题。换句话说，你原本不期望这些域是等价的。调用该命令如下所示：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The duplicate allow rule checks whether allow rules exist on types that also
    exist on attributes that the type inherits from. The allow rule on the specific
    type is a candidate for removal, since there is already an `allow` on the attribute.
    To execute this check, run the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的允许规则检查是否存在这样的规则：类型上存在允许规则，而这些规则也存在于该类型继承的属性上。由于在属性上已经有一个`allow`规则，因此特定类型上的允许规则是删除的候选者。要执行此检查，请运行以下命令：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The difference is also handy is also handy to view type differences within
    a file. If you want to see what the difference between two domains is, you can
    use this feature. This is useful for identifying possible domains to coalesce.
    To perform this check, execute the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件内查看域类型差异的功能也很有用。如果你想了解两个域之间的差异，可以使用这个功能。这对于识别可能的合并域很有帮助。要执行此检查，请执行以下命令：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how the various components that control the policy
    on the device are actually built and created, such as `sepolicy` and `mac_permissions.xml`.
    This chapter also presented the `BOARD_SEPOLICY_*` variables used to manage and
    build a policy across devices and configurations. Then we reviewed the `Android.mk`
    components, detailing how the heart of the build and configuration management
    works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了控制设备上策略的各种组件是如何实际构建和创建的，例如`sepolicy`和`mac_permissions.xml`。本章还介绍了用于跨设备和配置管理构建策略的`BOARD_SEPOLICY_*`变量。然后我们回顾了`Android.mk`组件，详细说明了构建和配置管理核心的工作原理。
