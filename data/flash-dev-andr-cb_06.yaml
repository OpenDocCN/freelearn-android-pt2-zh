- en: 'Chapter 6. Structural Adaptation: Handling Device Layout and Scaling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 结构适应性：处理设备布局和缩放
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Detecting useable screen bounds and resolution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测可用的屏幕边界和分辨率
- en: Detecting screen orientation changes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测屏幕方向变化
- en: Scaling visual elements across devices at runtime
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时跨设备缩放视觉元素
- en: Scaling visual elements based on stage resize in Flash Professional CS5.5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flash Professional CS5.5 中基于舞台大小调整视觉元素
- en: Employing the project panel in Flash Professional CS5.5
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flash Professional CS5.5 中使用项目面板
- en: Freezing a Flex application to landscape or portrait mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Flex 应用程序锁定为横屏或竖屏模式
- en: Defining a blank Flex mobile application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个空的 Flex 移动应用程序
- en: Defining a Flex mobile view-based application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个基于视图的 Flex 移动应用程序
- en: Defining a Flex mobile tabbed application with multiple sections
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个具有多个部分的 Flex 移动标签应用程序
- en: Using a splash screen within a Flex mobile application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flex 移动应用程序中使用启动画面
- en: Configuring the ActionBar within a Flex mobile project for use with ViewNavigator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flex 移动项目中配置 ActionBar 以与 ViewNavigator 一起使用
- en: Hiding the ActionBar Control in a single view for a Flex mobile project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flex 移动项目中为单一视图隐藏 ActionBar 控件
- en: Hiding the ActionBar Control in all views for a Flex mobile project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flex 移动项目中所有视图中隐藏 ActionBar 控件
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With such a variety of hardware devices running Android, developing applications
    that look and function properly across different resolutions can be a challenge.
    Thankfully, this is something the Flash platform is well-suited for. Whether using
    the default layout mechanisms as part of the Flex SDK or writing your own layout
    and scaling logic, there are many things to consider.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行 Android 系统的硬件设备种类繁多，开发在不同分辨率下都能正确显示和运行的应用程序可能是一项挑战。幸运的是，Flash 平台非常适合这项工作。无论是使用
    Flex SDK 中的默认布局机制，还是编写自己的布局和缩放逻辑，都有许多需要考虑的事项。
- en: In this chapter we will look at layout mechanisms when dealing with the Flex
    framework for mobile application development, and also explore a variety of considerations
    for pure ActionScript projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在使用 Flex 框架进行移动应用程序开发时处理布局机制的问题，并探索纯 ActionScript 项目的各种注意事项。
- en: Detecting useable screen bounds and resolution
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测可用的屏幕边界和分辨率
- en: When producing applications for a desktop or laptop computer, we don't have
    to give too much thought on the actual screen real estate we have to work with,
    or the **Pixels Per Inch(PPI)** resolution for that matter. It can be generally
    assumed that we will have at least a 1024x768 screen to work against, and we can
    be sure that it is a 72 PPI display. With mobile, that it all out the window.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当为桌面或笔记本电脑制作应用程序时，我们不必过多考虑我们实际可用的屏幕空间，或者 **每英寸像素(PPI)** 分辨率。我们可以假设至少有一个 1024x768
    的屏幕供我们使用，并且我们可以确定这是一个 72 PPI 的显示。对于移动设备来说，这一切都不同了。
- en: With mobile device displays, our applications can basically be full screen or
    almost full screen; that is, but for the notification bar. These device screens
    can vary in size from just a few pixels, to hundreds. Then we must take into account
    different aspect ratios and the fact that the screen will certainly display 250
    PPI or above. We must have a new set of checks in place to perform application
    layout modifications depending upon the device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动设备显示屏，我们的应用程序基本上可以是全屏或几乎全屏；也就是说，除了通知栏。这些设备屏幕的大小可以从仅仅几像素到几百像素不等。然后，我们还必须考虑不同的宽高比以及屏幕肯定能显示250
    PPI 或更高的事实。我们必须有一套新的检查机制，以便根据设备进行应用程序布局的修改。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'At runtime, we can monitor many device capabilities and react by modifying
    our various visual elements across the screen:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们可以监控许多设备功能，并通过调整屏幕上的各种视觉元素做出反应：
- en: 'First, import the following classes into your project:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will now declare a `TextField` and `TextFormat` pair to relay text messages
    onto the device display:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`TextField`和`TextFormat`组合，以将文本消息传递到设备显示屏上：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的 `TextField`，应用一个 `TextFormat`，并将其添加到 `DisplayList` 中。在这里，我们创建一个方法来为我们执行所有这些操作：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The final step is to create a method to gather all of the data we need to make
    any further modifications to our layout or UI components. In this example, we
    are reading both the `Stage.stageHeight` and `Stage.stageWidth` to get the usable
    area. We can contract this with `Capabilities.screenResolutionX` and `Capabilities.screenResolutionY`
    to get the actual display resolution.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是创建一个方法来收集我们进行任何进一步布局修改或UI组件所需的所有数据。在这个例子中，我们读取`Stage.stageHeight`和`Stage.stageWidth`以获取可用区域。我们可以将其与`Capabilities.screenResolutionX`和`Capabilities.screenResolutionY`进行比较，以获取实际的显示分辨率。
- en: 'Other important pieces of information are the `Capabilities.touchscreenType`
    to determine whether the touch screen expects a finger or stylus, `Capabilities.pixelAspectRatio`
    to retrieve pixel aspect ratio (though this is generally always 1:1), and most
    importantly that we use `Capabilities.screenDPI` to discover the PPI measurement
    of our display:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他重要信息包括`Capabilities.touchscreenType`以确定触摸屏是预期使用手指还是触笔，`Capabilities.pixelAspectRatio`以获取像素宽高比（尽管这通常是1:1），以及最重要的是我们使用`Capabilities.screenDPI`来发现显示器的PPI测量值：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The resulting application will display as shown in the following screenshot:![How
    to do it…](img/1420_06_01.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序将显示如下截图所示：![如何操作…](img/1420_06_01.jpg)
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Through the `flash.display.Stage` and `flash.system.Capabilities` classes, we
    can learn a lot about the particular device display our application is running
    on and have the application react to that in some way. In this example, we are
    outputting the gathered information to a `TextField`, but this data could be also
    used to adjust the location, size, or arrangement of visual elements based on
    `Stage` resolution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`flash.display.Stage`和`flash.system.Capabilities`类，我们可以了解很多关于应用程序正在运行的特定设备显示屏的信息，并让应用程序以某种方式对此作出反应。在这个例子中，我们将收集到的信息输出到一个`TextField`中，但这些数据也可以用来根据`Stage`分辨率调整视觉元素的位置、大小或布局。
- en: Detecting screen orientation changes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测屏幕方向变化
- en: As most Android devices have at least two screen orientations, that is, portrait
    and landscape, it is useful when developing for these devices to know what the
    current orientation is in order to properly display application user interface
    elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数Android设备至少有两种屏幕方向，即纵向和横向，因此在为这些设备开发时，了解当前的屏幕方向以正确显示应用程序用户界面元素是非常有用的。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will register an event listener on our `Stage` to listen for `StageOrientationEvent`
    changes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`Stage`上注册一个事件监听器，以监听`StageOrientationEvent`的变化：
- en: 'First, import the following classes into your project:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will now declare a `TextField` and `TextFormat` pair to relay text messages
    onto the device display:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`TextField`和`TextFormat`对，以将文本信息传递到设备显示屏上：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建了一个方法来执行所有这些操作：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next step will be to register an event listener to detect changes in screen
    orientation. We do this by listening for `StageOrientationEvent.ORIENTATION_CHANGE`
    events on the `Stage:`
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将注册一个事件监听器，以检测屏幕方向的变化。我们通过在`Stage`上监听`StageOrientationEvent.ORIENTATION_CHANGE`事件来实现这一点：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When a `StageOrientationEvent.ORIENTATION_CHANGE` event is detected, it will
    invoke a method named `onOrientationChange`. We will create this method and use
    it to write a text constant representing the new orientation to the `TextField`.
    We will also invoke a method to adjust our layout at this point:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检测到`StageOrientationEvent.ORIENTATION_CHANGE`事件时，它将调用一个名为`onOrientationChange`的方法。我们将创建这个方法，并使用它将表示新方向的文本常量写入`TextField`。我们还将在此处调用一个方法来调整我们的布局：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we will use the `reformLayout` method to adjust any visual components
    on screen to match our new `Stage` dimensions. Here, we simply adjust the sizes
    of our `TextField` object:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`reformLayout`方法调整屏幕上的任何视觉组件以匹配我们新的`Stage`尺寸。这里，我们简单调整了我们的`TextField`对象的大小：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting application will display as shown in the following screenshot:![How
    to do it…](img/1420_06_01_2.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序将显示如下截图所示：![如何操作…](img/1420_06_01_2.jpg)
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Basically this is a simple event listener that is tied to devices, which have
    a variety of possible orientations. We register an event listener of type `StageOrientationEvent.ORIENTATION_CHANGE`
    on the `Stage` and receive two important pieces of data back: `StageOrientationEvent.beforeOrientation`
    and `StageOrientationEvent.afterOrientation`. The values contained within these
    event results will report device orientation constants.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是一个简单的事件监听器，与具有各种可能方向设置的设备相关联。我们在`Stage`上注册类型为`StageOrientationEvent.ORIENTATION_CHANGE`的事件监听器，并接收两个重要数据返回：`StageOrientationEvent.beforeOrientation`和`StageOrientationEvent.afterOrientation`。这些事件结果中包含的值将报告设备方向常量。
- en: 'There are four constants that can possibly be reported:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个可能被报告的常量：
- en: '`StageOrientation.DEFAULT`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StageOrientation.DEFAULT`'
- en: '`StageOrientation.ROTATED_LEFT`'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StageOrientation.ROTATED_LEFT`'
- en: '`StageOrientation.ROTATED_RIGHT`'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StageOrientation.ROTATED_RIGHT`'
- en: '`StageOrientation.UPSIDE_DOWN`'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StageOrientation.UPSIDE_DOWN`'
- en: Again, these are simply possibilities. There are some devices which do not support
    all four of these constants so we must be cautious and not assume otherwise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些只是可能性。有些设备不支持这四个常量中的所有，因此我们必须谨慎，不能想当然。
- en: There's more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: There are actually a number of ways in which we could detect screen orientation
    changes. One would be to monitor the `Stage.orientation` through a `Timer` and
    react accordingly. Another would involve testing `Accelerometer` values for orientation
    changes. Using `StageOrientationEvent` is the most direct way, however, and supplies
    us with information about both the orientation before and after the event fires,
    which can be very useful.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有多种方法可以检测屏幕方向变化。一种是通过`Timer`监控`Stage.orientation`并相应地做出反应。另一种涉及测试`Accelerometer`值以检测方向变化。然而，使用`StageOrientationEvent`是最直接的方法，它为我们提供了事件触发前后的方向信息，这非常有用。
- en: See also…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: 'For an example of how you might go about a similar task through the `Accelerometer`
    API, have a look at [Chapter 3](ch03.html "Chapter 3. Movement through Space:
    Accelerometer and Geolocation Sensors"), *Movement through Space: Accelerometer
    and Geolocation Sensors.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解如何通过`Accelerometer` API完成类似任务，请参阅[第三章](ch03.html "第三章. 空间移动：加速度计和地理定位传感器")，*空间移动：加速度计和地理定位传感器。*
- en: Scaling visual elements across devices at runtime
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时跨设备缩放视觉元素
- en: The wide variety of Pixels Per Inch (PPI) measurements and overall screen resolution
    differences across Android devices can make it difficult to make sizing and layout
    decisions when creating visual elements, especially interactive elements, as these
    must be large enough for users to touch with their fingertips easily. It is generally
    accepted that a physical measurement of a half inch square is ideal for proper
    touch. In this recipe, we will demonstrate how to ensure the same physical specifications
    across devices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备间广泛的每英寸像素（PPI）测量和整体屏幕分辨率差异，使得在创建视觉元素时，特别是在制作交互式元素时，难以进行大小和布局决策。一般认为，一个半英寸的物理测量正方形是便于用户用指尖触摸的理想大小。在本教程中，我们将演示如何确保在设备间保持相同的物理规格。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create some visual elements on the screen that are sized to physical
    measurements based upon the detected device display PPI:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上创建一些视觉元素，这些元素的大小基于检测到的设备显示PPI进行物理测量：
- en: 'First, import the following classes into your project:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step will be to declare a number of objects to use in our application.
    We will create three `Shape` objects, which will be used to demonstrate this particular
    layout and sizing technique. We also set up two `Number` objects to hold specific
    measurements for use when determining size and position across the application:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将是声明将在我们的应用程序中使用的一些对象。我们将创建三个`Shape`对象，用于演示这种特定的布局和大小调整技术。同时，我们还设置两个`Number`对象，用于在确定应用程序中的大小和位置时保存特定的测量值：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we must draw out our visual elements onto the `Stage`. As mentioned earlier,
    we are targeting a physical resolution of one half inch as the smallest measurement.
    Therefore, we begin by performing a calculation to determine the representation,
    measured in pixels, of both half inch and one full inch.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将我们的视觉元素绘制到`Stage`上。如前所述，我们的目标是物理分辨率为半英寸作为最小测量值。因此，我们首先进行计算，以确定半英寸和一英寸在像素中的表示。
- en: We will be creating a box in the upper left, and another in the upper right;
    each will be a half inch square and positioned based upon the available `Stagewidth`
    and `height`. A larger box will be positioned at the very bottom of our screen
    and will extend across the width of the `Stage:`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在左上角创建一个方块，在右上角创建另一个方块；每个方块都是半英寸见方，并根据可用的`Stagewidth`和`height`进行定位。在屏幕最底部将放置一个更大的方块，其宽度将延伸至`Stage`的整个宽度：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Register an event listener of type `StageOrientationEvent.ORIENTATION_CHANGE`
    upon the `Stage`. This will detect device orientation changes and alert us so
    that we may resize and reposition our visual elements appropriately:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Stage`上注册一个类型为`StageOrientationEvent.ORIENTATION_CHANGE`的事件监听器。这将检测设备方向变化并通知我们，以便我们可以适当地调整和重新定位视觉元素：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following method will fire upon each orientation change detected by our
    application. In this case, we do not care so much what our present orientation
    actually is, but will reposition (and resize, when necessary) any visual element
    on the `Stage` to properly reflow the screen. We once again use our numeric measurements
    to perform these actions:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方法将在我们的应用程序检测到每次方向变化时触发。在这种情况下，我们并不太关心当前的实际方向是什么，但会重新定位（必要时重新调整大小）`Stage`上的任何视觉元素，以正确地重新排列屏幕。我们再次使用我们的数值测量来执行这些操作：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The resulting application will display similar to what we see in the following
    screenshot:![How to do it…](img/1420_06_03.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序的显示将类似于我们在以下屏幕截图中所看到的：![如何实现…](img/1420_06_03.jpg)
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'A good trick to sizing visual components is to multiply the reported `Capabilities.screenDPI`
    times whatever physical measurement you want to achieve. For instance, if we want
    to be sure that certain touch elements are exactly half inch in width across devices,
    you can use the following formula:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉组件大小调整的一个好方法是，将报告的`Capabilities.screenDPI`乘以您想要达到的任何物理尺寸。例如，如果我们想要确保某些触摸元素在设备上的宽度正好是半英寸，可以使用以下公式：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we set up some variables, which represent measurements of physical
    half-inch and full-inch calculations, and then apply these upon the creation of
    our elements for layout and sizing. If a change in device orientation is detected,
    we adjust our layout based upon the new `Stage` dimensions and also resize visual
    elements as appropriate. As the two top `Shapes` are half inch squares, we simply
    adjust their `x` and `y` coordinates, but the bottom shape has the additional
    requirement of adjusting its `width` upon every orientation change to fill the
    width of the screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们设置了一些变量，这些变量表示物理半英寸和全英寸的计算，然后在创建我们的元素进行布局和大小调整时应用这些变量。如果检测到设备方向发生变化，我们将根据新的`Stage`尺寸调整我们的布局，并适当地调整视觉元素的大小。由于两个顶部的`Shapes`是半英寸的方块，我们只需调整它们的`x`和`y`坐标，但底部的形状还需要在每次方向变化时调整其`width`以填满屏幕宽度。
- en: Scaling visual elements based on stage resize in Flash Professional CS5.5
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Flash Professional CS5.5 中根据舞台大小调整视觉元素的缩放
- en: One of the features introduced in Flash Professional CS5.5 that makes targeting
    various device resolutions easier is the ability for Flash to resize and reposition
    visual elements upon `Stage` resize. This allows us to modify our FLA files targeting
    specific resolutions and devices quite easily.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Flash Professional CS5.5 引入了一项功能，使针对各种设备分辨率的目标定位变得更加容易，即当`Stage`大小调整时，Flash
    能够重新调整和定位视觉元素。这使得我们可以轻松地修改针对特定分辨率和设备的 FLA 文件。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We will demonstrate how to employ **Scale content with stage** in order to
    target different screen resolutions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用**随舞台缩放内容**以针对不同的屏幕分辨率：
- en: Here we see a demo application laid out at **480x800**, targeting a Nexus S
    device. In the **Properties** panel, click upon the wrench icon next to the **Size**
    controls:![How to do it…](img/1420_06_04.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个针对 Nexus S 设备的**480x800**布局的演示应用程序。在**属性**面板中，点击**大小**控制旁边的扳手图标：![如何实现…](img/1420_06_04.jpg)
- en: We want to adjust the display resolution to match that of a Droid2 so we change
    the **Document Settings** to reflect a **480x854** display resolution to match
    this device. Additionally, we can select **Scale content with stage**, which will
    scale our visual elements proportionately:![How to do it…](img/1420_06_05.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望调整显示分辨率以匹配 Droid2，因此我们将**文档设置**更改为反映**480x854**的显示分辨率以匹配此设备。此外，我们可以选择**随舞台缩放内容**，这将按比例缩放我们的视觉元素：![如何实现…](img/1420_06_05.jpg)
- en: Upon hitting the **OK** button, we can see that the `Stage` has resized and
    our visual elements are now centered upon the `Stage`. Since we only adjusted
    the **height** of this application, the layout of the visual elements is repositioned
    according to settings which can be adjusted in **Edit | Preferences | General
    | Scale Content**, where we can choose to **Align top left** or not. Leaving this
    box unselected will center our elements upon rescaling the stage and selecting
    to scale contents, as we can see below.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮后，我们可以看到`舞台`已调整大小，我们的视觉元素现在位于`舞台`中心。由于我们只调整了应用程序的**高度**，视觉元素的布局会根据可以在**编辑
    | 首选项 | 常规 | 缩放内容**中调整的设置重新定位。如果不清除这个复选框，元素会在缩放舞台并选择缩放内容时居中，如下所示。
- en: To demonstrate this further, we will resize our `Stage` to match the resolution
    of a fictional Android tablet device. In the **Properties** panel, once again
    click upon the wrench icon next to the **Size** controls:![How to do it…](img/1420_06_06.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步演示，我们将调整`舞台`大小以匹配假想的Android平板设备的分辨率。在**属性**面板中，再次点击**大小**控制旁边的扳手图标：![如何操作…](img/1420_06_06.jpg)
- en: Our fictional tablet has a resolution of **800x1000**, so we will once again
    adjust the width and height settings and select **Scale content with stage** followed
    by a click of the button marked **OK:**![How to do it…](img/1420_06_07.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们假想的平板分辨率为**800x1000**，因此我们将再次调整宽度和高度设置，选择**随舞台缩放内容**，然后点击标记为**确定**的按钮：![如何操作…](img/1420_06_07.jpg)
- en: The new scaling feature is much more apparent now, and we can even see how much
    our application assets have been scaled by referring to the guides, which were
    originally marking our initial resolution. At this point, we can make any further
    adjustments to our application layout to be sure it appears exactly as we want
    upon the target device:![How to do it…](img/1420_06_08.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的缩放功能现在更加明显，我们可以通过参考最初标记我们初始分辨率的指南，查看应用程序资源被缩放的情况。在这个阶段，我们可以对应用程序布局进行进一步的调整，以确保在目标设备上显示的效果完全符合我们的预期：![如何操作…](img/1420_06_08.jpg)
- en: If we wanted to target a number of devices in a visual way, we could construct
    an FLA for each one using this technique, along with a shared codebase. Although
    many devices would be able to use an application generated from the exact same
    `.fla`, it all depends upon target device resolution and how much tweaking we
    want to do for each one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要以视觉方式针对多个设备，可以使用此技术为每个设备构建一个FLA文件，并共享代码库。尽管许多设备可以使用完全相同的`.fla`生成的应用程序，但这取决于目标设备的分辨率以及我们想要对每个设备进行多少调整。
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: With Flash Professional CS5.5 and above, we now have the added feature of scaling
    content on our `Stage` when we adjust the `Stage` dimensions. This is excellent
    for mobile Android development purposes since there exists such a variety of display
    resolutions across devices. The ability to scale our content allows for rapid
    layout adjustments of FLA documents which, when compiled to `.APK`, target certain
    devices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flash Professional CS5.5及其以上版本，我们现在在调整`舞台`尺寸时，可以增加缩放`舞台`上内容的功能。这对于移动Android开发来说非常棒，因为设备间存在如此多的显示分辨率差异。缩放内容的能力使得FLA文档的布局调整变得迅速，当编译成`.APK`文件时，可以针对特定设备。
- en: There's more…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: It is important to note that the scaling of our visual elements will always
    be done in a way that preserves their original aspect ratio. If the new aspect
    ratio differs from the original, there will be further adjustments, which will
    be needed to be made in order to make the layout suitable to whichever device
    we are targeting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们视觉元素的缩放将始终以保持其原始宽高比的方式进行。如果新的宽高比与原始宽高比不同，将需要进一步调整以使布局适合我们针对的任何设备。
- en: Employing the Project panel in Flash Professional CS5.5
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flash Professional CS5.5中的项目面板
- en: It has traditionally been troublesome when attempting to design application
    layout in Flash Professional since it required the manual organization of various
    FLA files, along with some mechanism of synchronizing changes between them in
    code and asset management. Flash Professional CS5.5 attempts to alleviate much
    of this burden with a new Project structure, including the ability to share author
    time Flash Library assets across project documents.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash Professional中设计应用程序布局传统上一直很麻烦，因为它需要手动组织各种FLA文件，并通过代码和资产管理之间的某种机制来同步它们之间的更改。Flash
    Professional CS5.5试图通过新的项目结构减轻这种负担，包括在项目文档之间共享作者时间的Flash库资产的能力。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will configure a Flash Project, which will allow us to target multiple screen
    resolutions using the same shared asset pool across device-targeted FLAs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置一个Flash项目，这将允许我们针对多个屏幕分辨率使用相同的共享资产池，跨设备针对的FLAs：
- en: Create a new Flash Professional project by opening the **Project panel** by
    selecting **Create New | Flash Project** on the welcome screen, or through **File
    | New** | **Flash Project** from the application menu:![How to do it…](img/1420_06_09.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在欢迎屏幕上选择**创建新项目 | Flash项目**打开**项目面板**，或者通过应用程序菜单中的**文件 | 新建** | **Flash项目**创建一个新的Flash
    Professional项目：![如何操作…](img/1420_06_09.jpg)
- en: The **Create New Project** panel will appear, allowing us to configure a new
    **Flash Project**. We will provide a **Project name**, define a **Root folder**
    for the project files to reside, and choose a **Player**. In the case of AIR for
    Android, we will want to be sure to choose **AIR 2.6** or the latest version of
    AIR you wish to target:![How to do it…](img/1420_06_10.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现**创建新项目**的面板，允许我们配置一个新的**Flash项目**。我们将提供一个**项目名称**，定义一个用于存放项目文件的**根文件夹**，并选择一个**播放器**。在针对Android的AIR的情况下，我们一定要选择**AIR
    2.6**或您希望针对的最新版本的AIR：![如何操作…](img/1420_06_10.jpg)
- en: The Flash Project structure allows us to define a number of different FLA documents
    within one project, which target a variety of resolutions and layouts. Here, for
    example, we have created specific documents targeting the Droid, EVO, and Nexus
    One mobile Android devices. In addition to these documents we also have an `AuthortimeSharedAssets.fla`
    file, which is generated for us automatically by Flash Professional. This will
    contain any assets which are shared across our other documents.![How to do it…](img/1420_06_11.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flash项目结构允许我们在一个项目中定义多个不同的FLA文档，这些文档针对各种分辨率和布局。这里，例如，我们创建了针对Droid、EVO和Nexus
    One移动Android设备的具体文档。除了这些文档，我们还有一个`AuthortimeSharedAssets.fla`文件，这是Flash Professional自动为我们生成的。这将包含我们其他文档之间共享的任何资产。![如何操作…](img/1420_06_11.jpg)
- en: Now, as we design and develop our application assets, we can mark each one as
    an author-time shared asset, which can be linked across all of our documents,
    making asset management within this particular project much more organized than
    it would be, otherwise. To mark a **Library** asset as shared, simply click on
    the checkbox next to it:![How to do it…](img/1420_06_12(2).jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们设计和开发应用程序资产时，我们可以将每个资产标记为作者时间共享资产，这可以在所有文档之间链接，使得在这个特定项目中的资产管理比其他情况下更有组织。要将**库**资产标记为共享，只需点击它旁边的复选框：![如何操作…](img/1420_06_12(2).jpg)
- en: While marking a particular asset to be shared across documents in a project
    does make it sharable, we must also be sure to include the **Library** asset within
    the document in question to be able to access it within a particular device document
    at author time.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中将特定资产标记为在文档之间共享确实使其可共享，我们还必须确保在相关的文档中包含**库**资产，以便在特定设备文档中在作者时间内访问它。
- en: For instance, if we have two `.fla` files that we want to share a MovieClip
    symbol called "RedBall", we will first define "RedBall" in one `.fla`, and mark
    it as shared within that Library. This will place the symbol into our `AuthortimeSharedAssets.fla`
    file, but it will not be available to any other `.fla` until we actually bring
    it into the **Library** of the second `.fla`. At this point, any modifications
    made in either `.fla` will be shared across both because of the shared asset linkage
    in our project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果我们有两个`.fla`文件，希望共享一个名为"RedBall"的MovieClip符号，我们首先在一个`.fla`中定义"RedBall"，并将其在库中标记为共享。这样会将符号放入我们的`AuthortimeSharedAssets.fla`文件中，但在我们实际将其引入第二个`.fla`的**库**之前，其他任何`.fla`都无法使用它。此时，在任何`.fla`中进行的任何修改都会因为项目中的共享资产链接而在这两个文件之间共享。
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: The `AuthortimeSharedAssets.fla` file contains all of the Flash **Library**
    assets that are shared across our multiple FLA files. This allows us to modify
    a shared asset in one file, and have those changes cascade across all project
    documents in which it is used. The ability to define a variety of screen resolution
    layouts through multiple, targeted FLA files allows a designer great flexibility
    when structuring the application user interface. Having all of those interface
    elements linked through this new project structure keeps the work organized and
    clean.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthortimeSharedAssets.fla` 文件包含了所有跨多个 FLA 文件共享的 Flash **库** 资源。这使得我们可以在一个文件中修改共享资源，并且这些更改会影响到所有使用它的项目文档。通过多个针对不同目标分辨率布局的
    FLA 文件，设计师在构建应用程序用户界面时具有极大的灵活性。所有这些界面元素通过这种新的项目结构链接起来，保持了工作的有序性和整洁性。'
- en: There's more…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Not only does the new Flash Project panel and associated project structure allow
    for author time asset sharing and multi-device targeting through multiple FLA
    files, but the file structure is now totally compatible with Flash Builder. This
    allows developers to start a Flash Project in Flash Professional, and continue
    editing it in Flash Builder by importing the project folder within that environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Flash 项目面板及其相关项目结构不仅允许通过多个 FLA 文件进行作者时间资源共享和多设备定位，而且文件结构现在完全兼容 Flash Builder。这使得开发人员可以在
    Flash Professional 中启动 Flash 项目，并通过在 Flash Builder 中导入项目文件夹继续编辑。
- en: Freezing a Flex application to landscape or portrait mode
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Flex 应用程序冻结为横向或纵向模式
- en: It is sometimes desirable to constrain your application layout to a specific
    aspect ratio, landscape, or portrait. When building Android projects using the
    Flex framework, it is a simple matter to accomplish this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望将应用程序布局限制为特定的宽高比，横向或纵向。在使用 Flex 框架构建 Android 项目时，实现这一点非常简单。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can freeze a particular aspect ratio for our application by modifying the
    AIR application descriptor file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改 AIR 应用程序描述符文件来为我们的应用程序冻结特定的宽高比：
- en: 'By default, when we define a new Flex mobile project, an application descriptor
    `XML` file is created. This file includes a node dedicated to the application
    `initialWindow` configuration. It will appear similar to the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，当我们定义一个新的 Flex 移动项目时，会创建一个应用程序描述符 `XML` 文件。这个文件包括一个专门用于应用程序 `initialWindow`
    配置的节点。它将类似于以下代码：
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want to modify the contents of this node in two ways. First, set the `autoOrients`
    tag to `false`. This will prevent the application from re-orienting itself upon
    device rotation:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望以两种方式修改这个节点的内容。首先，将 `autoOrients` 标签设置为 `false`。这将防止应用程序在设备旋转时重新定位：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we will add an `aspectRatio` tag and provide it with one of two values,
    `landscape` or `portrait:`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个 `aspectRatio` 标签，并为其赋予两个值之一，`landscape` 或 `portrait`：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we test this application on our device, even when holding it upright, in
    portrait mode, our application remains locked to landscape:![How to do it…](img/1420_06_13(2).jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上测试这个应用程序时，即使将其竖直持握，在纵向模式下，我们的应用程序仍然锁定为横向：![如何操作…](img/1420_06_13(2).jpg)
- en: How it works…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The application descriptor file is very powerful as it can define many elements
    of our application without even editing any MXML or ActionScript. In this example,
    we are modifying tags within the project `initialWindow` node; setting `autoOrients`
    to false and adding an `aspectRation` tag, setting the aspect ratio of our application
    to `landscape` or `portrait`. Performing these edits will ensure that our application
    runs in a fixed aspect ratio no matter how the device is rotated by the user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序描述符文件非常强大，因为它可以定义我们应用程序的许多元素，而无需编辑任何 MXML 或 ActionScript。在这个例子中，我们正在修改项目
    `initialWindow` 节点内的标签；将 `autoOrients` 设置为 false 并添加一个 `aspectRation` 标签，将我们应用程序的宽高比设置为
    `landscape` 或 `portrait`。进行这些编辑将确保无论用户如何旋转设备，我们的应用程序都在固定的宽高比下运行。
- en: There's more…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Users of Flash professional CS5.5 will find that they can easily adjust these
    properties through the **AIR for Android Settings** dialog. This can be accessed
    from either the **Properties** panel or from **File | AIR for Android Settings:**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Flash Professional CS5.5 的用户会发现，他们可以通过 **AIR for Android 设置** 对话框轻松调整这些属性。可以从
    **属性** 面板或从 **文件 | AIR for Android 设置** 访问：
- en: '![There''s more…](img/1420_06_14(2).jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多内容…](img/1420_06_14(2).jpg)'
- en: See also…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: 'We will explore the application descriptor file in greater depth within [Chapter
    9](ch09.html "Chapter 9. Manifest Assurance: Security and Android Permissions"),
    *Manifest Assurance: Security and Android Permissions.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章. 清单保证：安全性和安卓权限")中更深入地探讨应用程序描述符文件，*清单保证：安全性和安卓权限*。
- en: Defining a blank Flex mobile application
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个空白 Flex 移动应用程序
- en: When you create a **Flex Mobile Project** in Flash Builder, there are a number
    of default view and layout controls that come along with it, including the `ActionBar`
    control and `ViewNavigator` container. These are very useful controls for many
    types of projects, but not all will benefit from these extra structures. Sometimes
    it is better to start with a blank project and build from there.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flash Builder 中创建一个**Flex 移动项目**时，它会附带许多默认视图和布局控件，包括 `ActionBar` 控件和 `ViewNavigator`
    容器。这些控件对于许多类型的项目非常有用，但并非所有项目都会从这些额外结构中受益。有时从空白项目开始并逐步构建会更好。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: There are two ways to go about defining a blank Flex Mobile Application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个空白 Flex 移动应用程序有两种方法。
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flash Builder 中创建一个**新的 Flex 移动项目**时：
- en: Define your **Project Location** and click **Next**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的**项目位置**并点击**下一步**。
- en: Now simply choose **Blank** in the **Application Template** area and proceed
    with your project setup:![How to do it…](img/1420_06_15(2).jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需在**应用程序模板**区域选择**空白**，然后继续你的项目设置：![如何操作…](img/1420_06_15(2).jpg)
- en: 'The second way is to modify an existing **Flex Mobile Project** to remove certain
    mobile-related structures:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是修改现有的**Flex 移动项目**以移除某些移动相关结构：
- en: 'Your mobile project will initially include the following MXML:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的移动项目最初将包含以下 MXML：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will now modify this in a number of ways. First, change your `ViewNavigatorApplication`
    tags to read as `Application` tags:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将以多种方式修改这部分内容。首先，将你的 `ViewNavigatorApplication` 标签更改为 `Application` 标签：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remove all `View` references in your code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除代码中所有的 `View` 引用：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Either of these methods will enable a blank Flex Mobile application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将创建一个空白 Flex 移动应用程序：
- en: '![How to do it…](img/1420_06_16(2).jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/1420_06_16(2).jpg)'
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: What defines whether the `ActionBar` and other mobile-related structures are
    present within a Flex Mobile Project is whether or not the application is of type
    `spark.components.ViewNavigatorApplication` or `spark.components.TabbedViewNavigatorApplication`.
    When using the more traditional `spark.components.Application` for your Flex Mobile
    project, the `ActionBar, TabBar`, and `ViewStack` are no longer present or usable
    within the project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 决定 Flex 移动项目中是否存在 `ActionBar` 和其他移动相关结构的是应用程序是否为 `spark.components.ViewNavigatorApplication`
    或 `spark.components.TabbedViewNavigatorApplication` 类型。当你的 Flex 移动项目使用更传统的 `spark.components.Application`
    时，`ActionBar, TabBar` 和 `ViewStack` 将不再存在于项目中或无法使用。
- en: For more information about the structures mentioned above, have a look at the
    next few recipes, which describe ways of working in projects with `ViewNavigator`
    enabled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关上述结构的更多信息，请查看接下来的几个食谱，其中描述了在启用了 `ViewNavigator` 的项目中工作的方法。
- en: There's more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: It is not a good idea to modify a Flex mobile project after working on it for
    some time, as you will most likely be tied deeply into the `ViewStack` at that
    point.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间后对 Flex 移动项目进行修改不是一个好主意，因为那时你可能会深深依赖于 `ViewStack`。
- en: Defining a Flex mobile view-based application
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个基于 Flex 移动视图的应用程序
- en: A view-based Flex mobile application provides us with a number of very useful
    controls and containers that specifically target the mobile application development
    layout and structure. These include an `ActionBar` along the top of the screen,
    and the `ViewNavigator` control.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基于视图的 Flex 移动应用程序为我们提供了许多非常有用的控件和容器，这些控件和容器专门针对移动应用程序开发的布局和结构。包括屏幕顶部的 `ActionBar`
    和 `ViewNavigator` 控件。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: There are two ways to go about creating a Flex mobile view-based application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于 Flex 移动视图的应用程序有两种方法。
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flash Builder 中创建一个**新的 Flex 移动项目**时：
- en: Define your **Project Location** and click **Next**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的**项目位置**并点击**下一步**。
- en: Now simply choose **View-Based Application** in the **Application Template**
    area and proceed with your project setup:![How to do it…](img/1420_06_17(2).jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需在**应用程序模板**区域选择**基于视图的应用程序**，然后继续你的项目设置：![如何操作…](img/1420_06_17(2).jpg)
- en: 'The second way is to modify an existing Flex project to add certain mobile-related
    structures:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是修改现有的Flex项目，以添加某些与移动相关的结构：
- en: 'Your Flex project will initially include the following MXML:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的Flex项目最初将包含以下MXML：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now modify this in a number of ways. First, change your `Application`
    tags to read as `ViewNavigatorApplication` tags:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将以几种方式修改这一点。首先，将你的`Application`标签更改为`ViewNavigatorApplication`标签：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `View` MXML file within the current project source folder named `MainHomeView.mxml`
    for this example. In this case, we are creating it within a `views` package in
    our project structure.It is important to realize that every `ViewNavigatorApplication`
    includes any number of individual views. A `View` is a type of Flex container
    that can be managed through the `ViewNavigator` to expose or dismiss various "screens"
    within a mobile Flex application:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目源文件夹内创建一个名为`MainHomeView.mxml`的`View` MXML文件，作为示例。在这种情况下，我们是在项目结构中的`views`包内创建它。重要的是要认识到每个`ViewNavigatorApplication`都包含任意数量的单个视图。一个`View`是一种可以通过`ViewNavigator`管理以展示或关闭移动Flex应用程序内各种“屏幕”的Flex容器类型：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we must point to the file we just created as the `firstView` property of
    our `ViewNavigatorApplication:`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将我们刚刚创建的文件指向`ViewNavigatorApplication`的`firstView`属性：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Either of these methods will define a Flex mobile view-based application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以定义一个基于Flex移动视图的应用程序。
- en: '![How to do it…](img/1420_06_18(2).jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/1420_06_18(2).jpg)'
- en: How it works…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What defines whether the `ActionBar` is present within a Flex mobile project
    is whether or not the application is of type `spark.components.ViewNavigatorApplication`
    (or `spark.components.TabbedViewNavigatorApplication)`. By defining our application
    as a `ViewNavigatorAppplication`, we have access to all of these mobile specific
    structures and controls, including the powerful `ViewNavigator` through which
    we can manage all of our application views.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 决定`ActionBar`是否存在于Flex移动项目中的是应用程序是否为`spark.components.ViewNavigatorApplication`（或`spark.components.TabbedViewNavigatorApplication`）类型。通过将我们的应用程序定义为`ViewNavigatorApplication`，我们可以访问所有这些移动特定的结构和控件，包括强大的`ViewNavigator`，通过它我们可以管理所有的应用程序视图。
- en: A View defines a specific "screen" within our application and the user will
    likely switch between many different views while the application is in use. We
    can manage all of these views from the `ViewNavigator`, which automatically preserves
    a view history for us when the application is in use. As a result of this, when
    the user interacts with the Android back button, previous views can be revisited.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`View`定义了应用程序内的一个特定“屏幕”，用户在使用应用程序时可能会切换到许多不同的视图。我们可以通过`ViewNavigator`管理所有这些视图，当应用程序在使用时，它会自动为我们保存视图历史。因此，当用户与Android后退按钮互动时，可以重新访问之前的视图。
- en: Defining a Flex mobile tabbed application with multiple sections
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个具有多个部分的Flex移动标签应用程序
- en: Setting up a mobile Android project using the Flex framework can be as simple
    or as complex as we want it to be. Going one step beyond the `ViewNavigatorApplication`,
    is the `TabbedViewNavigatorApplication`, which includes the ability to have multiple
    sections of content, each with their own `ViewNavigator` and sets of `Views`.
    Defining a `TabbedViewNavigatorApplication` will allow us access to the `TabBar`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flex框架设置一个移动Android项目可以像我们想要的那么简单或复杂。超越`ViewNavigatorApplication`的一步是`TabbedViewNavigatorApplication`，它包括拥有多个内容部分的能力，每个部分都有自己的`ViewNavigator`和`View`集合。定义一个`TabbedViewNavigatorApplication`将允许我们访问`TabBar`。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: There are two ways to go about configuring a Flex mobile tabbed application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Flex移动标签应用程序有两条路径。
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash Builder中创建一个**新的Flex移动项目**时：
- en: Define your **Project Location** and click **Next >**
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的**项目位置**并点击**下一步 >**
- en: Now simply choose **Tabbed Application** in the **Application Template** area
    and proceed with your project setup:![How to do it…](img/1420_06_19(2).jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需在**应用程序模板**区域选择**标签式应用程序**，然后继续你的项目设置：![如何操作…](img/1420_06_19(2).jpg)
- en: 'The second way is to modify an existing Flex project to add certain mobile-related
    structures:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是修改现有的Flex项目，以添加某些与移动相关的结构：
- en: 'Your Flex project will initially include the following MXML:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的Flex项目最初将包含以下MXML：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now modify this in a number of ways. First, change your `Application`
    tags to read as `TabbedViewNavigatorApplication` tags:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将以几种方式修改这一点。首先，将你的`Application`标签更改为`TabbedViewNavigatorApplication`标签：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a set of `View` MXML files within the current project source folder.
    In this case, we are creating them all within a `views` package in our project
    structure:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目源文件夹内创建一组`View` MXML 文件。在本例中，我们将在项目结构中的`views`包内创建它们：
- en: 'TabOne.mxml:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TabOne.mxml：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'TabTwo.mxml:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TabTwo.mxml：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'TabThree.mxml:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TabThree.mxml：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we must point to the files we just created by nesting a series of `ViewNavigator`
    declarations within our `TabbedViewNavigatorApplication` structure. Each will
    point to one of the unique `View` MXML files we have just created:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须通过将一系列`ViewNavigator`声明嵌套在我们的`TabbedViewNavigatorApplication`结构中，来指向我们刚刚创建的文件。每个都将指向我们刚刚创建的独特`View`
    MXML 文件之一：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Either of these methods will define a Flex mobile tabbed application:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的任何一种都将定义一个 Flex 移动标签应用程序：
- en: '![How to do it…](img/1420_06_20(2).jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/1420_06_20(2).jpg)'
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What defines whether the `TabBar` is present within a Flex Mobile Project is
    whether or not the application is of type `spark.components.TabbedViewNavigatorApplication`.
    When using the more traditional `spark.components.Application` for your Flex mobile
    project, the `TabBar` and `ViewStack` are no longer present or usable within the
    project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flex 移动项目中是否包含`TabBar`是由应用程序是否为`spark.components.TabbedViewNavigatorApplication`类型来定义的。当在
    Flex 移动项目中使用更传统的`spark.components.Application`时，`TabBar`和`ViewStack`在项目中不再存在或可用。
- en: There's more…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: It is important to note here that when using `TabbedViewNavigator`, each tab
    has its own exclusive `ViewNavigator` each with its own view stack. The `ViewNavigotor`
    instances do not have a mechanism to share data with one another unless drawn
    upon from a separate source, such as a shared data pool, which would be defined
    by the developer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当使用`TabbedViewNavigator`时，每个标签都有自己专用的`ViewNavigator`，每个都有自己的视图堆栈。除非从其他来源（如共享数据池）获取，否则`ViewNavigotor`实例之间没有机制共享数据，这需要由开发人员定义。
- en: Using a splash screen within a Flex mobile application
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Flex 移动应用程序中使用启动画面
- en: Adobe AIR for Android is an excellent runtime for building and distributing
    Android applications, but there are some trade-offs in comparison to native development.
    Depending upon the size of your application, it may take a few seconds to load
    everything up for the user. The mobile Flex framework allows us to define a splash
    screen to let the user know that the application is loading once they launch,
    and to add an extra bit of flourish to the entire experience.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓版的 Adobe AIR 是一个优秀的运行时环境，用于构建和分发安卓应用程序，但与原生开发相比，它有一些权衡。根据应用程序的大小，它可能需要几秒钟的时间为用户加载所有内容。移动
    Flex 框架允许我们定义一个启动画面，让用户在启动应用程序时知道应用程序正在加载，并为整个体验增添一点额外的装饰。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will configure our application to display a splash screen while the application
    loading process takes place:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置应用程序，在应用程序加载过程中显示启动画面：
- en: Upon defining our Flex mobile project, we will need to be sure the `ViewNavigatorApplication`
    or `TabbedViewNavigatorApplication` (depending upon your project) is the currently
    selected MXML tag and enter **Design** view.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义 Flex 移动项目时，我们需要确保`ViewNavigatorApplication`或`TabbedViewNavigatorApplication`（取决于你的项目）是当前选定的
    MXML 标签，并进入**设计**视图。
- en: Next, we will modify a few settings within the **Common** area of our **Properties**
    panel. Here, browse to an image file to embed a **Splash image** and set the **Splash
    scale mode** to **none, letterbox, stretch**, or **zoom:**![How to do it…](img/1420_06_21(2).jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改**属性**面板中**通用**区域内的几个设置。在这里，浏览到一个图像文件以嵌入**启动画面**，并将**启动画面缩放模式**设置为**无，信箱，拉伸**或**缩放**：![如何操作…](img/1420_06_21(2).jpg)
- en: 'Enter **Source view** and the MXML document will appear as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**源代码视图**，MXML 文档将如下所示：
- en: '[PRE33]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can, of course, modify any of the settings we have just configured from
    here by pointing to another file to embed or changing the scale mode. We will
    be adding one more property to our main application tag called `splashScreenMinimumDisplayTime`
    and set its value to the minimum duration, in milliseconds, that we want the splash
    screen image to display for:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，你可以从这里修改我们刚刚配置的任何设置，指向另一个文件进行嵌入或更改缩放模式。我们将在主应用程序标签中添加一个名为`splashScreenMinimumDisplayTime`的属性，并将其值设置为希望启动画面图像显示的最短持续时间（毫秒）：
- en: '[PRE34]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the user runs the application on their device, they will be presented with
    a handsome splash screen identifying the application and letting them know that
    it is now loading:![How to do it…](img/1420_06_22(2).jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在他们的设备上运行应用程序时，他们会看到一个精美的启动画面，标识应用程序并告知它们正在加载：![如何操作…](img/1420_06_22(2).jpg)
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Setting the `splashScreenImage` property on our main application file will
    allow us to display an embedded custom image to the user while our application
    is loading. The addition of a `splashScreenMinimumDisplayTime` property allows
    us to define the minimum length of time (in milliseconds) that our splash screen
    will display for. If the application takes longer than this defined time, the
    splash screen will continue to display as needed. The splash screen also can accept
    a specific scale mode behavior by setting the `splashScreenScaleMode` property:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在主应用程序文件上设置`splashScreenImage`属性，可以在用户加载应用程序时向其显示一个嵌入的自定义图像。添加`splashScreenMinimumDisplayTime`属性允许我们定义启动画面显示的最短时间（以毫秒为单位）。如果应用程序加载时间超过这个定义的时间，启动画面将根据需要继续显示。启动画面还可以通过设置`splashScreenScaleMode`属性接受特定的缩放模式行为：
- en: Setting `splashScreenScaleMode` to `none` will present our defined image at
    its native resolution without any modification. This is probably unacceptable
    as device screen resolutions vary so greatly.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`splashScreenScaleMode`设置为`none`会以原始分辨率呈现我们定义的图像，不做任何修改。这可能无法接受，因为设备屏幕分辨率差异很大。
- en: Setting `splashScreenScaleMode` to `letterbox` will fit the splash image into
    the frame defined by the device display resolution, but will display empty padding
    in the areas that the image does not cover.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`splashScreenScaleMode`设置为`letterbox`将把启动图像缩放到由设备显示分辨率定义的框架中，但在图像未覆盖的区域会显示空白填充。
- en: Setting `splashScreenScaleMode` to `stretch` will stretch the defined image
    into the frame defined by the device display resolution, filling the entire display
    area. Some distortion may occur with this setting as the image may be scaled disproportionately.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`splashScreenScaleMode`设置为`stretch`将拉伸定义的图像以适应由设备显示分辨率定义的框架，填充整个显示区域。由于图像可能不成比例地缩放，这种设置可能会导致一些失真。
- en: Setting `splashScreenScaleMode` to `zoom` will fit the splash image into the
    frame defined by the device display resolution without allowing any padding. It
    will fill the entire display area by cropping portions of the image from view.
    This may be undesirable as portions of the image may not be visible to the user.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`splashScreenScaleMode`设置为`zoom`将把启动图像缩放到由设备显示分辨率定义的框架中，不允许任何填充。它将通过裁剪图像的某些部分来填充整个显示区域。这可能是不希望的，因为用户可能无法看到图像的某些部分。
- en: 'Example: a 480x800 pixel image will appear as follows when rendered on a device
    display measuring 320x480:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：一个480x800像素的图像在320x480的设备显示屏上呈现时如下所示：
- en: '![How it works…](img/1420_06_23(2).jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/1420_06_23(2).jpg)'
- en: Configuring the ActionBar within a Flex mobile project for use with ViewNavigator
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flex移动项目中配置ActionBar，以便与ViewNavigator一起使用。
- en: The Flex mobile `ViewNavigatorApplication` and `TabbedViewNavigatorApplication`
    contain a special control called the `ActionBar`, which contains three editable
    child containers. We can define the contents of these child containers by modifying
    the MXML in our project documents.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Flex移动`ViewNavigatorApplication`和`TabbedViewNavigatorApplication`包含一个名为`ActionBar`的特殊控件，其中包含三个可编辑的子容器。我们可以通过修改项目文档中的MXML来定义这些子容器的内容。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Modify the document MXML to customize our `ActionBar` contents. In this example,
    we will define some interactive image controls and provide a rich title image
    across our application `ViewStack:`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文档MXML来自定义我们的`ActionBar`内容。在这个例子中，我们将定义一些交互式图像控件，并在应用程序`ViewStack`中提供一个丰富的标题图像。
- en: 'When we first configure a new Flex mobile project, our main MXML document will
    appear as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次配置新的Flex移动项目时，主MXML文档将如下所示：
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ActionBar` contains three distinct areas within which we can define additional
    controls, they are the `navigationContent, titleContent`, and `actionContent`
    containers.![How to do it…](img/1420_06_24(2).jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActionBar`包含三个独立区域，我们可以在其中定义额外的控件，它们分别是`navigationContent`、`titleContent`和`actionContent`容器。![如何操作…](img/1420_06_24(2).jpg)'
- en: 'We will first define a `navigationContent` node within our main application
    MXML. Define a Spark `Image` control within, embedding a navigation image that
    will function as a way for users to get back to the "home" screen of our application:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在我们的主应用程序MXML中定义一个`navigationContent`节点。在其中定义一个Spark `Image`控件，嵌入一个导航图片，这将作为用户返回到我们应用程序“主页”屏幕的方式：
- en: '[PRE36]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, define the `titleContent` container and create an `Image` control within
    it embedding an image used as the title of our application:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义`titleContent`容器，并在其中创建一个`Image`控件，嵌入作为我们应用程序标题的图片：
- en: '[PRE37]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, define a `actionContent` node and embed another image within it, just
    as we did for our `navigationContent` container. This will function as a close
    button:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个`actionContent`节点，并在其中嵌入另一个图片，就像我们对`navigationContent`容器所做的那样。这将作为一个关闭按钮：
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will then set up a `script` block in our MXML to contain any functions we
    will be writing:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在MXML中设置一个`script`块，以包含我们将要编写的任何函数：
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Define a method within our script block that will return the user to our initial
    `View` when the `navigationContent` child `Image` is pressed by invoking the `ViewNavigator.popToFirstView()`
    method.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的脚本块中定义一个方法，当用户按下`navigationContent`子级的`Image`时，通过调用`ViewNavigator.popToFirstView()`方法将用户返回到我们的初始`View`。
- en: '[PRE40]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define a second method to exit the application when the `actionContent` child
    `Image` is pressed by the user:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个第二种方法，当用户按下`actionContent`子级的`Image`时退出应用程序：
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we will complete this example by assigning click events to each of our
    interactive `ActionBarImage` controls, registering them with the methods we created
    previously:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过为每个交互式`ActionBarImage`控件分配点击事件来完成此示例，使用我们之前创建的方法注册它们：
- en: '[PRE42]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will also define our two `View` mxml files in such a way that these `ActionBar`
    controls will be clearly functional for this example. The initial `View` will
    include a Button in order to navigate to the secondary `View` using the `ViewNavigator.push()`
    method. When invoking this method, we simply need to pass in a reference to the
    particular the application should enable for the user to interact with. We can
    optionally pass in a second argument, which contains data to feed the `View`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将以这种方式定义两个`View` mxml文件，以便这些`ActionBar`控件对于此示例清晰起作用。初始`View`将包括一个按钮，以便使用`ViewNavigator.push()`方法导航到次要`View`。调用此方法时，我们只需传入对特定应用程序应允许用户交互的视图的引用。我们可以选择性地传入第二个参数，其中包含要传递给`View`的数据。
- en: 'From the secondary `View`, a user can either exit the application through clicking
    the `ActionBar` exit `Image`, press the Android back button, or click the `ActionBarhome
    Image` to invoke the `ViewNavigator.popToFirstView()` method and return to the
    initial application state:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从次要`View`，用户可以通过点击`ActionBar`上的退出`Image`退出应用程序，按Android返回按钮，或者点击`ActionBar`上的主页`Image`来调用`ViewNavigator.popToFirstView()`方法，返回到初始的应用程序状态：
- en: 'CustomAction BarHomeView.mxml:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义ActionBar的HomeView.mxml：
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we run the application upon our device, the **ActionBar** will appear as
    follows:![How to do it…](img/1420_06_25.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上运行应用程序时，**ActionBar**将如下显示：![如何操作…](img/1420_06_25.jpg)
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The Flex mobile `ActionBar` is an excellent structural element that can be used
    across a variety of mobile Android applications. The three container areas; `navigationContent,
    titleContent`, and `actionContent` behave much like any other Flex container.
    The contents of the `ActionBar` and the functions they perform are really up to
    the application developer and what makes sense for the target user. We must be
    sure to consider the amount of space available to us and how this can change across
    devices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flex`移动端的`ActionBar`是一个优秀的结构元素，可以广泛应用于各种Android移动应用程序中。三个容器区域：`navigationContent`、`titleContent`和`actionContent`与其他Flex容器的行为类似。`ActionBar`中的内容及其功能实际上取决于应用程序开发人员，以及这对目标用户是否有意义。我们必须确保考虑可用的空间量以及这如何在不同设备间变化。'
- en: When dealing with the `ViewNavigator`, there are a number of important methods
    that mobile developers should be familiar with. We will briefly touch upon them
    here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`ViewNavigator`时，移动开发人员应该熟悉许多重要方法。我们在这里将简要提及它们。
- en: '`popToFirstView()` removes all views from the `ViewNavigator` except the bottom
    view, essentially having the application return to the "home" view. `popView()pops`
    the current view off the navigation stack, exposing the previous view to the user.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`popToFirstView()`方法会移除`ViewNavigator`中除最底层视图外的所有视图，实质上是让应用程序返回到“主页”视图。`popView()`方法将当前视图从导航堆栈中弹出，向用户展示上一个视图。'
- en: '`pushView()pushed` a new view to the top of the `ViewNavigator` navigation
    stack, making it the current view. For this to function, a valid `View` object
    reference must be passed in as an argument of this method.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushView()`方法将一个新的视图推送到`ViewNavigator`导航堆栈的顶部，使其成为当前视图。为此，必须将有效的`View`对象引用作为此方法的参数传入。'
- en: There's more…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'We can also manage the view transitions by passing a transition reference through
    as the final argument in any of the `ViewNavigator` methods outlined in the previous
    section. For example, if we wanted to replace the normal sliding transition with
    a cube flipping up, we could do so through these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在前一节中概述的`ViewNavigator`方法的最后一个参数中传递一个过渡引用来管理视图过渡。例如，如果我们想用翻转的立方体替换正常的滑动过渡，可以通过以下步骤实现：
- en: 'Import the following classes:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下类：
- en: '[PRE44]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Invoke a method to create our transition and pass it along as an argument of
    `ViewNavigator.popView()`. When creating our transition, we can define things
    such as duration, the direction of movement, and whether the `ActionBar` control
    is animated along with the view content or not:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用创建我们过渡的方法，并将其作为`ViewNavigator.popView()`的参数传递。创建过渡时，我们可以定义诸如持续时间、移动方向以及`ActionBar`控件是否与视图内容一起动画等事项：
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a number of different transition types for us to explore when developing
    mobile Flex projects. This is just an example of how to go about using one of
    them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发移动Flex项目时，我们可以探索许多不同的过渡类型。这仅是使用其中一种类型的方法示例。
- en: Hiding the ActionBar control in a single view for a Flex mobile project
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flex移动项目的单个视图中隐藏ActionBar控件
- en: You may want to use the `ViewNavigator` structure and functionality of the `ViewNavigatorApplication`
    container, but simply want to hide the `ActionBar` in a specific application View.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想使用`ViewNavigatorApplication`容器的`ViewNavigator`结构和功能，但只是想在特定应用程序视图中隐藏`ActionBar`。
- en: How to do it…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Set the View `actionBarVisible` property to `true`. The following example shows
    how to toggle the `ActionBar` off and on for a particular `View` based on a button
    click:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将View的`actionBarVisible`属性设置为`true`。以下示例显示如何根据按钮点击为特定`View`打开和关闭`ActionBar`：
- en: 'Define a new Flex mobile view-based application:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的基于Flex移动视图的应用程序：
- en: '[PRE46]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new MXML file called `MainHomeView.mxml` within a `views` package
    that will define our primary view for this application:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个`views`包中创建一个名为`MainHomeView.mxml`的新MXML文件，这将定义此应用程序的主要视图：
- en: '[PRE47]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Define a `Button` component within the MXML file we just created, which constitutes
    our `ViewNavigatorApplicationfirstView:`
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚才创建的MXML文件中定义一个`Button`组件，这构成了我们的`ViewNavigatorApplicationfirstView:`：
- en: '[PRE48]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will then set up a `script` block in our MXML to contain any functions we
    will be writing:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在MXML中设置一个`script`块，以包含我们将要编写的任何函数：
- en: '[PRE49]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, create a function called `toggleActionBar` and within it, we will create
    an `if` statement checking whether the `actionBarVisible` property of our `View`
    is `true` or `false`. Depending upon the current `Boolean` value, we will toggle
    to the opposite value:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`toggleActionBar`的函数，并在其中创建一个`if`语句，检查我们`View`的`actionBarVisible`属性是`true`还是`false`。根据当前的`Boolean`值，我们将切换到相反的值：
- en: '[PRE50]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we simply need to create a click event handler on our `Button` component
    to invoke the function just created:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需在`Button`组件上创建一个点击事件处理程序，以调用刚才创建的函数：
- en: '[PRE51]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This `Button` will now toggle the `ActionBar` off and on when toggled:![How
    to do it…](img/1420_06_26.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这个`Button`可以在切换时打开和关闭`ActionBar`：![如何操作…](img/1420_06_26.jpg)
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Each `View` of your application has an `actionBarVisible` property. Setting
    `actionBarVisible = false`; will hide the `ActionBar` control for those particular
    `Views` it is set on. This is really quite flexible, as we can turn the `ActionBar`
    control on and off as needed, depending upon which `View` we are currently on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的每个`View`都有一个`actionBarVisible`属性。设置`actionBarVisible = false`; 将隐藏特定`View`上的`ActionBar`控件。这实际上非常灵活，因为我们可以根据当前所在的`View`按需打开或关闭`ActionBar`控件。
- en: There's more…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'The mechanism with which we have removed the `ActionBar` control from our `View`
    is similar to the one with which we can use to remove the `TabBar` from a `TabbedViewNavigatorApplication`
    project by setting the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`View`中移除`ActionBar`控件的方法与从`TabbedViewNavigatorApplication`项目中移除`TabBar`的方法类似，通过设置以下内容：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
