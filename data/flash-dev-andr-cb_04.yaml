- en: 'Chapter 4. Visual and Audio Input: Camera and Microphone Access'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 视觉和音频输入：相机和麦克风访问
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Detecting camera and microphone support
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测相机和麦克风支持
- en: Using the traditional camera API to save a captured image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传统相机API保存捕捉到的图像
- en: Using the Mobile CameraUI API to save a captured photograph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移动设备CameraUI API保存捕捉到的照片
- en: Using the Mobile CameraUI API to save a captured video
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移动设备CameraUI API保存捕捉到的视频
- en: Using the device microphone to monitor audio sample data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备麦克风监控音频样本数据
- en: Recording microphone audio sample data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录麦克风音频样本数据
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Camera and microphone are standard accessories on most mobile devices and Android
    devices are no exception to this. The present chapter will cover everything from
    accessing the camera and taking photos, recording video data, and encoding raw
    audio captured from the device microphone and encoding it to WAV or MP3 for use
    on other platforms and systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相机和麦克风是大多数移动设备和Android设备上的标准配件。本章将涵盖从访问相机和拍照，录制视频数据，以及从设备麦克风捕获原始音频并将其编码为WAV或MP3以便在其他平台和系统上使用的一切内容。
- en: All of the recipes in this chapter are represented as pure ActionScript 3 classes
    and are not dependent upon external libraries or the Flex framework. Therefore,
    we will be able to use these examples in any IDE we wish.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都表示为纯ActionScript 3类，并且不依赖于外部库或Flex框架。因此，我们可以使用我们希望的任何IDE中的这些示例。
- en: Detecting camera and microphone support
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测相机和麦克风支持
- en: Nearly all Android devices come equipped with camera hardware for capturing
    still images and video. Many devices now have both front and rear-facing cameras.
    It is important to know whether the default device camera is usable through our
    application. We should never assume the availability of certain hardware items,
    no matter how prevalent across devices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Android设备都配备了用于捕捉静态图像和视频的相机硬件。现在许多设备都拥有前后置摄像头。了解默认设备相机是否可通过我们的应用程序使用非常重要。我们绝不能假设某些硬件的可用性，无论它们在设备中多么普遍。
- en: Similarly, we will want to be sure to have access to the device microphone as
    well, when capturing video or audio data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当捕捉视频或音频数据时，我们也需要确保能够访问设备麦克风。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will determine which audio and video APIs are available to us on our Android
    device:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确定我们的Android设备上可用的音频和视频API：
- en: 'First, import the following classes into your project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象对，以允许在设备上可见输出：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用`TextFormat`，并将`TextField`添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we must check the `isSupported` property of each of these objects. We create
    a method here to perform this across all three and write results to a `TextField:`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须检查这些对象的`isSupported`属性。我们在这里创建一个方法来对所有三个进行检查，并将结果写入`TextField：`
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now know the capabilities of video and audio input for a particular device
    and can react accordingly:![How to do it...](img/1420_04_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在知道特定设备的视频和音频输入功能，并可以相应地做出反应：![如何操作...](img/1420_04_01.jpg)
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Each of these three classes has a property `isSupported`, which we may invoke
    at any time to verify support on a particular Android device. The traditional
    `Camera` and mobile-specific `CameraUI` both refer to the same hardware camera,
    but are entirely different classes for dealing with the interaction between Flash
    and the camera itself, as `CameraUI` relies upon the default device camera applications
    to do all the capturing, and `Camera` works exclusively within the Flash environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类都拥有一个属性`isSupported`，我们可以随时调用它来验证在特定Android设备上的支持情况。传统的`Camera`和针对移动设备的`CameraUI`都指的是同一硬件相机，但它们是处理闪光灯与相机本身交互的完全不同的类，因为`CameraUI`依赖于设备默认相机应用程序完成所有捕捉工作，而`Camera`仅在Flash环境中工作。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The traditional `Microphone` object is also supported in this manner.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式也支持传统的`Microphone`对象。
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to note that even though many Android devices come equipped
    with more than one camera, only the primary camera (and microphone) will be exposed
    to our application. Support for multiple cameras and other sensors will likely
    be added to the platform as Android evolves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管许多Android设备配备了不止一个摄像头，但只有主摄像头（和麦克风）会对我们的应用程序可见。随着Android的发展，可能会增加对多个摄像头和其他传感器的支持。
- en: Using the traditional camera API to save a captured image
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传统的摄像头API保存捕捉到的图像
- en: When writing applications for the web through Flash player, or for a desktop
    with AIR, we have had access to the `Camera` class through ActionScript. This
    allows us to access different cameras attached to whatever machine we are using.
    On Android, we can still use the `Camera` class to access the default camera on
    the device and access the video stream it provides for all sorts of things. In
    this example, we will simply grab a still image from the `Camera` feed and save
    it to the Android `CameraRoll`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过Flash播放器为网页编写应用程序，或者为桌面应用使用AIR时，我们可以通过ActionScript访问`Camera`类。这使得我们可以访问连接到我们使用的任何机器上的不同摄像头。在Android上，我们仍然可以使用`Camera`类来访问设备上的默认摄像头，并获取它提供的视频流用于各种事情。在本例中，我们将简单地从`Camera`的输入中抓取一个静态图像，并将其保存到Android的`CameraRoll`中。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will construct a `Video` object to bind the `Camera` stream to, and use
    `BitmapData` methods to capture and then save our rendered image using the mobile
    `CameraRoll` API:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个`Video`对象来绑定`Camera`的流，并使用`BitmapData`方法捕获并保存我们渲染的图像，使用移动设备的`CameraRoll`
    API：
- en: 'At a minimum, we need to import the following classes into our project:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，我们需要将以下类导入到我们的项目中：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we must declare the object instances necessary for camera access and file
    reference:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须声明进行摄像头访问和文件引用所需的实例对象：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Initialize a `Video` object, passing in the desired width and height, and add
    it to the `DisplayList:`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`Video`对象，传入所需的宽度和高度，并将其添加到`DisplayList`：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Initialize a `Camera` object and employ `setMode` to specify width, height,
    and frames per second before attaching the `Camera` to our `Video` on the `DisplayList:`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`Camera`对象，并使用`setMode`方法来指定宽度、高度和每秒帧数，然后再将`Camera`附加到`DisplayList`上的`Video`：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now register a `TouchEvent` listener of type `TOUCH_TAP` to the `Stage`.
    This will enable the user to take a snapshot of the camera display by tapping
    the device screen:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在`Stage`上注册一个类型为`TOUCH_TAP`的`TouchEvent`监听器。这将使用户可以通过点击设备屏幕来捕获摄像头显示的快照：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To capture an image from the camera feed, we will initialize our `BitmapData`
    object, matching the width and height of our `Video` object, and employ the `draw`
    method to translate the `Video` pixels to `BitmapData`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从摄像头输入中捕获图像，我们将初始化我们的`BitmapData`对象，使其与`Video`对象的宽度和高度相匹配，并使用`draw`方法将`Video`的像素转换为`BitmapData`。
- en: To save our acquired image to the device, we must initialize a `CameraRoll`
    object and invoke `addBitmapData()`, passing in the `BitmapData` object we have
    created using `Video` object pixels. We will also determine whether or not this
    device supports the `addBitmapData()` method by verifying `CameraRoll.supportsAddBitmapData`
    is equal to `true:`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们获取的图像保存到设备上，我们必须初始化一个`CameraRoll`对象，并调用`addBitmapData()`，传入我们使用`Video`对象像素创建的`BitmapData`对象。我们还将确定此设备是否支持`addBitmapData()`方法，通过验证`CameraRoll.supportsAddBitmapData`是否等于`true`：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How to do it...](img/1420_04_02.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1420_04_02.jpg)'
- en: If we now check our Android Gallery, we will find the saved image:![How to do
    it...](img/1420_04_03.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在检查我们的Android图库，我们会找到保存的图像：![如何操作...](img/1420_04_03.jpg)
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Most of this is performed exactly as it would be with normal Flash Platform
    development on the desktop. Attach a `Camera` to a `Video`, add the `Video` to
    the `DisplayList`, and then do whatever you need for your particular application.
    In this case, we simply capture what is displayed as `BitmapData`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分操作与在桌面上的正常Flash平台开发完全相同。将一个`Camera`附加到一个`Video`上，将`Video`添加到`DisplayList`，然后根据你的特定应用程序进行需要的操作。在本例中，我们只是简单地捕获显示的`BitmapData`作为图像。
- en: The `CameraRoll` class, however, is specific to mobile application development
    as it will always refer to the directory upon which the device camera stores the
    photographs it produces. If you want to save these images within a different directory,
    we could use a `File` or `FileReference` object to do so, but this involves more
    steps for the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`CameraRoll`类是特定于移动应用开发的，因为它总是指的是设备相机存储所产生照片的目录。如果你想要将这些图片保存在不同的目录中，我们可以使用`File`或`FileReference`对象来实现，但这需要用户进行更多操作。
- en: Note that while using the `Camera` class, the hardware orientation of the camera
    is landscape. We can deal with this by either restricting the application to landscape
    mode, or through rotations and additional manipulation as we've performed in our
    example class. We've applied a 90 degree rotation to the image in this case using
    `videoHolder.rotation` to account for this shift when reading in the `BitmapData`.
    Depending on how any specific application handles this, it may not be necessary
    to do so.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`Camera`类时，相机的硬件方向是横屏的。我们可以通过将应用限制为横屏模式，或者像我们在示例类中所做的那样通过旋转和额外的操作来处理这个问题。在这种情况下，我们使用了`videoHolder.rotation`对图像应用了90度旋转，以在读取`BitmapData`时考虑这个偏移。具体应用如何处理，可能不需要这样做。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Other use cases for the traditional Camera object are things such as sending
    a video stream to Flash Media Server for live broadcast, augmented reality applications,
    or real-time peer to peer chat.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传统Camera对象的其他用例包括将视频流发送到Flash Media Server进行直播，增强现实应用，或者实时点对点聊天。
- en: See also...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'In order to access the camera and storage, we will need to add some Android
    permissions for `CAMERA` and `WRITE_EXTERNAL_STORAGE`. Refer to [Chapter 11](ch11.html
    "Chapter 11. Final Considerations: Application Compilation and Distribution"),
    *Final Considerations: Application Compilation and Distribution* for information
    on how to go about this.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问相机和存储，我们需要添加一些Android权限，分别是`CAMERA`和`WRITE_EXTERNAL_STORAGE`。关于如何进行，请参考[第11章](ch11.html
    "第11章. 最终考虑：应用程序编译和分发")，*最终考虑：应用程序编译和分发*。
- en: Using the Mobile CameraUI API to save a captured photograph
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用移动端CameraUI API保存捕获的照片
- en: Using the new `CameraUI` API (available in the mobile AIR SDK), we can perform
    and alternative capture process to the normal `Camera` API. The `Mobile CameraUI`
    class will make use of the default Android camera application, alongside our custom
    app, to capture a photograph.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`CameraUI` API（在移动AIR SDK中可用），我们可以执行与正常`Camera` API不同的捕获过程。`Mobile CameraUI`类将利用默认的Android相机应用程序以及我们的自定义应用程序来捕获一张照片。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will set up a `CameraUI` object to invoke the native Android camera to capture
    a photograph:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`CameraUI`对象来调用原生的Android相机来捕获一张照片：
- en: 'First, import the following classes into your project:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declare aTextField and `TextFormat` object pair to allow visible output upon
    the device. A `CameraUI` object must also be declared for this example:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象对，以便在设备上显示输出。这个示例还需要声明一个`CameraUI`对象：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用`TextFormat`，并将`TextField`添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instantiate a new `CameraUI` instance, which will be used to launch the device
    camera application and return file information back to us. If the `CameraUI` object
    is not supported on a particular device, a message is output to our `TextField`
    indicating this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`CameraUI`实例，它将用于启动设备相机应用程序，并将文件信息返回给我们。如果某个特定设备不支持`CameraUI`对象，则会向我们的`TextField`输出一条消息表示这一点：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an event listener to the `CameraUI` object so that we know when the capture
    is complete. We will also register a touch event on the `Stage` to initiate the
    capture:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CameraUI`对象上添加一个事件监听器，这样我们就可以知道捕获何时完成。我们还将为`Stage`注册一个触摸事件来启动捕获：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To employ the default camera application on our Android device, we will need
    to invoke the `launch` method, passing in the `MediaType.IMAGE` constant to specify
    that we wish to capture a photograph:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Android设备上使用默认的相机应用，我们需要调用`launch`方法，并传入`MediaType.IMAGE`常量以指定我们希望拍摄一张照片：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the default Android camera will initialize, allowing the user to capture
    a photograph. Once the user hits **OK**, focus will return to our application.![How
    to do it...](img/1420_04_04.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，默认的安卓相机将初始化，允许用户拍摄照片。用户点击**确定**后，焦点将返回到我们的应用程序。![如何操作...](img/1420_04_04.jpg)
- en: Finally, once we complete the capture process, an event of type `MediaEvent.COMPLETE`
    will fire, invoking our `photoReady` method. From this, we can ascertain certain
    details about our captured photograph.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们完成捕获过程，将触发一个类型为`MediaEvent.COMPLETE`的事件，调用我们的`photoReady`方法。从中我们可以确定有关我们捕获的照片的某些细节。
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output will look something like this:![How to do it...](img/1420_04_05.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将类似于这样：![如何操作...](img/1420_04_05.jpg)
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Invoking the `CameraUI.launch` method will request the Android device to open
    the default camera application and allow the user to take a photograph. Upon completing
    the capture process and confirming the captured photograph, focus is then returned
    to our application along with a set of data about the new file contained within
    the `MediaEvent.COMPLETE` event object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`CameraUI.launch`方法将请求安卓设备打开默认的相机应用程序，并允许用户拍照。在完成捕获过程并确认捕获的照片后，焦点将返回到我们的应用程序，同时返回包含在`MediaEvent.COMPLETE`事件对象中的一组关于新文件的数据。
- en: At this point, our application can do all sorts of things with the data returned,
    or even open the file within the application, assuming that the file type can
    be loaded and displayed by the runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的应用程序可以对返回的数据执行各种操作，甚至可以在应用程序中打开文件，假设文件类型可以被运行时加载和显示。
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The default camera application will not load if the device does not have a storage
    card mounted. It is also important to note that if the device becomes low on memory
    during the capture process, Android may terminate our application before the process
    is complete.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备没有挂载存储卡，则默认的相机应用程序将不会加载。还需要注意的是，如果在捕获过程中设备内存不足，安卓可能会在过程完成前终止我们的应用程序。
- en: See also...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'We will discuss the display of images through an AIR for Android application
    in [Chapter 5](ch05.html "Chapter 5. Rich Media Presentation: Working with Images,
    Video, and Audio"): *Rich Media Presentation: Working with Images, Video, and
    Audio.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章.富媒体展示：处理图像、视频和音频")讨论通过AIR for Android应用程序显示图像：*富媒体展示：处理图像、视频和音频。*
- en: Using the Mobile CameraUI API to save a captured video
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用移动CameraUI API保存捕获的视频
- en: Using the new `CameraUI` API (available in the mobile AIR SDK) we can perform
    and alternative capture process to the normal `Camera` API. The mobile `CameraUI`
    class will make use of the default Android camera application, alongside our custom
    app to capture a video.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`CameraUI` API（在移动AIR SDK中可用），我们可以执行与正常`Camera` API不同的捕获过程。移动`CameraUI`类将利用默认的安卓相机应用程序，以及我们的自定义应用程序来捕获视频。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will set up a `CameraUI` object to invoke the native Android camera to capture
    a video:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个`CameraUI`对象来调用原生的安卓相机以捕获视频：
- en: 'First, import the following classes into your project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device. A `CameraUI` object must also be declared for this example:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象对，以允许在设备上可见输出。对于此示例，还必须声明一个`CameraUI`对象：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用一个`TextFormat`，并将`TextField`添加到`DisplayList`中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Instantiate a new `CameraUI` instance, which will be used to launch the device
    camera application and return file information back to us. If the `CameraUI` object
    is not supported on a particular device, a message is output to our `TextField`
    indicating this.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`CameraUI`实例，它将用于启动设备相机应用程序并将文件信息返回给我们。如果特定设备不支持`CameraUI`对象，则会在我们的`TextField`中输出一条消息指示这一点。
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add an event listener to the `CameraUI` object so that we know when the capture
    is complete. We will also register a touch event on the `Stage` to initiate the
    capture:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`CameraUI`对象添加一个事件监听器，以便我们知道捕获何时完成。我们还将向`Stage`注册一个触摸事件来启动捕获：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To employ the default camera application on our Android device, we will need
    to invoke the `launch` method, passing in the `MediaType.VIDEO` constant to specify
    that we wish to capture a video file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在安卓设备上使用默认相机应用程序，我们需要调用`launch`方法，并传入`MediaType.VIDEO`常量以指定我们希望捕获视频文件：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, the default Android camera will initialize, allowing the user to take some
    video. Once the user hits **OK**, focus will return to our application:![How to
    do it...](img/1420_04_06.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，默认的安卓相机将初始化，允许用户拍摄一些视频。当用户点击**确定**后，焦点将返回到我们的应用程序：![如何操作...](img/1420_04_06.jpg)
- en: 'Finally, once we complete the capture process, an event of type `MediaEvent.COMPLETE`
    will fire, invoking our `videoReady` method. From this, we can ascertain certain
    details about our captured video file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们完成捕获过程，将触发一个类型为`MediaEvent.COMPLETE`的事件，调用我们的`videoReady`方法。从中我们可以了解有关捕获的视频文件的某些详细信息：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output will look something like this:![How to do it...](img/1420_04_07.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将类似于这样：![如何操作...](img/1420_04_07.jpg)
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Invoking the `CameraUI.launch` method will request that the Android device open
    the default camera application and allow the user to capture some video. Upon
    completing the capture process and confirming the captured video file, focus is
    then returned to our application along with a set of data about the new file contained
    within the `MediaEvent.COMPLETE` event object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`CameraUI.launch`方法将请求安卓设备打开默认的相机应用程序，并允许用户捕获一些视频。在完成捕获过程并确认捕获的视频文件后，焦点将连同包含在`MediaEvent.COMPLETE`事件对象中的一组新文件数据一起返回到我们的应用程序。
- en: At this point, our application can do all sorts of things with the data returned,
    or even open the file within the application, assuming that the file type can
    be loaded and displayed by the runtime. This is very important when it comes to
    video as certain devices will use a variety of codecs to encode the captured video,
    not all of them Flash Platform compatible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的应用程序可以对返回的数据执行各种操作，甚至可以在应用程序中打开文件，假设文件类型可以被运行时加载和显示。这对于视频来说非常重要，因为某些设备将使用各种编解码器来编码捕获的视频，并非所有这些编解码器都与Flash平台兼容。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The default camera application will not load if the device does not have a storage
    card mounted. It is also important to note that if the device becomes low on memory
    during the capture process, Android may terminate our application before the process
    is complete.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备没有挂载存储卡，则默认相机应用程序将无法加载。还需要注意的是，如果在捕获过程中设备内存不足，安卓可能会在过程完成前终止我们的应用程序。
- en: Also, there are many other events aside from `MediaEvent.COMPLETE` that we can
    use in such a process. For instance, register an event listener of type `Event.CANCEL`
    in order to react to the user canceling a video save.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了`MediaEvent.COMPLETE`，我们还可以在类似过程中使用许多其他事件。例如，注册一个类型为`Event.CANCEL`的事件监听器，以响应用户取消视频保存。
- en: See also...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'We will discuss the playback of video files through an AIR for Android application
    in [Chapter 5](ch05.html "Chapter 5. Rich Media Presentation: Working with Images,
    Video, and Audio").'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章.富媒体展示：使用图像、视频和音频")中讨论通过AIR for Android应用程序播放视频文件。
- en: Using the device microphone to monitor audio sample data
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备麦克风监控音频样本数据
- en: By monitoring the sample data being returned from the Android device microphone
    through the ActionScript `Microphone` API, we can gather much information about
    the sound being captured, and perform responses within our application. Such input
    can be used in utility applications, learning modules, and even games.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过监控从安卓设备麦克风通过ActionScript `Microphone` API返回的样本数据，我们可以收集有关正在捕获的声音的许多信息，并在我们的应用程序内执行响应。这种输入可以用于实用程序、学习模块，甚至游戏。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will set up an event listener to respond to sample data reported through
    the `Microphone` API:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个事件监听器，以响应通过`Microphone` API报告的样本数据：
- en: 'First, import the following classes into your project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device. A `Microphone` object must also be declared for this example:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象对，以允许在设备上可见输出。本示例还需要声明一个`Microphone`对象：
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置`TextField`，应用`TextFormat`，并将`TextField`添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we must instantiate our `Microphone` object and set it up according to
    our needs and preferences with adjustments to `codec, rate, silenceLevel`, and
    so forth. Here we use `setSilenceLevel()` to determine what the minimum input
    level our application should consider to be "sound" and the `rate` property is
    set to **44**, indicating that we will capture audio data at a rate of 44kHz.
    Setting the `setLoopBack ()` property to false will keep the captured audio from
    being routed through the device speaker:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须实例化我们的`Microphone`对象，并根据我们的需求和偏好调整`codec, rate, silenceLevel`等来设置它。这里我们使用`setSilenceLevel()`来确定应用程序应视为“声音”的最小输入水平，并将`rate`属性设置为**44**，表示我们将以44kHz的速率捕获音频数据。将`setLoopBack()`属性设置为false将防止捕获的音频通过设备扬声器播放：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have instantiated our `Microphone` object, we can then register a variety
    of event listeners. In this example, we''ll be monitoring audio sample data from
    the device microphone, so we will need to register our listener for the `SampleDataEvent.SAMPLE_DATA`
    constant:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们实例化了`Microphone`对象，我们就可以注册各种事件监听器。在这个例子中，我们将监控来自设备麦克风的音频采样数据，因此我们需要为`SampleDataEvent.SAMPLE_DATA`常量注册我们的监听器：
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the `Microphone` API generates sample data from the Android device input,
    we can now respond to this in a number of ways, as we have access to information
    about the `Microphoneobject` itself, and more importantly, we have access to the
    sample bytes with which we can perform a number of advanced operations:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Microphone` API从Android设备输入生成采样数据，我们现在可以通过多种方式对此做出响应，因为我们能够访问有关`Microphone`对象本身的信息，更重要的是，我们可以访问采样字节，从而执行许多高级操作：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output will look something like this. The first three values are taken from
    the `Microphone` itself, the second three from `Microphone` sample data:![How
    to do it...](img/1420_04_08.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将类似于这样。前三个值来自`Microphone`本身，后三个来自`Microphone`采样数据：![如何操作...](img/1420_04_08.jpg)
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we instantiate a `Microphone` object and register a `SampleDataEvent.SAMPLE_DATA`
    event listener, we can easily monitor various properties of our Android device
    microphone and the associated sample data being gathered. We can then respond
    to that data in many ways. One example would be to move objects across the `Stage`
    based upon the `Microphone.activityLevel` property. Another example would be to
    write the sample data to a `ByteArray` for later analysis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个`Microphone`对象并注册一个`SampleDataEvent.SAMPLE_DATA`事件监听器时，我们可以轻松监控Android设备麦克风的各项属性以及正在收集的相关采样数据。然后我们可以以多种方式对这些数据做出响应。一个例子是依据`Microphone.activityLevel`属性在`Stage`上移动对象。另一个例子是将采样数据写入`ByteArray`以便稍后分析。
- en: What do all these properties mean?
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有这些属性意味着什么？
- en: '`activityLevel:` This is a measurement indicating the amount of sound being
    received'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activityLevel:` 这是一个表示接收到的声音量的测量值'
- en: '`codec:` This indicates the codec being used: Nellymoser or Speex'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codec:` 这表示正在使用的编解码器：Nellymoser或Speex'
- en: '`gain:` This is an amount of boosting provided by the microphone to the sound
    signal'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gain:` 这是麦克风为声音信号提供的增强量'
- en: '`bytesAvailable:` This reveals the number of bytes from the present position
    until the end of our sample data `byteArray`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytesAvailable:` 这揭示了从当前位置到采样数据`byteArray`末尾的字节数量'
- en: '`length:` Lets us know the total length of our sample data `byteArray`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length:` 让我们知道采样数据`byteArray`的总长度'
- en: '`position:` This is the current position, in bytes, within our sample data
    `byteArray`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position:` 这是我们的采样数据`byteArray`中的当前位置，以字节为单位'
- en: See also...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'In order to access the microphone, we will need to add some Android permissions
    for `RECORD_AUDIO`. Refer to [Chapter 11](ch11.html "Chapter 11. Final Considerations:
    Application Compilation and Distribution") for information on how to go about
    this.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问麦克风，我们需要添加一些Android权限以`RECORD_AUDIO`。有关如何进行此操作的信息，请参考[第11章](ch11.html "第11章.最后的考虑：应用程序编译和分发")。
- en: Recording Microphone Audio Sample Data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录麦克风音频采样数据
- en: One of the most fundamental things a developer would want to be able to do with
    audio sample data gathered from an Android microphone, would be to capture the
    data and use it in some way within an application. This recipe will demonstrate
    how to preserve and play back captured microphone audio sample data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，使用从Android麦克风收集的音频采样数据最基础的事情之一，就是捕获数据并在应用程序中以某种方式使用它。本教程将演示如何保存和回放捕获的麦克风音频采样数据。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will employ an event listener to respond to sample data reported through
    the `Microphone` API by writing captured audio data to a `ByteArray` and then
    playing it back internally through the `Sound` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个事件监听器来响应通过`Microphone` API报告的样本数据，通过将捕获的音频数据写入`ByteArray`，然后通过`Sound`对象在内部播放：
- en: 'First, import the following classes into your project:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device. A `Microphone` object must also be declared for this example.
    To store and play back the sample data, we will need to declare a `ByteArray`,
    along with a `Sound` and `SoundChannel` pair:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象对，以便在设备上输出可见内容。这个例子还需要声明一个`Microphone`对象。为了存储和播放样本数据，我们还需要声明一个`ByteArray`，以及一个`Sound`和`SoundChannel`对：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置`TextField`，应用`TextFormat`，并将`TextField`添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, instantiate a `Microphone` object and set it up according to our needs
    and preferences with adjustments to `codec, rate, silenceLevel`, and so forth.
    Here we use `setSilenceLevel()` to determine what the minimum input level our
    application should consider to be "sound" and the `rate` property is set to **44**,
    indicating that we will capture audio data at a rate of 44kHz. Setting the `setLoopBack
    ()` property to false will keep the captured audio from being routed through the
    device speaker. We''ll also instantiate a `ByteArray` to hold all of our audio
    samples as they are intercepted:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实例化一个`Microphone`对象，并根据我们的需求和偏好调整`codec`、`rate`、`silenceLevel`等来设置它。这里我们使用`setSilenceLevel()`来确定应用程序应考虑的最小输入级别作为“声音”，并将`rate`属性设置为**44**，表示我们将以44kHz的速率捕获音频数据。将`setLoopBack()`属性设置为false将防止捕获的音频通过设备扬声器播放。我们还将实例化一个`ByteArray`来保存所有拦截到的音频样本：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we have instantiated our `Microphone` and `ByteArray` objects, we can
    then register an event listener to enable touch interactions. A simple tap will
    suffice:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们实例化了`Microphone`和`ByteArray`对象，我们就可以注册一个事件监听器来启用触摸交互。一个简单的轻触就足够了：
- en: '[PRE34]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once recording has been invoked by the user, we''ll be monitoring audio sample
    data from the device microphone, so will need to register our listener for the
    `SampleDataEvent.SAMPLE_DATA` constant:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户启动录音，我们将监控来自设备麦克风的音频样本数据，因此需要为`SampleDataEvent.SAMPLE_DATA`常量注册我们的监听器：
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As the `Microphone` API generates sample data from the Android device input,
    we have access to the audio sample data bytes, which we can write to a `ByteArray`
    for later use:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Microphone` API从Android设备输入生成样本数据，我们可以访问音频样本数据字节，我们可以将其写入`ByteArray`以供以后使用：
- en: '[PRE36]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To stop recording, we will need to remove the `SampleDataEvent.SAMPLE_DATA`
    event listener from our `Microphone` object:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止录音，我们需要从`Microphone`对象中移除`SampleDataEvent.SAMPLE_DATA`事件监听器：
- en: '[PRE37]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To prepare for playback, we will instantiate a new `Sound` object and register
    a `SampleDataEvent.SAMPLE_DATA` event upon it just as we had done for the `Microphone`
    object previously. We will also instantiate a `SoundChannel` object and invoke
    the `play()` method of our `Sound` object to play back the captured `Microphone`
    audio:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了准备播放，我们将实例化一个新的`Sound`对象，并在其上注册一个`SampleDataEvent.SAMPLE_DATA`事件，就像我们之前对`Microphone`对象所做的那样。我们还将实例化一个`SoundChannel`对象，并调用我们`Sound`对象的`play()`方法来播放捕获的`Microphone`音频：
- en: '[PRE38]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once we invoke the `play()` method upon our `Sound` object, it will begin gathering
    generated sample data from a method called `onSampleDataRequest`. We need to create
    this method now, and allow it to loop over the bytes we previously wrote to our
    `ByteArray` object. This is, effectively, the inverse of our capture process.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们对`Sound`对象调用`play()`方法时，它将从名为`onSampleDataRequest`的方法中开始收集生成的样本数据。我们现在需要创建这个方法，并让它遍历我们之前写入`ByteArray`对象的字节，这实际上是我们的捕获过程的反操作。
- en: In order to provide proper playback within our application we must provide between
    2048 and 8192 samples of data. It is recommended to use as many samples as possible,
    but this will also depend upon the sample frequency.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在应用程序中提供适当的播放，我们必须提供2048到8192个样本数据。建议尽可能使用更多的样本，但这还取决于采样频率。
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we invoke `writeFloat()` twice within the same loop because we need
    our data expressed in stereo pairs, one for each channel.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们在同一个循环中两次调用`writeFloat()`，因为我们需要将数据表示为立体声对，每个通道一个。
- en: 'When using `writeBytes()` in this example, we are actually channeling sound
    data back out through our `SampleDataEvent` and through a `Sound` object, thus
    enabling the application to produce sound:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中使用 `writeBytes()` 时，我们实际上是通过 `SampleDataEvent` 和 `Sound` 对象将声音数据输出，从而使应用程序能够产生声音：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Output to our `TextField` will change depending upon the current application
    state:![How to do it...](img/1420_04_09.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出到我们的 `TextField` 的内容将根据当前应用程序状态的变化而变化：![如何操作...](img/1420_04_09.jpg)
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we instantiate a `Microphone` object and register a `SampleDataEvent.SAMPLE_DATA`
    event listener, we can easily monitor the associated sample data being gathered
    and write this data to a `ByteArray` for later playback. As new samples come in,
    more data is added to the `ByteArray`, building up the sound data over time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个 `Microphone` 对象并注册一个 `SampleDataEvent.SAMPLE_DATA` 事件监听器时，我们可以轻松监控相关样本数据的收集，并将这些数据写入
    `ByteArray` 以便稍后播放。随着新样本的到来，更多的数据被添加到 `ByteArray` 中，随着时间的推移构建声音数据。
- en: By registering a `SampleDataEvent.SAMPLE_DATA` event listener to a `Sound` object,
    we instruct it to actively seek audio data generated from a specific method as
    soon as we invoke `play()`. In our example, we move through the constructed `ByteArray`
    and send audio data back out through this method, effectively playing back the
    recorded audio through the `Sound` object and associated `SoundChannel`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 `Sound` 对象注册 `SampleDataEvent.SAMPLE_DATA` 事件监听器，我们指示它在我们调用 `play()` 时主动寻找由特定方法生成的音频数据。在我们的示例中，我们遍历构建的
    `ByteArray`并通过此方法将音频数据输出，通过 `Sound` 对象和相关联的 `SoundChannel` 实际播放录制的音频。
- en: See also...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: The use of bytes within ActionScript is a complex subject. To read more about
    this topic, we recommend Thibault Imbert's book *"What can you do with bytes?"*,
    which is freely available from [http://www.bytearray.org/?p=711](http://www.bytearray.org/?p=711).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ActionScript 中字节的使用是一个复杂的主题。要了解更多关于这个话题的信息，我们推荐Thibault Imbert的书 *"你能用字节做什么？"*，该书可在[http://www.bytearray.org/?p=711](http://www.bytearray.org/?p=711)免费获取。
- en: 'To read recipes concerning the playback of audio files, have a look at [Chapter
    5](ch05.html "Chapter 5. Rich Media Presentation: Working with Images, Video,
    and Audio"). For information on saving captured audio data to the Android device,
    refer to [Chapter 8:](ch08.html "Chapter 8. Abundant Access: File System and Local
    Database") *Abundant Access: File System and Local Database.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 想要阅读关于音频文件播放的配方，请查看[第5章](ch05.html "第5章.富媒体展示：处理图像、视频和音频")。有关将捕获的音频数据保存到Android设备的信息，请参考[第8章：](ch08.html
    "第8章.丰富访问：文件系统和本地数据库") *丰富访问：文件系统和本地数据库*。
