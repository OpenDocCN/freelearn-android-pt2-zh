- en: Chapter 5. Form-filling Dialogs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 表单填写对话
- en: Many speech-enabled apps use one-shot dialogs like the ones described in the
    previous chapter. Do you feel that speech interfaces can go further than that?
    Can you imagine more complex interactions in which several items of information
    have to be elicited from the user for a wide variety of purposes, for example,
    to launch apps, query databases, start web services or web services mashups, and
    a lot more?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多启用语音的应用程序使用前一章描述的一键式对话。你觉得语音界面可以比这走得更远吗？你能想象更复杂的交互，其中需要从用户那里获取多个信息项，用于各种目的，例如启动应用程序、查询数据库、启动网络服务或网络服务混搭，以及更多？
- en: These types of dialog are similar to form-filling in a traditional web application.
    By the end of this chapter you should be able to implement simple form-filling
    dialogs in order to obtain the data necessary to access a web service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这类对话与传统的网络应用程序中的表单填写相似。在本章结束时，你应该能够实现简单的表单填写对话，以便获取访问网络服务所需的数据。
- en: Form-filling dialogs
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单填写对话
- en: 'A form-filling dialog can be seen in terms of a number of slots to be filled.
    For example, in the case of a flight booking app, the system may have to fill
    five slots: destination, arrival date, arrival time, departure date, and departure
    time. In a simple form-filling dialog each slot is processed one at a time and
    the relevant questions are asked until all the slots have been filled. At that
    point the app can look up the required flight and present the results to the user.
    The following is an example of how a dialog might proceed and how status of the
    slots changes as the dialog progresses.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表单填写对话可以看作是多个待填写的槽位。例如，在航班预订应用程序的情况下，系统可能需要填写五个槽位：目的地、到达日期、到达时间、出发日期和出发时间。在简单的表单填写对话中，每个槽位逐一处理，并提出相关问题，直到所有槽位都被填写。此时，应用程序可以查找所需的航班，并将结果呈现给用户。以下是一个对话可能进行的方式的示例，以及对话进行时槽位状态的变化。
- en: 'App: Welcome to the Flight Information Service. Where would you like to travel
    to?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序：欢迎来到航班信息服务。你想要去哪里旅行？
- en: 'Caller: London.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通话者：伦敦。
- en: '| Slot | Destination | Arrival date | Arrival time | Departure date | Departure
    time |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|槽位|目的地|到达日期|到达时间|出发日期|出发时间|'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|---|---|---|---|---|---|'
- en: '| Value | London | unknown | unknown | unknown | unknown |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|值|伦敦|未知|未知|未知|未知|'
- en: 'App: What date would you like to fly to London?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序：你想要哪一天飞往伦敦？
- en: 'Caller: The 10th of July.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通话者：7月10日。
- en: '| Slot | Destination | Arrival date | Arrival time | Departure date | Departure
    time |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|槽位|目的地|到达日期|到达时间|出发日期|出发时间|'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|---|---|---|---|---|---|'
- en: '| Value | London | 07/10/2013 | unknown | unknown | unknown |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|值|伦敦|07/10/2013|未知|未知|未知|'
- en: Frames can also have conditions attached to the slots, for example, if it is
    a return journey, then values would also be required for the slots of the return
    leg.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的槽位也可以附加条件，例如，如果是往返旅程，那么还需要填写返回旅程的槽位值。
- en: 'In a more complex dialog the user can fill more than one slot at a time, as
    in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的对话中，用户可以一次填写多个槽位，如下面的示例所示：
- en: 'App: Welcome to the Flight Information Service. Where would you like to travel
    to?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序：欢迎来到航班信息服务。你想要去哪里旅行？
- en: 'Caller: I would like to fly to London on Friday.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通话者：我想在周五飞往伦敦。
- en: '| Slot | Destination | Arrival date | Arrival time | Departure date | Departure
    time |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|槽位|目的地|到达日期|到达时间|出发日期|出发时间|'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|---|---|---|---|---|---|'
- en: '| Value | London | 21/06/2013 | unknown | unknown | unknown |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|值|伦敦|21/06/2013|未知|未知|未知|'
- en: As the user has already provided the arrival date in response to the destination
    question, that slot can be filled and the system can skip the arrival question.
    However, to process the caller's input in this example more complicated grammars
    would be required, as discussed in [Chapter 6](ch06.html "Chapter 6. Grammars
    for Dialog"), *Grammars for Dialog*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户在回答目的地问题时已经提供了到达日期，因此可以填写该槽位，系统可以跳过到达时间的问题。然而，为了处理本例中通话者的输入，需要更复杂的语法，如[第6章](ch06.html
    "第6章. 对话语法")中讨论的*对话语法*。
- en: Implementing form-filling dialogs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现表单填写对话
- en: 'In order to implement form-filling dialogs it is necessary to:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现表单填写对话，需要：
- en: Create a data structure to represent the slots that will hold the information
    that the system has to elicit from the user.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个数据结构来表示系统必须从用户那里获取信息的槽位。
- en: Develop an algorithm to process the slots, extracting the required prompts for
    each of them.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个算法来处理槽位，提取每个槽位所需的提示语。
- en: 'VoiceXML ([http://www.w3.org/TR/voicexml20/](http://www.w3.org/TR/voicexml20/))
    provides a useful structure for this task in terms of forms containing fields
    that represent the different items of information (slots) required to complete
    the form. The following code is an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: VoiceXML（[http://www.w3.org/TR/voicexml20/](http://www.w3.org/TR/voicexml20/)）为这项任务提供了一个有用的结构，即包含表示完成表单所需不同信息项（槽位）的表单字段。以下代码是一个示例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding example shows an app that asks for two pieces of information:
    destination and date. To ask for destination, it uses the prompt `where would
    you like to travel to?`, and to ask for the date it synthesizes `what day would
    you like to travel?`. Each piece of data is acquired sequentially by reprompting
    the user until all the information is collected. In VoiceXML this is done using
    the **Form Interpretation Algorithm** (**FIA**) which is further described in
    [http://www.w3.org/TR/voicexml20/#dml2.1.6](http://www.w3.org/TR/voicexml20/#dml2.1.6).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了一个应用，该应用需要获取两项信息：目的地和日期。为了询问目的地，它使用了提示语 `where would you like to travel
    to?`，而询问日期时，它合成了 `what day would you like to travel?`。每一条数据都是通过重复提示用户直到收集完所有信息的方式来顺序获取的。在VoiceXML中，这是通过使用**表单解释算法**（**FIA**）完成的，具体描述见[http://www.w3.org/TR/voicexml20/#dml2.1.6](http://www.w3.org/TR/voicexml20/#dml2.1.6)。
- en: While implementing a complete VoiceXML approach to form-filling is beyond the
    scope of this book, in the remainder of this chapter we will show how to create
    a simple form-filling app that makes use of a similar data structure and algorithm.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本书中完全实现VoiceXML表单填充的方法超出了范围，但在本章的剩余部分，我们将展示如何创建一个简单的表单填充应用，该应用使用了类似的数据结构和算法。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**You can also try…**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**你也可以尝试…**'
- en: You can create your own VoiceXML dialogs using **Voxeo Evolution** ([http://evolution.voxeo.com/](http://evolution.voxeo.com/)).
    You can sign up for a free developer account and then you will be able to create
    your own VoiceXML applications that will be assigned a Skype number that you can
    use to interact with them. Note that this is not directly useful for Android applications
    but will provide insight into VoiceXML and how it works as a dialog scripting
    language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Voxeo Evolution**（[http://evolution.voxeo.com/](http://evolution.voxeo.com/)）来创建自己的VoiceXML对话。你可以注册一个免费的开发者账户，然后你就可以创建自己的VoiceXML应用，并将分配一个Skype号码，你可以使用它与应用互动。请注意，这对于Android应用来说并不直接有用，但可以让你了解VoiceXML以及它作为对话脚本语言是如何工作的。
- en: 'You might also wish to investigate the use of JVoiceXML ([http://jvoicexml.sourceforge.net/](http://jvoicexml.sourceforge.net/))
    to build a complete VoiceXML parser in Java. The code for an initial implementation
    for android can be found here: [http://sourceforge.net/p/jvoicexml/code/HEAD/tree/branches/android/](http://sourceforge.net/p/jvoicexml/code/HEAD/tree/branches/android/)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想研究使用JVoiceXML（[http://jvoicexml.sourceforge.net/](http://jvoicexml.sourceforge.net/)）来构建一个完整的Java
    VoiceXML解析器。针对Android的初步实现代码可以在这里找到：[http://sourceforge.net/p/jvoicexml/code/HEAD/tree/branches/android/](http://sourceforge.net/p/jvoicexml/code/HEAD/tree/branches/android/)。
- en: Threading
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程处理
- en: We will use XML files for various purposes in the remaining chapters and have
    encapsulated the common code in the `XMLLib` library. One important issue involves
    threading. When launching an app, a thread is created to run the code. This thread
    is responsible for the actions that involve updating the user interface, so it
    is sometimes called the **UI thread**. Carrying out very expensive operations
    in the UI thread, such as downloading files, carrying out HTTP requests, opening
    socket connections, or accessing databases, might block the UI thread for a long
    time, making it unresponsive and freezing updates of the interface. For this reason
    from Android 3 (HoneyComb) onwards, when trying to perform a networking operation
    on the main thread of an Android app, the `android.os.NetworkOnMainThreadException`
    is raised.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余章节中，我们将出于各种目的使用XML文件，并将公共代码封装在`XMLLib`库中。一个重要的问题涉及到线程处理。启动应用时，会创建一个线程来运行代码。这个线程负责涉及更新用户界面的操作，因此有时被称为**UI线程**。在UI线程中执行非常耗时的操作，如下载文件、执行HTTP请求、打开套接字连接或访问数据库，可能会使UI线程长时间阻塞，导致界面无响应并冻结更新。因此，从Android
    3（HoneyComb）开始，当尝试在Android应用的 主线程上执行网络操作时，会引发`android.os.NetworkOnMainThreadException`异常。
- en: 'Android provides several ways to enable communication between background threads
    and the UI thread as explained here: [http://developer.android.com/guide/components/processes-and-threads.html](http://developer.android.com/guide/components/processes-and-threads.html)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了多种方法来实现后台线程与UI线程之间的通信，具体解释请参见：[http://developer.android.com/guide/components/processes-and-threads.html](http://developer.android.com/guide/components/processes-and-threads.html)
- en: 'One of the alternatives is to use an asynchronous task (`AsyncTask`). The `AsyncTask`
    runs all the time-consuming operations in the background and publishes the results
    in the UI thread. The documentation for `AsyncTask` can be found here: [http://developer.android.com/reference/android/os/AsyncTask.html](http://developer.android.com/reference/android/os/AsyncTask.html)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是使用异步任务（`AsyncTask`）。`AsyncTask`始终在后台运行耗时的操作，并在UI线程中发布结果。关于`AsyncTask`的文档可以在这里找到：[http://developer.android.com/reference/android/os/AsyncTask.html](http://developer.android.com/reference/android/os/AsyncTask.html)
- en: 'In short, when an asynchronous task is executed it undergoes four stages which
    can be controlled with the methods: `onPreExecute` before the task is executed,
    `doInBackground` that performs the background computation right after `onPreExecute`,
    `onProgressUpdate` that displays the progress of the operation (for example, in
    a progress bar in the user interface), and `onPostExecute`, that is invoked when
    the background computation is finished.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当执行异步任务时，它会经历四个阶段，可以通过以下方法进行控制：`onPreExecute`在任务执行之前，`doInBackground`在`onPreExecute`之后立即执行后台计算，`onProgressUpdate`显示操作进度（例如，在用户界面中的进度条），以及`onPostExecute`，当后台计算完成时调用。
- en: XMLLib
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMLLib
- en: 'In our library (`sandra.libs.util.xmllib` in the code bundle), the `RetrieveXMLTask`
    (see `RetrieveXMLTask.java`) is responsible for fetching an XML file from the
    web and saving its content in a String to be further processed. It is declared
    in the following way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的库中（代码包中的`sandra.libs.util.xmllib`），`RetrieveXMLTask`（见`RetrieveXMLTask.java`）负责从网上获取XML文件并将其内容保存为字符串以供进一步处理。它是以下列方式声明的：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It has been defined as an asynchronous task (`AsyncTask`) that receives a collection
    of Strings as input parameters. It does not produce any type of progress values
    (void), and produces a String as a result of the background computation (<parameters,
    progress, result>). In our case, the String input is the URL to retrieve the XML
    file, and the String result is the XML code in the file. The reading of the XML
    file from the specified URL is done as a background task in the `doInBackground`
    method that uses other private methods that open the HTTP connection and read
    the byte streams (`saveXmlInString` and `readStream`). Take a look at the `doInBackground`
    and `saveXMLInString` methods in the code bundle (`XMLLib` project, `RetrieveXMLTask.java`).
    There is a nice tutorial on how to make an asynchronous HTTP request at: [http://mobiledevtuts.com/android/android-http-with-asynctask-example/](http://mobiledevtuts.com/android/android-http-with-asynctask-example/)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它被定义为一个异步任务（`AsyncTask`），接收一个字符串集合作为输入参数。它不产生任何类型的进度值（void），并以字符串形式产生后台计算的结果（<parameters,
    progress, result>）。在我们的案例中，字符串输入是获取XML文件的URL，字符串结果是文件中的XML代码。从指定URL读取XML文件作为`doInBackground`方法中的后台任务，该方法使用其他私有方法来打开HTTP连接和读取字节流（`saveXmlInString`和`readStream`）。查看代码包中的`doInBackground`和`saveXMLInString`方法（`XMLLib`项目，`RetrieveXMLTask.java`）。这里有一个关于如何进行异步HTTP请求的好教程：[http://mobiledevtuts.com/android/android-http-with-asynctask-example/](http://mobiledevtuts.com/android/android-http-with-asynctask-example/)
- en: As it can be observed, the management of exceptions in `RetrieveXMLTask` is
    carried out in a special way, as there is an attribute called `exception` that
    is used to save the possible exceptions raised during the connection or reading
    operations (the `doInBackground` method). The management of such exceptions is
    carried out once the asynchronous task is completed (in the `onPostExecute` method).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，`RetrieveXMLTask`中的异常处理以一种特殊的方式进行，因为有一个名为`exception`的属性，用于保存连接或读取操作（`doInBackground`方法）期间可能引发的异常。一旦异步任务完成（在`onPostExecute`方法中），就会处理此类异常。
- en: 'Once the background task is finished, we need to provide our results back to
    the calling class using the `onPostExecute` method. In order to do so, we define
    the interface `XML AsyncResponse` (see `XML AsyncResponse.java`) with the abstract
    method `processXMLContents`. The idea is that the class that invokes the asynchronous
    task implements the interface providing the code for the `processXMLContents`
    method, and `onPostExecute` delegates the processing of the output to this method
    (see the `onPostExecute` method in the code bundle: `sandra.libs.util.xmllib.RetrieveXMLTask`).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦后台任务完成，我们需要使用`onPostExecute`方法将结果返回给调用类。为此，我们定义了接口`XML AsyncResponse`（见`XML
    AsyncResponse.java`），其中包含抽象方法`processXMLContents`。这个想法是调用异步任务的类实现该接口，并提供`processXMLContents`方法的代码，而`onPostExecute`将输出处理委托给此方法（见代码包中的`onPostExecute`方法：`sandra.libs.util.xmllib.RetrieveXMLTask`）。
- en: FormFillLib
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单填充库
- en: 'To build a form-filling app, we must specify a data structure such as the one
    in the flight example. To do this, we define two classes: `Form` and `Field`.
    As shown in the UML diagram, a `Form` has a collection of Fields, and a `Field`
    has five attributes; a name, a string representing the prompt that the app will
    use to ask for the piece of data, two strings representing the prompts to be used
    when the app does not understand the user''s response to the initial prompt (`nomatch`),
    or does not hear it (`noinput`), and the value that has been understood by the
    app.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个表单填充应用程序，我们必须指定一个类似于飞行示例中的数据结构。为此，我们定义了两个类：`Form`和`Field`。如UML图所示，`Form`拥有字段集合，而`Field`具有五个属性：一个名称，一个表示应用程序将用于请求该数据片段的提示字符串，以及两个表示当应用程序不理解用户对初始提示的响应（`nomatch`）或听不到（`noinput`）时使用的提示字符串，以及应用程序理解的值。
- en: '![FormFillLib](img/5297OS_05_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![FormFillLib](img/5297OS_05_01.jpg)'
- en: 'For example, the `Field` flight setting could have the following values for
    its attributes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Field`飞行设置可能为其属性具有以下值：
- en: '**name:** **Destination**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**name:** **目的地**'
- en: '**prompt:** **What is your destination?**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**prompt:** **你的目的地是哪里？**'
- en: '**nomatch:** **Sorry, I did not understand what you said**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**nomatch:** **抱歉，我没理解你说的话**'
- en: '**noinput:** **Sorry, I could not hear you**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**noinput:** **抱歉，我听不到你的声音**'
- en: '**value:** **Rome** (when the user has said **Rome** in response to the system
    prompt)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**value:** **罗马**（当用户对系统提示回答**罗马**时）'
- en: This structure will suffice to build an app of the type we are discussing in
    this chapter. It is only necessary to create as many objects of the `Field` class
    as slots to be filled, and a `Form` that contains a collection of the fields in
    the desired order. This can be easily done programmatically in Java, however it
    is not very reader-friendly and it is difficult for the programmer to change some
    parameters like the system prompts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构足以构建我们本章讨论类型的程序。只需创建与待填充槽位数量相等的`Field`类对象，以及一个包含所需字段集合的`Form`。这可以通过Java编程轻松实现，然而它对读者不太友好，程序员也很难更改一些如系统提示之类的参数。
- en: To solve this, we will implement a subset of the VoiceXML standard to create
    easy-to-read XML files containing the structure of the dialog. Then, we will use
    the `VXMLParser` class to automatically parse the XML files and translate them
    into objects for the `Field` and `Form` classes. Finally, a `DialogInterpretation`
    class will use these objects to manage the interaction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决此问题，我们将实现VoiceXML标准的一个子集，以创建易于阅读的XML文件，其中包含对话的结构。然后，我们将使用`VXMLParser`类自动解析XML文件，并将它们转换为`Field`和`Form`类的对象。最后，`DialogInterpretation`类将使用这些对象来管理交互。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This does not make the VoiceXML design completely independent from the app.
    The apps need to know which pieces of information it is necessary to process and
    these are indicated as fields in the VoiceXML file. Thus, the developer can change
    anything in the VoiceXML except for the number and name of the fields.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着VoiceXML设计完全独立于应用程序。应用程序需要知道哪些信息需要处理，这些信息在VoiceXML文件中作为字段指出。因此，开发者可以更改VoiceXML中的任何内容，除了字段的数量和名称。
- en: VXMLParser
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VXML解析器
- en: There are different ways to implement parsers in Android, mainly using DOM,
    SAX, or a Pull parser. Android recommends the use of the `XMLPullParser` class
    ([http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html)),
    as it has been designed for better performance and simplicity. XML pull parsing
    allows streaming parsing, where the process can be interrupted and resumed at
    any time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中实现解析器有不同的方法，主要是使用DOM、SAX或Pull解析器。Android推荐使用`XMLPullParser`类（[http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html](http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html)），因为它设计得更为高效和简单。XML的Pull解析允许流式解析，处理过程可以随时中断和恢复。
- en: In order to parse VXML files, we create an `XMLPullParser` to read the XML contents,
    and repeatedly invoke the method `next()` to retrieve the next event, until the
    event is `END_DOCUMENT`. This way, we process the `START_TAG`, `TEXT`, and `END_TAG`
    events to respectively manage the situations in which the system encounters a
    starting tag, processes the text inside a tag, or encounters a closing tag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析VXML文件，我们创建了一个`XMLPullParser`来读取XML内容，并不断调用`next()`方法来获取下一个事件，直到事件为`END_DOCUMENT`。这样，我们处理`START_TAG`、`TEXT`和`END_TAG`事件，分别对应系统遇到开始标签、处理标签内的文本或遇到结束标签的情况。
- en: We create a new `Form` object when the system encounters the <form> tag. As
    the idea of the parser is to process a single form, if there were several forms
    in the file, we would only keep track of the last one. This is done by keeping
    only one instance of the `Form` class as an attribute of the `VXMLParser` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统遇到<form>标签时，我们会创建一个新的`Form`对象。由于解析器的理念是处理单个表单，如果文件中有多个表单，我们只跟踪最后一个。这是通过将`Form`类的实例作为`VXMLParser`类的一个属性来实现的。
- en: With respect to fields, their names are extracted by parsing the attributes
    of the <field> tag. Then, we also save the information about the `prompt`, `nomatch`,
    and `noinput` prompts when their corresponding VoiceXML tags are encountered.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字段，它们的名称是通过解析<field>标签的属性提取的。然后，当遇到相应的VoiceXML标签时，我们也会保存关于`prompt`、`nomatch`和`noinput`提示的信息。
- en: Any class using the VoiceXML parser can invoke the `parseVXML` method (see `sandra.libs.dm.fomfilllib.VXMLParser`)
    to obtain the form created when parsing the data. The parser employs the `FormFillLibException`
    class in order to carry out a more fine-grained control of exceptions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用VoiceXML解析器的类都可以调用`parseVXML`方法（见`sandra.libs.dm.fomfilllib.VXMLParser`），以获取解析数据时创建的表单。解析器使用`FormFillLibException`类，以便对异常进行更细粒度的控制。
- en: DialogInterpreter
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DialogInterpreter
- en: 'The `DialogInterpreter` resembles the FIA algorithm in VoiceXML. It visits
    all the fields in sequential order until the app obtains a speech recognition
    result for each of them. In each field, it synthesizes the prompt and listens
    for the user input. If speech recognition is successful, then it moves to the
    next field, if not, the system repeats the process for the current field. The
    following pseudo code describes the interpreter behavior:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogInterpreter`类似于VoiceXML中的FIA算法。它按顺序访问所有字段，直到应用程序为每个字段获取语音识别结果。在每个字段中，它合成提示并监听用户输入。如果语音识别成功，则移动到下一个字段；如果失败，系统将重复当前字段的过程。以下伪代码描述了解释器的行为：'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The behavior described in the pseudo code is developed in the `DialogInterpreter`
    class. This class uses different attributes to control the interpretation: the
    `Form` that must be interpreted, an integer `currentPosition` that represents
    the position of the field that must be interpreted in the list of the form''s
    fields, two strings with prompts for the `nomatch` and `noinput` events (that
    will be replaced by the ones parsed from the VoiceXML file if there are any available),
    and a `HashMap` that contains the results of the interpretation in the form of
    pairs of strings <field name, field value>.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码中描述的行为在`DialogInterpreter`类中开发。这个类使用不同的属性来控制解释：必须解释的`Form`、表示字段在表单字段列表中位置的整型`currentPosition`、两个用于`nomatch`和`noinput`事件的提示字符串（如果VoiceXML文件中有可用的，则会被解析出来的标签替换），以及包含解释结果的`HashMap`，形式为字符串对<字段名,
    字段值>。
- en: 'Interpretation starts when the `startInterpreting` method is invoked. The form
    to be interpreted is provided, the `currentPosition` is initialized to 0 and the
    `interpretCurrentField` is invoked. The `interpretCurrentField` method does not
    encapsulate all the behavior shown in the pseudocode for `interpret field i`,
    as it is necessary to use different methods to control the various ASR events.
    Thus, `interpretCurrentField` only controls the first part: it plays the field
    prompt and starts ASR. Then, the methods `processAsrResults` and `processAsrErrors`
    from `ASRLib` are used to account for the different events. The former controls
    the case in which the ASR understands something from the user''s input, saves
    its value in the `Hashmap` of results and invokes the `moveToNextField` method.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `startInterpreting` 方法时开始解释。要解释的表单被提供，`currentPosition` 初始化为 0，并调用 `interpretCurrentField`。`interpretCurrentField`
    方法没有封装 `interpret field i` 伪代码中显示的所有行为，因为需要使用不同的方法来控制各种 ASR 事件。因此，`interpretCurrentField`
    只控制第一部分：播放字段提示并启动 ASR。然后，使用 `ASRLib` 中的 `processAsrResults` 和 `processAsrErrors`
    方法来处理不同的事件。前者控制 ASR 从用户输入中理解到内容的情况，将其值保存在结果 `Hashmap` 中，并调用 `moveToNextField`
    方法。
- en: The latter controls the case in which there is an error in ASR, if the error
    code is `ERROR_NO_MATCH` or `ERROR_SPEECH_TIMEOUT` (`nomatch` or `noinput`), the
    corresponding prompts are synthetized and the field is interpreted again. If the
    error is due to network problems, the interpretation is stopped. You can take
    a look at this method in the code bundle (`sandra.libs.dm.formfilllib.DialogInterpreter`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 后者控制 ASR 出错的情况，如果错误代码是 `ERROR_NO_MATCH` 或 `ERROR_SPEECH_TIMEOUT`（`nomatch` 或
    `noinput`），将合成相应的提示并重新解释字段。如果错误是由于网络问题，则停止解释。你可以在代码包中的 `sandra.libs.dm.formfilllib.DialogInterpreter`
    查看这个方法。
- en: 'The `moveToNextField` method is similar to the pseudocode shown earlier: it
    moves the position of the current field forward while the field does not have
    a value. If there is a field without a value, it is interpreted, if there are
    no more fields to interpret, the interpretation is finished and the `processDialogResults`
    method is invoked.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToNextField` 方法与之前显示的伪代码类似：当字段没有值时，它会向前移动当前字段的位置。如果存在没有值的字段，它将被解释；如果没有更多字段需要解释，则解释完成并调用
    `processDialogResults` 方法。'
- en: The `processDialogResults` method is abstract so that any subclass of `DialogInterpreter`
    can provide its own code to process the results of the interpretation. In the
    next section, we will show an app that uses the `FormFillLib` library and implements
    this method to use the results of the dialog to invoke a web service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`processDialogResults` 方法是抽象的，这样任何 `DialogInterpreter` 的子类都可以提供自己的代码来处理解释的结果。在下一节中，我们将展示一个使用
    `FormFillLib` 库并实现此方法的应用程序，以使用对话结果调用网络服务。'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**You can also try…**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**你也可以尝试…**'
- en: 'Another interesting alternative is to code the structure of the dialog in different
    data structures in the Java code. This is the approach followed in the *Pizza
    Ordering App* example (Chapter 15) from Deitel, P., Deitel, H., Deitel, A. and
    Morgano, M., *Android for Programmers: An App-Driven Approach*, Prentice Hall
    2011, which you can find here: [http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/bookreg/9780132121361/android_15_speech_final_a.pdf](http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/bookreg/9780132121361/android_15_speech_final_a.pdf).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个有趣的选择是在 Java 代码中用不同的数据结构编写对话的结构。这是 Deitel, P., Deitel, H., Deitel, A. 和
    Morgano, M. 在其著作《Android for Programmers: An App-Driven Approach》（Prentice Hall
    2011）第15章中的“Pizza Ordering App”示例所采用的方法，你可以在这里找到：[http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/bookreg/9780132121361/android_15_speech_final_a.pdf](http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/bookreg/9780132121361/android_15_speech_final_a.pdf)。'
- en: The advantage of the approach that we are using is that we provide different
    libraries to parse and manage the interaction, which are reusable by any app that
    requires an interface with a basic form-filling dialog. Thus, it is a general
    purpose approach in which the details for each particular app are supplied in
    a simple VoiceXML file. An example is shown in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所采用的方法的优势在于，我们提供了不同的库来解析和管理交互，这些库可以被任何需要与基本表单填充对话框接口的应用重复使用。因此，这是一种通用方法，每个特定应用程序的详细信息都在一个简单的
    VoiceXML 文件中提供。下一节将展示一个示例。
- en: MusicBrain app
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MusicBrain 应用
- en: 'To illustrate how to use the `FormFillLib` we will develop an app that asks
    the user for the pieces of data necessary to query a web service. The relations
    between the classes in the app and the libraries described in this chapter are
    shown in the following class diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用`FormFillLib`，我们将开发一个应用程序，要求用户提供查询网络服务所需的数据片段。本节中描述的应用程序中的类与库之间的关系在以下类图中展示：
- en: '![MusicBrain app](img/5297OS_05_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![MusicBrain 应用](img/5297OS_05_02.jpg)'
- en: Apps are no longer standalone isolated applications; usually they combine their
    own resources with data and functionalities gathered from third-party web services.
    Recently, many web applications have published APIs (Application Programming Interfaces)
    that allow interested developers to use them in their own apps. This integration
    can be as complex as desired, involving multiple sources. These are known as mashups.
    For example, a travel mashup can integrate Google maps to indicate geographical
    locations with Flickr to show pictures of the relevant tourist attractions while
    at the same time checking for good restaurants in FoodSpotting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不再是独立的孤立应用；它们通常将自身的资源与从第三方网络服务收集的数据和功能相结合。最近，许多网络应用程序发布了API（应用程序编程接口），允许感兴趣的开发商在自己的应用中使用它们。这种集成可以尽可能复杂，涉及多个来源。这些被称为mashups。例如，一个旅行mashup可以整合谷歌地图来标示地理位置，同时用Flickr显示相关旅游景点的图片，并在FoodSpotting中查找好的餐厅。
- en: 'A list of a wide range of available APIs can be found at: [http://www.programmableweb.com](http://www.programmableweb.com).
    Some of these (for example, Amazon, Google, and Facebook) require you to register
    in order to use their APIs. Others can only be used by licensed partners, and
    some are open and available for public (usually non-profit) use.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到一系列可用的API列表：[http://www.programmableweb.com](http://www.programmableweb.com)。其中一些（例如，亚马逊、谷歌和脸书）要求您注册才能使用它们的API。其他只能由授权合作伙伴使用，还有一些是公开的，可供公众（通常是非盈利）使用。
- en: For the `MusicBrain` app (`sandra.examples.formfill.musicbrain`) we will use
    the **MusicBrainZ** public API. MusicBrainZ ([http://musicbrainz.org/](http://musicbrainz.org/))
    is an open music encyclopedia that contains metadata for music. It allows the
    user to query about areas (music from a certain place), artists or groups, albums,
    and releases.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MusicBrain`应用（`sandra.examples.formfill.musicbrain`），我们将使用**MusicBrainZ**公共API。MusicBrainZ（[http://musicbrainz.org/](http://musicbrainz.org/)）是一个开放的音乐百科全书，包含音乐的元数据。它允许用户查询地区（特定地点的音乐）、艺术家或团体、专辑和发行版。
- en: 'The MusicBrain app provides information about albums released between two dates
    whose title contains a certain text. A sample interaction with the app is the
    following excerpt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MusicBrain应用提供了关于在两个日期之间发布的标题包含特定文本的专辑的信息。与应用程序的一个示例交互如下所示：
- en: App> **Please say a word of the album title**
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序> **请说出专辑标题中的一个词**
- en: User> robot
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用户> robot
- en: App> **Please say a starting date for the search**
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序> **请说出搜索的起始日期**
- en: User > 1970
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 > 1970
- en: App> **Please say a final date for the search**
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序> **请说出搜索的最终日期**
- en: User> 2000
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 用户> 2000
- en: 'The result of the preceding interaction produces the result as shown in the
    following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前一交互的结果产生了如下截图所示的结果：
- en: '![MusicBrain app](img/5297OS_05_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![MusicBrain 应用](img/5297OS_05_03.jpg)'
- en: 'The form-filling dialog is started when the activity is created in `MusicBrain.java`.
    This involves retrieving the VoiceXML file, parsing it, and interpreting it to
    obtain the three pieces of data (word in title, starting year and final year)
    that will be used to query the MusicBrainZ web service. The VoiceXML code is as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表单填充对话框在`MusicBrain.java`中创建活动时启动。这涉及到获取VoiceXML文件，解析它，并解释它以获取三个数据片段（标题中的词、起始年份和最终年份），这些数据将用于查询MusicBrainZ网络服务。VoiceXML代码如下：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the dialog is over, the app queries MusicBrainZ and obtains an XML with
    all the albums whose titles contain the word uttered by the user, then the XML
    is parsed and filtered to keep just the albums released between the dates selected.
    Finally the information is shown to the user in the GUI.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对话结束后，应用程序查询MusicBrainZ，并获得一个包含用户说出的词的所有专辑的XML，然后解析并筛选XML，只保留在选定日期之间发布的专辑。最后，在GUI中向用户展示信息。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Web services usually provide the results in XML or JSON. We have used the XML
    version of MusicBrainZ because it is more stable in this particular API, though
    you might be interested in considering other options when using other web services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务通常以XML或JSON格式提供结果。我们使用MusicBrainZ的XML版本，因为在这个特定的API中它更稳定，尽管在使用其他网络服务时，您可能需要考虑其他选项。
- en: The speech dialog is controlled with the `startDialog`, `processXMLContents`,
    and `processDialogResults` methods. The `startDialog` method initializes the ASR
    and TTS engines (using the `ASRLib` and `TTSLib` libraries described in the previous
    chapters) and starts retrieving the VoiceXML file. As explained earlier, when
    the VoiceXML file is retrieved, the `processXMLContents` method is invoked. As
    there are two possible XML files being retrieved in the app (the VoiceXML with
    the dialog, and the XML with the results from the web service), the `processXMLContents`
    method checks what is the current XML being processed and starts the corresponding
    parsing procedure. Finally, the `processDialogResults` method is invoked when
    the VoiceXML parsing is finished. This method queries MusicBrainZ using the word
    inside the album title uttered by the user during the dialog. Take a look at the
    `startDialog` and `processDialogResult` methods in the code bundle (`MusicBrain.java`,
    `MusicBrain` project).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 语音对话由`startDialog`、`processXMLContents`和`processDialogResults`方法控制。`startDialog`方法初始化ASR和TTS引擎（使用前几章描述的`ASRLib`和`TTSLib`库）并开始检索VoiceXML文件。如前所述，当检索到VoiceXML文件时，会调用`processXMLContents`方法。由于应用程序中可能检索到两种XML文件（包含对话的VoiceXML和来自网络服务的结果的XML），`processXMLContents`方法会检查当前正在处理的XML类型，并启动相应的解析过程。最后，当VoiceXML解析完成后，将调用`processDialogResults`方法。此方法使用用户在对话中提到的专辑标题中的单词查询MusicBrainZ。请查看代码包中的`startDialog`和`processDialogResult`方法（`MusicBrain.java`，`MusicBrain`项目）。
- en: The results of the query to the web service are coded in an XML file with the
    structure explained in [http://musicbrainz.org/doc/Development/XML_Web_Service/Version_2/Search#Release](http://musicbrainz.org/doc/Development/XML_Web_Service/Version_2/Search#Release).
    This file is parsed in the method `parseMusicResults`. This method makes use of
    the `MusicBrainParser` class (see `MusicBrainParser.java`) in which we have implemented
    an `XMLPullParser`. The parser iterates through the XML file obtaining a collection
    of albums. To do so, we have defined the `Album` class, which contains information
    about each album title, interpreter, release date, country, and label.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对网络服务的查询结果编码在一个XML文件中，其结构在[http://musicbrainz.org/doc/Development/XML_Web_Service/Version_2/Search#Release](http://musicbrainz.org/doc/Development/XML_Web_Service/Version_2/Search#Release)中解释。这个文件在`parseMusicResults`方法中被解析。该方法使用了`MusicBrainParser`类（见`MusicBrainParser.java`），在其中我们实现了一个`XMLPullParser`。解析器遍历XML文件，获取一系列专辑。为此，我们定义了`Album`类，其中包含有关每张专辑的标题、表演者、发行日期、国家以及唱片公司的信息。
- en: We use alert dialogs to show the reasons for parsing, ASR, or TTS errors. This
    way, the user will be better aware of the fact that the app is not working because
    of ill-formed XMLs or Internet connection problems. The method used to create
    them is `createAlert` (in `MusicBrain.java`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用警告对话框来显示解析、ASR或TTS错误的原因。这样，用户可以更好地意识到应用程序不工作是因为格式错误的XML或互联网连接问题。创建这些对话框的方法是`createAlert`（在`MusicBrain.java`中）。
- en: Once the XML file has been parsed into a collection of `Album` objects, these
    are filtered using the `filterAlbums` method (`MusicBrain.java`). This way, from
    all the albums whose title contains the desired word, we only take into account
    those that were released between the dates provided by the user. If the recognition
    results cannot be parsed as dates, then all albums are considered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦XML文件被解析成一系列的`Album`对象，这些对象将通过`filterAlbums`方法（`MusicBrain.java`）进行过滤。这样，从所有标题包含所需单词的专辑中，我们只考虑那些在用户提供的日期之间发行的专辑。如果识别结果无法解析为日期，那么所有专辑都将被考虑在内。
- en: Once the albums have been filtered, we show them on the GUI with the method
    `showResults`. It is not necessary to sort the albums a posteriori, as we have
    saved them in a `TreeSet`, a collection that allows us to avoid duplicates and
    to save its elements in order. To do so, we override the `equals` method in `Album.java`
    using code to compare if two albums are equal (we check whether they have the
    same title and interpreter), and we create a custom comparator in `AlbumComparator.java`
    that compares the albums according to their release date so that they can be sorted
    from the most to the least recent.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选专辑后，我们使用`showResults`方法在GUI上显示它们。不必在事后对专辑进行排序，因为我们将它们保存在一个`TreeSet`中，这是一个允许我们避免重复并按顺序保存元素的集合。为此，我们在`Album.java`中重写`equals`方法，使用代码比较两个专辑是否相等（我们检查它们是否有相同的标题和解释者），并在`AlbumComparator.java`中创建一个自定义比较器，根据专辑的发行日期进行比较，以便可以从最近到最远排序。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has shown how to implement form-filling dialogs in which the app
    engages in simple conversations with the user in order to retrieve several pieces
    of data which can later be used to provide advanced functionalities to the user
    through web services or mashups.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何实现表单填充对话，应用程序通过与用户的简单对话来获取多块数据，这些数据稍后可以通过网络服务或混搭为用户提供高级功能。
- en: The `FormFillLib` contains the classes to retrieve and parse an XML definition
    of the dialog structure into Java objects. These objects are employed to control
    the oral interaction with the user. This library makes it possible to easily build
    any form-filling dialog in an Android app by specifying its structure in a simplified
    VoiceXML file accessible on the Internet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormFillLib`包含了用于检索和解析对话结构的XML定义到Java对象的类。这些对象用于控制与用户的口头交互。这个库使得通过在互联网上访问简化的VoiceXML文件来轻松构建Android应用程序中的任何表单填充对话成为可能。'
- en: The `MusicBrain` app shows how to use the library to gather information from
    the user through a spoken conversation to query a web service. In this case, the
    app asks the user for a word and two dates which are used to query the MusicBrainZ
    open music encyclopedia for albums with the word in their title and those released
    between the specified dates. The example also shows how to parse and filter the
    results provided by the web service so that they can be presented to the user.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`MusicBrain`应用程序展示了如何通过语音对话从用户那里收集信息，以查询一个网络服务。在这个例子中，应用程序询问用户一个单词和两个日期，用于在MusicBrainZ开放音乐百科全书查询在这些日期之间发布且标题中包含该单词的专辑。该示例还展示了如何解析和过滤网络服务提供的结果，以便向用户展示。'
- en: In this example the ASR input is not restricted, but in many applications it
    is desirable to limit the vocabulary or phrases that the user might employ. In
    [Chapter 6](ch06.html "Chapter 6. Grammars for Dialog"), *Grammars for Dialog*,
    we will study how to use grammars that impose some limits on the input while at
    the same time allowing quite complex structures as well as adding semantics to
    provide an interpretation of the input.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，ASR输入没有限制，但在许多应用程序中，限制用户可能使用的词汇或短语是可取的。在[第6章](ch06.html "第6章. 对话语法")《对话语法》中，我们将研究如何使用语法来限制输入，同时允许相当复杂的结构，并添加语义以提供输入的解释。
