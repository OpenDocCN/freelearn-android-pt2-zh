- en: Chapter 5. Exploring Fragments, AppWidgets, and the System UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 探索片段、应用小部件和系统界面
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and using a Fragment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用片段
- en: Adding and removing Fragments during runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时添加和移除片段
- en: Passing data between Fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在片段间传递数据
- en: Creating a shortcut on the Home screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主屏幕上创建快捷方式
- en: Creating a Home screen widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主屏幕上创建小部件
- en: Adding Search to the Action Bar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向操作栏添加搜索
- en: Showing your app full screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的应用全屏显示
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: With a firm understanding of layouts from [Chapter 2](ch02.html "Chapter 2. Layouts"),
    *Layouts*, we'll dig deeper into UI development with Fragments. Fragments are
    a way to separate your UI into smaller sections that can easily be reused. Think
    of Fragments as mini-activities, complete with their own classes, layouts, and
    lifecycle. Instead of designing your screen in one Activity Layout, possibly duplicating
    functionality across multiple layouts, you can break the screen into smaller,
    logical sections and turn them in to Fragments. Your Activity Layout can then
    reference one or multiple Fragments, as needed. The first three recipes will explore
    Fragments in-depth.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[第2章](ch02.html "第2章. 布局")对布局的深入了解，*布局*，我们将进一步探讨使用片段的用户界面开发。片段是将你的用户界面分割成更小部分的一种方式，这些部分可以轻松复用。将片段视为迷你活动，它们有自己的类、布局和生命周期。你不需要在一个活动布局中设计整个屏幕，可能在多个布局中重复功能，你可以将屏幕分解成更小、逻辑上的部分，并将它们转换为片段。然后，你的活动布局可以根据需要引用一个或多个片段。前三个食谱将深入探讨片段。
- en: With an understanding of Fragments, we're ready to expand on our discussion
    of Widgets. In [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and Styles"),
    *Views, Widgets, and Styles*, we discussed how to add widgets to your own app.
    Now, we'll look at how to create an App Widget so users can put their app on their
    Home screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解片段后，我们准备扩展关于小部件的讨论。在[第3章](ch03.html "第3章. 视图、小部件和样式")中，*视图、小部件和样式*，我们讨论了如何向你的应用添加小部件。现在，我们将看看如何创建一个应用小部件，以便用户可以将他们的应用放在主屏幕上。
- en: The last recipes of the chapter will explore System UI options. We have a recipe
    for adding a `Search` option to the Action Bar using the Android `SearchManager`
    API. The last recipe shows Full Screen mode and several additional variations
    of altering the System UI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后的食谱将探讨系统界面选项。我们有一个食谱，介绍如何使用 Android `SearchManager` API 在操作栏中添加 `Search`
    选项。最后一个食谱展示了全屏模式以及几种改变系统界面的额外变体。
- en: Creating and using a Fragment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用片段
- en: Android didn't always support Fragments. The early versions of Android were
    designed for phones, when screens had relatively small displays. It wasn't until
    Android started being used on tablets that there was a need to split the screen
    into smaller sections. Android 3.0 introduced the `Fragments` class and the Fragment
    Manager.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓并非一直支持片段。早期的安卓版本是为手机设计的，当时屏幕相对较小。直到安卓开始被用在平板上，才需要将屏幕分割成更小的部分。安卓3.0引入了 `Fragments`
    类和片段管理器。
- en: Along with a new class, also came the Fragment Lifecycle. The Fragment Lifecycle
    is similar to the Activity Lifecycle introduced in [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, as most events parallel the Activity Lifecycle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新类的出现，也引入了片段生命周期。片段生命周期与[第1章](ch01.html "第1章. 活动")中介绍的活动生命周期相似，*活动*，因为大多数事件与活动生命周期平行。
- en: 'Here''s a brief overview of the main callbacks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是主要回调函数的简要概述：
- en: '`onAttach()`: It''s called when the Fragment is associated with an Activity.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAttach()`: 当片段与活动关联时调用。'
- en: '`onCreate()`: It''s called when the Fragment is first created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 当片段首次被创建时调用。'
- en: '`onCreateView()`: It''s called when the Fragment is about to be displayed for
    the first time.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateView()`: 当片段即将第一次显示时调用。'
- en: '`onActivityCreated()`: It''s called when the associated Activity is created.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivityCreated()`: 当关联的活动被创建时调用。'
- en: '`onStart()`: It''s called when the Fragment will become visible to the user.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart()`: 当片段将要对用户可见时调用。'
- en: '`onResume()`: It''s called just before a Fragment is displayed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 在片段显示之前调用。'
- en: '`onPause()`: It''s called when the Fragment is first suspended. The user may
    return to the Fragment, but this is where you should persist any user data.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当片段首次被暂停时调用。用户可能会返回到片段，但这里是你应该保存任何用户数据的地方。'
- en: '`onStop()`: It''s called when the Fragment is no longer visible to the user.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop()`: 当片段对用户不再可见时调用。'
- en: '`onDestroyView()`: It''s called to allow final cleanup.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroyView()`：它被调用以允许最后的清理。'
- en: '`onDetach()`: It''s called when the Fragment is no longer associated with the
    Activity.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDetach()`：当片段不再与活动关联时调用。'
- en: 'For our first exercise, we will create a new Fragment derived from the standard
    `Fragment` class. But there are several other `Fragment` classes we could derive
    from, including:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个练习中，我们将创建一个从标准`Fragment`类派生的新片段。但我们还可以从其他几个`Fragment`类派生，包括：
- en: '`DialogFragment`: It''s used for creating a floating dialog'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DialogFragment`：用于创建一个浮动的对话框'
- en: '`ListFragment`: It''s creates a `ListView` in a Fragment, similar to the `ListActivity`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListFragment`：它在片段中创建一个`ListView`，类似于`ListActivity`'
- en: '`PreferenceFragment`: It''s creates a list of Preference objects, commonly
    used for a Settings page'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreferenceFragment`：它创建一个偏好设置对象列表，通常用于设置页面'
- en: In this recipe, we will walk through creating a basic Fragment derived from
    the `Fragment` class and include it in an Activity Layout.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将通过创建一个基于`Fragment`类的简单片段，并将其包含在活动布局中来逐步操作。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `CreateFragment`. Use the
    default **Phone & Tablet** options and select the **Empty Activity** option when
    prompted for the Activity Type.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为`CreateFragment`。使用默认的**Phone & Tablet**选项，在选择活动类型时选择**Empty
    Activity**选项。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will create a new `Fragment` class with an accompanying
    layout file. We will then add the Fragment to the Activity Layout so it will be
    visible when the Activity starts. Here are the steps to create and display a new
    Fragment:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个带有伴随布局文件的新`Fragment`类。然后，我们将片段添加到活动布局中，以便在活动启动时能够看到它。以下是创建和显示新片段的步骤：
- en: 'Create a new layout called `fragment_one.xml` using the following XML:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下XML创建一个名为`fragment_one.xml`的新布局：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FragmentOne`的新Java文件，并使用以下代码：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `main_activity.xml` file and replace the existing `<TextView>` element
    with the following `<fragment>` element:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main_activity.xml`文件，用以下`<fragment>`元素替换现有的`<TextView>`元素：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program on a device or emulator.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating a new class, the same as we do for an Activity. In this
    recipe, we only create an overwrite for the `onCreateView()` method to load our
    Fragment layout. But, just like with the Activity events, we can override the
    other events as we need them. Once the new Fragment is created, we then add it
    to the Activity Layout. Since the `Activity` class was created before `Fragments`
    existed, they do not support `Fragments`. If we were using pure framework classes,
    we would want to use `FragmentActivity` instead. If you used the Android Studio
    New Project Wizard, then by default the `MainActivity` extends `AppCompatActivity`,
    which already includes support for Fragments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先像创建活动一样创建一个新类。在本教程中，我们只创建了一个`onCreateView()`方法的覆盖，以加载我们的片段布局。但是，与活动事件一样，我们可以根据需要覆盖其他事件。创建新的片段后，我们将其添加到活动布局中。由于`Activity`类是在`Fragments`存在之前创建的，所以它们不支持`Fragments`。如果我们使用纯框架类，我们会希望使用`FragmentActivity`。如果你使用了Android
    Studio的新项目向导，那么默认情况下`MainActivity`扩展了`AppCompatActivity`，这已经包括了片段的支持。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We're only creating a single, simple Fragment in this recipe to teach the fundamentals
    of Fragments. But this is a good time to point out the power of Fragments. If
    we are creating multiple Fragments (and usually we are, as that's the point of
    using Fragments), when creating the Activity Layouts as we did in Step 4, we could
    create different layout configurations using the Android Resource Folders. The
    portrait layout may have only a single Fragment while the landscape may have two
    or more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此教程中，我们仅创建一个简单的片段来教授片段的基础知识。但现在是指出片段强大功能的好时机。如果我们正在创建多个片段（通常是这样，因为使用片段的目的就在于此），在步骤4中创建活动布局时，我们可以使用Android资源文件夹创建不同的布局配置。竖屏布局可能只有一个片段，而横屏可能有多个片段。
- en: Adding and removing Fragments during runtime
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时添加和移除片段
- en: Defining a Fragment in the layout, as we did in the previous recipe, is known
    as a static Fragment and cannot be changed during runtime. Rather than using the
    `<fragment>` element, we will create a container to hold the Fragment, then create
    the Fragment dynamically in the Activity's `onCreate()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局中定义一个Fragment，就像我们在上一个配方中所做的那样，这称为静态Fragment，在运行时无法更改。我们将创建一个容器来保存Fragment，而不是使用`<fragment>`元素，然后在Activity的`onCreate()`方法中动态创建Fragment。
- en: 'The `FragmentManager` provides the APIs for adding, removing, and changing
    Fragments during runtime using a `FragmentTransaction`. A Fragment transaction
    consists of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`提供了在运行时使用`FragmentTransaction`添加、移除和更改Fragments的API。一个Fragment事务包括：'
- en: Starting a transaction
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个事务
- en: Performing one or multiple actions
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个或多个动作
- en: Committing the transaction
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交事务
- en: This recipe will demonstrate the `FragmentManager` by adding and removing Fragments
    during runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示通过在运行时添加和移除Fragments来演示`FragmentManager`。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `RuntimeFragments`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为`RuntimeFragments`。使用默认的**Phone & Tablet**选项，在选择**Activity
    Type**时选择**Empty Activity**。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To demonstrate adding and removing Fragments, we first need to create the Fragments,
    which we will do be extending the `Fragment` class. After creating the new Fragments,
    we need to alter the layout for the Main Activity to include the `Fragment` container.
    From there, we just add the code to handle the Fragment transactions. Here are
    the steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示添加和移除Fragments，我们首先需要创建Fragments，这可以通过扩展`Fragment`类来完成。创建新的Fragments后，我们需要更改主活动的布局以包含`Fragment`容器。从那里，我们只需添加处理Fragment事务的代码。以下是步骤：
- en: 'Create a new layout file called `fragment_one.xml` and include the following
    XML:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment_one.xml`的新布局文件，并包含以下XML：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second layout file called `fragment_two.xml` is almost identical, with
    the only difference being the text:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个名为`fragment_two.xml`的布局文件几乎相同，唯一的区别是文本：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FragmentOne`的新Java文件，并包含以下代码：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Import from the following library:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the second Java file called `FragmentTwo` with the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为`FragmentTwo`的Java文件，并包含以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Import from the following library:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to add a container and a button to the Main Activity layout. Change
    `main_activity.xml` as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在主活动布局中添加一个容器和一个按钮。如下更改`main_activity.xml`：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the Fragments created and the container added to the layout, we are now
    ready to write the code to manipulate the Fragments. Open `MainActivity.java`
    and add the following code below the class constructor:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了Fragments并且将容器添加到布局中后，我们现在准备编写操作Fragments的代码。打开`MainActivity.java`并在类构造函数下面添加以下代码：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code to the existing `onCreate()` method, below `setContentView()`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`onCreate()`方法中，在`setContentView()`下面添加以下代码：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import from the following libraries:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last code we need to add handles the Fragment switching, called by the
    button:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一段代码处理按钮触发的Fragment切换：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program on a device or emulator.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Most of the steps for this recipe involve setting up the Fragments. Once the
    Fragments are declared, we create them in the `onCreate()` method. Though the
    code can be condensed to a single line, it's shown in the long form as it makes
    it easier to read and understand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的多数步骤涉及设置Fragments。一旦声明了Fragments，我们将在`onCreate()`方法中创建它们。尽管代码可以压缩成单行，但它以长形式展示，这样更容易阅读和理解。
- en: First, we get the `FragmentManager` so we can begin a `FragmentTransaction`.
    Once we have a `FragmentTransaction`, we start the transaction with `beginTransaction()`.
    Multiple actions can occur within the transaction, but all we need here is to
    `add()` our initial Fragment. We call the `commit()` method to finalize the transaction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取`FragmentManager`以便开始一个`FragmentTransaction`。一旦有了`FragmentTransaction`，我们通过`beginTransaction()`开始事务。在事务中可以发生多个动作，但这里我们只需要`add()`我们的初始Fragment。我们调用`commit()`方法来最终确定事务。
- en: 'Now that you understand the Fragment transaction, here is the succinct version
    for `onCreate()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您理解了Fragment事务，这是`onCreate()`的简洁版本：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`switchFragment` does basically the same type of Fragment transaction. Instead
    of calling the `add()` method, we call the `replace()` method with the existing
    Fragment. We keep track of the current Fragment with the `showingFragment` variable
    so we know which Fragment to show next. We are not limited to switching between
    two Fragments either. If we needed additional Fragments, we just need to create
    them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchFragment`基本上执行相同类型的Fragment事务。我们不是调用`add()`方法，而是使用`replace()`方法替换现有Fragment。我们通过`showingFragment`变量跟踪当前Fragment，这样我们就知道接下来要显示哪个Fragment。我们不仅限于在两个Fragment之间切换。如果我们需要额外的Fragment，只需创建它们即可。'
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the *Switching between activities* recipe from [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, we discussed the back stack. Most users would expect the back key
    to move backward through the "screens" and they don't know or care if those screens
    are activities or Fragments. Fortunately, Android makes it very easy to add Fragments
    to the back stack just by adding a call to `addToBackStack()` before calling `commit()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 活动")《活动》中的*活动间切换*一节，我们讨论了返回栈。大多数用户会期望按返回键可以向后穿过“屏幕”，他们不知道或不在乎这些屏幕是活动还是Fragment。幸运的是，Android通过在调用`commit()`之前添加对`addToBackStack()`的调用，非常容易地将Fragment添加到返回栈中。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a Fragment is removed or replaced without adding it to the back stack,
    it is immediately destroyed. If it is added to the back stack, it is stopped and,
    if the user returns to the Fragment, it is restarted, instead of recreated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在没有将Fragment添加到返回栈的情况下移除或替换它，它将被立即销毁。如果添加到返回栈中，它会被停止，如果用户返回到该Fragment，它将被重新启动，而不是重新创建。
- en: Passing data between Fragments
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Fragment之间传递数据
- en: Often, the need arises to pass information between the Fragments. An email application
    serves as a classic example. It's common to have the list of emails in one Fragment,
    and show the email details in another Fragment (this is commonly referred to as
    a Master/Detail pattern). Fragments make creating this pattern easier because
    we only have to code each Fragment once, then we can include them in different
    layouts. We can easily have a single Fragment in a portrait layout with the ability
    to swap out the master Fragment with the detail Fragment when an email is selected.
    We can also create a two-panel layout where both the list and detail Fragments
    are side-by-side. Either way, when the user clicks the email in the list, the
    email opens up in the detail panel. This is when we need to communicate between
    two Fragments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要在Fragment之间传递信息。电子邮件应用程序就是一个典型的例子。通常在一个Fragment中显示电子邮件列表，在另一个Fragment中显示电子邮件详情（这通常被称为Master/Detail模式）。由于我们只需要为每个Fragment编写一次代码，然后就可以将它们包含在不同的布局中，所以Fragment使得创建这种模式变得更容易。我们可以在纵向布局中轻松地拥有一个单独的Fragment，并在选择电子邮件时，用详情Fragment替换主Fragment。我们还可以创建一个双面板布局，其中列表和详情Fragment并排显示。无论哪种方式，当用户点击列表中的电子邮件时，电子邮件都会在详情面板中打开。这就是我们需要在两个Fragment之间进行通信的时候。
- en: Since one of the primary goals of Fragments is that they be completely self-contained,
    direct communication between Fragments is discouraged, and for good reason. If
    Fragments had to rely on other Fragments, your code would likely break when the
    layouts changed and only one Fragment was available. Fortunately, direct communication
    is not required for this scenario either. All Fragment communication should pass
    through the host Activity. The host activity is responsible for managing the Fragments
    and can properly route the messages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fragment的一个主要目标是完全自包含，因此不建议直接在Fragment之间进行通信，这有充分的理由。如果Fragment必须依赖其他Fragment，当布局更改且只有一个Fragment可用时，你的代码很可能会出问题。幸运的是，在这种情况下也不需要直接通信。所有Fragment的通信都应该通过宿主活动进行。宿主活动负责管理Fragment，并且可以正确地传递消息。
- en: 'Now the question becomes: How do Fragments communicate with the activity? The
    answer is with an `interface`. You''re probably already familiar with an interface,
    as that''s how a view communicates an event back to an activity. A button click
    is a common example.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题变成了：Fragment是如何与活动通信的？答案是：通过一个`接口`。你可能已经熟悉了接口，因为视图就是通过接口将事件回传给活动的。按钮点击就是一个常见的例子。
- en: 'In this recipe, we will create two Fragments to demonstrate passing data from
    one Fragment to another via the host activity. We''ll also build on what we learned
    from the previous recipe by including two different Activity Layouts—one for portrait
    and one for landscape. When in portrait mode, the activity will swap the Fragments
    as needed. Here is a screenshot of when the application first runs in portrait
    mode:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们将创建两个片段，以展示通过宿主活动从一个片段向另一个片段传递数据。我们将在上一个食谱的基础上，包括两种不同的活动布局——一种用于竖屏，一种用于横屏。在竖屏模式下，活动将根据需要交换片段。以下是应用程序首次在竖屏模式下运行时的截图：
- en: '![Passing data between Fragments](img/B05057_05_01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![在片段间传递数据](img/B05057_05_01.jpg)'
- en: 'This is the screen showing the detail Fragment when you click on a country
    name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当你点击国家名称时显示详情片段的屏幕：
- en: '![Passing data between Fragments](img/B05057_05_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![在片段间传递数据](img/B05057_05_02.jpg)'
- en: 'When in landscape, both Fragments will be side-by-side, as shown in the landscape
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在横屏模式下，两个片段将并排显示，如下横屏截图所示：
- en: '![Passing data between Fragments](img/B05057_05_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![在片段间传递数据](img/B05057_05_03.jpg)'
- en: Since the Master/Detail pattern generally involves a list for the master, we'll
    take advantage of the `ListFragment` (mentioned in the *Creating and using a Fragment*
    introduction.) When an item in the list is selected, the item text (country name
    in our example) will be sent to the detail Fragment via the host Activity.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主/详模式通常涉及主列表，我们将利用 `ListFragment`（在*创建和使用片段*介绍中提到）。当列表中的项目被选中时，项目文本（在我们的示例中是国家名称）将通过宿主
    Activity 发送到详情片段。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `Fragmentcommunication`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，并将其命名为 `Fragmentcommunication`。使用默认的 **Phone & Tablet**
    选项，在选择 **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To fully demonstrate working Fragments, we'll need to create two Fragments.
    The first Fragment will extend from the `ListFragment` so it will not need a layout.
    We're going to go one step further by creating both portrait and landscape layouts
    for our Activity. For portrait mode, we'll swap Fragments and for landscape mode,
    we'll show both Fragments side-by-side.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全展示工作的片段，我们需要创建两个片段。第一个片段将继承自 `ListFragment`，因此不需要布局。我们还将进一步创建活动和横屏模式下的两种布局。对于竖屏模式，我们将交换片段，对于横屏模式，我们将并排显示两个片段。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When typing this code, Android Studio will offer two different library import
    options. Since the New Project Wizard automatically references the `AppCompat`
    library, we need to use the support library APIs instead of the framework APIs.
    Though very similar, the following code uses the support Fragment APIs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入这段代码时，Android Studio 会提供两个不同的库导入选项。由于新项目向导会自动引用 `AppCompat` 库，我们需要使用支持库 API
    而非框架 API。尽管它们非常相似，以下代码使用了支持片段 API。
- en: 'Here are the steps, starting with the first Fragment:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从第一个片段开始的步骤：
- en: 'Create a new Java class called `MasterFragment` and change it so it extends
    `ListFragment` as shown:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MasterFragment` 的新 Java 类，并将其更改为继承 `ListFragment`，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import from the following library:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the following `interface` inside the `MasterFragment` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MasterFragment` 类内部创建以下 `interface`：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set up the interface callback listener with the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码设置接口回调监听器：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last step for the `MasterFragment` is to create a `ListAdapter` to populate
    the `ListView`, which we do in the `onViewCreated()` method. We''ll use the `setOnItemClickListener()`
    to call our `OnMasterSelectedListener` interface when a country name is selected
    with the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MasterFragment` 的最后一步是创建一个 `ListAdapter` 来填充 `ListView`，我们在 `onViewCreated()`
    方法中进行。我们将使用 `setOnItemClickListener()` 在选择国家名称时调用我们的 `OnMasterSelectedListener`
    接口，代码如下：'
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we need to create the `DetailFragment`, starting with the Layout. Create
    a new layout file called: `fragment_detail.xml` with the following XML:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要创建 `DetailFragment`，从布局开始。创建一个名为 `fragment_detail.xml` 的新布局文件，包含以下 XML：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new Java class called `DetailFragment` extending from `Fragment` as
    follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DetailFragment` 的新 Java 类，继承自 `Fragment`，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import from the following library:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下库导入：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following constant to the class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下常量添加到类中：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override `onCreateView()` as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式覆盖 `onCreateView()`：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code the `onViewCreated()` as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编写 `onViewCreated()`：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step for this Fragment is to update the TextView when we receive the
    selected country name. Add the following method to the class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个Fragment的最后一个步骤是在接收到选定的国家名称时更新TextView。将以下方法添加到类中：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The existing `activity_main.xml` layout will handle the portrait mode layout.
    Remove the existing `<TextView>` and replace with the following `<FrameLayout>`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的`activity_main.xml`布局将处理竖屏模式的布局。移除现有的`<TextView>`并替换为以下`<FrameLayout>`：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new directory in the **res** folder for the landscape layout as: `res/layout-land`.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**res**文件夹中为横屏布局创建一个新目录，如：`res/layout-land`。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not see the new res/layout-land directory, change from **Android**
    **view** to **Project** **view**.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有看到新的`res/layout-land`目录，从**Android**视图更改为**Project**视图。
- en: 'Create a new `activity_main.xml` layout in `res/layout-land` as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout-land`中创建一个新的`activity_main.xml`布局，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final steps are to set up the `MainActivity` to handle the Fragments. Open
    the `MainActivity.java` file and add the following class variable to track single/dual
    pane:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的步骤是设置`MainActivity`以处理Fragments。打开`MainActivity.java`文件，并添加以下类变量以跟踪单/双面板：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, change `onCreate()` as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按如下方式更改`onCreate()`：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last code to add is the `sendCountryName()` method, which handles sending
    the country name to `DetailFragment`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要添加的最后一段代码是处理将国家名称发送给`DetailFragment`的`sendCountryName()`方法：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the program on a device or emulator.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We start by creating the `MasterFragment`. In the Master/Detail pattern we are
    using, this usually represents a list, so we create a list by extending the `ListFragment`.
    The `ListFragment` is the Fragment equivalent of the `ListActivity`. Other than
    extending from a Fragment, it's basically the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`MasterFragment`。在我们使用的Master/Detail模式中，这通常代表一个列表，因此我们通过扩展`ListFragment`来创建一个列表。`ListFragment`是`ListActivity`对应的Fragment版本。除了从Fragment扩展而来，基本上是相同的。
- en: As stated in the recipe introduction, we shouldn't attempt to communicate directly
    with other Fragments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如菜谱介绍中所说，我们不应该尝试直接与其他Fragments进行通信。
- en: 'To provide a means to communicate the list item selection, we expose the interface:
    `OnMasterSelectedListener`. We call `onItemSelected()` every time an item is selected
    in the list.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一种方法来通知列表项的选择，我们暴露了接口：`OnMasterSelectedListener`。每次在列表中选择一个项目时，我们都会调用`onItemSelected()`。
- en: 'Most of the work for passing data between Fragments is done in the host activity
    but, ultimately, the receiving Fragment needs a way to receive the data. `DetailFragment`
    supports this in two ways:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fragments之间传递数据的大部分工作由宿主活动完成，但最终，接收Fragment需要一种接收数据的方法。`DetailFragment`通过以下两种方式支持这一点：
- en: Passing the country name in the argument bundle, available at creation time.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时通过参数包传递国家名称。
- en: A public method for the activity to call directly.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个供活动直接调用的公共方法。
- en: When the activity creates the Fragment, it also creates a `bundle` to hold the
    data we want to send. Here we add the country name using `KEY_COUNTRY_NAME` defined
    in Step 7\. We retrieve this bundle with `getArguments()` in `onViewCreated()`.
    If the key is found in the bundle, it is extracted and displayed using the `showSelectedCountry()`
    method. This is the same method the activity will call directly if the Fragment
    is already visible (in the two-panel layout).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动创建Fragment时，它还会创建一个`bundle`来保存我们想要发送的数据。这里我们使用在步骤7中定义的`KEY_COUNTRY_NAME`添加国家名称。我们在`onViewCreated()`中使用`getArguments()`获取这个包。如果包中找到了键，则提取并使用`showSelectedCountry()`方法显示。如果Fragment已经可见（在双面板布局中），活动将直接调用此方法。
- en: 'Most of the work for this recipe is in the activity. We created two layouts:
    one for portrait and one for landscape. Android will choose the landscape layout
    using the `res/layout-land` directory created in *Step 12*. Both layouts use a
    `<FrameLayout>` placeholder, similar to the previous exercise. We manage the Fragments
    in both `onCreate()` and `sendCountryName()`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的大部分工作都在活动中完成。我们创建了两个布局：一个用于竖屏，一个用于横屏。Android将使用在*步骤12*中创建的`res/layout-land`目录选择横屏布局。这两个布局都使用类似于之前练习的`<FrameLayout>`占位符。我们在`onCreate()`和`sendCountryName()`中管理两种Fragments。
- en: 'In `onCreate()`, we set the `dualPane` flag by checking whether the current
    layout includes the `frameLayout` view. If `frameLayout` is found (it won''t be
    null), then we have only a single panel because the `frameLayout` ID is only in
    the portrait layout. If frameLayout is not found, then we have two `<FrameLayout>`
    elements instead: one for the `MasterFragment` and another for the `DetailFragment`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`中，我们通过检查当前布局是否包含`frameLayout`视图来设置`dualPane`标志。如果找到了`frameLayout`（它不会为空），那么我们只有一个面板，因为`frameLayout`的ID只存在于竖屏布局中。如果没有找到frameLayout，那么我们将有两个`<FrameLayout>`元素：一个用于`MasterFragment`，另一个用于`DetailFragment`。
- en: The last thing we do in the `onCreate()` is to set up the `MasterFragment` listener
    by creating an anonymous callback, which passes the country name to `sendCountryName()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`中我们最后要做的事情是设置`MasterFragment`的监听器，通过创建一个匿名回调函数，将国家名称传递给`sendCountryName()`。
- en: '`sendCountryName()` is where the data is actually passed to the `DetailFragment`.
    If we are in portrait (or single pane) mode, we need to create a `DetailFragment`
    and replace the existing `MasterFragment`. This is where we create the bundle
    with the country name and call `setArguments()`. Notice how we call `addToBackStack()`
    before committing the transaction? This allows the back key to bring the user
    back to the list (`MasterFragment`). If we are in landscape mode, the `DetailFragment`
    is already visible so we call the `showSelectedCountry()` public method directly.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendCountryName()`是实际将数据传递给`DetailFragment`的地方。如果我们处于竖屏（或单面板）模式，我们需要创建一个`DetailFragment`并替换现有的`MasterFragment`。在这里，我们创建带有国家名称的包，并调用`setArguments()`。注意我们在提交事务之前是如何调用`addToBackStack()`的吗？这使得按下返回键可以将用户带回列表（`MasterFragment`）。如果我们处于横屏模式，`DetailFragment`已经可见，因此我们直接调用`showSelectedCountry()`公共方法。'
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the `MasterFragment`, before sending the `onItemSelected()` event, we check
    to make sure the listener is not null with this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MasterFragment`中，在发送`onItemSelected()`事件之前，我们通过以下代码检查以确保监听器不为空：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Though it's the job of the activity to set up the callback to receive the events,
    we don't want this code to crash if there's no listener. An alternative approach
    would be to verify the activity extends our interface in the Fragment's `onAttach()`
    callback.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然活动负责设置回调以接收事件，但我们不希望如果没有监听器这段代码崩溃。另一种方法是在Fragment的`onAttach()`回调中验证活动是否扩展了我们的接口。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on ListViews, see *Using ListView, GridView and Adapters*
    in [Chapter 2](ch02.html "Chapter 2. Layouts"), *Layouts*.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关ListViews的更多信息，请参见[第2章](ch02.html "第2章. 布局")中的*使用ListView、GridView和适配器*，*布局*。
- en: For more information on resource directories, see *Selecting themes based on
    the Android version* in [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and
    Styles"), *Views, Widgets, and Styles*.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关资源目录的更多信息，请参见[第3章](ch03.html "第3章. 视图、小部件和样式")中的*根据Android版本选择主题*，*视图、小部件和样式*。
- en: Creating a shortcut on the Home screen
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主屏幕上创建快捷方式
- en: This recipe explains how to create a link or create a shortcut for your app
    on the user's Home screen. So as not to be too obtrusive, it's generally best
    to make this an option for the user to initiate, such as in the settings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱解释了如何在用户的主屏幕上为你的应用创建链接或快捷方式。为了避免过于突兀，通常最好让用户在设置中自行选择启动这一选项。
- en: 'Here is a screenshot showing our shortcut on the Home screen:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张截图，展示了我们在主屏幕上的快捷方式：
- en: '![Creating a shortcut on the Home screen](img/B05057_05_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![在主屏幕上创建快捷方式](img/B05057_05_04.jpg)'
- en: As you can see, this is just a shortcut, but we will explore creating a Home
    screen (AppWidget) in the next recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是个快捷方式，但在下一个食谱中我们将探讨创建主屏幕（AppWidget）的方法。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `HomescreenShortcut`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，将其命名为：`HomescreenShortcut`。使用默认的**手机 & 平板**选项，并在提示**活动类型**时选择**空活动**选项。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step is to add the appropriate permission. Here are the steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是添加适当的权限。以下是步骤：
- en: 'Open the `AndroidManifest` file and add the following permission:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest`文件，并添加以下权限：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, open `activity_main.xml` and replace the existing TextView with the following
    button:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`activity_main.xml`，并用以下按钮替换现有的TextView：
- en: '[PRE34]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following method to `ActivityMain.java`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ActivityMain.java`添加以下方法：
- en: '[PRE35]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the program on a device or emulator. Notice, each time you press the button,
    the app will make a shortcut on the Home screen.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。注意，每次你按按钮，应用将在主屏幕上创建一个快捷方式。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once you set up the proper permission, this is a rather straightforward task.
    When the button is clicked, the code creates a new intent called: `shortcutIntent`.
    This is the intent that will be called when the icon is pressed on the Home screen.
    The next intent created, `installIntent`, is responsible for actually creating
    the shortcut.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了适当的权限后，这个任务相当直接。当按钮被点击时，代码创建了一个名为`shortcutIntent`的新意图。这是当在主屏幕上按下图标时将被调用的意图。接下来创建的意图`installIntent`负责实际创建快捷方式。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you also wanted to remove the shortcut, you would need the following permission:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想移除快捷方式，你需要以下权限：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead of using the INSTALL_SHORTCUT action, you would set the following action
    instead:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用INSTALL_SHORTCUT动作，不如设置以下动作：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating a Home screen widget
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主屏幕小部件
- en: 'Before we dig in to the code for creating an App Widget, let''s cover the basics.
    There are three required and one optional component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究创建App Widget的代码之前，让我们先了解基础知识。有三个必需和一个可选的组件：
- en: 'The `AppWidgetProviderInfo` file: It''s an XML resource described later on'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProviderInfo`文件：稍后描述的XML资源'
- en: 'The `AppWidgetProvider` class: This is a Java class'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类：这是一个Java类'
- en: 'The View layout file: It''s a standard layout XML file, with some restrictions
    listed later on'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图布局文件：这是一个标准的布局XML文件，稍后会列出一些限制
- en: 'The App Widget configuration Activity (optional): This Activity launches when
    placing the widget to set configuration options'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Widget配置Activity（可选）：在放置小部件时启动此Activity以设置配置选项
- en: 'The `AppWidgetProvider` must also be declared in the `AndroidManifest` file.
    Since the `AppWidgetProvider` is a helper class based on the Broadcast Receiver,
    it is declared in the manifest with the `<receiver>` element. Here is an example
    manifest entry:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`还必须在`AndroidManifest`文件中声明。由于`AppWidgetProvider`是基于广播接收器的辅助类，因此它使用`<receiver>`元素在清单中声明。以下是一个示例清单条目：'
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The meta-data points to the `AppWidgetProviderInfo` file, which is placed in
    the `res/xml` directory. Here is a sample `AppWidgetProviderInfo.xml` file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据指向`AppWidgetProviderInfo`文件，该文件位于`res/xml`目录中。以下是一个示例`AppWidgetProviderInfo.xml`文件：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s a brief overview of the available attributes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可用属性的简要概述：
- en: '`minWidth`: The default width when placed on the Home screen'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minWidth`：放置在主屏幕上的默认宽度'
- en: '`minHeight`: The default height when placed on the Home screen'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minHeight`：放置在主屏幕上的默认高度'
- en: '`updatePeriodMillis`: It''s part of `onUpdate()` polling interval (in milliseconds)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePeriodMillis`：它是`onUpdate()`轮询间隔的一部分（以毫秒为单位）'
- en: '`initialLayout`: The AppWidget layout'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout`：AppWidget布局'
- en: '`previewImage` (optional): The image shown when browsing App Widgets'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previewImage`（可选）：浏览App Widgets时显示的图片'
- en: '`configure` (optional): The activity to launch for configuration settings'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure`（可选）：用于启动配置设置的activity'
- en: '`resizeMode` (optional): The flags indicate resizing options — `horizontal`,
    `vertical`, `none`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizeMode`（可选）：标志表示调整大小选项 - `horizontal`（水平）、`vertical`（垂直）、`none`（无）'
- en: '`minResizeWidth` (optional): The minimum width allowed when resizing'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeWidth`（可选）：调整大小时允许的最小宽度'
- en: '`minResizeHeight` (optional): The minimum height allowed when resizing'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeHeight`（可选）：调整大小时允许的最小高度'
- en: '`widgetCategory` (optional): Android 5+ only supports Home screen widgets'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widgetCategory`（可选）：Android 5+仅支持主屏幕小部件'
- en: 'The `AppWidgetProvider` extends the `BroadcastReceiver` class, which is why
    `<receiver>` is used when declaring the `AppWidget` in the Manifest. As it''s
    `BroadcastReceiver`, the class still receives the OS broadcast events, but the
    helper class filters those events down to those applicable for an App Widget.
    The `AppWidgetProvider` class exposes the following methods:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`扩展了`BroadcastReceiver`类，这就是在清单中声明App Widget时使用`<receiver>`的原因。由于它是`BroadcastReceiver`，该类仍然接收操作系统的广播事件，但辅助类将这些事件过滤为适用于App
    Widget的事件。`AppWidgetProvider`类公开以下方法：'
- en: '`onUpdate()`: It''s called when initially created and at the interval specified.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate()`：在最初创建时以及指定的时间间隔调用。'
- en: '`onAppWidgetOptionsChanged()`: It''s called when initially created and any
    time the size changes.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppWidgetOptionsChanged()`：在最初创建时以及任何大小更改时调用。'
- en: '`onDeleted()`: It''s called any time a widget is removed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDeleted()`：每当小部件被移除时调用。'
- en: '`onEnabled()`: It''s called the first time a widget is placed (is not called
    when adding a second and subsequent widgets).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnabled()`: 当小部件首次被放置时调用（在添加第二个及以后的小部件时不会调用）。'
- en: '`onDisabled()`: It''s called when the last widget is removed.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDisabled()`: 当最后一个部件被移除时调用。'
- en: '`onReceive()`: It''s called on every event received, including the preceding
    event. Usually not overridden as the default implementation only sends the applicable
    events.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onReceive()`: 在接收到每个事件时调用，包括前面的那些事件。通常不重写，因为默认实现只发送适用的事件。'
- en: 'The last required component is the layout. Remote Views only support a subset
    of the available layouts. As an App Widget is a Remote View, only the following
    layouts are supported:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必需的组件是布局。Remote Views只支持可用布局的一个子集。由于App Widget是Remote View，因此只支持以下布局：
- en: '`FrameLayout`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrameLayout`'
- en: '`LinearLayout`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinearLayout`'
- en: '`RelativeLayout`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeLayout`'
- en: '`GridLayout`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridLayout`'
- en: 'And the following widgets:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下小部件：
- en: '`AnalogClock`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnalogClock`'
- en: '`Button`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`'
- en: '`Chronometer`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chronometer`'
- en: '`ImageButton`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageButton`'
- en: '`ImageView`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageView`'
- en: '`ProgressBar`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBar`'
- en: '`TextView`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextView`'
- en: '`ViewFlipper`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewFlipper`'
- en: '`ListView`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`'
- en: '`GridView`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView`'
- en: '`StackView`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackView`'
- en: '`AdapterViewFlipper`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdapterViewFlipper`'
- en: With the App Widget basics covered, it's now time to start coding. Our example
    will cover the basics so you can expand the functionality as needed. This recipe
    uses a View with a clock, which, when pressed, opens our activity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了App Widget的基础知识后，现在开始编码。我们的示例将涵盖基础知识，以便你可以根据需要扩展功能。这个示例使用了一个带有时钟的视图，按下时，会打开我们的活动。
- en: 'This screenshot shows the widget in the widget list when adding to the Home
    screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了在添加到主屏幕时小部件在部件列表中的样子：
- en: '![Creating a Home screen widget](img/B05057_05_05.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![创建主屏幕小部件](img/B05057_05_05.jpg)'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The widget list appearance varies by launcher.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件列表的外观因启动器而异。
- en: 'Here''s a screenshot showing the widget after it is added to the Home screen:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张添加到主屏幕后的小部件截图：
- en: '![Creating a Home screen widget](img/B05057_05_06.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![创建主屏幕小部件](img/B05057_05_06.jpg)'
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `AppWidget`. Use the default
    **Phone & Tablet** options and select the **Empty Activity** option when prompted
    for the **Activity Type**.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为：`AppWidget`。使用默认的**Phone & Tablet**选项，在选择**Activity
    Type**时选择**Empty Activity**。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll start by creating the widget layout, which resides in the standard layout
    resource directory. Then we'll create the xml resource directory to store the
    `AppWidgetProviderInfo` file. We'll add a new Java class and extend `AppWidgetProvider`,
    which handles the `onUpdate()` call for the widget. With the receiver created,
    we can then add it to the Android Manifest.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建小部件布局开始，该布局位于标准布局资源目录中。然后我们将创建xml资源目录以存储`AppWidgetProviderInfo`文件。我们将添加一个新的Java类并扩展`AppWidgetProvider`，它处理小部件的`onUpdate()`调用。创建接收器后，我们可以将其添加到Android清单中。
- en: 'Here are the detailed steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是详细的步骤：
- en: 'Create a new file in `res/layout` called `widget.xml` using the following XML:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`中创建一个名为`widget.xml`的新文件，使用以下XML：
- en: '[PRE40]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new directory called `xml` in the resource directory. The final result
    will be: `res/xml`.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源目录中创建一个名为`xml`的新目录。最终结果将是：`res/xml`。
- en: 'Create a new file in `res/xml` called `appwidget_info,xml` using the following
    xml:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml`中创建一个名为`appwidget_info.xml`的新文件，使用以下xml：
- en: '[PRE41]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you cannot see the new xml directory, switch from **Android** view to **Project**
    view in the **Project** panel dropdown.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你看不到新的xml目录，请在**项目**面板下拉菜单中将视图从**Android**切换到**Project**。
- en: Create a new Java class called `HomescreenWidgetProvider` extending `AppWidgetProvider`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HomescreenWidgetProvider`的新Java类，继承自`AppWidgetProvider`。
- en: 'Add the following `onUpdate()` method to the `HomescreenWidgetProvider` class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomescreenWidgetProvider`类中添加以下`onUpdate()`方法：
- en: '[PRE42]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add `HomescreenWidgetProvider` to `AndroidManifest` using the following XML
    declaration within the `<application>` element:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest`中使用以下XML声明将`HomescreenWidgetProvider`添加到`<application>`元素中：
- en: '[PRE43]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run the program on a device or emulator. After first running the application,
    the widget will then be available to add to the Home screen.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。首次运行应用程序后，小部件就可以添加到主屏幕上了。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our first step is to create the layout file for the widget. This is a standard
    layout resource with the restrictions based on the App Widget being a Remote View,
    as discussed in the recipe introduction. Though our example uses an Analog Clock
    widget, this is where you'd want to expand the functionality based on your application
    needs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建小部件的布局文件。这是一个标准的布局资源，受到App Widget作为远程视图的限制，如菜谱介绍中所述。尽管我们的示例使用了模拟时钟小部件，但这是根据你的应用程序需求扩展功能的地方。
- en: The xml resource directory serves to store the `AppWidgetProviderInfo`, which
    defines the default widget settings. The configuration settings determine how
    the widget is displayed when initially browsing the available widgets. We use
    very basic settings for this recipe, but they can easily be expanded to include
    additional features such as a preview image to show a functioning widget and sizing
    options. The `updatePeriodMillis` attribute sets the update frequency. Since the
    update will wake up the device, it's a trade-off between having up-to-date data
    and battery life. (This is where the optional Settings Activity is useful to let
    the user decide.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: XML资源目录用于存储`AppWidgetProviderInfo`，它定义了默认的小部件设置。配置设置决定了在最初浏览可用小部件时如何显示小部件。本例中我们使用非常基础的设置，但它们可以轻松扩展，以包含如预览图像显示功能正常的小部件和大小选项等附加功能。`updatePeriodMillis`属性设置了更新频率。由于更新将唤醒设备，这是保持数据最新与电池寿命之间的权衡。（这时可选的设置活动就很有用，可以让用户决定。）
- en: The `AppWidgetProvider` class is where we handle the `onUpdate()` event triggered
    by the `updatePeriodMillis` polling. Our example doesn't need any updating so
    we set the polling to zero. The update is still called when initially placing
    the widget. The `onUpdate()` is where we set the pending intent to open our app
    when the clock is pressed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类是我们处理由`updatePeriodMillis`轮询触发的`onUpdate()`事件的地方。我们的示例不需要任何更新，因此我们将轮询设置为0。尽管如此，在最初放置小部件时仍会调用更新。在`onUpdate()`中，我们设置了当按下时钟时打开我们应用的待定意图。'
- en: Since the `onUpdate()` method is probably the most complicated aspect of AppWidgets,
    we'll explain this is some detail. First, it's worth noting that `onUpdate()`
    will occur only once each polling interval for all the widgets is created by this
    provider. (Widgets created after the first will be on the cycle of the first widget.)
    This explains the `for` loop, as we need it to iterate through all the existing
    widgets. This is where we create a pending intent to call our app when the clock
    is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to
    get the layout, we call `RemoteViews()` with our fully qualified package name
    and the layout ID. Once we have the layout, we can attach the pending intent to
    the clock view using `setOnClickPendingIntent()`. We call the `AppWidgetManager`
    named `updateAppWidget()` to initiate the changes we made.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onUpdate()`方法可能是AppWidgets最复杂的方面，我们将详细解释这一点。首先需要注意的是，`onUpdate()`在每个轮询间隔内只发生一次，对于由此提供者创建的所有小部件。（创建第一个之后的小部件将遵循第一个小部件的周期。）这就解释了`for`循环的必要性，我们需要它来遍历所有现有的小部件。在这里，我们创建了一个待定意图，当按下时钟时调用我们的应用。如前所述，AppWidget是一个远程视图。因此，为了获取布局，我们使用带有完全限定包名和布局ID的`RemoteViews()`。一旦我们有了布局，就可以使用`setOnClickPendingIntent()`将待定意图附加到时钟视图上。我们调用名为`updateAppWidget()`的`AppWidgetManager`来启动我们做出的更改。
- en: 'The last step to make all this work is to declare the widget in the Android
    Manifest. We identify the action we want to handle with the `<intent-filter>`.
    Most App Widgets will likely want to handle the Update event, as ours does. The
    other item to note in the declaration is this line:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使所有这些工作正常，最后一步是在Android Manifest中声明小部件。我们使用`<intent-filter>`标识我们要处理的行为。大多数应用小部件可能都想处理更新事件，就像我们的例子一样。声明中需要注意的另一项是这一行：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells the system where to find our configuration file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉系统在哪里找到我们的配置文件。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Adding an App Widget configuration Activity allows greater flexibility with
    your widget. Not only can you offer polling options, but you could offer different
    layouts, click behaviors, and so on. Users tend to really appreciate flexible
    App Widgets.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 添加App Widget配置活动可以使你的小部件更加灵活。你不仅可以提供轮询选项，还可以提供不同的布局、点击行为等。用户往往非常重视灵活的App Widgets。
- en: 'Adding a configuration Activity requires a few additional steps. The Activity
    needs to be declared in the Manifest as usual, but needs to include the `APPWIDGET_CONFIGURE`
    action, as shown in this example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 添加配置 Activity 需要几个额外的步骤。Activity 需要像往常一样在 Manifest 中声明，但需要包含 `APPWIDGET_CONFIGURE`
    动作，如下例所示：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Activity also needs to be specified in the `AppWidgetProviderInfo` file
    using the configure attribute, as shown in this example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Activity 还需要在 `AppWidgetProviderInfo` 文件中使用 configure 属性指定，如下例所示：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `configure` attribute requires the fully qualified package name as this
    Activity will be called from outside of your application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 属性需要完全限定的包名，因为此 Activity 将从您的应用外部调用。'
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember, the `onUpdate()` method will not be called when using a configuration
    Activity. The configuration Activity is responsible for handling any initial setup,
    if required.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用配置 Activity 时不会调用 `onUpdate()` 方法。如果需要，配置 Activity 负责处理任何初始设置。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For App Widget Design Guidelines, visit Google''s page at: [http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关应用微件设计指南，请访问 Google 的页面：[http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)
- en: Adding Search to the Action Bar
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将搜索添加到操作栏
- en: Along with the Action Bar, Android 3.0 introduced the `SearchView` widget, which
    can be included as a menu item when creating a menu. This is now the recommended
    UI pattern to provide a consistent user experience.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作栏，Android 3.0 还引入了 `SearchView` 小部件，创建菜单时可以作为菜单项包含。这是现在推荐使用以提供一致用户体验的 UI
    模式。
- en: 'The following screenshot shows the initial appearance of the Search icon in
    the Action Bar:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了搜索图标在操作栏中的初始外观：
- en: '![Adding Search to the Action Bar](img/B05057_05_07.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![将搜索添加到操作栏](img/B05057_05_07.jpg)'
- en: 'This screenshot shows how the Search option expands when pressed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图展示了按下搜索选项时如何展开：
- en: '![Adding Search to the Action Bar](img/B05057_05_08.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![将搜索添加到操作栏](img/B05057_05_08.jpg)'
- en: If you want to add a Search functionality to your application, this recipe will
    walk you through the steps to set up your User Interface and properly configure
    the Search Manager API.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在应用中添加搜索功能，本指南将引导你完成设置用户界面和正确配置搜索管理器 API 的步骤。
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `SearchView`. Use the default
    **Phone & Tablet** options and select **Empty Activity** when prompted for the
    Activity Type.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，并将其命名为 `SearchView`。使用默认的 **Phone & Tablet** 选项，在选择
    Activity 类型时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up the Search UI pattern, we need to create the Search menu item and
    a resource called `searchable`. We''ll create a second activity to receive the
    search query. Then we''ll hook it all up in the `AndroidManifest` file. To get
    started, open the `strings.xml` file in `res/values` and follow these steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置搜索 UI 模式，我们需要创建一个搜索菜单项和一个名为 `searchable` 的资源。我们将创建第二个 Activity 以接收搜索查询。然后我们将在
    `AndroidManifest` 文件中连接所有内容。首先，打开 `res/values` 中的 `strings.xml` 文件，并按照以下步骤操作：
- en: 'Add the following string resources:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字符串资源：
- en: '[PRE47]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the menu directory: `res/menu`.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建菜单目录：`res/menu`。
- en: 'Create a new menu resource called `menu_options.xml` in `res/menu` using the
    following xml:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/menu` 中创建一个名为 `menu_options.xml` 的新菜单资源，使用以下 xml：
- en: '[PRE48]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Override `onCreateOptionsMenu()` to inflate the menu and set up the Search
    Manager as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onCreateOptionsMenu()` 以展开菜单并按以下方式设置搜索管理器：
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new xml resource directory: `res/xml`.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 xml 资源目录：`res/xml`。
- en: 'Create a new file in the `res/xml` called `searchable.xml` using the following
    xml:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/xml` 中创建一个名为 `searchable.xml` 的新文件，使用以下 xml：
- en: '[PRE50]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Crate a new layout called `activity_search_result.xml` using this xml:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此 xml 创建一个名为 `activity_search_result.xml` 的新布局：
- en: '[PRE51]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a new Activity called `SearchResultActivity`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SearchResultActivity` 的新 Activity。
- en: 'Add the following variable to the class:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下变量：
- en: '[PRE52]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change the `onCreate()` to load our layout, set the TextView and check for
    the `QUERY` action:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onCreate()` 方法改为加载我们的布局，设置 TextView 并检查 `QUERY` 动作：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following method to handle the search:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来处理搜索：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the User Interface and code now complete, we just need to hook everything
    up correctly in the `AndroidManifest`. Here is the complete manifest including
    both activities:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 界面和代码现在已完成，我们只需要在 `AndroidManifest` 中正确地连接所有内容。以下是包含两个活动的完整 manifest：
- en: '[PRE55]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the application on a device or emulator. Type in a search query and hit
    the **Search** button (or press enter). The `SearchResultActivity` will display
    showing the search query entered.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。输入搜索查询并点击**搜索**按钮（或按回车键）。`SearchResultActivity`将显示，并展示输入的搜索查询。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Since the New Project Wizard uses the `AppCompat` library, our example uses
    the support library API. Using the support library provides the greatest device
    compatibility as it allows the use of modern features (such as the Action Bar)
    on older versions of the Android OS. This can sometimes provide an extra challenge
    as often the official documentation focuses on the framework API. Though usually
    the support library closely follows the framework API, they are not always interchangeable.
    The Search UI pattern is one of those situations, so it's worth paying extra attention
    to the steps outlined previously.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新建项目向导使用了`AppCompat`库，我们的示例使用了支持库API。使用支持库可以提供最大的设备兼容性，因为它允许在旧版本的Android OS上使用现代功能（如操作栏）。这有时可能会带来额外的挑战，因为官方文档通常关注的是框架API。尽管支持库通常紧跟框架API，但它们并不总是可以互换的。搜索UI模式就是这样的情况，因此值得对之前概述的步骤给予更多关注。
- en: We start by creating string resources for the `searchable`, as declared in Step
    6.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从为`searchable`创建字符串资源开始，如第6步中声明的那样。
- en: In Step 3, we create the menu resource, as we've done many times. One difference
    is that we use the `app` namespace for the `showAsAction` and `actionViewClass`
    attributes. The earlier versions of the Android OS don't include these attributes
    in their Android namespace. This serves as a way to bring new functionality to
    older versions of the Android OS
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们创建菜单资源，就像我们之前多次做的那样。一个不同点是，我们为`showAsAction`和`actionViewClass`属性使用`app`命名空间。早期版本的Android
    OS在其Android命名空间中不包括这些属性。这可以作为将新功能引入旧版本Android OS的一种方式。
- en: In Step 4, we set up the `SearchManager`, again using the support library APIs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们设置了`SearchManager`，同样使用了支持库API。
- en: Step 6 is where we define the `searchable`, which is an xml resource used by
    the `SearchManager`. The only required attribute is the `label`, but the `hint`
    is recommended so the user will have an idea of what they should type in the field.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步是定义`searchable`的地方，这是一个由`SearchManager`使用的xml资源。唯一必需的属性是`label`，但建议使用`hint`，以便用户了解他们应该在字段中输入什么。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `android:label` must match the application name or the activity name and
    must use a string resource (as it does not work with a hard-coded string).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:label`必须与应用程序名称或活动名称相匹配，并且必须使用字符串资源（因为它不适用于硬编码的字符串）。'
- en: Steps 7-11 are for the `SearchResultActivity`. Calling a second activity is
    not a requirement of the `SearchManager`, but is commonly done to provide a single
    activity for all searches initiated in your application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第7-11步是针对`SearchResultActivity`的。调用第二个活动不是`SearchManager`的要求，但通常这样做是为了为应用程序中启动的所有搜索提供一个单一的活动。
- en: 'If you ran the application at this point, you would see the search icon, but
    nothing would work. Step 12 is where we put it all together in the `AndroidManifest`
    file. The first item to note is the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此刻运行应用程序，您将看到搜索图标，但没有任何功能可以使用。第12步是我们将所有内容在`AndroidManifest`文件中整合在一起的地方。首先要注意的是以下内容：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice this is in the application element and not in either of the `<activity>`
    elements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是在应用程序元素中，而不是在任一`<activity>`元素中。
- en: 'We specify the searchable resource in the `SearchResultActivity <meta-data>`
    element:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SearchResultActivity <meta-data>`元素中指定可搜索的资源：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also need to set the intent filter for `SearchResultActivity` as we do here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`SearchResultActivity`设置意图过滤器，就像这里做的那样：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `SearchManager` broadcasts the `SEARCH` intent when the user initiates
    the search. This declaration directs the intent to the `SearchResultActivity`
    activity. Once the search is triggered, the query text is sent to the `SearchResultActivity`
    using the `SEARCH` intent. We check for the `SEARCH` intent in the `onCreate()`
    and extract the query string using the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发起搜索时，`SearchManager`会广播`SEARCH`意图。此声明将意图指向`SearchResultActivity`活动。一旦触发搜索，查询文本就会通过`SEARCH`意图发送到`SearchResultActivity`。我们在`onCreate()`中检查`SEARCH`意图，并使用以下代码提取查询字符串：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You now have the Search UI pattern fully implemented. With the UI pattern complete,
    how you handle the search is specific to your application needs. Depending on
    your application, you might search a local database or maybe a web service.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完全实现了搜索UI模式。UI模式完成后，如何处理搜索取决于你的应用需求。根据你的应用，你可能要搜索本地数据库，或者可能是网络服务。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To take your search to the Internet, see *Internet queries* in [Chapter 12](ch12.html
    "Chapter 12. Telephony, Networks, and the Web"), *Telephony, Networks, and the
    Web*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在互联网上进行搜索，请查看[第12章](ch12.html "第12章. 电信、网络和Web")中的*互联网查询*，*电信、网络和Web*。
- en: Showing your app full screen
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示应用全屏
- en: 'Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike
    the previous full screen flag, your app receives all the touch events while in
    Immersive Mode. This mode is ideal for certain activities, such as reading books
    and news, full-screen drawing, gaming, or watching a video. There are several
    different approaches to full screen, and each have a best use case:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.4（API 19）引入了一个名为沉浸模式的UI特性。与之前的全屏标志不同，应用在沉浸模式下接收所有触摸事件。这种模式非常适合某些活动，如阅读书籍和新闻、全屏绘图、游戏或观看视频。实现全屏有几种不同的方法，每种方法都有最佳使用场景：
- en: 'Reading books/articles, and so on: Immersive Mode with easy access to the system
    UI'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读书籍/文章等：带有便捷访问系统UI的沉浸模式
- en: 'Game/Drawing app: Immersive Mode for full screen use but minimal system UI'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏/绘图应用：沉浸模式用于全屏使用但系统UI最小化
- en: 'Watching video: Full screen and normal system UI'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看视频：全屏和正常系统UI
- en: The key difference between the modes is how the System UI responds. In the first
    two scenarios, your app is expecting user interaction, so the System UI is hidden
    to make it easier for your user (such as not hitting the back button while playing
    a game). While using full screen with a normal system UI, such as watching a video,
    you wouldn't expect your user to use the screen at all, so when they do, the system
    UI should respond normally. In all modes, the user can bring back the System UI
    with a swipe inward across the hidden System Bar.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式的主要区别在于系统UI的响应方式。在前两种场景中，应用期望用户交互，因此隐藏系统UI以便用户更容易操作（例如，在玩游戏时不会误按返回按钮）。而在使用带有正常系统UI的全屏观看视频时，你不会期望用户操作屏幕，所以当用户操作时，系统UI应该正常响应。在所有模式下，用户可以通过在隐藏的系统栏内向内滑动来调出系统UI。
- en: 'Since watching a video doesn''t require the new **Immersive Mode**, full-screen
    mode can be achieved using the two flags: `SYSTEM_UI_FLAG_FULLSCREEN` and `SYSTEM_UI_FLAG_HIDE_NAVIGATION`,
    available since Android 4.0 (API 14).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于观看视频不需要新的**沉浸模式**，可以使用两个标志`SYSTEM_UI_FLAG_FULLSCREEN`和`SYSTEM_UI_FLAG_HIDE_NAVIGATION`实现全屏模式，这两个标志自Android
    4.0（API 14）起可用。
- en: Our recipe will demonstrate setting up Immersive Mode. We're also going to add
    the ability to toggle the System UI with a tap on the screen.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的教程将演示如何设置沉浸模式。我们还将添加通过在屏幕上轻敲来切换系统UI的功能。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `ImmersiveMode`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for the **Activity Type**. When selecting the **Minimum API Level**, choose **API
    19** or higher.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，名为`ImmersiveMode`。使用默认的**手机 & 平板**选项，在选择**活动类型**时选择**空活动**。在选择**最低API级别**时，选择**API
    19**或更高。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll create two functions for handling the system UI visibility, then we''ll
    create a gesture listener to detect the screen tap. All the steps for this recipe
    are adding code to `MainActivity.java`, so open the file and let''s begin:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个处理系统UI可见性的函数，然后我们将创建一个手势监听器来检测屏幕轻敲。这个食谱的所有步骤都是向`MainActivity.java`添加代码，所以打开文件，让我们开始吧：
- en: 'Add the following method to hide the System UI:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以隐藏系统UI：
- en: '[PRE60]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add the following method to show the System UI:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以显示系统UI：
- en: '[PRE61]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the following class variable:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类变量：
- en: '[PRE62]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following `GestureListener` class at the class level, below the previous
    class variable:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类级别的先前类变量下方，添加以下`GestureListener`类：
- en: '[PRE63]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Override the `onTouchEvent()` callback with the following:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容重写`onTouchEvent()`回调：
- en: '[PRE64]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following code to the `onCreate()` method to set the `GestureListener`
    and hide the System UI:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中添加以下代码，以设置`GestureListener`和隐藏系统UI：
- en: '[PRE65]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Run the application on a device or emulator. Swiping inward across a hidden
    System Bar will show the System UI. Tapping the screen will toggle the System
    UI.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用。向内滑动隐藏的系统栏将显示系统界面。轻触屏幕将切换系统界面。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create the `showSystemUI()` and `hideSystemUI()` methods by using `setSystemUiVisibility()`
    on the application window. The flags we set (and don't set) control what is visible
    and what is hidden. When we set the visibility without the `SYSTEM_UI_FLAG_IMMERSIVE`
    flag, we in effect, disable Immersive Mode.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在应用窗口上使用`setSystemUiVisibility()`来创建`showSystemUI()`和`hideSystemUI()`方法。我们设置的标志（以及不设置的标志）控制着哪些是可见的，哪些是隐藏的。当我们不带有`SYSTEM_UI_FLAG_IMMERSIVE`标志设置可见性时，实际上，我们禁用了沉浸模式。
- en: If all we wanted to do was hide the System UI, we could just add `hideSystemUI()`
    to `onCreate()` and we'd be done. The problem is it wouldn't stay hidden. Once
    the user exited Immersive Mode, it would stay in the regular display mode. That's
    why we created the `GestureListener`. (We'll discuss gestures again in [Chapter
    8](ch08.html "Chapter 8. Using the Touchscreen and Sensors"), *Using the Touchscreen
    and Sensors*.) Since we only want to respond to the `onSingleTapUp()` gesture,
    we don't implement the full range of gestures. When `onSingleTapUp` is detected,
    we toggle the System UI.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想隐藏系统界面，我们可以在`onCreate()`中添加`hideSystemUI()`就完成了。问题是它不会保持隐藏。一旦用户退出沉浸模式，它将保持常规显示模式。这就是为什么我们创建了`GestureListener`。（我们将在[第8章](ch08.html
    "第8章. 使用触摸屏和传感器")，*使用触摸屏和传感器*中再次讨论手势。）由于我们只想响应`onSingleTapUp()`手势，所以我们没有实现全套手势。当检测到`onSingleTapUp`时，我们会切换系统界面。
- en: There's more...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s look at some of the other important tasks that can be performed:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他重要的任务：
- en: Sticky Immersion
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粘性沉浸
- en: There's another option we can use if we want the System UI to stay hidden automatically.
    Instead of using `SYSTEM_UI_FLAG_IMMERSIVE` to hide the UI, we can use `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望系统界面能自动保持隐藏，还有另一种选择。我们可以不使用`SYSTEM_UI_FLAG_IMMERSIVE`来隐藏界面，而是使用`SYSTEM_UI_FLAG_IMMERSIVE_STICKY`。
- en: Dimming the System UI
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 淡化系统界面
- en: If all you need is to reduce the visibility of the Navigation bar, there's also
    `SYSTEM_UI_FLAG_LOW_PROFILE` to dim the UI.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要减少导航栏的可见性，还可以使用`SYSTEM_UI_FLAG_LOW_PROFILE`来淡化界面。
- en: 'Use this flag with the same `setSystemUiVisibility()` call as the Immersive
    Mode flag:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个标志与沉浸模式标志相同的`setSystemUiVisibility()`调用：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Call `setSystemUiVisibility()` with 0 to clear all flags:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setSystemUiVisibility()`并传入0来清除所有标志：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Setting the Action Bar as an Overlay
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将操作栏设置为覆盖层
- en: 'If you just need to hide or show the Action Bar, use these methods:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要隐藏或显示操作栏，请使用以下方法：
- en: '[PRE68]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'One problem with this approach is that the system resizes the layout each time
    either method is called. Instead, you might want to consider using a theme option
    to make the System UI behave as an overlay. To enable overlay mode, add the following
    to the theme:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，每次调用这两个方法时，系统都会调整布局的大小。相反，你可能需要考虑使用主题选项使系统界面表现为覆盖层。要启用覆盖模式，请在主题中添加以下内容：
- en: '[PRE69]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Translucent system bars
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明的系统栏
- en: 'These two themes enable the translucent settings:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主题启用了半透明设置：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If you are creating your own theme, use the following theme settings:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建自己的主题，请使用以下主题设置：
- en: '[PRE71]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: See also
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Recognizing a gesture* recipe in [Chapter 8](ch08.html "Chapter 8. Using
    the Touchscreen and Sensors"), *Using the Touchscreen and Sensors*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章. 使用触摸屏和传感器")，*使用触摸屏和传感器*中的*识别手势*部分。
