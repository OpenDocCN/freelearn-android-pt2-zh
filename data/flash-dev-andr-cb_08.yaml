- en: 'Chapter 8. Abundant Access: File System and Local Database'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 丰富的访问：文件系统和本地数据库
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Opening a local file from device storage
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备存储中打开本地文件
- en: Saving a file to device storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件保存到设备存储
- en: Saving data across sessions through Local Shared Object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过本地共享对象跨会话保存数据
- en: Storing application state automatically by using Flex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flex自动保存应用程序状态
- en: Creating a local SQLite database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本地SQLite数据库
- en: Providing a default application database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供默认的应用程序数据库
- en: Automating database tasks with FlexORM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FlexORM自动化数据库任务
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Many file system attributes are shared between desktop and mobile, yet there
    are specific use cases on Android devices for handling application state preservation
    in case of session interruption, or to simply preserve data across sessions. This
    chapter will cover tips for loading and saving individual files, creating and
    managing local databases, dealing with local shared objects, and preserving navigation
    state using the mobile Flex framework.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件系统属性在桌面和移动设备之间是共享的，但在处理应用程序状态保存以应对会话中断，或者简单地在会话之间保存数据时，Android设备上有特定的使用场景。本章将介绍加载和保存单个文件、创建和管理本地数据库、处理本地共享对象以及使用移动Flex框架保存导航状态的技巧。
- en: Opening a local file from device storage
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从设备存储中打开本地文件
- en: Oftentimes, we may want to read certain files from the application storage or
    from some other location on our Android device. In the following example, we will
    perform this action upon a simple text file, but this can also be used to read
    in all sorts of files from image data to encoded `MP3` audio bytes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能需要从应用程序存储或Android设备上的其他位置读取某些文件。在以下示例中，我们将对简单的文本文件执行此操作，但这也可用于读取各种文件，从图像数据到编码的`MP3`音频字节。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Employ a variety of classes within the `flash.filesystem` package to open local
    file data within an application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用`flash.filesystem`包中的各种类来打开本地文件数据：
- en: 'First, we will need to import the following classes:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入以下类：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will now go about defining a set of constants and variables to be used throughout
    the application. Initialize a `String` constant to retain the file path, which
    will be used within the example. We will also require a `File` and accompanying
    `FileStream` in order to open the text file within our application, along with
    a `TextField` and `TextFormat` pair to serve as our final output display:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在开始定义一组在整个应用程序中使用的常量和变量。初始化一个`String`常量以保留文件路径，该路径将在示例中使用。我们还需要一个`File`和一个相应的`FileStream`以在应用程序中打开文本文件，以及一个`TextField`和`TextFormat`对作为我们的最终输出显示：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To actually open the file within our application, we will first instantiate
    our `File` object and assign it to the current application directory through `File.applicationDirectory`.
    We can then specify a file within that location by passing in the constant, which
    declares it through the `File.resolvePath()` method.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，为了在应用程序中打开文件，我们首先会实例化我们的`File`对象，并通过`File.applicationDirectory`将其分配给当前应用程序目录。然后，我们可以通过传递常量并使用`File.resolvePath()`方法指定该位置中的文件。
- en: The second portion of this process involves instantiating a `FileStream`, which
    will allow us to perform the remainder of our processes. Register an event listener
    of type `Event.COMPLETE` upon the `FileStream`. Finally, invoke `FileStream.openAsync()`
    passing in the previously defined `File` as the first parameter followed by the
    `FileMode`. We are going to simply read in the bytes of this file, so use `FileMode.READ:`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此过程的第二部分涉及实例化一个`FileStream`，这将使我们能够执行余下的流程。在`FileStream`上注册一个类型为`Event.COMPLETE`的事件监听器。最后，调用`FileStream.openAsync()`，传入先前定义的`File`作为第一个参数，然后是`FileMode`。我们只是要读取这个文件的字节，因此使用`FileMode.READ`：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the `FileStream` has completed its work, our `fileOpened` method will
    fire, allowing us to read in the `File` bytes as plain text (specified by `File.systemCharset)`
    and assign the text to our `TextField`. Whenever we are finished working with
    a `FileStream` object, we must invoke `close()` upon it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`FileStream`完成了工作，我们的`fileOpened`方法将被触发，允许我们以纯文本（由`File.systemCharset`指定）读取`File`字节并将其分配给我们的`TextField`。每当我们完成与`FileStream`对象的操作时，我们必须调用它的`close()`方法：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we compile and run our application upon a device, it should appear as follows:![How
    to do it...](img/1420_08_01.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上编译并运行应用程序时，它应该如下所示：![如何操作...](img/1420_08_01.jpg)
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We can open a file within our application by creating a `File` reference and
    opening that reference through a `FileStream`. Once the process is complete, we
    can then work with the contents of the file itself, either through direct assignment
    or through the processing of the bytes within. In this example, we are reading
    in the contents of a text file and outputting that to a basic `TextField` in our
    application. The `FileStream` class has many different methods and properties,
    which can be used more or less effectively on different file types and processes.
    For example, we use the `FileStream.openAsync()` method here to actually open
    the `FileStream`. We could have also used use the `FileStream.open()` method just
    as well, but using `openAsync()` will allow us to employ an event listener so
    that we can react to the data that is loaded with confidence. The important thing
    is to read up on these through the documentation and use what is best for your
    particular situation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个`File`引用，并通过`FileStream`打开该引用，在应用程序中打开一个文件。这个过程完成后，我们可以通过直接赋值或处理加载的字节来处理文件本身的内容。在这个例子中，我们读取文本文件的内容并将其输出到应用程序中的基本`TextField`。`FileStream`类有许多不同的方法和属性，可以更有效地用于不同类型的文件和处理过程。例如，我们在这里使用`FileStream.openAsync()`方法实际打开`FileStream`。我们同样也可以使用`FileStream.open()`方法，但使用`openAsync()`将允许我们使用事件监听器，以便我们可以自信地处理加载的数据。重要的是要阅读这些文档，并选择最适合您特定情况的操作。
- en: 'There are a number of static properties that we can leverage with the `flash.filesystem.File`
    class for quick access to a variety of storage locations. These are listed as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`flash.filesystem.File`类的静态属性，快速访问各种存储位置。以下是这些属性的列表：
- en: '`File.applicationStorageDirectory:` Unique application storage directory [read/write]'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.applicationStorageDirectory:` 独特的应用程序存储目录[读写]'
- en: '`File.applicationDirectory:` Application installation directory [read only]'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.applicationDirectory:` 应用程序安装目录[只读]'
- en: '`File.desktopDirectory:` Maps to the SD card root[read/write]'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.desktopDirectory:` 映射到SD卡根目录[读写]'
- en: '`File.documentsDirectory:` Maps to the SD card root[read/write]'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.documentsDirectory:` 映射到SD卡根目录[读写]'
- en: '`File.userDirectory:` Maps to the SD card root[read/write]'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.userDirectory:` 映射到SD卡根目录[读写]'
- en: 'For a comprehensive look at the `File` class, please refer to the Adobe LiveDocs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解`File`类，请参考Adobe LiveDocs：
- en: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html)'
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While we are opening a text file in this example, any file can be opened and
    processed in a similar fashion. However, reading the bytes of a complex file type
    can be incredibly difficult if you do not have a good background on how such things
    work, and for larger files, the process can be slow on mobile devices due to the
    amount of processing you may be performing upon the loaded bytes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开了一个文本文件，但任何文件都可以以类似的方式打开和处理。然而，如果你没有良好的背景知识来了解这些文件是如何工作的，读取复杂文件类型的字节可能会非常困难，对于较大的文件，由于你可能对加载的字节执行了大量处理，在移动设备上这个过程可能会很慢。
- en: Saving a file to device storage
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件保存到设备存储
- en: There are a number of ways in which we can save data from an application to
    local device storage. Audio, images, and text data can all be created by the user
    and saved to either an application-defined location, or the user can be allowed
    to choose, which specific location to store the file upon within an Android device.
    In this example, we will demonstrate this through the generation of a simple text
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以将应用程序中的数据保存到本地设备存储中。音频、图像和文本数据都可以由用户创建，并保存到应用程序定义的位置，或者允许用户选择在Android设备中的特定位置保存文件。在这个例子中，我们将通过生成一个简单的文本文件来演示这一点。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will allow the user to select the location and name of a basic text file
    that they will generate within our application and save to their Android device:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许用户在我们的应用程序内选择基本文本文件的位置和名称，并将其保存到他们的Android设备上：
- en: 'First, we will need to import the following classes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入以下类：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will need to declare a number of objects for use within this application.
    A `String` constant will serve to define our file name. Next, we declare a `File`
    object, which will be used eventually to save our text file to disk. A `TextField`
    and `TextFormat` pair will relay text messages onto the device display. Finally,
    declare a `Sprite` as our interactive element, along with an additional `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们需要声明多个对象。一个`String`常量将用于定义我们的文件名。接下来，我们声明一个`File`对象，最终用于将我们的文本文件保存到磁盘。一个`TextField`和`TextFormat`组合将把文本信息传递到设备显示上。最后，声明一个`Sprite`作为我们的交互元素，以及一个额外的`TextField`和`TextFormat`组合作为按钮标签：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we will continue to set up our `TextField`, apply a `TextFormat`, and add
    it to the `DisplayList`. Here, we create a method to perform all of these actions
    for us. Be sure to set the `TextField.type` to `input` in order to allow the user
    to type!
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来为我们执行所有这些操作。确保将`TextField.type`设置为`input`，以允许用户输入！
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now; we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个带有简单背景填充的`Sprite`。我们按钮构建的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。这里，我们创建一个方法来为我们执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we run our application, we can see how everything lays out on the display.
    We can also, at this point, freely edit the `TextField`, which serves as input
    for our text file:![How to do it...](img/1420_08_02.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们可以看到所有内容在显示上的布局情况。在这一点上，我们也可以自由编辑`TextField`，它作为我们文本文件的输入：![如何操作...](img/1420_08_02.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`分配给通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸轻触事件，并调用一个名为`onTouchTap`的方法，其中包含我们的其余逻辑：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As the user interacts with the application and performs a touch tap upon the
    button to save any text input as a file, the following method is fired. Within
    this function, we first create a new `File` object and register an event listener
    of type `Event.COMPLETE` before invoking `File.save()`. The `File.Save()` method
    expects two arguments, the contents of the file to create, and the name of the
    file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户与应用程序交互并在按钮上轻触以将任何文本输入保存为文件时，将触发以下方法。在这个函数中，我们首先创建一个新的`File`对象，并在调用`File.save()`之前注册一个类型为`Event.COMPLETE`的事件监听器。`File.Save()`方法需要两个参数：要创建的文件内容以及文件名称：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the user inputs some text and hits the button to save it as a file, Android
    will produce an overlay requesting confirmation to perform the save. The user,
    at this point, can rename the file or save to an alternate location. By default,
    the file is saved to the root of the device SD card. If we want to avoid a save
    dialog, we can employ a `flash.filesystem.FileStream` class to do so:![How to
    do it...](img/1420_08_03.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户输入一些文本并点击按钮将其保存为文件，Android将产生一个覆盖层，请求确认执行保存操作。此时，用户可以重命名文件或选择其他位置保存。默认情况下，文件保存在设备SD卡的根目录中。如果我们想避免保存对话框，可以采用`flash.filesystem.FileStream`类来实现：![如何操作...](img/1420_08_03.jpg)
- en: 'Once the save has completed successfully, we can remove our event listeners,
    clear out the input `TextField` and change the button label `TextField` to let
    the user know everything has saved correctly:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存成功完成后，我们可以移除事件监听器，清除输入的`TextField`并将按钮标签`TextField`更改为让用户知道一切已正确保存：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following image illustrates what the user will see upon a successful save:![How
    to do it...](img/1420_08_04.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下图展示了用户在成功保存后将会看到的内容：![如何操作...](img/1420_08_04.jpg)
- en: The user can now use a file browser or some other application to open the text
    file within the default Android text viewer, as seen in the following screenshot:![How
    to do it...](img/1420_08_05.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户现在可以使用文件浏览器或其他应用程序在默认的Android文本查看器中打开文本文件，如下面的截图所示：![如何操作...](img/1420_08_05.jpg)
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Writing a plain text file to the device storage is fairly straightforward. The
    process involves creating a `File` object and then invoking the `save()` method
    upon that object. Using this method, we pass over the contents of the file to
    save, along with the desired file name. Note that while we are passing over simple
    text in this case, we can also save bytes in the form of audio files or images.
    If we require more control over the entire process, we can also use a `FileStream`
    object to set various encodings and write the bytes in a greater variety of ways.
    Using a `FileStream` will also allow us to append a previously created file with
    new information, and avoids the save dialog seen in this example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将纯文本文件写入设备存储相当直接。这个过程涉及创建一个`File`对象，然后调用该对象的`save()`方法。使用此方法，我们传递要保存的文件内容以及所需的文件名。请注意，虽然在这种情况下我们传递的是简单文本，但我们也可以保存音频文件或图像形式的字节。如果我们需要对整个过程进行更多控制，我们还可以使用`FileStream`对象来设置各种编码，并以更多方式写入字节。使用`FileStream`还可以让我们将新信息追加到先前创建的文件中，并且避免了本例中出现的保存对话框。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You will need to provide any application which writes local files access to
    write to the local file system through the Android manifest file. For more information
    on this, see [Chapter 9](ch09.html "Chapter 9. Manifest Assurance: Security and
    Android Permissions"), *Manifest Assurance: Security and Android Permissions.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为任何写入本地文件的应用程序提供访问本地文件系统的权限，通过Android的清单文件进行设置。关于这方面的更多信息，请参见[第9章](ch09.html
    "第9章. 清单保证：安全与Android权限")，*清单保证：安全与Android权限。*
- en: Saving data across sessions through local shared object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过本地共享对象跨会话保存数据
- en: Shared objects have been used for years in browser-based Flash applications.
    They are sometimes referred to as "Flash Cookies" or "Super Cookies" and do provide
    much of the same functionality as normal browser-based cookies, but are tailored
    more to the Flash environment. Normally explicit permissions are needed to save
    such data using a Flash application on the web; however, using AIR frees us of
    many of these restrictions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象在基于浏览器的Flash应用程序中已经使用了多年。它们有时被称为“Flash Cookies”或“超级Cookies”，并提供与基于浏览器的普通Cookies类似的许多功能，但更适合Flash环境。通常，使用Web上的Flash应用程序保存此类数据需要明确的权限；然而，使用AIR使我们摆脱了这些限制中的许多。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a local `SharedObject` to preserve specific application data across
    sessions. We will use an interactive `Sprite` to illustrate this visually:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个本地`SharedObject`以在会话之间保存特定的应用程序数据。我们将使用一个交互式`Sprite`来直观地说明这一点：
- en: 'First, we will need to import the following classes:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入以下类：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we will need to declare a number of objects for use within this application.
    Declare a `SharedObject`, which will be used to preserve session data. The `Point`
    object will be used to write coordinates onto the `SharedObject`. A `Sprite` will
    serve as the user interaction element and visual reference for this example. Finally,
    declare a `TextField` and `TextFormat` pair to relay text messages onto the device
    display:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要声明一些在此应用程序中使用的对象。声明一个 `SharedObject`，用于保存会话数据。`Point` 对象将用于将坐标写入 `SharedObject`。`Sprite`
    将作为用户交互元素和此示例的视觉参考。最后，声明一个 `TextField` 和 `TextFormat` 对，用于在设备显示屏上传递文本消息。
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的 `TextField`，应用 `TextFormat`，并将其添加到 `DisplayList` 中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will need to set up an interactive object for the user to move around based
    on touch. The coordinates of this object will eventually be preserved across application
    sessions. Let''s create a basic circular `Sprite` with the graphics API:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置一个交互式对象，让用户根据触摸移动它，这个对象的坐标最终将在应用程序会话之间保留。让我们使用图形 API 创建一个基本的圆形 `Sprite`。
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before moving too far into this example, we must perform some actions upon the
    `SharedObject` we've declared. First, invoke `SharedObject.getLocal("airandroid")`
    upon our `SharedObject` instance. This will read in the `SharedObject` called
    `airandroid`, if it exists. If the `SharedObject` does not yet exist, this invocation
    will create it for us.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在深入这个示例之前，我们必须对我们声明的 `SharedObject` 执行一些操作。首先，在我们的 `SharedObject` 实例上调用 `SharedObject.getLocal("airandroid")`。如果存在名为
    `airandroid` 的 `SharedObject`，这将读取它；如果 `SharedObject` 尚不存在，这个调用将为我们创建它。
- en: Now we can check to see whether the `ballPoint` object exists within the `SharedObjectdata`
    property. If so, this means we have gone through and completed a session previously
    and can assign the `ballPoint x` and `y` properties to our `ballSprite:`
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以检查 `SharedObjectdata` 属性中是否存在 `ballPoint` 对象。如果是这样，这意味着我们之前已经完成了一个会话，可以将
    `ballPoint x` 和 `y` 属性赋给我们的 `ballSprite`。
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we run the application for the first time, we are told that no shared object
    is detected and the ball is placed in the default position:![How to do it...](img/1420_08_06.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次运行应用程序时，我们会被告知没有检测到共享对象，并且球被放置在默认位置：![如何操作...](img/1420_08_06.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register two event listeners
    of type `TouchEvent.TOUCH_MOVE` and `TouchEvent.TOUCH_END` upon the circular `Sprite`.
    This will detect any touch events initiated by the user and invoke certain methods
    to deal with each:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将 `Multitouch.inputMode` 设置为通过 `MultitouchInputMode.TOUCH_POINT` 常量响应原始触摸事件。在圆形
    `Sprite` 上注册两个类型为 `TouchEvent.TOUCH_MOVE` 和 `TouchEvent.TOUCH_END` 的事件监听器。这将检测用户发起的任何触摸事件，并调用特定方法来处理每一个。
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As `TouchEvent.TOUCH_MOVE` events are detected upon our `Sprite`, the `onTouchMove`
    method fires, allowing us to change the `x` and `y` coordinates of the `Sprite`
    to allow the user to drag it around the `Stage:`
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在我们的 `Sprite` 上检测到 `TouchEvent.TOUCH_MOVE` 事件时，`onTouchMove` 方法将被触发，使我们能够改变
    `Sprite` 的 `x` 和 `y` 坐标，从而允许用户在 `Stage` 上拖动它。
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When our application detects a `TouchEvent.TOUCH_END` event upon the `Sprite`
    object, we will use this opportunity to wrap the `Sprite x` and `y` coordinates
    in a `Point` object, and assign it to our `SharedObject`. To perform this action,
    we first assign the `Sprite` coordinates to our `Point` object, which is then
    assigned to our `SharedObjectdata` property.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的应用程序在 `Sprite` 对象上检测到 `TouchEvent.TOUCH_END` 事件时，我们将利用这个机会将 `Sprite x` 和
    `y` 坐标包装在一个 `Point` 对象中，并将其赋值给我们的 `SharedObject`。为了执行这个操作，我们首先将 `Sprite` 坐标赋给我们的
    `Point` 对象，然后将其赋给我们的 `SharedObjectdata` 属性。
- en: 'In order to write the `SharedObject` to the local file system, we must invoke
    `SharedObject.flush()`. We can assign the `flush()` commands return value to a
    `String` in order to monitor and respond to its status. In this example, we simply
    use a switch/case statement to check `SharedObjectFlushStatus` and write a message
    into our `TextField`, letting the user know what is happening:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将 `SharedObject` 写入本地文件系统，我们必须调用 `SharedObject.flush()`。我们可以将 `flush()` 命令的返回值赋给一个
    `String`，以便监控和响应其状态。在这个示例中，我们仅使用 switch/case 语句检查 `SharedObjectFlushStatus` 并在我们的
    `TextField` 中写入一条消息，让用户知道正在发生的情况。
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The user can now interact with the ball by touching and moving it around the
    display. When the user stops interacting with the ball, these coordinates are
    saved to our local shared object:![How to do it...](img/1420_08_07.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户现在可以通过触摸并移动球体来与球体互动。当用户停止与球体互动时，这些坐标会被保存到我们的本地共享对象中：![如何操作...](img/1420_08_07.jpg)
- en: Note
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the user exists and at some future time opens the application again, the
    local shared object is read in and the ball is repositioned based upon this preserved
    data. In order to truly test this upon a device, a developer will need to kill
    the application using the application management features under the Android **Settings**
    menu, or employ a third party "task killer" to ensure the application is completely
    stopped.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户存在，并且在将来的某个时间再次打开应用程序，本地共享对象将被读取，并根据这些保留的数据重新定位球体。为了在设备上真正测试这一点，开发者需要使用Android
    **设置**菜单下的应用程序管理功能来结束应用程序，或者使用第三方“任务杀手”以确保应用程序完全停止。
- en: '![How to do it...](img/1420_08_08.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1420_08_08.jpg)'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `SharedObject` in Flash is a lot like the cookie implementation used in web
    browsers. It was initially implemented in browser-based Flash to allow for a similar
    experience when developers wanted to preserve small pieces of data across user
    sessions. Luckily, this also works in AIR and cam be used as simple storage within
    our Android applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Flash中的`SharedObject`与网络浏览器中使用的cookie实现非常相似。它最初在基于浏览器的Flash中实现，以便当开发人员希望跨用户会话保留小块数据时，能够提供类似的体验。幸运的是，这在AIR中同样有效，并可以作为我们Android应用程序中的简单存储使用。
- en: To read a `SharedObject`, simply invoke the `getLocal()` method upon it, passing
    in the name of the `SharedObject` we wish to retrieve. To save a `SharedObject`,
    we assign it with new data and invoke the `flush()` method, which saves the new
    information to disk.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取`SharedObject`，只需调用它的`getLocal()`方法，传入我们希望检索的`SharedObject`的名称。要保存`SharedObject`，我们为其分配新数据并调用`flush()`方法，该方法将把新信息保存到磁盘。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We use a local `SharedObject` in this instance, but could also save such data
    to a local or remote database, a text or XML file, or even use a remote `SharedObject`
    depending upon our needs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中我们使用了一个本地`SharedObject`，但也可以根据需要将此类数据保存到本地或远程数据库、文本或XML文件，甚至使用远程`SharedObject`。
- en: Storing application state automatically by using Flex
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flex自动存储应用程序状态
- en: While there are many times in which we will need to store specific application
    parameters in the case that our session is interrupted by other device functions
    (such as an incoming phone call), the mobile Flex framework does provide a good
    level of session preservation, which can be handled automatically for us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很多时候我们需要在会话被其他设备功能（如来电）中断时存储特定的应用程序参数，但移动Flex框架确实提供了一定程度的会话保留，这可以自动为我们处理。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Instruct Flex to preserve application state for us automatically by enabling
    `persistNavigatorState:`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用`persistNavigatorState`，指示Flex自动为我们保留应用程序状态：
- en: 'We will first set up a new mobile Flex project with two views, these we simply
    call `first` and `second`. Our initial `ViewNavigatorApplication` file will appear
    as such:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先会创建一个新的移动Flex项目，其中包含两个视图，我们将其简称为`first`和`second`。初始的`ViewNavigatorApplication`文件将如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a button to our `first` view that will enable us to push the `second` view
    from there:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`first`视图中添加一个按钮，这将使我们能够从那里推送`second`视图：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a button to our `second` view allowing us to return to the `first` view.
    Now we can navigate back and forth, building up our `ViewNavigator` history:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`second`视图中添加一个按钮，允许我们返回到`first`视图。现在我们可以来回导航，构建我们的`ViewNavigator`历史记录：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to allow Flex to preserve both our `ViewNavigator` history and retain
    our current place within that history in the event that our session is interrupted,
    we will modify the `ViewNavigatorApplication` to include an attribute called `persistNavigatorState`
    and we will set this to `true`. Let''s also declare a `creationComplete` event,
    which will invoke a function called `init()`. We will use this to set up some
    additional functionality:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让Flex在会话被中断的情况下既保存我们的`ViewNavigator`历史记录，又保留我们在该历史记录中的当前位置，我们将修改`ViewNavigatorApplication`以包含一个名为`persistNavigatorState`的属性，并将其设置为`true`。我们还将声明一个`creationComplete`事件，它将调用一个名为`init()`的函数。我们将使用它来设置一些额外的功能：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `Script` tag within the MXML and import the `FlexEvent` class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MXML中创建一个`Script`标签，并导入`FlexEvent`类：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we must declare our `init()` method, which will be invoked upon `creationComplete`.
    Within this method, we will register an event listener of type `FlexEvent.NAVIGATOR_STATE_SAVING`
    on our application:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须声明我们的`init()`方法，该方法将在`creationComplete`时被调用。在这个方法中，我们将在应用程序上注册一个类型为`FlexEvent.NAVIGATOR_STATE_SAVING`的事件监听器：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever our application begins to save the application state upon application
    exit through the Flex persistence manager, our `stateSaving` method will fire,
    allowing us to perform additional actions, or even invoke `preventDefault()` upon
    the `FlexEvent` to allow our own logic to take command before exiting. In development
    and testing, we can easily place a breakpoint within this method in order to introspect
    our application state.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当应用程序在退出时通过Flex持久化管理器开始保存应用程序状态时，我们的`stateSaving`方法将被触发，允许我们执行额外的操作，甚至可以在`FlexEvent`上调用`preventDefault()`，以便在退出之前让我们的逻辑接管。在开发和测试中，我们可以轻松在这个方法中设置断点，以便检查应用程序状态。
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we compile and run our application, it will appear as shown in the next
    screenshot. Flipping from our first to second view and back a number of times
    will populate the application `ViewNavigator` history:![How to do it...](img/1420_08_09.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们编译并运行我们的应用程序时，它将显示在下个截图中所示的样子。从我们的第一个视图翻到第二个视图，并来回多次，将填充应用程序`ViewNavigator`的历史记录：![如何操作...](img/1420_08_09.jpg)
- en: If our application session is interrupted by a phone call, or some other event,
    the navigation history and current view will be preserved. When the application
    is run again, the user will be able to continue exactly where the interruption
    occurred:![How to do it...](img/1420_08_10.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序会话被电话或其他事件中断，导航历史和当前视图将被保留。当再次运行应用程序时，用户将能够从中断发生的地方继续操作：![如何操作...](img/1420_08_10.jpg)
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: When using the mobile Flex framework, we have the option of enabling `persistNavigatorState`
    within the application. This will automatically preserve our `ViewNavigator` history,
    as well as remember which view we were interacting with upon application session
    interruption. It does this by saving session information to a local Shared Object
    on the device. The data which is saved includes information about the application
    version number, the full navigation stack, and the current navigation view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用移动Flex框架时，我们可以在应用程序中启用`persistNavigatorState`选项。这将自动保存我们的`ViewNavigator`历史记录，并记住在应用程序会话中断时我们正在交互的视图。它通过将会话信息保存到设备上的本地共享对象来实现这一点。保存的数据包括有关应用程序版本号、完整的导航堆栈和当前导航视图的信息。
- en: Additionally, we can intercept the `FlexEvent.NAVIGATOR_STATE_SAVING` event
    when the application begins to exit and perform our own desired actions in its
    place, such as saving critical application data to the file system, a Local Shared
    Object, or even an SQLite database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当应用程序开始退出时，我们可以拦截`FlexEvent.NAVIGATOR_STATE_SAVING`事件，并执行我们自己的期望操作，例如将关键应用程序数据保存到文件系统、本地共享对象，甚至是SQLite数据库。
- en: Creating a local SQLite database
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地SQLite数据库
- en: Adobe AIR has had support for embedded SQLite databases from the beginning.
    This is one of the best ways of storing structured information within our Android
    applications. SQLite is a software library that implements a self-contained, serverless,
    zero-configuration, transactional SQL database engine. The database files it creates
    are simply individual `.db` files, which can be transported across a network,
    copied, and deleted just like any other file type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe AIR从一开始就支持嵌入式SQLite数据库。这是我们在Android应用程序中存储结构化信息的最佳方式之一。SQLite是一个软件库，它实现了一个自包含、无服务器、零配置、事务性的SQL数据库引擎。它创建的数据库文件就是单独的`.db`文件，可以通过网络传输、复制和删除，就像其他任何文件类型一样。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a mobile application along with a local SQLite database, which
    can employ the SQL query language to allow the user access to add new records
    and run a simple query based upon these entries:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个带有本地SQLite数据库的移动应用程序，该程序可以使用SQL查询语言，允许用户添加新记录并基于这些条目运行简单查询：
- en: 'First, import the following classes necessary for this example:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入这个示例所需的以下类：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will need to declare a number of objects for use within this application.
    A `SQLConnection` will allow us to interact with a local SQLite database. The
    first `TextField` and `TextFormat` pair will serve as an input field for the user
    to type into. Another `TextField` and `TextFormat` pair will relay text messages
    onto the device display. Finally, declare a `Sprite` as our interactive element,
    along with a final `TextField` and `TextFormat` pair to serve as a button label:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要声明一些在此应用程序中使用的对象。一个`SQLConnection`将允许我们与本地SQLite数据库进行交互。第一个`TextField`和`TextFormat`对将作为用户输入的输入字段。另一个`TextField`和`TextFormat`对将把文本信息传递到设备显示屏上。最后，声明一个`Sprite`作为我们的交互元素，以及一个最后的`TextField`和`TextFormat`对作为按钮标签：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we will continue to set up our `TextField`, apply a `TextFormat`, and add
    it to the `DisplayList`. Here, we create a method to perform all of these actions
    for us. Be sure to set the `TextField.type` to `input` in order to allow the user
    to type!
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作。确保将`TextField.type`设置为`input`，以允许用户输入！
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For our interactive `Sprite`, we will set up a `TextField`, apply a `TextFormat`
    object, and construct a `Sprite` with a simple background fill using the graphics
    API. The final step in the construction of our button is to add the `TextField`
    to our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create
    a method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的交互式`Sprite`，我们将设置一个`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个具有简单背景填充的`Sprite`。构建按钮的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作，并进行一些样式增强：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our final visual element involves another `TextField` and `TextFormat` pair
    to display database records upon the device:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后的视觉元素包括另一个`TextField`和`TextFormat`对，用于在设备上显示数据库记录：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`
    to perform additional actions.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`分配为通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用一个名为`onTouchTap`的方法来执行额外操作。
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To create the application database, we must first initialize our `SQLConnection`
    object and pass a `File.db` reference into the `SQLConnection.open()` method to
    establish the connection. If the database file does not exist, it will be automatically
    created. In order to write SQL syntax to interact with our database, we must initialize
    a `SQLStatement` object and assign our established `SQLConnection` to the `SQLStatement.sqlConnection`
    property. At this point, we can pass in a `String` of SQL statements into the
    `SQLStatement.text` property and invoke `SQLConnection.execute()` to actually
    execute the statement. This syntax will create a table within our database with
    two columns, `name` and `time`. If the table already exists, the statement will
    be ignored:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建应用程序数据库，我们首先需要初始化我们的`SQLConnection`对象，并将一个`File.db`引用传递给`SQLConnection.open()`方法以建立连接。如果数据库文件不存在，它将被自动创建。为了编写与数据库交互的SQL语法，我们必须初始化一个`SQLStatement`对象，并将我们建立的`SQLConnection`分配给`SQLStatement.sqlConnection`属性。此时，我们可以传入一个包含SQL语句的`String`到`SQLStatement.text`属性中，并调用`SQLConnection.execute()`实际执行语句。这个语法将在我们的数据库中创建一个包含两列`name`和`time`的表。如果表已经存在，该语句将被忽略：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To retrieve existing records from the database, we will again initialize a `SQLStatement`
    and assign the established `SQLConnection` to the `SQLStatement.sqlConnection`
    property. We will then pass in a `String` of SQL statements into the `SQLStatement.text`
    property and invoke `SQLConnection.execute()` to retrieve all records from the
    database.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从数据库中检索现有记录，我们将再次初始化一个`SQLStatement`，并将已建立的`SQLConnection`分配给`SQLStatement.sqlConnection`属性。然后，我们会传入一个包含SQL语句的`String`到`SQLStatement.text`属性中，并调用`SQLConnection.execute()`从数据库中检索所有记录。
- en: 'To write out the returned data to a `TextField`, we simply initialize a new
    `Array` to contain the returned records by assigning the `data` property (which
    is itself an `Array)` of `SQLStatement.getResult()` to the `Array`. Now create
    a `for` loop to parse the results, outputting the various properties assigned
    to each record to our `TextField`. This visually exposes the query results on
    an Android device:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将返回的数据写入`TextField`，我们只需初始化一个新的`Array`来包含通过将`SQLStatement.getResult()`的`data`属性（它本身是一个`Array`）赋值给`Array`返回的记录。现在创建一个`for`循环来解析结果，将每条记录分配的各种属性输出到我们的`TextField`中。这将在Android设备上直观地展示查询结果：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final method we need to write will allow the user to insert records to
    the database. A lot of this is very similar to how we have established and executed
    `SQLStatement` objects in the past two methods. An insertion, however, can be
    a bit more complex and structured, so we are making use of the inbuilt `SQLStatement.parametersArray`
    in assigning values to our record. For the `name` value, we read from the input
    `TextField` value provided by the user. In order to generate a timestamp to populate
    the value of `time`, we instantiate a new `Date` object and invoke `toUTCString()`.
    Following the execution of this fully-formed statement, we invoke `getDBItems()`
    once again to return the new database results, letting the user see immediately
    that the record has been inserted correctly:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写的最后一个方法是允许用户向数据库中插入记录。这大部分与我们之前两个方法中建立和执行`SQLStatement`对象的方式非常相似。然而，插入操作可能更加复杂和结构化，因此我们使用内置的`SQLStatement.parametersArray`来为我们的记录赋值。对于`name`值，我们从用户提供的输入`TextField`读取。为了生成一个时间戳来填充`time`的值，我们实例化一个新的`Date`对象并调用`toUTCString()`。执行这个完整形成的语句后，我们再次调用`getDBItems()`以返回新的数据库结果，让用户立即看到记录已被正确插入：
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running the application on our Android device allows us to input a name using
    the native virtual keyboard touch tap the **Insert to DB** button, which will
    create a new entry in our database consisting of the input text and current timestamp.![How
    to do it...](img/1420_08_11.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Android设备上运行应用程序，允许我们使用原生的虚拟键盘输入一个名字，并通过触摸点击**插入到数据库**按钮，这将在我们的数据库中创建一个由输入文本和当前时间戳组成的新条目。![如何操作...](img/1420_08_11.jpg)
- en: Each time we enter a new name into the application, the new entry is inserted
    and a query is made to trace all entries out into the `TextField`, along with
    the timestamp from when they were inserted:![How to do it...](img/1420_08_12.jpg)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们向应用程序中输入一个新名字时，新条目就会被插入，并且会进行查询，将所有条目以及它们被插入时的时间戳输出到`TextField`中：![如何操作...](img/1420_08_12.jpg)
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: SQLite is a local, self-contained database, which can be used within AIR for
    Android applications for a variety of tasks, ranging from simple to complex. In
    order to use this functionality, we must establish a `SQLConnection` to a local
    `.db` file on the device. Once this connection is established, we can use a set
    of `SQLStatements` to perform table creation and management tasks, selection,
    insertion, and deletion queries through standard SQL syntax. In this example,
    a user can insert records and perform a general selection query upon a database
    file within the application storage directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个本地自包含的数据库，可以在AIR for Android应用程序中用于执行各种任务，从简单到复杂。为了使用这个功能，我们必须建立一个到设备上本地`.db`文件的`SQLConnection`。一旦建立这个连接，我们可以使用一组`SQLStatements`来执行表创建和管理任务，通过标准的SQL语法进行选择、插入和删除查询。在这个例子中，用户可以在应用程序存储目录下的数据库文件中插入记录并执行一般的选择查询。
- en: 'In this demonstration, we make use of `flash.data.SQLStatement` to perform
    both `INSERT` and `SELECT` operations. For further exploration of this, and related
    classes, we refer you to the Adobe LiveDocs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们使用`flash.data.SQLStatement`来执行`INSERT`和`SELECT`操作。要进一步探索这一点以及相关类，我们请您参考Adobe
    LiveDocs：
- en: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/data/SQLStatement.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/data/SQLStatement.html)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/data/SQLStatement.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/data/SQLStatement.html)'
- en: Providing a default application database
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供默认的应用程序数据库
- en: Allowing the user to add and remove items from an application database, directly
    or indirectly, can be very useful in all sorts of scenarios. Perhaps though, we
    want to start the user out with a standard data set, or maybe provide some default
    settings for the user to manipulate down the road? These scenarios call for the
    ability of the application to provide itself with a default database. In this
    recipe, we will demonstrate how to handle this intelligently through the file
    system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户直接或间接地向应用程序数据库中添加或删除项目，在多种场景下都非常有用。或许，我们希望用户从一个标准数据集开始操作，或者为用户提供一些默认设置以供日后操作？这些场景要求应用程序能够提供默认的数据库。在本教程中，我们将展示如何通过文件系统智能地处理这个问题。
- en: Getting ready...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: In this recipe, we will be bundling an already established SQLite database file
    within our application directory. If you do not have access to a SQLite database
    file already, you can either use some of the other recipes in this chapter to
    generate one, else use any one of a variety of other freely available mechanisms
    for creating these portable little database files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将在应用程序目录中捆绑一个已经建立的SQLite数据库文件。如果您还没有可用的SQLite数据库文件，您可以使用本章中的其他教程来生成一个，或者使用任何一种可免费获得的机制来创建这些便携式的小型数据库文件。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will package a default SQLite database along with our application, check
    to see whether a user defined database exists, and provide the user with our default
    if need be:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一个默认的SQLite数据库与我们的应用程序打包在一起，检查是否存在用户定义的数据库，并在需要时向用户提供我们的默认数据库：
- en: 'First, import the following classes necessary for this example:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入本示例所需以下类：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will need to declare a few objects for use within this application. A `SQLConnection`
    will allow us to interact with a local SQLite database and a `TextField` and `TextFormat`
    pair will relay text messages onto the device display:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将需要声明几个对象。一个`SQLConnection`将允许我们与本地SQLite数据库交互，而`TextField`和`TextFormat`组合将把文本信息传递到设备显示屏上：
- en: '[PRE37]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we will set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList` along with some stylistic enhancements. Here, we create a method
    to perform all of these actions for us:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中，同时进行一些风格上的增强。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE38]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method will fire as soon as the `TextField` has been established, as we
    will be outputting messages to this visual element as each step in the copy process
    is completed.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法将在`TextField`建立后立即触发，因为我们将把复制过程中每一步完成的消息输出到这个视觉元素中。
- en: The first thing to do is establish whether or not an application database exists,
    as this will determine whether or not we need to copy the default database over.
    To do this, we will instantiate a new `File` object and reference a file called
    `products.db` within the application installation directory. If this file does
    not exist, we must create another `File` object, referencing the file name and
    location we wish to copy the file to.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要确定应用程序数据库是否存在，这将决定我们是否需要复制默认数据库。为此，我们将实例化一个新的`File`对象，并引用应用程序安装目录中的名为`products.db`的文件。如果此文件不存在，我们必须创建另一个`File`对象，引用我们要复制文件到的文件名和位置。
- en: 'Once this is established, use the `File.copyTo()` method upon the source `File`,
    passing in the destination `File`. If all goes well, you should now have an exact
    copy of the default database within the application storage directory:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立连接后，在源`File`上使用`File.copyTo()`方法，并传入目标`File`。如果一切顺利，现在应该在应用程序存储目录中有一个默认数据库的精确副本：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To open the application database, we must first initialize our `SQLConnection`
    object and pass a `File.db` reference into the `SQLConnection.open()` method to
    establish the connection. Now that we have a connection to the newly copied database,
    we invoke the `getDBItems()` method to retrieve the records for display:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开应用程序数据库，我们首先必须初始化我们的`SQLConnection`对象，并将`File.db`引用传递给`SQLConnection.open()`方法以建立连接。现在我们有了与新建复制的数据库的连接，我们调用`getDBItems()`方法来检索记录以供显示：
- en: '[PRE40]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To retrieve all of the records from the copied database, we will initialize
    a `SQLStatement` and assign the established `SQLConnection` to the `SQLStatement.sqlConnection`
    property. We will then pass in a `String` of SQL statements into the `SQLStatement.text`
    property and invoke `SQLConnection.execute()` to retrieve all records from the
    database.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从复制的数据库中检索所有记录，我们将初始化一个`SQLStatement`，并将建立的`SQLConnection`分配给`SQLStatement.sqlConnection`属性。然后，我们将SQL语句的`String`传递给`SQLStatement.text`属性，并调用`SQLConnection.execute()`从数据库中检索所有记录。
- en: 'To write out the returned data to a `TextField`, we simply initialize a new
    `Array` to contain the returned records by assigning the `data` property (which
    is itself an `Array)` of `SQLStatement.getResult()` to the `Array`. Now create
    a `for` loop to parse the results, outputting the various properties assigned
    to each record to our `TextField`. This visually exposes the query results on
    an Android device:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将返回的数据输出到`TextField`，我们只需初始化一个新的`Array`来包含返回的记录，通过将`SQLStatement.getResult()`的`data`属性（它本身是一个`Array`）分配给`Array`。现在创建一个`for`循环来解析结果，将每条记录分配的各种属性输出到我们的`TextField`。这将在Android设备上直观地显示查询结果。
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first time the application is run, a database is not found within the application
    storage directory. The default database is then copied into the expected position
    and then records are retrieved and displayed for the user to view:![How to do
    it...](img/1420_08_13.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序首次运行时，在应用程序存储目录中找不到数据库。然后将默认数据库复制到预期位置，然后检索记录并显示给用户查看：![如何操作...](img/1420_08_13.jpg)
- en: If the user runs this application subsequent times, the database is now in the
    expected location and the application simply performs a query and displays the
    records without any need to copy files from one location to another:![How to do
    it...](img/1420_08_14.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户后续运行此应用程序，数据库现在在预期位置，应用程序只需执行查询并显示记录，无需从一处位置复制文件到另一位置：![如何操作...](img/1420_08_14.jpg)
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we use a combination of `File` and `SQLConnection/SQLStatement`
    objects to determine whether or not a database exists, followed by either a simple
    query and record display, or a more involved file copy from the application install
    directory into the application storage directory using `File.copyTo()`. This method
    will copy a file reference, which is passed in as an initial argument into the
    specified location. There are many other similar methods for file manipulation.
    We will list some of these as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们使用`File`和`SQLConnection/SQLStatement`对象的组合来确定数据库是否存在，然后进行简单的查询和记录显示，或者使用`File.copyTo()`将文件从应用程序安装目录复制到应用程序存储目录的更复杂操作。此方法将复制作为初始参数传入的文件引用到指定位置。还有许多其他类似的文件操作方法。以下列出了一些这些方法：
- en: '`File.copyTo():` Copies the file or directory to a new location'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.copyTo()：`将文件或目录复制到新位置'
- en: '`File.moveTo():` Moves the file or directory to a new location'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.moveTo()：`将文件或目录移动到新位置'
- en: '`File.deleteFile()XE`"default application database:File.deleteFile() method"
    : Deletes the specified file'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.deleteFile()XE`"default application database:File.deleteFile()方法"：删除指定的文件'
- en: '`File.createDirectory():` Creates a directory as well as any needed parent
    directories'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.createDirectory()：`创建目录以及所需的所有父目录'
- en: '`File.deleteDirectory():` Deletes the specified directory'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.deleteDirectory()：`删除指定的目录'
- en: 'For a comprehensive look at the `File` class, please refer to the Adobe LiveDocs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解`File`类，请参考Adobe LiveDocs：
- en: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filesystem/File.html)'
- en: The database file, being just a regular file, can easily be manipulated through
    ActionScript just like any other file. It is important though to have a fair understanding
    of which directories the application does or does not have permission to write
    to, in such a case. For instance, `File.applicationDirectory` is read only. We
    cannot write files to this directory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件，仅仅是一个常规文件，可以通过ActionScript像其他任何文件一样轻松操作。但是，在这种情况下，了解应用程序是否有权限写入哪些目录是很重要的。例如，`File.applicationDirectory`是只读的。我们不能将文件写入此目录。
- en: If you require a tool to create or manage SQLite database files, you may be
    interested in a software project such as SQLite Database browser, freely downloaded
    from [http://sqlitebrowser.sourceforge.net/](http://sqlitebrowser.sourceforge.net/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个工具来创建或管理SQLite数据库文件，你可能会对像SQLite Database browser这样的软件项目感兴趣，可以免费从[http://sqlitebrowser.sourceforge.net/](http://sqlitebrowser.sourceforge.net/)下载。
- en: Automating database tasks with FlexORM
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FlexORM自动化数据库任务
- en: While we certainly do have full control over application databases through supported
    SQLite syntax, there are libraries of code to make things a bit easier. One such
    library is called **FlexORM**, and as the name suggests, it can only be used within
    a Flex project so pure ActionScript is out.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确实可以通过支持的SQLite语法完全控制应用程序数据库，但有一些代码库可以使事情变得更容易。这样一个库叫做**FlexORM**，顾名思义，它只能在Flex项目中使用，因此纯ActionScript是不行的。
- en: FlexORM is an Object Relational Mapping framework, which avoids having the developer
    write any database code or SQL for a project. Objects are made to be persistent,
    and any database transitions are handled by the framework itself, behind the scenes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: FlexORM是一个对象关系映射框架，它避免了开发者在项目中编写任何数据库代码或SQL。对象是持久的，任何数据库转换都由框架本身在幕后处理。
- en: Getting ready...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: 'When preparing this application example, you will want to take some additional
    steps to get ready as there is some setup involved in regard to acquiring the
    FlexORM library and setting it up within a project:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备这个应用程序示例时，你还需要采取一些额外的步骤来准备，因为涉及到获取FlexORM库并在项目中设置它的一些设置：
- en: First, we must open a web browser and go to [http://flexorm.riaforge.org/](http://flexorm.riaforge.org/)
    the project page for FlexORM.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须打开一个网络浏览器并前往[FlexORM的项目页面](http://flexorm.riaforge.org/)。
- en: Download the files either through the `ZIP` package at the bottom of the screen,
    or through the SVN repository.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过屏幕底部的`ZIP`包或通过SVN仓库下载文件。
- en: Once the files are on your system, we will want to navigate to **trunk | flexorm
    | src** and grab everything under **src**. This is the package we must import
    into Flash Builder in order to use FlexORM.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件一旦在你的系统上，我们将想要导航到**trunk | flexorm | src**目录，并获取**src**下的所有内容。这是我们为了使用FlexORM而必须导入到Flash
    Builder中的包。
- en: Create a new Mobile Flex Project and drag the files from **src** under the Flex
    project **src** folder. We can now begin to use **FlexORM** within our application.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的移动Flex项目，并将文件从Flex项目**src**文件夹下的**src**拖拽过来。我们现在可以在我们的应用程序中使用**FlexORM**。
- en: Your project will look very similar to the one shown in the following screenshot:![Getting
    ready...](img/1420_08_15.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的项目将与下面截图显示的项目非常相似：![准备工作...](img/1420_08_15.jpg)
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using the **FlexORM** framework, we will define a persistent object structure
    and manage the creation and deletion of object entries through a simple Flex mobile
    project:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**FlexORM**框架，我们将定义一个持久对象结构，并通过一个简单的Flex移动项目管理对象条目的创建和删除：
- en: 'The first thing we will do is create a class within a `vo` [Value Object] package
    called `Product`. This will serve as the declaration of our bindable object and
    is a reflection of what we will be inserting and reading from our database. Using
    metadata specific to **FlexORM**, we declare a table called `Products` with an
    ID column named `id` and an additional column called `ProductName`. These objects
    act as interfaces to our actual table structure and allow us to manage SQL commands
    through a familiar object-oriented paradigm:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要在一个名为`vo` [值对象] 的包中创建一个名为`Product`的类。这将作为我们可绑定对象的声明，并且反映了我们将要从数据库中插入和读取的内容。使用特定于**FlexORM**的元数据，我们声明一个名为`Products`的表，其中有一个名为`id`的ID列和一个名为`ProductName`的附加列。这些对象作为我们实际表结构的接口，允许我们通过熟悉的面向对象范例来管理SQL命令：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next step will be to write a `ViewNavigatorApplication` MXML file to serve
    as our main application file. We can include both a `firstView` attribute pointing
    to a specific `View`, and an `applicationComplete` attribute, which will invoke
    an initialization function for us:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将编写一个`ViewNavigatorApplication` MXML文件作为我们的主应用程序文件。我们可以包含一个指向特定`View`的`firstView`属性，以及一个`applicationComplete`属性，它将调用一个初始化函数：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we will declare a `Script` block and perform a set of imports, which are
    necessary for this portion of our application. All we need from **FlexORM** is
    the `EntityManager`. This is what is used to read from and write to our database.
    We must also import our `vo` object class for use with **FlexORM**, along with
    `ArrayCollection` to hold any records that are produced:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将声明一个`Script`块并执行一系列导入，这对于我们应用程序的这部分是必要的。我们从**FlexORM**只需要`EntityManager`。这是用于读取和写入我们数据库的内容。我们还必须导入与**FlexORM**一起使用的`vo`对象类以及用于保存产生的任何记录的`ArrayCollection`：
- en: '[PRE44]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we will instantiate both the `EntityManager` and the `ArrayCollection`
    for use in the application. Invoking `EntityManager.getInstance()` will allow
    us to begin using **FlexORM:**
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将实例化`EntityManager`和`ArrayCollection`以供应用程序使用。调用`EntityManager.getInstance()`将允许我们开始使用**FlexORM**：
- en: '[PRE45]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We must define the initialization method referred to in our `ViewNavigatorApplication`
    tag. Within this method, use the `File` class to refer to the database file to
    create within the application storage directory. Create a new `SQLConnection`
    and open the previously defined `File` reference with it. The `SQLConnection`
    can now be bound to the `sqlConnection` property of our `EntityManager`, allowing
    us to interact with the database using **FlexORM:**
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须定义在`ViewNavigatorApplication`标签中提到的初始化方法。在此方法内，使用`File`类引用要在应用程序存储目录中创建的数据库文件。创建一个新的`SQLConnection`，并用它打开先前定义的`File`引用。现在，可以将`SQLConnection`绑定到`EntityManager`的`sqlConnection`属性上，使我们能够使用**FlexORM**与数据库交互：
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method can be invoked whenever we want to refresh our collection from
    the database. Simply invoking `findAll()` upon the `EntityManager` and passing
    in the class name we want to retrieve from will return all the records from the
    table bound to that class:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在任何时候调用此方法从数据库刷新我们的集合。只需在`EntityManager`上调用`findAll()`，并传入我们想要检索的类名，就可以从绑定到该类的表中返回所有记录：
- en: '[PRE47]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will need to set up methods to insert and delete records from the application
    database. To save a record, we create an object based upon the class corresponding
    to the table we wish to save to. Now, we will assign properties to this class
    based upon the fields we are writing values to for this insertion. Invoking `EntityManager.save()`
    while passing in this object will instruct **FlexORM** to insert a new record
    into the database:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置方法以插入和删除应用程序数据库中的记录。为了保存记录，我们会根据希望保存到的表创建一个基于类的对象。现在，我们将根据要为此插入写入值的字段为此类分配属性。在传入此对象的同时调用`EntityManager.save()`，将指示**FlexORM**在数据库中插入新记录：
- en: '[PRE48]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Deleting a record from the database is just as simple. Invoke `EntityManager.remove()`
    while passing along the object within our collection, which corresponds to the
    specific record to remove from our database will ensure that **FlexORM** deletes
    the true record for us:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中删除记录同样简单。在传入集合中的对象时调用`EntityManager.remove()`，该对象与要从数据库中删除的特定记录相对应，这将确保**FlexORM**为我们删除真正的记录：
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now to construct our application view. Create a new `View` MXML file with whatever
    properties suits your specific project view. In this case, we are assigning it
    with a `VerticalLayout` with some generous padding:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建我们的应用程序视图。创建一个新的`View` MXML文件，并为其分配适合您特定项目视图的属性。在这种情况下，我们将其分配给带有一些宽大填充的`VerticalLayout`：
- en: '[PRE50]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The controls in our application which a user is able to interact with will consist
    of a `TextInput` to type in, a `Button` to submit from, and a `List` to display
    all of our database records. We will invoke a function called `addProduct()` on
    button click, and another function called `removeProduct()`, which is tied to
    our list change event. The final modification will be to bind our `ListdataProvider`
    to the defined `productArrayCollection` within our main MXML file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应用程序中用户可以与之交互的控件将包括一个用于输入的`TextInput`，一个用于提交的`Button`，以及一个用于显示我们所有数据库记录的`List`。我们将在按钮点击时调用一个名为`addProduct()`的函数，以及另一个名为`removeProduct()`的函数，该函数与我们的列表更改事件相关联。最后的修改是将我们的`ListdataProvider`绑定到主MXML文件中定义的`productArrayCollection`。
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using `parentApplication` as a convenience in this example. Depending
    upon the structure of your application, you may not want to do this, as it creates
    an oftentimes unwanted relationship between the application and its various modules.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用`parentApplication`作为方便。根据应用程序的结构，您可能不想这样做，因为它会在应用程序及其各个模块之间创建通常不希望的关系。
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a `Script` block and import the `IndexChangeEvent` class needed for
    our `List` change event to properly fire:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Script`块并导入我们的`List`变更事件正常触发所需的`IndexChangeEvent`类：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now all that is left to do is to create some local functions to pass along
    information to our main MXML file and perform local cleanup duty. First we create
    the method for our `Button` click event, which passes data along to the `saveProduct()`
    method we created previously. We will pass along the entered text and then clear
    out our `TextInput` to allow for further records to be defined:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要做的只剩下创建一些本地函数，以便将信息传递给我们的主 MXML 文件，并执行本地清理任务。首先，我们为`Button`点击事件创建方法，该方法将数据传递给之前创建的`saveProduct()`方法。我们将输入的文本传递过去，然后清空`TextInput`以允许定义更多的记录：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, write the function to handle removal of records based upon change
    events generated from the `List`. Any index change detected upon the `List` will
    pass index data along to the `deleteProduct()` method we created previously. We
    then set our `ListselectedIndex` to `-1`, signifying that no items are selected:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写一个函数来处理基于从`List`生成的变更事件删除记录。在`List`上检测到的任何索引变化都会将索引数据传递给之前创建的`deleteProduct()`方法。然后我们将`ListselectedIndex`设置为`-1`，表示没有选择任何项目：
- en: '[PRE54]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the user runs our application upon a device, they are able to type in data
    through the native Android virtual keyboard. Tapping the **Insert New Product**
    button will add their information to the database:![How to do it...](img/1420_08_16.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在设备上运行我们的应用程序时，他们能够通过原生的 Android 虚拟键盘输入数据。点击**插入新产品**按钮将把他们的信息添加到数据库中：![如何操作...](img/1420_08_16.jpg)
- en: The user will be able to add multiple records to the database and they will
    immediately appear within the `List` control. Tapping an item within the `List`
    will cause a change event to fire and consequently remove the corresponding record
    from the application database:![How to do it...](img/1420_08_17.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将能够向数据库添加多条记录，并且它们会立即出现在`List`控件中。点击`List`中的某个项目将触发一个变更事件，从而相应地从应用程序数据库中删除对应的记录：![如何操作...](img/1420_08_17.jpg)
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: FlexORM takes some initial setup to get the framework functioning in a way that
    is beneficial for us when developing an application, but once everything is in
    place, it can be a huge time saver with less complex databases. Whereas SQL is
    nothing at all such as ActionScript in syntax or usage. FlexORM provides an interface
    through which we can manage database records in an object-oriented manner through
    the use of the same language we are using for the rest of our application, ActionScript!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: FlexORM 需要一些初始设置，以便在开发应用程序时以对我们有利的方式运行该框架，但一旦一切就绪，对于不那么复杂的数据库，它可以节省大量的时间。而 SQL
    在语法或使用上与 ActionScript 完全不同。FlexORM 提供了一个接口，通过这个接口我们可以以面向对象的方式管理数据库记录，使用的语言与我们的应用程序其余部分使用的
    ActionScript 相同！
- en: There is more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: FlexORM is great for simple transactions, but does not fully support everything
    that SQLite offers. For example, we cannot create and manage an encrypted database
    using FlexORM. For such specific activities, it is best to write your queries
    by hand.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: FlexORM 对于简单的交易非常适用，但它并不完全支持 SQLite 提供的所有功能。例如，我们不能使用 FlexORM 创建和管理加密的数据库。对于这类特定活动，最好手写查询语句。
