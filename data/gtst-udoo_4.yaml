- en: Chapter 4. Using Sensors to Listen to the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 使用传感器倾听环境
- en: 'When we are building our prototypes, we want to provide the best possible interaction
    for our final users. Sometimes, we build real-world applications that don''t have
    any human interaction but they simply listen to the environment to collect data
    and decide what to do. Whatever our prototype, if we want to read and understand
    human actions or environment changes, we need to use a new set of electronic components:
    **sensors**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建原型时，希望为最终用户提供最佳的交互体验。有时，我们构建的实际应用没有任何人为交互，但它们只是监听环境以收集数据并决定要做什么。无论我们的原型是什么，如果我们想要读取和理解人类行为或环境变化，我们需要使用一组新的电子组件：**传感器**。
- en: Every time we build a physical application, we have to bear in mind that the
    more complex our project is, the more likely we need to add sensors to achieve
    the desired interaction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们构建物理应用时，都必须牢记，我们的项目越复杂，就越有可能需要添加传感器来实现所需的交互。
- en: In this chapter, we will start a new real-world application from scratch that
    is capable of sensing our heartbeat and publishing the result to our Android application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从零开始构建一个能够感知我们的心跳并将结果发布到我们的安卓应用程序中的真实应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with environment sensors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境传感器进行工作
- en: Building a heartbeat monitor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建心跳监测器
- en: Collecting data from sensors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从传感器收集数据
- en: Showing collected data from an Android application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从安卓应用程序展示收集的数据
- en: Working with environment sensors
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境传感器进行工作
- en: In electronics, sensors are components built *to detect any changes* of a particular
    matter or particle property. When any change occurs, the sensor provides a voltage
    variation that can change the current flow and behavior of other electric components.
    If a microcontroller is connected to a sensor, it can decide to take different
    actions according to the running program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子学中，传感器是构建来检测特定物质或粒子属性*任何变化*的组件。当发生任何变化时，传感器提供一个电压变化，可以改变其他电子组件的电流流动和行为。如果微控制器连接到传感器，它可以根据运行程序决定采取不同的行动。
- en: Sensors can detect changes in many *properties*, such as heat radiation, humidity,
    light, radio, sound waves, and many others. When we are using a sensor in our
    projects, we have to choose a particular property to listen to and then we need
    to read and manage the voltage variation. Sometimes, to perform our checks, we
    need to transform these electrical changes into other measurement units, such
    as meters or temperature's degree. At other times, we may use more complex sensors
    that already make a total or a partial conversion for us. For example, if we are
    building a robot rover, we may need to use a sensor to detect the distance from
    an object in order to dodge any room obstacles. In this case, we will use an *ultrasonic
    sensor* that is based on a principle similar to radar or sonar. It emits high
    frequency sound waves and evaluates the echo that is received. Analyzing the time
    interval between sending and receiving the signal echo, we can determinate the
    distance from an object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器可以检测许多*属性*的变化，如热辐射、湿度、光线、无线电、声波等。当我们在项目中使用传感器时，必须选择一个特定的属性进行监听，然后需要读取并管理电压的变化。有时，为了执行检查，我们需要将这些电学变化转换为其他测量单位，如米或温度度数。在其他时候，我们可能会使用更复杂的传感器，这些传感器已经为我们完成了全部或部分的转换。例如，如果我们正在构建一个机器人探测器，可能需要使用传感器来检测与物体的距离，以避开任何房间障碍。在这种情况下，我们将使用基于雷达或声纳原理相似的*超声波传感器*。它发射高频声波并评估接收到的回声。通过分析发送和接收信号回声之间的时间间隔，我们可以确定与物体的距离。
- en: Indeed, in a generic sketch, we read the elapsed microseconds from the sensor
    before the signal echo is received. To make these values more useful and to find
    the right distance, we may need to write a microsecond to centimeters or inches
    converter inside the sketch.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在一个通用的草图中，我们读取的是从传感器收到信号回声之前经过的微秒数。为了使这些值更有用并找到正确的距离，我们可能需要在草图内部编写一个微秒到厘米或英寸的转换器。
- en: However, this is possible only if we know how the sensor works and how many
    centimeters or inches are traveled by the signal for each microsecond. Fortunately,
    we can find this information in a document released by the component manufacturer,
    which is called a **datasheet**. With this knowledge, we can easily convert all
    probed values into what we are looking for. When we finish the prototype in this
    chapter, we could take a look at the URL [http://arduino.cc/en/tutorial/ping](http://arduino.cc/en/tutorial/ping),
    which includes an example about how to use an ultrasonic sensor and how it's easy
    to convert the detected signal into a different measurement unit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有在我们了解传感器的工作原理以及信号每微秒传播了多少厘米或英寸的情况下，这才可能实现。幸运的是，我们可以从组件制造商发布的文档中找到这些信息，这个文档被称为**数据手册**。有了这些知识，我们可以轻松地将所有探测到的值转换为我们要寻找的内容。当我们完成本章的原型后，可以查看URL
    [http://arduino.cc/en/tutorial/ping](http://arduino.cc/en/tutorial/ping)，其中包含了一个关于如何使用超声波传感器以及如何轻松地将检测到的信号转换为不同测量单位的示例。
- en: Building a heartbeat monitor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建心跳监测器
- en: In the previous chapters, we built our first prototype equipped with an LED
    actuator to alter the surround environment, and then we enabled the Android application
    to control the LED behavior through the internal ADK communication. We have seen
    that sensors are really helpful to improve interactions of our prototypes and
    we may be tempted to add this new capability to the previous project. Indeed,
    because we're using a component capable of producing light, we may think about
    adding an external light sensor so that the microcontroller is capable of turning
    on and off the LED according to the environment light.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了第一个配备LED执行器的原型，用以改变周围环境，并通过内部ADK通信使Android应用程序控制LED的行为。我们已经看到传感器对于提高我们原型的交互性非常有帮助，我们可能想要将这项新功能添加到之前的项目中。实际上，由于我们使用的是一个能够发光的组件，我们可能会考虑添加一个外部光传感器，以便微控制器可以根据环境光线来开关LED。
- en: This is just an example of how we can use a light sensor. Indeed, we have to
    bear in mind that each sensor can be used in different ways and it's our job to
    find a correlation between detected values and the goal of our physical application.
    We should never stop to use sensors only for their main use, as we will see in
    the heartbeat monitor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于如何使用光传感器的示例。实际上，我们必须牢记每个传感器都可以以不同的方式使用，我们的任务是要找到检测值与物理应用目标之间的相关性。我们绝不应该仅限于使用传感器的主要用途，正如我们将在心跳监测器中看到的那样。
- en: Creating a circuit with a light sensor
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有光传感器的电路
- en: Similar to the previous prototypes, the heartbeat monitor is composed of two
    parts. The first one is the circuit and the sketch that should collect data from
    the light sensor and convert it into a value that represents the **beats per minute**
    (**bpm**). The second is the Android application, which shows the computed value
    of our heart rate on the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的原型类似，心跳监测器由两部分组成。第一部分是电路和草图，应该从光传感器收集数据并将其转换为代表**每分钟节拍数**（**bpm**）的值。第二部分是Android应用程序，它会在屏幕上显示我们心率计算出的值。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if this prototype could achieve good results, it's always a bad idea to
    use homemade prototypes for medical reasons. The photoresistor is used only for
    a demonstration and *should not* be used for any medical purposes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个原型可能取得不错的效果，但用自制的原型用于医疗原因是不可取的。光敏电阻仅用于演示，*不应*用于任何医疗目的。
- en: For this physical application, we are going to use a **photoresistor** as a
    part of our light sensor. A photoresistor, also called **Light Dependent Resistor**
    (**LDR**), works like a traditional resistor used in previous prototypes, but
    it's slightly different regarding how much resistance it provides. Indeed, its
    resistance is variable according to measured light intensity and if we monitor
    this value, we can easily calculate whether the environment intensity is increasing
    or decreasing. We also use a *bright red* LED, which is different from the one
    used before because it's powerful enough to let the light pass through our skin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个物理应用，我们将使用**光敏电阻**作为光传感器的一部分。光敏电阻，也称为**光依赖电阻器**（**LDR**），其工作原理与之前原型中使用的传统电阻类似，但在提供的电阻方面略有不同。实际上，它的电阻根据测量的光照强度而变化，如果我们监测这个值，可以轻松计算出环境强度是在增加还是减少。我们还使用了一个*鲜红色*的LED，它不同于之前使用的LED，因为其亮度足以让光线透过我们的皮肤。
- en: Our goal is to create a circuit where we can put one side of our index finger
    at the top of the photoresistor, and the bright LED on the other side. In this
    way, a part of the light will pass through our finger and will be detected by
    the photoresistor. During every heartbeat, a pressure wave moves out along the
    arteries increasing our blood volume. When the light goes through our tissues,
    this blood volume variation changes the quantity of light that falls on the sensor.
    So, when we see medium or high changes in the probed values, probably, this is
    our heartbeat.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个电路，我们可以将食指的一侧放在光敏电阻的顶部，另一侧是明亮的LED。这样，一部分光线会穿过我们的手指，并被光敏电阻检测到。在每次心跳时，沿着动脉的血压力波会向外移动，增加我们的血量。当光线穿过我们的组织时，这种血量变化会改变落在传感器上的光线量。因此，当我们看到探测值中出现中等到高度变化时，这很可能是我们的心跳。
- en: 'To begin the construction of our prototype, we need to put the photoresistor
    into our breadboard so that we can achieve the following schema:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始构建我们的原型，我们需要将光敏电阻放入面包板中，以便我们可以实现以下电路图：
- en: '![Creating a circuit with a light sensor](img/1942OS_04_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用光传感器创建电路](img/1942OS_04_01.jpg)'
- en: 'Go through the following steps to achieve the preceding schema:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作，以实现前面的电路图：
- en: The photoresistor may have legs that are too long. Use an electronics component
    cutter to cut the legs so that they are, at most, 1.5cm. This is not a requirement
    but it could simplify the use of the prototype.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光敏电阻的腿可能太长。使用电子元件剪钳将腿剪短，最多1.5cm。这不是必须的，但可能会简化原型的使用。
- en: Connect the UDOO +3.3V pin to the first line of the breadboard. Be sure not
    to connect the +5V power pin because it may damage the board during connections.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO的+3.3V引脚连接到面包板的第一行。确保不要连接+5V电源引脚，因为在连接过程中可能会损坏电路板。
- en: Put a *10 KOhm* resistor on the board and connect it to the +3.3V pin; we also
    need to connect the other lead to the analog input A0 pin.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在电路板上放置一个*10 KOhm*电阻，并将其连接到+3.3V引脚；我们还需要将另一端连接到模拟输入A0引脚。
- en: Connect the photoresistor to the same column of the resistor and the A0 pin;
    the second lead should be connected to the negative line of the power bus.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光敏电阻连接到电阻和A0引脚的同一列；第二个引脚应连接到电源总线的负线。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Photoresistors act like any other resistors, so it's not important which lead
    we connect on this step because *they have no polarity*.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 光敏电阻的作用与其他电阻一样，所以在这一步我们连接哪一端并不重要，因为*它们没有极性*。
- en: Connect UDOO ground to the negative line of the power bus.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO的地线连接到电源总线的负线。
- en: With these steps, we built a **voltage divider** circuit composed of two resistors.
    These kinds of circuit produce an output voltage, which is a fraction of the input
    voltage according to the resistance values. This means that, because the resistance
    is variable according to the light intensity, the voltage divider gives an output
    voltage that changes with illumination. In this way, the board notices the changes
    and transforms them in a numeric value, in a range between 0 and 1023\. In other
    words, when the photoresistor is in the shade, we read a high value, while when
    it's in the light, we read a low value. Because we connect the *10 KOhm* resistor
    to the +3.3V pin, we can state that this voltage divider has been built using
    a **pull-up** resistor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们构建了一个由两个电阻组成的**电压分压器**电路。这类电路根据电阻值产生一个输入电压的分数作为输出电压。这意味着，由于电阻值会随光照强度变化而变化，电压分压器输出的电压也会随光照变化。这样，电路板可以检测到这些变化，并将其转换为一个0到1023之间的数值。换句话说，当光敏电阻处于阴影中时，我们读取到一个高值；而当它处于光照中时，我们读取到一个低值。由于我们将*10
    KOhm*电阻连接到+3.3V引脚，我们可以认为这个电压分压器是使用了一个**上拉**电阻构建的。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Voltage divers are commonly used in many electronic circuits. You can find more
    information about other applications of this kind of circuit at [https://learn.sparkfun.com/tutorials/voltage-dividers](https://learn.sparkfun.com/tutorials/voltage-dividers).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 电压分压器在许多电子电路中经常使用。你可以在[https://learn.sparkfun.com/tutorials/voltage-dividers](https://learn.sparkfun.com/tutorials/voltage-dividers)找到关于这类电路其他应用的信息。
- en: 'To complete our prototype, we have to add the bright LED to the circuit. However,
    because we need to put the LED on the opposite side of our finger, we can''t connect
    the component directly to our breadboard, but we need to use a couple of *crocodile
    clips*. As a first step, we need to extend the circuit as per the following schema:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的原型，我们不得不将高亮LED添加到电路中。然而，因为我们需要将LED放在手指的另一侧，我们不能直接将组件连接到我们的面包板上，但我们需要使用一对*鳄鱼夹*。作为第一步，我们需要按照以下电路图扩展电路：
- en: '![Creating a circuit with a light sensor](img/1942OS_04_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用光传感器创建电路](img/1942OS_04_02.jpg)'
- en: 'Go through the following steps to achieve the preceding schema:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现前面的电路图：
- en: Connect the UDOO +5V power pin to the positive line of the power bus.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOOU +5V电源引脚连接到电源总线的正线上。
- en: Add a *220 Ohm* resistor to the breadboard and connect one lead to the negative
    line of the power bus.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面包板上添加一个*220欧姆*电阻，并将一个引脚连接到电源总线的负线上。
- en: Connect one side of a wire connector to the other lead of the *220 Ohm* resistor.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电线连接器的一边接到*220欧姆*电阻的另一引脚上。
- en: Connect one side of a wire connector to the positive line of the power bus.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电线连接器的一边接到电源总线的正线上。
- en: Connect one side of the first crocodile clip to the wire connected to the positive
    line of the power bus.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个鳄鱼夹的一边连接到连接到电源总线正线的导线上。
- en: Connect one side of the second crocodile clip to the wire connected to the resistor.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个鳄鱼夹的一边连接到电阻器的导线上。
- en: Connect the crocodile clip that extends the +5V pin to the long leg of the LED.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将延长+5V引脚的鳄鱼夹连接到LED的长腿上。
- en: Note
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding with the next step, remember that you're using a really bright
    LED. You should avoid directing it at your eyes.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进行下一步之前，请记住你正在使用一个非常亮的LED。你应该避免将其直接对准你的眼睛。
- en: Connect the crocodile clip that extends the resistor and the ground connection
    to the short leg of the LED.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将延长电阻和接地连接的鳄鱼夹连接到LED的短腿上。
- en: If all the connections are set, the LED should turn on and we can use it as
    a moving part of our prototype. One thing to bear in mind is that the metal terminal
    ends of the crocodile clips *should never touch together* otherwise the circuit
    will stop working and some components may get damaged because of a *short circuit*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有连接都设置好了，LED应该会亮起，我们可以将其作为原型的一个活动部分。需要记住的一件事是，鳄鱼夹的金属端头*绝对不能相互接触*，否则电路将停止工作，一些组件可能因为*短路*而损坏。
- en: Collecting data from the sketch
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从草图中收集数据
- en: 'Now that we have a working circuit, we should start to write down our sketch
    to collect data from the light sensor. Then we should analyze these results and
    think about an algorithm to transform readings into a heartbeat counter. We should
    start a new sketch and add the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一个工作的电路，我们应该开始编写草图以从光传感器收集数据。然后我们应该分析这些结果，考虑一个将读数转换为心跳计数的算法。我们应该开始一个新的草图，并添加以下步骤：
- en: 'Add the following declarations on the top of the sketch:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图顶部添加以下声明：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We define the object-like macro `SENSOR` with a `A0` value that is the pin we
    will use for the analog read. We set `HEARTBEAT_POLL_PERIOD` to specify how many
    milliseconds the microcontroller should wait between consecutive sensor readings.
    With the `SECONDS` parameter, we define the seconds that should elapse before
    we use collected data to process and estimate the heart rate. Indeed, we multiply
    `SECONDS` by `1000` to convert this value into milliseconds and then we divide
    it by the `HEARTBEAT_POLL_PERIOD` parameter to define the `TIMESLOTS` constant.
    This variable defines how many times we should loop the reading phase to collect
    the right number of readings to estimate the heart rate. In this way, we make
    a read for each `TIMESLOTS` cycle and when the cycle ends, we calculate the heart
    rate. The last variable `sensorReading` is used to store the sensor reading during
    each loop iteration.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了一个类似对象的宏`SENSOR`，值为`A0`，这是我们将用于模拟读数的引脚。我们设置`HEARTBEAT_POLL_PERIOD`以指定微控制器在连续传感器读数之间应该等待多少毫秒。使用`SECONDS`参数，我们定义了在处理和估计心率之前应该过去多少秒。实际上，我们将`SECONDS`乘以`1000`将这个值转换为毫秒，然后除以`HEARTBEAT_POLL_PERIOD`参数来定义`TIMESLOTS`常数。这个变量定义了我们应该循环读取阶段多少次以收集估计心率所需正确数量的读数。这样，我们在每个`TIMESLOTS`周期进行一次读取，当周期结束时，我们计算心率。最后一个变量`sensorReading`用于在每次循环迭代中存储传感器读数。
- en: 'In the `setup()` function, add the initialization of the serial port so that
    we can open a communication between the UDOO board and our computer:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，添加串行端口的初始化，以便我们可以在UDOOboard和计算机之间打开通信：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following function at the bottom of the sketch to print read values
    through the serial port:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部添加以下函数，通过串行端口打印读取的值：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `analogRead` built-in function to read the incoming data from the
    analog input pin. Because these pins are read-only, we don't need to do any further
    configuration in the `setup()`function or to change the input resolution.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用内置的`analogRead`函数从模拟输入引脚读取传入数据。因为这些引脚是只读的，我们不需要在`setup()`函数中进行进一步配置或更改输入分辨率。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Sometimes we may need a better analog read resolution with a range between 0
    and 4095 instead of 0 and 1023\. In this case, we should change the resolution
    using the `analogReadResolution` parameter. We can find more information about
    the analog input resolution in the official documentation at [http://arduino.cc/en/Reference/AnalogReadResolution](http://arduino.cc/en/Reference/AnalogReadResolution).
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们可能需要更好的模拟读取分辨率，范围在0到4095之间，而不是0到1023。在这种情况下，我们应该使用`analogReadResolution`参数来改变分辨率。我们可以在官方文档中找到更多关于模拟输入分辨率的信息，地址是[http://arduino.cc/en/Reference/AnalogReadResolution](http://arduino.cc/en/Reference/AnalogReadResolution)。
- en: When the read is complete, we print the result in the serial port so that we
    can read these values through the Arduino IDE serial monitor.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当读取完成时，我们在串行端口打印结果，这样我们就可以通过Arduino IDE串行监视器读取这些值。
- en: 'In the main `loop()` function, add the `printRawData()` function call for each
    reading timeslot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中，为每个读取时隙添加`printRawData()`函数调用：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are making the `TIMESLOTS` iterations so that we can get readings for 10
    seconds, as defined earlier. After all the readings are done, we print a message
    on the serial port and wait for a second before starting again with the readings.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们进行`TIMESLOTS`迭代是为了在10秒内获取读数，如之前定义的。所有读数完成后，我们在串行端口打印一条消息，并在重新开始读取前等待一秒。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The delay of a second and the **Done!** message are only proof of the concept
    that the reading cycle is working correctly. We will remove them later.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一秒的延迟和**完成！**的消息仅证明读取周期正在正确工作。我们稍后会移除它们。
- en: After this configuration, we can upload the sketch and proceed with our first
    experiment. Put the bottom side of your index finger on the photoresistor while
    the LED is put on the other side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完毕后，我们可以上传草图并继续我们的第一次实验。将食指的底部放在光电阻上，同时将LED放在另一侧。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To get finer readings, it's better if the contact part with the photoresistor
    and the LED is the part between the phalanx and the nail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更精细的读数，如果光电阻和LED的接触部分是指关节和指甲之间的部分会更好。
- en: 'To start the experiment, click on the **Serial Monitor** button and when the
    sketch prints the **Done!** message, we will see some values as shown in the following
    screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开始实验时，点击**串行监视器**按钮，当草图打印出**完成！**的消息时，我们将看到如下截图所示的一些数值：
- en: '![Collecting data from the sketch](img/1942OS_04_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![从草图收集数据](img/1942OS_04_03.jpg)'
- en: 'These are the absolute values that the light sensor caught during our heartbeats.
    If we copy and paste a full 10 seconds iteration into Microsoft Excel, Libre Office
    Calc, or Numbers spreadsheet, we can draw a line chart and see the given results
    in a more understandable format:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们心跳期间光传感器捕捉到的绝对值。如果我们把一个完整的10秒迭代复制粘贴到Microsoft Excel、Libre Office Calc或Numbers表格中，我们可以绘制一个折线图，以更易于理解的形式查看给定结果：
- en: '![Collecting data from the sketch](img/1942OS_04_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![从草图收集数据](img/1942OS_04_04.jpg)'
- en: 'We can see that the values change over time, and when a heartbeat occurs, the
    light sensor detects a variation of the light intensity and this event causes
    a peak in our chart. In other words, we can assume that every peak is related
    to a single heartbeat. The next step is to improve our sketch to approximate and
    convert these values, because we should try to remove reading errors and false
    positives. The main idea is to collect a fixed number of samples after each iteration
    to store the difference between this reading and the last one. If we store all
    differences over the time, we can easily find the trend of our readings and recognize
    when we read a peak. To improve our algorithm, we need to perform the following
    steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，数值随时间变化，当发生心跳时，光传感器检测到光强的变化，这一事件导致图表中产生一个峰值。换句话说，我们可以假设每个峰值都对应一次心跳。下一步是改进我们的草图，以近似和转换这些数值，因为我们应该尝试去除读数错误和假阳性。主要思想是在每次迭代后收集固定数量的样本，以存储这次读数和上一次读数之间的差值。如果我们随着时间的推移存储所有差值，我们可以轻松找到读数趋势，并识别出我们读取峰值的时候。为了改进我们的算法，我们需要执行以下步骤：
- en: 'Add the following variables on the top of the sketch:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的顶部添加以下变量：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We set how many `SAMPLES` we use to calculate the incremental differences. We
    then use `lastReading`, `i`, and `delta` variables to store respectively the last
    reading, the current index to iterate the `readings` array and the current difference
    from the last reading. We then define an accumulator to store the current total
    reading.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们设置用于计算增量差值的`SAMPLES`数量。然后使用`lastReading`、`i`和`delta`变量分别存储上一次读数、用于迭代`readings`数组的当前索引，以及与上一次读数的当前差值。然后我们定义一个累加器来存储当前的读数总和。
- en: 'Initialize the `readings` array in the setup function:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`函数中初始化`readings`数组：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the `collectReads()` function at the bottom of the sketch:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部添加`collectReads()`函数：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first part we are going to read the current value and calculate the difference
    from the last reading. Then we accumulate this difference using the current `totalReading`
    and the last stored difference in the `readings` array. We can now update the
    `readings` array with the new `delta` object for the current index, which is incremented
    in the last line and is kept within bounds using the *modulo operator*.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一部分，我们将读取当前值并计算与上一次读数的差值。然后我们使用当前的`totalReading`和`readings`数组中存储的上一个差值来累加这个差值。现在我们可以用新的`delta`对象更新当前索引的`readings`数组，该索引在最后一行递增，并通过*模运算符*保持在界限内。
- en: 'In the main `loop()` function, substitute the `printRawData()` function call
    with the new `collectReads()` function and then print the accumulated value:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中，用新的`collectReads()`函数替换`printRawData()`函数调用，然后打印累积的值：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these enhancements, we can upload the new sketch and repeat the experiment
    in the same way we did previously:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些增强后，我们可以上传新的草图，并像之前一样重复进行实验：
- en: Put your index finger between the photoresistor and the LED.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的食指放在光电阻和LED之间。
- en: Click on **serial monitor** on the Arduino IDE.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Arduino IDE 上点击**串行监视器**。
- en: Complete a full 10 seconds iteration.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成一个完整的10秒迭代。
- en: Copy and paste the values into the previous spreadsheet and draw a bar chart.
    We should avoid including the first eight readings because they are related to
    the first iteration where the `readings` array is not initialized yet.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些值复制并粘贴到之前的电子表格中，并绘制条形图。我们应该避免包含前八个读数，因为它们与第一次迭代有关，而此时`readings`数组尚未初始化。
- en: 'The collected values produce a chart, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到的值产生了如下图表：
- en: '![Collecting data from the sketch](img/1942OS_04_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![从草图中收集数据](img/1942OS_04_05.jpg)'
- en: 'In these processed readings, there are fluctuations between positive and negative
    values and this occurs when we are climbing or descending the peaks we saw in
    the first chart. With this knowledge, we can improve a little of our algorithm
    so that we can track the climbing or descending phase and choose whether to discard
    the reading or count it as a single heartbeat. To complete this part, we need
    to add the following code using the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些处理过的读数中，正负值之间会有波动，这种情况出现在我们攀登或下降之前看到的峰值时。有了这些知识，我们可以稍微改进一下算法，以便追踪攀登或下降阶段，并选择是丢弃读数还是将其计为一次心跳。要完成这部分，我们需要按照以下步骤添加以下代码：
- en: 'Add these declarations at the top of the sketch:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的顶部添加这些声明：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define the `POS_THRESHOLD` and `NEG_THRESHOLD` parameters to set the bounds
    of the interval in which we discard values to avoid false positives. We also define
    a `PERMINUTE` constant to know which is the multiplier to get the beats per minute
    and the `beats` accumulator. As a last declaration, we set the `hillClimb` variable
    to store if the next readings are in the ascending or descending phase. For instance,
    a `True` value means that we are in the ascending phase.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了`POS_THRESHOLD`和`NEG_THRESHOLD`参数来设置我们丢弃值的区间边界，以避免误报。同时，我们还定义了一个`PERMINUTE`常数，以得知获取每分钟心跳数的乘数以及`beats`累加器。最后，我们设置了一个`hillClimb`变量，用来存储下一次读数是在上升阶段还是下降阶段。例如，`True`值意味着我们处于上升阶段。
- en: 'Add the `findBeat()` function at the bottom of the sketch:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部添加`findBeat()`函数：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We check whether the `totalReading` parameter is below `NEG_THRESHOLD` parameter
    to know whether we are in the descending phase of a peak. In this case, we set
    the `hillClimb` variable to `True`. In the last code block, we check whether we
    are over the `POS_THRESHOLD` and in the ascending phase. In that case, we set
    the `hillClimb` to `False` and count this phase change as a heartbeat. If we take
    a look at the previous chart, through the preceding code we can easily determine
    in which phase we are during each reading, and with this information we can discard
    as many errors and false positives as possible.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们检查`totalReading`参数是否低于`NEG_THRESHOLD`参数，以确定我们是否处于峰值下降阶段。在这种情况下，我们将`hillClimb`变量设置为`True`。在最后的代码块中，我们检查是否超过了`POS_THRESHOLD`并且处于上升阶段。如果是这样，我们将`hillClimb`设置为`False`，并将此阶段变化计为一次心跳。如果我们查看之前的图表，通过前面的代码，我们可以轻松确定每次读数时我们处于哪个阶段，并且利用这些信息尽可能多地排除错误和误报。
- en: 'Add the utility function `calcHeartRate()` at the bottom of the sketch:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部添加实用函数`calcHeartRate()`：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the main `loop()` function, add the following code to use the previous functions
    and to print the heart rate with the number of beats in the serial port:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中，添加以下代码以使用前面的函数，并在串行端口中打印心率及心跳数：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upload the sketch again and start to count the heartbeats. In the serial monitor,
    we will notice the following values:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次上传草图并开始计算心跳。在串行监视器中，我们会注意到以下值：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last improvement for our sketch is to add the ADK functionalities to send
    computed heartbeats to our Android application. At the top of the sketch, add
    the following *accessory descriptor*, which is almost equal to the one we used
    in the previous prototypes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们草图的最后改进是添加ADK功能，将计算出的心跳发送到我们的Android应用程序。在草图的顶部，添加以下*accessory descriptor*，它与我们之前原型中使用的基本相同：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As the last step, in the main `loop()` function, wrap the sketch execution
    in the ADK communication and remove all serial prints together with the last delay
    of a second:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，在主`loop()`函数中，将草图执行包裹在ADK通信中，并移除所有的串行打印以及最后的1秒延迟：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, the heart rate monitor will start when the ADK communication is
    up and running and we will use the `adk.write()` function to send the computed
    heart rate back to the Android application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，心率监测器将在ADK通信启动并运行时开始工作，我们将使用`adk.write()`函数将计算出的心率发送回Android应用程序。
- en: Android for data visualization
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android用于数据可视化
- en: Now that our physical application has a fully working circuit to read our heart
    rate through an unconventional use of a light sensor, we should complete the prototype
    with an Android application. From the Android Studio, start a new Android project
    called *HeartMonitor* with **Android API 19**. During the bootstrap process, choose
    a **Blank Activity** named *Monitor*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的物理应用程序已经有了一个完全工作的电路，可以通过对光传感器的非常规使用来读取心率，我们应该用Android应用程序来完成原型设计。从Android
    Studio开始，启动一个名为*HeartMonitor*的新Android项目，使用**Android API 19**。在引导过程中，选择一个名为*Monitor*的**空白活动**。
- en: 'We start writing the application from the user interface, and we have to think
    and design the activity layout. For the purpose of this application, we write
    a simple layout with a title and a text component that we will update every time
    Android receives a heartbeat estimation from the sketch. This layout could be
    achieved through the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从用户界面开始编写应用程序，并且需要思考和设计活动布局。为了这个应用程序的目的，我们编写了一个简单的布局，包含一个标题和一个文本组件，每次Android从草图中接收到心跳估算时，我们都会更新这个组件。这个布局可以通过以下步骤实现：
- en: 'In the `styles.xml` file under `res/values/`,add these color declarations and
    replace the standard theme:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values/`下的`styles.xml`文件中，添加这些颜色声明并替换标准主题：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `AppTheme` parameter inherits the `Theme.AppCompat` parameter that refers
    to the *Holo Dark* theme available in the Android support library. We also create
    green and red colors that we will use later in our application.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AppTheme`参数继承了`Theme.AppCompat`参数，它指的是Android支持库中可用的*Holo Dark*主题。我们还创建了绿色和红色，稍后将在我们的应用程序中使用。'
- en: 'In the `activity_monitor.xml` file under `res/layout/`, replace the root layout
    with the highlighted changes:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout/`下的`activity_monitor.xml`文件中，用高亮显示的更改替换根布局：
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Change the `TextView` parameter included in the preceding layout with the following
    code to have a bigger green title that will show the application name:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更改前一个布局中包含的`TextView`参数，以拥有一个更大的绿色标题，显示应用程序名称：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Nest a new `LinearLayout` in the root layout:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根布局中嵌套一个新的`LinearLayout`：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We set a margin from the previous element, using all available space to place
    the inner components in a center position.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从上一个元素设置一个边距，使用所有可用空间将内部组件放置在居中位置。
- en: 'Add the following TextViews to show the label and the placeholder that will
    contain the computed beats per minute:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下TextView以显示标签和占位符，占位符将包含计算出的每分钟节拍数：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Retrieve the widget within the activity class in order to change it after each
    reading. Add the following declaration at the top of the `Monitor` class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动类中获取小部件，以便在每次读取后更改它。在`Monitor`类的顶部添加以下声明：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Find the view identified by the `bpm` identifier in the `onCreate()` callback
    through the highlighted code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调中通过高亮代码找到由`bpm`标识符标识的视图：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Without any further configuration, the following is the obtained layout:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有进一步配置的情况下，以下是获得的布局：
- en: '![Android for data visualization](img/1942OS_04_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![用于数据可视化的Android](img/1942OS_04_06.jpg)'
- en: The application layout is now complete and we can proceed to setup the ADK communication.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序布局已完成，我们可以继续设置ADK通信。
- en: Setting up the ADKToolkit
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置ADKToolkit
- en: Like we did for the first prototype, we need to write all ADK classes and methods
    again to send and receive data. However, because a good principle of software
    development is Don't repeat yourself (DRY), we are going to use an external library
    that provides a high abstraction for all needed functionalities. The library is
    called **ADKToolkit** and it's a wrapper for the native ADK APIs that prevents
    code duplication every time we start a new project. We can find more information
    and examples related to the library at [http://docs.adktoolkit.org](http://docs.adktoolkit.org).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对第一个原型所做的那样，我们需要重新编写所有的ADK类和方法以发送和接收数据。然而，由于软件开发的良好原则是“不要重复自己”（DRY），我们将使用一个外部库，它为所有需要的功能提供了高抽象。这个库被称为**ADKToolkit**，它是原生ADK
    API的封装，可以防止我们在每次开始新项目时重复代码。我们可以在[http://docs.adktoolkit.org](http://docs.adktoolkit.org)找到更多关于该库的信息和示例。
- en: 'The first step that is required is to add the ADKToolkit library to the application
    dependencies. In the projects built with Android Studio, we have two different
    files called `build.gradle`. These files contain all the configurations related
    to the Gradle build system, and one of them is related to the global project,
    while the other is related to the module application we''re building. Even if
    both the files contain a list of dependencies, we should add the library to the
    `build.gradle` file related to the application module, which is located in the
    `app` folder. If we''re using the **Project** panel available on the left of the
    Android Studio interface, we have to double-click on the **build.gradle (Module:
    app)** script. In this file, we need to add the highlighted code within the `dependencies`
    block:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '首先需要做的是将ADKToolkit库添加到应用程序依赖项中。在用Android Studio构建的项目中，有两个名为`build.gradle`的不同文件。这些文件包含了与Gradle构建系统相关的所有配置，其中一个与全局项目相关，另一个与我们正在构建的应用程序模块相关。尽管这两个文件都包含依赖项列表，但我们应该将库添加到位于`app`文件夹中的与应用程序模块相关的`build.gradle`文件中。如果我们使用Android
    Studio界面左侧可用的**Project**面板，必须双击**build.gradle (Module: app)**脚本。在这个文件中，我们需要在`dependencies`块中添加高亮显示的代码：'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we can click on the **Sync Now** button available in the flash message and
    wait for gradle to complete the synchronization process that downloads the ADKToolkit
    library automatically.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以点击闪存消息中可用的**Sync Now**按钮，并等待Gradle完成同步过程，这个过程会自动下载ADKToolkit库。
- en: 'Like we did in [Chapter 2](ch02.html "Chapter 2. Know Your Tools"), *Know your
    Tools*, we should update the Android manifest file to register the application
    with the correct intent filter and accessory descriptor. To proceed with the ADK
    configuration, follow these reminders:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](ch02.html "第2章。了解你的工具")，*了解你的工具*中所做的那样，我们应该更新Android清单文件，以注册具有正确意图过滤器和配件描述符的应用程序。要继续进行ADK配置，请遵循以下提醒：
- en: 'Create the accessory filter file `usb_accessory_filter.xml` located under `res/xml/`
    with the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml/`目录下创建配件过滤器文件`usb_accessory_filter.xml`，并使用以下代码：
- en: '[PRE23]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add the USB `<uses-feature>` tag in the `AndroidManifest.xml` file.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加USB `<uses-feature>`标签。
- en: In the activity block of the `AndroidManifest.xml` file, add the ADK `<intent-filter>`
    and the `<meta-data>` tags to set the USB accessory filter.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件的Activity块中，添加ADK `<intent-filter>`和`<meta-data>`标签，以设置USB配件过滤器。
- en: 'Now we must initialize the ADKToolkit library to enable the communication and
    start reading processed data. In the `Monitor` class, add the following snippets:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须初始化ADKToolkit库以启用通信并开始读取处理后的数据。在`Monitor`类中，添加以下代码片段：
- en: 'Declare the `AdkManager` object at the top of the class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部声明`AdkManager`对象：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `AdkManager` initialization in the `onCreate()` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中添加`AdkManager`的初始化：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `AdkManager` is the main class of the ADKToolkit library. To initialize
    the manager instance, we should pass the current context to its constructor, and
    because the activity class inherits from `Context` class, we can simply pass the
    instance using the `this` keyword. All functionalities related to the ADK communication
    will be used through the `mAdkManager` instance.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AdkManager`是ADKToolkit库的主要类。为了初始化管理器实例，我们应该将当前上下文传递给它的构造函数，由于活动类从`Context`类继承，我们可以简单地使用`this`关键字传递实例。所有与ADK通信相关的功能都将通过`mAdkManager`实例来使用。'
- en: 'Override the `onResume()` and `onPause()` callbacks to start and stop the ADK
    connection when the `Monitor` activity is opening or closing:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onResume()`和`onPause()`回调，以便在`Monitor`活动打开或关闭时开始和停止ADK连接：
- en: '[PRE26]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `mAdkManager` instance exposes the `close()` and `open()` methods to control
    easily the accessory connection. We have to bear in mind that it's a requirement
    to open the ADK communication in the `onResume()` method, because the `AdkManager`
    initialization is not sufficient to enable the channel between Android and Arduino.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mAdkManager`实例暴露了`close()`和`open()`方法，以便轻松控制配件连接。我们必须记住，在`onResume()`方法中打开ADK通信是一个要求，因为`AdkManager`的初始化不足以启用Android和Arduino之间的通道。'
- en: With the previous steps, we have completed the ADK configuration and now we
    can start to write the logic to receive data from the sketch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上步骤，我们已经完成了ADK配置，现在可以开始编写接收草图数据的逻辑。
- en: Continuous data readings from Android
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Android进行连续数据读取
- en: The main concept of our Android application is to use the ADKToolkit to make
    continuous readings of data collected by UDOO board. Every time estimations are
    written in the OTG serial port, we need to read these values and update the Android
    user interface, but, before we proceed, we need to make some considerations about
    the Android threading system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Android应用程序的主要概念是使用ADKToolkit对UDOOboard收集的数据进行连续读取。每次估算通过OTG串行端口写入时，我们需要读取这些值并更新Android用户界面，但在我们继续之前，我们需要对Android线程系统进行一些考虑。
- en: When an Android application starts, all the components of this application run
    in the same process and thread. This is called the **main thread** and it hosts
    among other components, the current foreground `Activity` instance. Whenever we
    need to update any views of the current activity, we should run the updating code
    in the main thread, otherwise the application will crash. On the other hand, we
    have to bear in mind that any operation done in the main thread should be completed
    immediately. If our code is slow or if it makes blocking operations such as I/O,
    the system that will popup the **Application Not Responding** (**ANR**) dialog
    because the main thread is unable to handle user input events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android应用程序启动时，该应用程序的所有组件都在同一个进程和线程中运行。这称为**主线程**，它托管诸如当前前台`Activity`实例等其他组件。每当我们需要更新当前活动的任何视图时，我们应该在主线程中运行更新代码，否则应用程序将会崩溃。另一方面，我们必须记住，主线程中完成的任何操作都应该立即完成。如果我们的代码运行缓慢或执行阻塞操作（如I/O），系统将会弹出**应用程序无响应**（**ANR**）对话框，因为主线程无法处理用户输入事件。
- en: This error will surely occur if we run continuous readings in the main thread,
    because we should query the light sensor in a cycle, which causes blocking I/O
    operations every 10 seconds. For these reasons, we can make use of an `ExecutorService`
    class that can run periodical scheduled threads. In our case, we will define a
    short-lived thread that will be created every 10 seconds from the above scheduler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在主线程中运行连续读取，这种错误肯定会发生，因为我们应该在一个循环中查询光线传感器，这会导致每10秒发生阻塞I/O操作。因此，我们可以使用`ExecutorService`类来运行周期性的计划线程。在我们的案例中，我们将定义一个生命周期较短的线程，该线程将每隔10秒从上述调度程序中创建。
- en: 'When the scheduled thread finishes reading data from the OTG serial port, it
    should communicate the received message to the main thread through a `Handler`
    class. We can find more information and examples about how to communicate with
    the main thread in the official Android documentation at:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当计划线程从OTG串行端口读取数据完成后，它应该通过`Handler`类将接收到的消息传递给主线程。我们可以在官方Android文档中找到更多关于如何与主线程通信的信息和示例：
- en: '[https://developer.android.com/training/multiple-threads/communicate-ui.html](https://developer.android.com/training/multiple-threads/communicate-ui.html).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[在主线程中通信](https://developer.android.com/training/multiple-threads/communicate-ui.html)。'
- en: 'As a first step we should expose all the required methods to update the Android
    user interface through the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该通过以下步骤公开所有需要更新Android用户界面的方法：
- en: 'Create a new Java interface called `OnDataChanges` and add the following method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`OnDataChanges`的新Java接口，并添加以下方法：
- en: '[PRE27]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Through this code, we define the interface that we will use in our `Handler`
    to update the user interface with the given `heartRate` parameter.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这段代码，我们定义了将在我们的`Handler`中使用的接口，以给定`heartRate`参数更新用户界面。
- en: 'Implement the interface in the `Monitor` class through the highlighted code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Monitor`类中通过高亮代码实现接口：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Write the following code at the end of the class to update the Android user
    interface through the `updateBpm` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的末尾编写以下代码，通过`updateBpm`方法更新Android用户界面：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last required step is to implement our scheduled thread that reads processed
    data from Arduino and writes these values in the user interface. To complete this
    last building block, perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必需的步骤是实现我们的计划线程，从Arduino读取处理后的数据，并在用户界面中写入这些值。要完成这个最后的构建块，请执行以下步骤：
- en: Create a new package in your namespace called `adk`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的命名空间中创建一个名为`adk`的新包。
- en: In the `adk` package, add a new class named `DataReader`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`adk`包中，添加一个名为`DataReader`的新类。
- en: 'At the top of the class, add the following declarations:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，添加以下声明：
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We're defining the heartbeat polling time and an `int` variable that we use
    later to identify the published message within our handler. We also store the
    references for the `AdkManager` parameter and the `caller` activity to use the
    ADK `read` method and the `updateBpm` callback, respectively. Then we define our
    `ExecutorService` implementation together with a `Handler` that we will attach
    to the main thread.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了心跳轮询时间和一个后面要使用的`int`变量，用于在我们的处理程序中识别发布的信息。我们还存储了`AdkManager`参数和`caller`活动的引用，分别用于ADK的`read`方法和`updateBpm`回调。然后我们定义了`ExecutorService`实现以及一个要附加到主线程的`Handler`。
- en: 'Implement the `DataReader` constructor to define the handling message code
    when the main thread receives a new message from the background thread:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现构造函数`DataReader`，以定义当主线程从后台线程接收到新消息时的处理消息代码。
- en: '[PRE31]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After storing the `AdkManager` instance and `caller` activity references, we
    attach a new `Handler` to the application's main looper, which lives in the main
    thread. We should override the `handleMessage` callback in order to check the
    user defined message code to identify the `HEARTBEAT_READ` message. In this case,
    we call the `updateBpm` callback using the object attached to the received `message`
    parameter.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储了`AdkManager`实例和`caller`活动引用之后，我们向应用程序的主looper附加一个新的`Handler`，该looper位于主线程中。我们应该重写`handleMessage`回调，以便检查用户定义的消息代码，以识别`HEARTBEAT_READ`消息。在这种情况下，我们使用接收到的`message`参数中附加的对象来调用`updateBpm`回调。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Each `Handler` has its own namespace for message codes, so you do not need to
    worry about your `message.what` attribute's possible values conflicting with the
    other handlers.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个`Handler`都有自己消息代码的命名空间，因此你不需要担心你的`message.what`属性的可能值与其他处理程序发生冲突。
- en: 'At the bottom of the `DataReader` class, add the following private class that
    implements the `Runnable` interface to read and publish sensor data:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataReader`类的底部，添加以下实现了`Runnable`接口的私有类，以读取和发布传感器数据：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the thread starts, we read the available data using the `AdkManager read`
    method. This method returns an `AdkMessage` instance that contains the raw received
    bytes and some utilities to parse the response; in our case, we use the `getByte`
    method to get the first received byte. As the last step, we should publish the
    collected value through the main thread handler. We then create a `Message` instance
    using the `obtainMessage` method, which will pull a new message from the handler
    messages pool. Now we can dispatch the message to the main thread using the `sendToTarget`
    method.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当线程启动时，我们使用`AdkManager read`方法读取可用的数据。这个方法返回一个包含原始接收字节和一些用于解析响应的工具的`AdkMessage`实例；在我们的案例中，我们使用`getByte`方法获取第一个接收的字节。作为最后一步，我们应该通过主线程处理器发布收集到的值。然后我们使用`obtainMessage`方法创建一个`Message`实例，该方法将从处理器消息池中获取一条新消息。现在我们可以使用`sendToTarget`方法将消息派发给主线程。
- en: 'Add the `DataReader start()` method to start a scheduler that spawns threads
    periodically:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DataReader start()`方法以启动定期生成线程的调度程序：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we call this method from the `Monitor` activity, the `ExecutorService`
    parameter will be initialized using the `newSingleThreadScheduledExecutor()` function.
    This will create a single-threaded executor that guarantees to execute no more
    than one task at any given time despite the polling period. As the last step,
    we use a periodical scheduler to run our `SensorThread` every `HEARTBEAT_POLLING`
    milliseconds.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们从`Monitor`活动中调用这个方法时，`ExecutorService`参数将使用`newSingleThreadScheduledExecutor()`函数进行初始化。这将创建一个单线程的执行器，保证在任何给定时间执行的任务不会超过一个，尽管有轮询周期。作为最后一步，我们使用周期性调度程序每`HEARTBEAT_POLLING`毫秒运行一次我们的`SensorThread`。
- en: 'Add the `stop()` method to the `DataReader` class to stop the schedule from
    spawning new threads. In our case, we simply use the `shutdown()` executor''s
    method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataReader`类中添加`stop()`方法，以停止调度程序生成新线程。在我们的案例中，我们只需使用执行器的`shutdown()`方法：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we should go back to the `Monitor` class to start and stop our thread scheduler
    within the activity lifecycle. Add the `DataReader` declaration at the top of
    the `Monitor` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该回到`Monitor`类，在活动生命周期内启动和停止我们的线程调度程序。在`Monitor`类的顶部添加`DataReader`声明：
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks, as you can see in the following highlighted code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onResume()`和`onPause()`活动的回调中启动和停止读取调度程序，正如以下高亮代码所示：
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is nothing left to do and our prototype is ready to be deployed. Now we
    can put our index finger between the photoresistor and the LED and take a look
    at the Android application while the result is updated each 10 seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他事情可做，我们的原型已经准备好部署。现在我们可以将食指放在光敏电阻和LED之间，同时查看Android应用程序，结果每10秒更新一次。
- en: Enhancing the prototype
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进原型
- en: Even if the prototype obtains good results, we may want more accurate readings.
    A great enhancement for the physical application can be reached with a better
    housing for the photoresistor and the bright LED. Indeed, if we can remove the
    environment light and make both components more stable during readings, we can
    have great improvements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使原型获得了良好的结果，我们可能希望获得更准确的读数。为物理应用获得更好改进的一个方法是，为光敏电阻和明亮的LED提供一个更好的外壳。实际上，如果我们能够移除环境光线，并在读取时使这两个组件更加稳定，我们就能获得很大的改进。
- en: 'A good approach to achieve this goal is to use an easy-to-get component: *a
    wooden peg*. We can drill the peg in one go, so the holes are lined up. In this
    way, we can put the photoresistor in one hole while the LED is in the other one.
    The rest of components and the breadboard itself remain unaltered. The following
    illustration shows a wooden peg to house both the components:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此目标的一个好方法是使用一个容易获得的组件：*一个木制销钉*。我们可以一次性钻好销钉，使孔对齐。这样，我们可以将光敏电阻放在一个孔中，而LED在另一个孔中。其余的组件和面包板本身保持不变。以下插图显示了一个木制销钉，用于容纳这两个组件：
- en: '![Enhancing the prototype](img/1942OS_04_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![改进原型](img/1942OS_04_07.jpg)'
- en: 'Another improvement is to change and play with the algorithm parameters available
    in the sketch. Changing the interval and the samples number may obtain better
    results; however, we have to keep in mind that these changes may also get worse
    readings. The following is a collection of algorithm parameters that we may change:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进是改变和调整草图中可用的算法参数。改变间隔和样本数量可能会获得更好的结果；然而，我们必须记住，这些更改也可能导致读数变得更糟。以下是我们可以更改的一些算法参数的集合：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For instance, if we find that our photoresistor works badly with 50 milliseconds
    of the `HEARTBEAT_POLL_PERIOD` object-like macro, we may try to use more common
    timings such as 100 or 200 milliseconds.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们发现光敏电阻在50毫秒的`HEARTBEAT_POLL_PERIOD`对象宏下工作效果不佳，我们可能会尝试使用更常见的时序，如100毫秒或200毫秒。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the use of external sensors to improve the capabilities
    of our physical applications. We discovered how a sensor works and we took a look
    at an example that detects distance and object proximity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用外部传感器来增强我们的物理应用功能。我们了解了传感器的工作原理，并查看了一个检测距离和物体接近程度的示例。
- en: As the first step, we got some information about the biological process of the
    heartbeat and we found how a photoresistor together with a bright LED could help
    us to detect the heart rate. We did some initial experiments using our first heart
    monitor prototype and collected various absolute values that we plotted later
    into a chart. After the first analysis, we saw that each peak could be a heartbeat
    and this brought us to enhance the reading phase with an algorithm capable of
    computing differences between readings during chosen intervals.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们获取了一些关于心跳生物过程的信息，并发现了一个光敏电阻与一个明亮的LED如何帮助我们检测心率。我们使用第一个心率监测原型进行了一些初步实验，并收集了各种绝对值，我们后来将这些值绘制成图表。在初次分析后，我们发现每个峰值可能是一次心跳，这促使我们通过一个能够在选定间隔内计算读数差值的算法来增强读取阶段。
- en: With the previous values, we plotted a new chart and discovered that we should
    check when there is a phase change to find a possible heartbeat. Indeed, our last
    work was to add a function to calculate the heart rate ready to be sent back to
    the Android application through the ADK communication protocol.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 利用之前的数值，我们绘制了一张新图表，并发现我们应该检查相位变化以找到可能的心跳。实际上，我们最后的工作是添加一个功能，用于计算心率，并通过ADK通信协议将其发送回Android应用。
- en: To show the previous result, we created a layout for our Android application.
    We configured and used the ADKToolkit library to simplify the communication process.
    Through a `ScheduledExecutorService` instance, that launches short-lived threads
    for data collection, we set the processed heart rate in a custom user interface.
    At the end of this chapter, we explored how to improve our working prototype with
    some advice that we can follow before proceeding with the next chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示之前的结果，我们为Android应用创建了一个布局。我们配置并使用了ADKToolkit库以简化通信过程。通过一个`ScheduledExecutorService`实例，该实例启动短生命周期的线程进行数据采集，我们在自定义用户界面中设置了处理后的心率。在本章末尾，我们探讨了在进入下一章之前，如何通过一些建议来改进我们的工作原型。
- en: In the next chapter, we will build another physical application that uses an
    external component to control the Android application. It will make use of some
    Android native APIs to realize, in an easy way, some features that will not be
    possible without an over complicated hardware and sketch.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建另一个物理应用，它将使用外部组件来控制Android应用。它将利用一些Android原生API，以简单的方式实现一些没有复杂硬件和草图就无法完成的功能。
