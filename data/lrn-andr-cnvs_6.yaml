- en: Chapter 6. Putting it All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 将它们整合在一起
- en: At last we have made it to the end of our process of gaining basic knowledge
    and skills to work with Android Canvas. In this chapter, we will develop a complete
    application step-by-step from scratch with all the functionality, using all the
    knowledge and techniques that we have used in the previous chapters. In each chapter,
    throughout this book, we have learned and practiced one core essential component
    of drawing with Canvas. Now in this chapter, we will bring all those components
    together with some additional features to create a fully functional application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经学完了使用Android Canvas的基础知识和技能的过程。在本章中，我们将从零开始逐步开发一个完整的应用程序，实现所有功能，使用我们在前几章中学到的所有知识和技巧。在本书的每一章中，我们都学习和练习了使用Canvas绘图的一个核心基本组件。现在，在本章中，我们将把这些组件与一些额外的功能结合起来，创建一个功能齐全的应用程序。
- en: To create any application or game, we need to have a plan, plot, or story board
    for it. The story board will tell us how things will work and appear in our application,
    what will be the core functionality or output of our application, and what are
    the extra or supporting features that we need to make our application useful and
    complete. The plan could be some rough bulleted notes on a paper or it can be
    some hand-drawn sketches, but it will encapsulate all our needs and outputs that
    we want from it. Some notes attached to the drawing will complete our plan and
    the overall vision of our application. One good thing about planning is that it
    freezes the requirements and our application. In normal software engineering,
    before starting the development of an application, a **Software Requirements Specification**
    document is prepared in that all the requirements are written and signed by both
    parties. It defines the boundaries of the project and this is very important.
    Without defining the boundaries or limits of requirements, the development of
    an application will never end because, with time, requirements increase during
    development. So we must have a defined set of requirements and functions. Later
    on, we can add more functionality in the new versions of the application, but
    at least the core requirements and functionality will be complete in the base
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建任何应用程序或游戏，我们需要有一个计划、情节或故事板。故事板将告诉我们应用程序中事物的工作和展示方式，应用程序的核心功能或输出是什么，以及我们需要使应用程序有用和完整的一些额外或支持功能。计划可以是纸上的一些粗略的子弹笔记，也可以是一些手绘草图，但它将包含我们从它那里需要的所有需求和输出。附在绘图上的一些注释将完成我们的计划和对应用程序的整体构想。规划的好处在于它冻结了需求和我们的应用程序。在正常的软件工程中，在开始应用程序开发之前，会准备一份**软件需求规范**文档，其中写明了所有需求，并由双方签字。它定义了项目的边界，这非常重要。如果没有定义需求的边界或限制，应用程序的开发将永无止境，因为在开发过程中，随着时间的推移，需求会增加。所以我们必须有一套明确的需求和功能。以后，我们可以在应用程序的新版本中添加更多功能，但至少基础应用程序中的核心需求和功能将是完整的。
- en: The story board
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事板
- en: We will start with the wireframe of our application with some notes on it and
    some pointers and sections; then we will explain the sketch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用程序的线框开始，上面有一些注释、指针和部分内容；然后我们会解释这个草图。
- en: 'The following diagram shows the story board of our application that we will
    develop:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们将要开发的应用程序的故事板：
- en: '![The story board](img/5396OS_06_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![故事板](img/5396OS_06_01.jpg)'
- en: The previous diagram is quite self-explanatory and gives us a complete sketch
    of what we are planning to do. The top-most area shows the application title and
    will also display a small icon if we have used one while creating the application.
    Below the title bar is the major empty **Drawing Area,** where we will perform
    all our free-hand drawing and painting. At the bottom of the screen, we will have
    a **Control panel**, from where we can select the function as well as the drawing
    and painting style. The **Control panel** will help us in selecting the colors
    for our brush. We can change the size of the brush. We can perform certain functions
    such as create a new drawing, save the existing drawing, select a brush size,
    click on the eraser to select it, and erase the currently drawn painting. We will
    use our fingers and touch events to draw on the Canvas. Later, we can either **Save**,
    **Erase**, or change the color and brush size, and proceed with our painting.
    So our goal is a simple Paint-like application for Android.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表非常直观，为我们提供了完整的设计草图，展示了我们计划要做的事情。最顶部区域显示应用程序标题，如果我们创建应用程序时使用了小图标，它也会显示出来。标题栏下方是主要的空白**绘图区域**，我们将在那里进行所有的自由手绘和绘画。在屏幕底部，我们将有一个**控制面板**，从中可以选择功能以及绘图和绘画风格。**控制面板**将帮助我们选择画笔的颜色。我们可以改变画笔的大小。我们可以执行某些功能，如创建新绘图、保存现有绘图、选择画笔大小、点击橡皮擦以选择它，以及擦除当前绘制的画作。我们将使用手指和触摸事件在Canvas上绘图。稍后，我们可以选择**保存**、**擦除**，或者更改颜色和画笔大小，然后继续我们的绘画。所以我们的目标是开发一个类似Paint的简单Android应用程序。
- en: The project and application development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目和应用开发
- en: 'We will achieve our goal by dividing the project into four stages. During the
    development process, we will go through each stage step-by-step and at the end,
    we will have our working paint application. Following are the stages:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将项目划分为四个阶段来实现我们的目标。在开发过程中，我们会逐步完成每个阶段，最终开发出我们自己的绘图应用程序。以下是各个阶段：
- en: The user interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: Enabling the touch and painting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用触摸和绘画
- en: Enabling the color selection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用颜色选择
- en: Spicing up our application with more functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序增加更多功能
- en: The user interface
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: We will start our project by creating a new Android application in Eclipse through
    the wizard, as we have practiced earlier in this book. Only the first screen of
    the new Android application wizard is attached.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在Eclipse中通过向导创建一个新的Android应用程序来开始我们的项目，正如我们在本书前面练习的那样。仅附上了新Android应用程序向导的第一屏。
- en: 'The following screenshot shows the first screen of the new Android application
    wizard:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了新Android应用程序向导的第一屏：
- en: '![The user interface](img/5396OS_06_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面](img/5396OS_06_02.jpg)'
- en: We will name our application as `OurFirstPaintApp`, the **Project Name** will
    be populated automatically, and we will change the **Package Name** to `com.learningandroidcanvasmini`.
    During the development of this application, we will be working with XML files
    in the `res` folder and Java files in the `src` folder of our project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的应用程序命名为`OurFirstPaintApp`，**项目名称**将会自动填充，我们将**包名称**更改为`com.learningandroidcanvasmini`。在开发这个应用程序的过程中，我们将在项目的`res`文件夹中的XML文件和`src`文件夹中的Java文件中工作。
- en: Screen orientation
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕方向
- en: Before we start anything, we need to decide what orientation our project will
    support. Let's say we want our project application to always be in **Portrait**
    form even if the user is holding the device in landscape mode. To do this, we
    will open the `AndroidManifest.xml` file and will change `android:screenOrientation="landscape"`
    in the `Activity` tag to `android:screenOrientation="portrait"`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要决定我们的项目将支持哪种方向。假设我们希望我们的项目应用程序即使在用户横屏持设备时也始终保持**纵向**形式。为此，我们将打开`AndroidManifest.xml`文件，并将`Activity`标签中的`android:screenOrientation="landscape"`更改为`android:screenOrientation="portrait"`。
- en: The paint brush
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画笔
- en: 'From our story board, we know that we have to use different sizes of brushes;
    for this, we will define some numbers that will refer to certain brush sizes.
    We will go to the `res/values` folder and will open the `dimens.xml` file. If
    the file is not there, we will create a new XML file with the name `dimens.xml`
    and will put our values in it. In this file, we will look for the `<resources></resources>`
    tag. Inside this tag, we will put our values as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的故事板中，我们知道需要使用不同大小的画笔；为此，我们将定义一些数字，这些数字将代表特定的画笔大小。我们将转到 `res/values` 文件夹，并打开
    `dimens.xml` 文件。如果文件不在那里，我们将创建一个名为 `dimens.xml` 的新 XML 文件，并将我们的值放入其中。在这个文件中，我们将查找
    `<resources></resources>` 标签。在这个标签内部，我们将按如下方式放置我们的值：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will keep the dimension and the integer value the same so that the user interface
    can show the exact brush size when we use it for drawing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持尺寸和整数值相同，以便用户界面在我们绘图时可以显示确切的画笔大小。
- en: Designing the Control panel
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计控制面板
- en: 'In the Control panel that we have in our story board sketch, we have a row
    of colors and another row with some button that performs certain functions. Now
    we will start designing the **Control panel**. To begin with, we will add all
    the strings that we will use in the **Control panel**. To do this, we will open
    the `string.xml` file in the `res/values` folder and will add the following code
    to the file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们故事板草图中的控制面板中，我们有一排颜色和另一排执行某些功能的按钮。现在我们将开始设计**控制面板**。首先，我们将添加所有在**控制面板**中使用的字符串。为此，我们将打开
    `res/values` 文件夹中的 `string.xml` 文件，并将以下代码添加到文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up the layout
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置布局
- en: 'First, we will either create or download the following images from the Web
    and copy them in the `res/drawable` folder. The following screenshot shows the
    images in the `res/drawable` folder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从网上创建或下载以下图片，并将它们复制到 `res/drawable` 文件夹中。以下屏幕截图显示了 `res/drawable` 文件夹中的图片：
- en: '![Setting up the layout](img/5396OS_06_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![设置布局](img/5396OS_06_03.jpg)'
- en: Now, we will set up the **Layout** for our Canvas and **Control panel**, the
    drawing space, and the space that will host our buttons. We will open the `activity_main.xml`
    file. Inside the main `Layout` tag, we will enter three sub layout tags as mentioned
    in the following code snippet. The first one will hold the image for the new,
    brush, erase, and save buttons and the next two will each hold a row of colors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的画布和控制面板设置**布局**，绘图空间以及将容纳我们按钮的空间。我们将打开 `activity_main.xml` 文件。在主 `Layout`
    标签内部，我们将输入以下代码片段中提到的三个子布局标签。第一个将包含新建、画笔、擦除和保存按钮的图像，接下来的两个将分别包含一排颜色。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next we will add two more layouts in which we will have two rows of colored
    buttons as shown:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个更多布局，我们将在其中有两排彩色按钮，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The dots in the preceding code represent the code for the rest of the color
    buttons that we would like to add. The only thing that needs to be changed in
    the preceding block of code is the `android:tag="#FF660000"` code, which is the
    value of the color. Now we have the layout ready to for our Control panel. We
    need to fix some space in the layout for our drawing. Here, we will create a new
    Java class in the `src` folder by the name of `CustomDrawingView` that will extend
    View. For the time being, we will only create the skeleton code of the class so
    that we can refer to it in our layout XML file. Later, we will customize every
    section of our `CustomDrawingView` class and will put in all the functionality
    that we want our application to have. The skeleton code will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的点代表我们想要添加的其余颜色按钮的代码。在前面代码块中唯一需要更改的是 `android:tag="#FF660000"` 代码，这是颜色的值。现在我们已经为控制面板准备好了布局。我们需要在布局中为我们的绘图预留一些空间。这里，我们将在
    `src` 文件夹中创建一个名为 `CustomDrawingView` 的新 Java 类，该类将扩展 View。目前，我们只创建类的骨架代码，以便可以在布局
    XML 文件中引用它。稍后，我们将定制 `CustomDrawingView` 类的每个部分，并加入我们希望应用程序拥有的所有功能。骨架代码如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So we have added a `CustomDrawingView` class with a constructor and a `setupDrawing()`
    method. These are the most essential components right now. Without the constructor,
    the program will generate an error. Now we will come back to our `activity_main.xml`
    file and will add the following code just below the opening tag of the parent
    `layout` tag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经添加了一个 `CustomDrawingView` 类以及它的构造函数和 `setupDrawing()` 方法。这些是目前最核心的组件。没有构造函数，程序将生成错误。现在，我们将回到
    `activity_main.xml` 文件，并在父级 `layout` 标签的打开标签下方添加以下代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line of code, `<com.learningandroidcanvasmini.ourfirstpaintapp.CustomDrawingView`,
    in our XML file shows the package directory of our custom view. Second, this also
    shows us how we can add customized code-based layouts in our XML layout files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们XML文件中的代码行`<com.learningandroidcanvasmini.ourfirstpaintapp.CustomDrawingView`显示了我们的自定义视图的包目录。其次，这也告诉我们如何在我们的XML布局文件中添加基于自定义代码的布局。
- en: 'Although we now have our layout almost ready, it is still not complete. We
    need color selection buttons that are proper rectangles in our **Control panel**.
    So far, we have defined the image buttons, but some configuration is still needed
    such as the shape of those buttons. We want the same square-shaped buttons with
    slightly rounded corners. For this purpose, we will create a new `paint.xml` file
    in the `res/drawables` folder. In this file, we will use the technique explained
    in Drawables from Resource XML. We will create a two-layered Drawable shape: one
    layer for the rectangle object and the other for rounding its corners.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的布局几乎已经准备好了，但仍然不完整。我们需要在**控制面板**中添加适当的矩形颜色选择按钮。到目前为止，我们已经定义了图像按钮，但还需要一些配置，比如这些按钮的形状。我们希望这些按钮是略带圆角的正方形。为此，我们将在`res/drawables`文件夹中创建一个新的`paint.xml`文件。在这个文件中，我们将使用资源XML中的Drawables技术。我们将创建一个双层Drawable形状：一层用于矩形对象，另一层用于圆角。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have used a layer-list tag in which we have used two
    items. The first item is for the rectangle shape and the second is for rounding
    its corner. We will save all files and will run our code in the emulator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了layer-list标签，在其中我们使用了两个项目。第一个项目用于矩形形状，第二个用于圆角。我们将保存所有文件，并在模拟器中运行我们的代码。
- en: 'The following screenshot shows our application without any functionality:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们没有任何功能的应用程序：
- en: '![Setting up the layout](img/5396OS_06_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![设置布局](img/5396OS_06_04.jpg)'
- en: So far, we have completed the user interface and are done with the graphics
    work. Now we have to make our application touch enabled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了用户界面并完成了图形工作。现在，我们需要使我们的应用程序能够响应触摸。
- en: Enabling the touch and painting using touch
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用触摸并使用触摸绘画
- en: 'The target is to enable the touch: in other words, our application will paint
    as we drag our finger on the screen. We will start with opening our `CustomDrawingView`
    class and will add the following objects and variables:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是启用触摸：换句话说，我们的应用程序将在我们拖动手指在屏幕上时进行绘画。我们将从打开我们的`CustomDrawingView`类开始，并添加以下对象和变量：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this in the `setupDrawing()` method, we will instantiate the `Path` and
    `Paint` objects and will set its different attributes to certain values that we
    want it to get as default values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，在`setupDrawing()`方法中，我们将实例化`Path`和`Paint`对象，并将其不同的属性设置为某些我们希望它获得的默认值：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, in the method we will instantiate the canvasPaint object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在方法中，我们将实例化canvasPaint对象：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will jump to the `onDraw()` method and will add the following lines
    of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将跳转到`onDraw()`方法，并添加以下代码行：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `onDraw()` method receives an object of type `Canvas` as an argument and
    is used to draw the bitmap and the drawing or painting that we want. Each time
    we touch the screen and drag our finger, the `invalidate()` method will be called
    on the previous painting on the Canvas and the `onDraw()` method will be called
    automatically, displaying our current painting.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw()`方法接收一个类型为`Canvas`的对象作为参数，用于绘制位图和我们想要的绘图或绘画。每次我们触摸屏幕并拖动手指，`Canvas`上之前的绘画将调用`invalidate()`方法，`onDraw()`方法将自动被调用，显示我们当前的绘画。'
- en: 'We have almost everything in place but we have still not made our application
    touch enabled. For this, we will add an `onTouchEvent()` method to our `CustomDrawingView`
    class, as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经准备好了一切，但我们还没有使我们的应用程序能够响应触摸。为此，我们将向我们的`CustomDrawingView`类添加一个`onTouchEvent()`方法，如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this method, we have to do two jobs: detect the user''s touch and check
    the motion direction. The touch can be either up, meaning the finger is not touching
    the screen, or down, meaning that the finger is pressed on the screen. Motion
    can be a pressed finger moving in any direction. First, we will get the x, y location
    of the touch using the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们需要完成两项工作：检测用户的触摸动作并检查移动的方向。触摸可以是向上的，意味着手指没有接触屏幕；也可以是向下的，意味着手指按在屏幕上。动作可以是按下的手指向任何方向移动。首先，我们将使用以下代码获取触摸的x、y位置：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we will respond to that touch event according to one of the possible cases,
    which we will include in the following switch code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将根据以下开关代码中包含的可能情况之一响应触摸事件：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the down action event, the finger is pressed. Move the drawing point to
    the location touched:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下动作事件时，手指按下。将绘制点移动到触摸的位置：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the motion event, the finger is pressed and dragged in some direction.
    First, the point of drawing will be the point that is touched and then a line
    will be drawn along the motion of the finger during the dragging action:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动作事件，手指按住并向某个方向拖动。首先，绘制点将是触摸的点，然后在拖动动作期间沿着手指的移动绘制一条线：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, when the finger is lifted, a path on the Canvas will be drawn and the
    `Path` object will be refreshed so that it''s ready to draw a new line from the
    next location touched:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当手指抬起时，在Canvas上将会绘制一条路径，并且`Path`对象将被刷新，以便它准备好从下一个触摸位置开始绘制新线：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the end, we will call the `invalidate()` method so that we can activate
    the `onDraw()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将调用`invalidate()`方法，以便我们可以激活`onDraw()`方法：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The whole code of the class is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类的代码如下：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Enabling the color selection
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用颜色选择
- en: 'We will enable the color selection from the user interface that we created
    earlier. We know that we have two rows of different colors. Now we need our application
    to be able to set the color of our paint brush to the color that we select from
    the available color palette. To do this, we will open our main activity class
    and will add `import` statements for `View`, `ImageButton`, and `LinearLayout`
    to our import section of the main activity class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启用之前创建的用户界面进行颜色选择。我们知道我们有两行不同的颜色。现在我们需要应用程序能够将画笔颜色设置为从可用调色板中选择的颜色。为此，我们将打开主活动类，并在主活动类的导入部分添加`View`、`ImageButton`和`LinearLayout`的`import`语句：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, inside our main activity class, we will create an object of our `CustomDrawingView`
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的主活动类内部，我们将创建我们`CustomDrawingView`类的一个对象：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `onCreate()` method of our main activity class, we will instantiate
    the `drawView` object by getting a reference to its layout as defined in the `activity_main.xml`
    file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在主活动类的`onCreate()`方法中，我们将通过获取其在`activity_main.xml`文件中定义的布局引用来实例化`drawView`对象：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will add another object that will let us know which paint button is clicked:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加另一个对象，以便我们知道哪个画笔按钮被点击了：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next in the `onCreate()` method, we will add the following code. First we will
    get the layout that hosts our paint buttons. The `paint_colors` property is defined
    in the `activity_main.xml` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`onCreate()`方法中，我们将添加以下代码。首先，我们会获取承载我们画笔按钮的布局。`paint_colors`属性在`activity_main.xml`文件中定义：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will select the first color in the top-color row as the default selected
    color:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择顶部颜色行中的第一个颜色作为默认选中颜色：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To differentiate between the select color button and others, we will use a
    different Drawable for the selected one. To have a separate `Drawable` object
    for the selected button, we will first define a separate XML file in our `drawable`
    folder. The code of the selected button in the XML file is listed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分选中颜色按钮与其他按钮，我们将为选中的按钮使用不同的Drawable。为了给选中的按钮一个单独的`Drawable`对象，我们将在`drawable`文件夹中先定义一个单独的XML文件。XML文件中选中按钮的代码如下所示：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code is exactly the same as the previous XML file that we created in the
    `drawable` folder for our normal paint buttons. The only difference here would
    be a different value for `android:color` and solid `android:color`. After this,
    we will open our main activity class and, in the `onCreate()` method, which is
    below the image button code that we have recently added, we will add the following
    line to enable a different style for the select button:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与我们在`drawable`文件夹中为普通画笔按钮创建的前一个XML文件完全相同。这里唯一的区别是`android:color`和`solid android:color`的不同值。在此之后，我们将打开主活动类，并在最近添加的图片按钮代码下面的`onCreate()`方法中，添加以下行以启用选择按钮的不同样式：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next we will create a method in the `CustomDrawingView` class to update the
    paint color used when we draw our painting:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`CustomDrawingView`类中，我们将创建一个方法来更新我们在绘制绘画时使用的画笔颜色：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the preceding method in our main activity class shortly. Note that,
    in the code of our image buttons in the XML file, we have mentioned an `onClick()`
    method with the method name `paintClicked`. Now is the time to create the `paintClicked`
    method in our main activity class. We will start by defining the method as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将在主活动类中使用前面的方法。请注意，在XML文件中的图像按钮代码中，我们提到了一个`onClick()`方法，方法名为`paintClicked`。现在是时候在我们的主活动类中创建`paintClicked`方法了。我们将从以下方式定义该方法开始：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we will check whether the clicked color button is not already selected:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查点击的颜色按钮是否已经被选择：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If not selected, we will get the tag from the button clicked and will set the
    current color for our painting to the selected tag color:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择，我们将从点击的按钮获取标签，并将当前绘画颜色设置为选中标签的颜色：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following line of code will call the `setColor()` method created earlier
    in the `CustomDrawingView` class to change the paint color:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将调用在`CustomDrawingView`类中先前创建的`setColor()`方法，以改变画笔颜色：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, we will simply update the **Control panel** to display that the
    selected button is modified by changing the Drawable of the selected button; we
    will revert the previously selected button to its normal state:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将简单地更新**控制面板**，通过更改选中按钮的Drawable来显示选中的按钮已被修改；我们将把之前选中的按钮恢复到正常状态：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our progress status shows that we have covered three quarters of our project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进度状态显示，我们已经完成了项目的四分之三：
- en: We have a relatively attractive user interface for our application in place
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序已经拥有相对吸引人的用户界面。
- en: Our application is touch enabled
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序支持触摸操作。
- en: We are able to draw using finger touch and drag actions; moreover, we can change
    the color or the paint brush with which we are drawing
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够通过手指触摸和拖动进行绘画；此外，我们还可以更改绘画时所使用的颜色或画笔。
- en: 'The following screenshot shows our current state with a rough drawing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了我们当前的状态，带有一个粗糙的绘画：
- en: '![Enabling the color selection](img/5396OS_06_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![启用颜色选择](img/5396OS_06_05.jpg)'
- en: I have tried to draw a brush that appears on the brush button, as shown in the
    preceding screenshot. I am not a good artist and it's not even a good drawing,
    but it's good enough to explain where we stand now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图在如图所示的画笔按钮上绘制一个画笔。我不是一个好的艺术家，这甚至不是一个好的绘画，但它足以解释我们目前的位置。
- en: Spicing up our application with more functions
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的应用程序增加更多功能，使其更加丰富。
- en: The core structure of our application is already complete, but we should still
    make it more useful and attractive; we need to make it more spicy with more functions,
    rather than just providing a selection of colors and painting. We will start with
    the functionality of saving our paintings to the device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序核心结构已经完成，但我们仍应使其更有用、更吸引人；我们需要通过增加更多功能来让它更加有趣，而不仅仅是提供颜色选择和绘画。我们将从将绘画保存到设备的功能开始。
- en: Saving the painting
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存绘画。
- en: 'We will create an instance of `savePaintingButton` in our main activity class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主活动类中创建`savePaintingButton`的实例：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will create its instances and will listen to its clicks in the `onCreate()`
    method in our main activity class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在主活动类的`onCreate()`方法中创建它的实例，并监听其点击事件：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we write the preceding line of code for the click listener, a red line
    will appear under it, warning us that something is wrong. Right-clicking on this
    line will give us all the possible options to fix the problem. Select the option
    that best solves the problem. Let''s say that, in the example, we select the option
    of the main activity implementing the inherited `OnClickListner`; two things will
    happen. First our main activity class will inherit `OnClickListner` as shown in
    the line of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为点击监听器编写前面的代码行时，下面会出现一条红线，警告我们有问题。右键点击这条线将给我们所有可能解决问题的选项。选择最能解决问题的选项。假设在示例中，我们选择了主活动实现继承的`OnClickListner`的选项；会发生两件事。首先，我们的主活动类将继承`OnClickListner`，如代码行所示：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And second, the following method will be created inside our main activity class
    with an empty body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，以下方法将在我们的主活动类内部创建，其内容为空。
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we will write our saving logic here inside the preceding method. To save
    our painting we will start with a reference to the layout that contains our painting
    and will enable the drawing cache for it. Then we will create a `Bitmap` object
    and will provide a drawing cache with our view objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在前面的方法内编写我们的保存逻辑。为了保存我们的画作，我们将从包含我们画作的布局开始，并为它启用绘图缓存。然后，我们将创建一个`Bitmap`对象，并提供一个带有我们视图对象的绘图缓存。
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will define a string that will contain the path where we will save
    our file and will create a `File` object that will be provided with that path:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个字符串，其中包含我们保存文件的路径，并创建一个`File`对象，该对象将提供该路径：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the path doesn''t exist, we will create a new directory at that location
    and, if the path exists, we will create our file at that location, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径不存在，我们将在该位置创建一个新目录，如果路径存在，我们将在该位置创建我们的文件，如下所示：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After this we will create a `FileOutputStream` object. An output stream writes
    bytes to a file if it exists; if not, a new file is created and the stream is
    written to it. The `Bitmap` object that we have created earlier that has our drawing
    cache, we will use it to call a method `compress()` providing it with the information
    of compression type and the `FileOutputStream` object to create an image file
    for us with a `JPEG` extension. To track it back, that is, to see how the painting
    information got here in this JPEG file, the `Bitmap` object is provided with the
    `FileOutputStream` object that contains the `myPath` object. The `myPath` object
    contains the complete path where the file has to be saved and the name with which
    the file will be saved. In addition, the `Bitmap` object has already got the necessary
    information of our painting from the `View` object that we created and what''s
    available in the drawing cache at the specific moment. The block of code explains
    the creation of the output steam object and supplies it to our already created
    `Bitmap` object. The last line in the `try` block uses `MediaStore`. `MediaStore`
    contains metadata for all available media on external and internal storage devices.
    The `insertImage` from `MediaStore` will insert an image and will create a thumbnail
    for it in our gallery:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建一个`FileOutputStream`对象。如果文件存在，输出流将字节写入文件；如果不存在，将创建一个新文件，并将流写入其中。我们之前创建的带有我们绘图缓存的`Bitmap`对象，我们将使用它来调用`compress()`方法，提供压缩类型信息和`FileOutputStream`对象，以创建具有`JPEG`扩展名的图像文件。为了追踪它，即查看画作信息是如何进入这个JPEG文件的，`Bitmap`对象提供了包含`myPath`对象的`FileOutputStream`对象。`myPath`对象包含文件必须保存的完整路径以及保存文件的名称。此外，`Bitmap`对象已经从我们创建的`View`对象中获取了画作的必要信息，以及特定时刻绘图缓存中可用的内容。代码块解释了输出流对象的创建，并将其提供给我们已经创建的`Bitmap`对象。`try`块中的最后一行使用了`MediaStore`。`MediaStore`包含外部和内部存储设备上所有可用媒体的元数据。`MediaStore`的`insertImage`将插入图像，并在我们的图库中为其创建缩略图：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, we will add the following permission to our `AndroidManifest.xml` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`AndroidManifest.xml`文件中添加以下权限：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Without these permissions, our application will not be allowed to read or write
    from the storage drives. For more details on permissions and its understanding,
    visit the link [http://developer.android.com/guide/topics/security/permissions.html](http://developer.android.com/guide/topics/security/permissions.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些权限，我们的应用程序将不允许从存储驱动器中读取或写入。有关权限及其理解的更多详细信息，请访问链接[http://developer.android.com/guide/topics/security/permissions.html](http://developer.android.com/guide/topics/security/permissions.html)。
- en: 'With the end of this block of code, our saving functionality completes. Now
    we can draw and save our paintings in our gallery. The following screenshot shows
    us the saved paintings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码的末尾，我们的保存功能完成了。现在我们可以在图库中绘制并保存我们的画作。以下屏幕截图显示了已保存的画作：
- en: '![Saving the painting](img/5396OS_06_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![保存画作](img/5396OS_06_06.jpg)'
- en: If we check the gallery, we will find our image saved there if we check the
    details of the newly created image, it will show us a thumbnail of the image,
    its name, and the date created. Our image is saved with our application name because
    that's what we provided as the filename in our code. We must also make sure that
    our emulator is created with SD card options. If our emulator is created without
    SD card options, this code will not work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看图库，会发现如果我们在查看新创建图像的详情时，它会显示图像的缩略图、名称和创建日期。我们的图像以我们的应用程序名称保存，因为这是我们代码中提供的文件名。我们还必须确保我们的模拟器创建时包含SD卡选项。如果我们的模拟器在未选择SD卡选项的情况下创建，这段代码将无法工作。
- en: Creating a new drawing
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新绘图
- en: 'To create a new painting or enabling the functionality of the new button, we
    need to clear whatever is currently drawn on the Canvas and clear the previous
    drawing cache. To do this, we will create an instance of the new button, a listener,
    and an `onCreate()` method just as we did for the `savePaintingButton` button.
    We will add the following code in the listener of the new button:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新绘画或启用新按钮的功能，我们需要清除画布上当前绘制的任何内容，并清除之前的绘图缓存。为此，我们将创建一个新按钮的实例、一个监听器以及一个`onCreate()`方法，就像我们对`savePaintingButton`按钮所做的那样。我们将在新按钮的监听器中添加以下代码：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code will clear the screen and cache. I won''t go into the details
    of `PorterDuff` but will only write here that it''s not Android-specific. `PorterDuff`
    is the `AlphaComposite` class implementing the 12 rules defined by Porter and
    Duff. More details in reference to Android can be found in the following link:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将清除屏幕和缓存。我不会详细介绍`PorterDuff`，但只想在这里写一下它不是Android特有的。`PorterDuff`是实现Porter和Duff定义的12条规则的`AlphaComposite`类。关于Android的更多详细信息可以在以下链接中找到：
- en: '[http://developer.android.com/reference/android/graphics/PorterDuff.html](http://developer.android.com/reference/android/graphics/PorterDuff.html)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[PorterDuff参考文档](http://developer.android.com/reference/android/graphics/PorterDuff.html)'
- en: Enabling eraser in our application
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的应用程序中启用橡皮擦
- en: 'We will add one more functionality to our application in this chapter: using
    the eraser. I know I am not a Picasso and I''ll definitely need an eraser in my
    painting application. So we will write some more code to make our application
    eraser enabled. First, we will create an instance of the eraser button and a listener
    for it, as we did for the `savePaintingButton` button. The simplest way of making
    the eraser functionality is to set the paint color to that of the background color.
    It will appear that we are erasing the drawing but actually, we will be painting
    it with the paint color set as the background color.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的应用程序增加一个功能：使用橡皮擦。我知道我不是毕加索，而且在我的绘画应用程序中我肯定需要橡皮擦。因此，我们将编写更多代码，使我们的应用程序支持使用橡皮擦。首先，我们将创建一个橡皮擦按钮的实例，并为它设置一个监听器，就像我们对`savePaintingButton`按钮所做的那样。实现橡皮擦功能的最简单方法是将画笔颜色设置为背景色。这样看起来我们像是在擦除绘图，但实际上，我们是用设置为背景色的画笔颜色来绘制。
- en: 'This is the code of our paint selection:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们选择画笔的代码：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We know that our background color is white and, from our XML layout file, we
    know that the tag we have defined for the color white is `#FFFFFFFF` and the background
    color for our white button is `#FFFFFFFF`. So, to enable erasing in our application,
    we will simply change the values of `String color = view.getTag().toString();`
    to `String color = "#FFFFFFFF";`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的背景色是白色，从我们的XML布局文件中，我们知道我们为白色定义的标签是`#FFFFFFFF`，我们白色按钮的背景色是`#FFFFFFFF`。因此，要在我们的应用程序中启用擦除功能，我们只需将`String
    color = view.getTag().toString();`的值更改为`String color = "#FFFFFFFF";`。
- en: 'Save the file and run the application. Now our application will have the erasing
    functionality. The following screenshot shows the eraser used in our application
    on our previous paint brush drawing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行应用程序。现在我们的应用程序将具有擦除功能。以下屏幕截图显示了我们应用程序中使用的橡皮擦，针对我们之前的画笔绘图：
- en: '![Enabling eraser in our application](img/5396OS_06_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的应用程序中启用橡皮擦](img/5396OS_06_07.jpg)'
- en: 'With the eraser functionality in place, our basic paint application is complete
    but, in terms of extra spice, the extra functionalities are not limited to new,
    paint, erase, and save. We can put in a lot of other functionalities, as far as
    our imagination can take us. But one thing is clear that: whatever we plan to
    put in there, we will be using one of the things that are explained in the course
    of this book. The approach and the order in which things will be coded might be
    different but, as far as the basic 2D graphics are concerned, the lessons and
    examples in this book will cover it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着橡皮擦功能的实现，我们基本的绘图应用程序已经完成，但说到增加趣味，额外的功能不仅限于新画、擦除和保存。只要我们的想象力足够，我们可以加入许多其他功能。但有一点很清楚：无论我们计划加入什么功能，我们都会用到本书中讲解的内容。虽然实现的方法和顺序可能有所不同，但就基本的2D图形而言，本书中的课程和示例将会涵盖。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have learned more than we actually promised at the beginning.
    What we have learned is listed as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到的内容比一开始承诺的要多。我们学到的东西如下：
- en: Planning our application and the use of story boards
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划我们的应用程序和故事板的使用
- en: Creating a rich, complex user interface with nested layouts
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套布局创建丰富、复杂的用户界面
- en: Creation of graphic objects using just XML
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用XML创建图形对象
- en: Creation of our own separate `View` class and referencing to that class in XML
    files and our main activity file code
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的独立`View`类并在XML文件和主活动文件代码中引用该类
- en: Use of the `Path`, `Paint`, `Bitmap`, and `Canvas` objects
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Path`、`Paint`、`Bitmap`和`Canvas`对象
- en: Defining listeners and capturing touch events
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义监听器并捕获触摸事件
- en: Responding to those touch events
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对触摸事件做出响应
- en: Switching the color for the paint brush
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换画笔的颜色
- en: Working with a filesystem and output streams
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统和输出流合作
- en: Saving files to the storage devices
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件保存到存储设备
- en: Adding permissions to the `AndroidManifest.xml` file
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加权限
- en: Clearing the Canvas, drawing cache, and creating a new drawing
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除画布、绘图缓存，并创建新的绘图
- en: Erasing the already drawn painting using very simple logic
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非常简单的逻辑擦除已经绘制的画作
- en: We made it to the end of this book. This book only focuses on the very basics,
    starting from level 0 to mid-level knowledge of working with Canvas for Android.
    Still, the knowledge that is enclosed in this book will work for all kinds of
    basic 2D Android graphic applications. For a more complex application with animation,
    we might need advance-level knowledge of Android Canvas and some core knowledge
    of working with 3D in OpenGL ES. OpenGL ES is a flavor of OpenGL for embedded
    devices or handheld devices.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经读到了这本书的结尾。本书仅关注最基础的内容，从0级到中级关于使用Android的Canvas进行工作的知识。尽管如此，本书中包含的知识适用于所有类型的基本的2D
    Android图形应用程序。对于更复杂的带有动画的应用程序，我们可能需要更高级的Android Canvas知识和一些在OpenGL ES中处理3D的核心知识。OpenGL
    ES是针对嵌入式设备或手持设备的OpenGL版本。
