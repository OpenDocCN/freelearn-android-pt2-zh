- en: Chapter 2. Know Your Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。了解你的工具
- en: As discussed in the last chapter, real-world applications aren't just software.
    They are composed of simple or complex circuits that perform actions in the physical
    world. Before we start to build our first interactive project, we need to know
    how these physical components work, so that we know what's inside our toolbox.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一章所述，现实世界应用不仅仅是软件。它们由在物理世界中执行动作的简单或复杂电路组成。在我们开始构建第一个交互式项目之前，我们需要了解这些物理组件是如何工作的，这样我们才知道工具箱里有什么。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Uploading the first Arduino program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传第一个Arduino程序
- en: Enabling a connection with Arduino
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Arduino建立连接
- en: Writing an Android application capable of acting as a controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个能作为控制器作用的Android应用
- en: Building a simple circuit controlled by Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个由Android控制的简单电路
- en: Introducing Arduino Due capabilities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Arduino Due的功能
- en: The physical world is composed of many forms of energy that we perceive in the
    form of light, heat, sound, or motion. While driving a car when we are near traffic
    lights and see a red light up ahead, we start to slow down and stop the car. We
    are just sensing a light form of energy and this led us to change our activity
    because someone taught us what every traffic light's phase means.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 物理世界由我们以光、热、声音或运动形式感知的多种能量形式组成。当我们在驾车时，靠近交通灯，看到前方红灯亮起，我们会开始减速并停车。我们只是感知了一种光能形式，这使我们改变了活动，因为有人教过我们每个交通灯阶段的意义。
- en: This natural behavior is the same we want to bring to our interactive physical
    applications. We use hardware devices called **sensors** that listen to the environment
    and that cooperate with other hardware components, called **actuators**, which
    perform actions in the real world. However, we need a third element called **microcontroller**
    that uses connected sensors and actuators to sense and alter the surrounding environment,
    according to the uploaded program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自然行为正是我们希望带到我们的交互式物理应用中的。我们使用的硬件设备叫做**传感器**，它们监听环境，并与其他硬件组件，即**执行器**协同工作，执行现实世界中的动作。然而，我们需要一个叫做**微控制器**的第三种元素，它使用连接的传感器和执行器来感知并改变周围环境，根据上传的程序进行操作。
- en: 'The onboard Arduino Due bears the latest part and provides a common way to
    connect external electronic components. It has 54 digital I/O pins that we can
    use to send or receive digital signals. This is particularly useful when we want
    to gather inputs from external devices such as switches or push buttons, while
    we can send digital signals to turn simple components on or off. In the following
    diagram, you can see all the digital pins in black:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 板载的Arduino Due采用了最新的部件，并提供了一种连接外部电子组件的通用方式。它有54个数字I/O引脚，我们可以使用它们发送或接收数字信号。当我们想要从外部设备（如开关或按钮）收集输入时，这特别有用，同时我们可以发送数字信号以打开或关闭简单的组件。在下面的图表中，你可以看到所有的数字引脚都是黑色的：
- en: '![Introducing Arduino Due capabilities](img/1942OS_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Arduino Due的功能](img/1942OS_02_01.jpg)'
- en: 'We have 12 analog inputs at our disposal, with a 12 bits resolution for 4096
    different values for reading. They are useful when we need to collect data from
    our sensors and use the returned value as a condition for our program to change
    the behavior of our physical device. Good examples of read values are related
    to temperature, light, or proximity sensors. The board also offers 2 **Digital
    to Analog Converters** (**DAC**),with a 12 bits resolution, which can be used
    as analog output when we have to use a digital signal to drive an analog device.
    A good example of when you''ve to use DAC I/O pins is when you have to create
    an audio output with your device. In the following diagram, you will find all
    analog pins marked in black, while the 2 DAC pins are marked in gray:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用12个模拟输入，其12位分辨率可以读取4096个不同的值。当需要从传感器收集数据，并使用返回值作为程序改变物理设备行为的条件时，它们非常有用。读取值的良好例子与温度、光线或接近传感器相关。板子还提供了2个**数字至模拟转换器**（**DAC**），具有12位分辨率，当需要使用数字信号驱动模拟设备时，可以作为模拟输出使用。当你需要用你的设备创建音频输出时，使用DAC
    I/O引脚的一个好例子。在下面的图表中，你将找到所有模拟引脚都是黑色的，而2个DAC引脚是灰色的：
- en: '![Introducing Arduino Due capabilities](img/1942OS_02_12.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Arduino Due的功能](img/1942OS_02_12.jpg)'
- en: With these functionalities, we have all the required tools to control little
    devices from our Android applications. On the other hand, we can also take advantages
    from the inverse and let connected devices change the behavior of our Android
    interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些功能，我们就有了一切必要的工具来从我们的Android应用程序中控制小型设备。另一方面，我们也可以反过来利用，让连接的设备改变我们Android界面的行为。
- en: However, UDOO becomes really powerful when used to pilot a complex circuit that
    may need a hardware driver to interact with it. This could become the usual approach
    when we are going to recycle devices that we already own, such as old toys, or
    when we are buying new things such as little motorized robots or rovers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当UDO用于控制复杂的电路并且可能需要一个硬件驱动程序与它交互时，UDO才能真正显示出其强大的功能。当我们打算回收我们已拥有的设备，如旧玩具，或者购买新设备如小型电动机器人或漫游车时，这可能会成为一种常见的方法。
- en: Building hardware drivers is an expensive task that requires a lot of experience
    in software and electronics. UDOO, through the onboard Arduino, makes this task
    easy because it reuses all components built from the makers community. We can
    add other functionalities combining UDOO with a *shield*, which is a pluggable
    board that implements a complex circuit with all the required hardware logic.
    Good examples are LCD Arduino compatible screens, Bluetooth controllers and motor
    shields to control connected motors, with a few lines of code and without the
    need to build an external circuit.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 构建硬件驱动程序是一项昂贵的任务，需要软件和电子方面的丰富经验。UDO通过板载Arduino使这项任务变得简单，因为它重用了制造商社区构建的所有组件。我们可以通过将UDO与一个*盾板*结合来添加其他功能，这是一个可插拔的板，它实现了一个复杂的电路，包含了所有必需的硬件逻辑。好的例子包括兼容Arduino的LCD屏幕、蓝牙控制器以及控制连接电机的电机盾板，只需几行代码，无需构建外部电路。
- en: Uploading the first program
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传第一个程序
- en: Now that we know what are the main components and capabilities of our UDOO board,
    we can start to write and upload our first program. We have to keep in mind that,
    even if the SAM3X is a standalone processor, we need a working microSD card with
    a valid UDOO image, otherwise the Arduino programmer will not work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了UDO板的主要组件和能力，我们可以开始编写并上传我们的第一个程序。我们必须牢记，尽管SAM3X是一个独立的处理器，但我们仍需要一个带有有效UDO镜像的工作microSD卡，否则Arduino编程器将无法工作。
- en: 'As we did earlier for Android, we are going to write a simple application that
    prints Hello World! on our screen, without any Android interaction at the moment.
    Before opening the Arduino IDE, we need to connect the board to our computer via
    the microUSB port, available on the left of the board, as you can see in the following
    schema:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前为Android所做的那样，我们将编写一个简单的应用程序，在屏幕上打印“Hello World!”，此时不需要任何Android交互。在打开Arduino
    IDE之前，我们需要通过左侧的microUSB端口将板连接到我们的计算机，如下图所示：
- en: '![Uploading the first program](img/1942OS_02_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![上传第一个程序](img/1942OS_02_03.jpg)'
- en: However, this connection isn't enough to allow a correct communication between
    the Arduino SAM3X and our computer because both the processors use this microUSB
    port to communicate via a serial port with the connected device. An internal physical
    switch chooses the connected processor between the i.MX6 that runs Android and
    the Arduino SAM3X.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种连接不足以让Arduino SAM3X和我们的计算机之间进行正确的通信，因为这两个处理器都使用这个microUSB端口通过串行端口与连接的设备进行通信。一个内部物理开关在运行Android的i.MX6和Arduino
    SAM3X之间选择连接的处理器。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a different connection and not the same used in the previous chapter.
    It refers to the serial port and must not be confused with the OTG microUSB port
    used for the deployment of Android applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不同的连接，不是前一章中使用的那个。它指的是串行端口，不应与用于部署Android应用程序的OTG microUSB端口混淆。
- en: 'To enable the connection between our computer and the SAM3X, we must unplug
    the physical **jumper J18** as we can see in the following schema:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的计算机和SAM3X之间能够连接，我们必须拔掉下图所示的物理**跳线J18**：
- en: '![Uploading the first program](img/1942OS_02_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![上传第一个程序](img/1942OS_02_04.jpg)'
- en: Now we are ready to launch the Arduino IDE and proceed to write and upload our
    first program. When the IDE shows up, it will open an empty program. Every program
    and code written for Arduino is called a **sketch**. Arduino sketches are written
    using a simplified set of C/C++, and if you are interested, you can find a full
    reference at [http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备启动Arduino IDE并继续编写和上传我们的第一个程序。当IDE出现时，它将打开一个空程序。为Arduino编写的每个程序和代码都称为**草图**。Arduino草图使用一组简化的C/C++编写，如果您感兴趣，可以在[http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage)找到完整的参考资料。
- en: 'The initial sketch contains two functions as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 初始草图包含以下两个函数：
- en: '`setup()`: This is called once during the initial execution and there we put
    all initial configurations'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`: 这在初始执行时被调用一次，我们在其中放置所有初始配置。'
- en: '`loop()`: This is called over and over until someone turns off the device,
    and it represents the core of our sketch'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop()`: 这会在设备关闭之前不断被调用，它代表了我们草图的内核。'
- en: All our sketches must contain both functions, otherwise our program will not
    work. We may add our own functions to make the code more readable and reusable,
    so we can embrace the programming principle **Don't Repeat Yourself** (**DRY**).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的草图都必须包含这两个函数，否则程序将无法工作。我们可以添加自己的函数以使代码更具可读性和可重用性，这样我们就可以遵循编程原则**不要重复自己**（**DRY**）。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must bear in mind that we are going to write software for a microcontroller
    that has at most 512 KB of available memory to store the code. Moreover, we have
    the 96 KB of SRAM limit in which the sketch creates and manipulates variables
    at runtime. For complex projects, we should always optimize our code to reduce
    the used memory, but for the purpose of this book, we write the code so that it's
    more readable and easy to implement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住，我们是为一个最多有512 KB可用内存来存储代码的微控制器编写软件。此外，草图在运行时创建和操作变量的96 KB SRAM限制。对于复杂项目，我们应该始终优化代码以减少使用的内存，但为了本书的目的，我们编写代码使其更具可读性和易于实现。
- en: 'To print Hello World! on our screen, we need to code a sketch that writes a
    String into the built-in serial port. This sketch can be implemented with the
    following easy steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上打印出“Hello World!”，我们需要编写一个向内置串行端口写入字符串的草图。这个草图可以通过以下简单步骤实现：
- en: 'In the `setup()` function, initialize the serial port with the specified data
    rate expressed in **bits per second** (**baud**), as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，以指定的每秒**比特数**（**波特**）初始化串行端口，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We choose `115200` baud per second, because the onboard Arduino Due supports
    this data rate.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择每秒`115200`波特率，因为板载的Arduino Due支持这个数据率。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您的账户下载您购买的所有 Packt 图书的示例代码文件，网址是[http://www.packtpub.com](http://www.packtpub.com)。如果您在别处购买了这本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)注册，我们会将文件直接通过电子邮件发送给您。
- en: 'Write into the serial port using the `println()`function within the main `loop()`
    function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中使用`println()`函数向串行端口写入：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even if we are tempted to upload our project, we have to bear in mind that the
    `loop()` function is called over and over and this means that maybe we will receive
    too many Hello World! instances. A good thing is to add a `delay()` function so
    that Arduino waits for the given milliseconds before starting with the `loop()`
    function again.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使我们有上传我们项目的冲动，我们也必须记住`loop()`函数会不断被调用，这意味着我们可能会收到太多的“Hello World!”实例。一个好方法是添加一个`delay()`函数，这样Arduino在再次开始`loop()`函数之前会等待给定毫秒数。
- en: 'To print one sentence per second, add the highlighted code as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要每秒打印一句话，请添加以下突出显示的代码：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we are ready to start the upload process. It consists of two phases where
    our code is first compiled and then uploaded to the SAM3X processor. If we upload
    two different sketches, the latest one overrides the first one because we can
    load and execute only one sketch at a time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始上传过程。这个过程包括两个阶段，首先编译我们的代码，然后上传到 SAM3X 处理器。如果我们上传两个不同的草图，最新的会覆盖第一个，因为我们一次只能加载和执行一个草图。
- en: 'In this case, we need to configure the IDE so it can program the correct board
    connected to the correct serial port. Click on **Tools**, hover over **Boards**
    and choose **Arduino Due (programming port)**. Now click on **Tools**, hover over
    **Port**, and choose your configured port. The correct port depends on your operating
    system and usually they have the following values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要配置IDE，使其能够为连接到正确串行端口的正确电路板编程。点击**工具**，悬停在**电路板**上并选择**Arduino Due
    (编程端口)**。现在点击**工具**，悬停在**端口**上，并选择你配置的端口。正确的端口取决于你的操作系统，它们通常具有以下值：
- en: 'In Windows: The `COM` port with the highest number'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中：编号最高的`COM`端口
- en: 'In Mac OS X: `/dev/tty.SLAB_USBtoUART`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS X中：`/dev/tty.SLAB_USBtoUART`
- en: 'In Linux: `/dev/ttyUSB0`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中：`/dev/ttyUSB0`
- en: 'To upload the program, click on **File** and then on **Upload** or use the
    shortcut available in the toolbar. If the upload process goes fine, you will see
    the logger with the following output in the bottom of the window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传程序，请点击**文件**，然后点击**上传**，或者使用工具栏中可用的快捷方式。如果上传过程顺利，你将在窗口底部看到以下输出的记录器：
- en: '![Uploading the first program](img/1942OS_02_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![上传第一个程序](img/1942OS_02_05.jpg)'
- en: 'To be sure that our first sketch works as expected, we need to use a serial
    port reader, and the Arduino IDE provides a built-in serial monitor. Click on
    **Tools** and then on **Serial Monitor**, or use the shortcut available in the
    toolbar. We may see some strange characters and this occurs because the serial
    monitor is configured by default to read the serial at 9600 baud. In the bottom-right
    dropdown, select **115200 baud** to see the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的第一个草图按预期工作，我们需要使用串行端口阅读器，而Arduino IDE提供了一个内置的串行监视器。点击**工具**，然后点击**串行监视器**，或者使用工具栏中可用的快捷方式。我们可能会看到一些奇怪的字符，这是因为串行监视器默认配置为以9600波特读取串行。在右下角的下拉菜单中，选择**115200波特**以查看以下输出：
- en: '![Uploading the first program](img/1942OS_02_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![上传第一个程序](img/1942OS_02_06.jpg)'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `Serial.println()` function allows you to send data through the serial
    port. This is not used to communicate with the i.MX6 processor, but it's a great
    way to debug variables or your sketch flow from your computer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Serial.println()`函数可以通过串行端口发送数据。这并不是用来与i.MX6处理器通信的，但这是从电脑调试变量或草图流程的好方法。
- en: When we've finished the sketch upload, we can plug in the **J18 jumper**. Now
    that we know how to deploy Android applications and Arduino sketches, it's time
    to start from scratch and build our first project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成草图上传后，我们可以插入**J18跳线**。现在我们知道如何部署Android应用程序和Arduino草图了，是时候从头开始构建我们的第一个项目了。
- en: Interacting with the real world
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与现实世界的互动
- en: Our first real-world prototype should be an Android application that we can
    use to control a simple electronic component. We have to choose something that
    is not too trivial, so we can experiment with it, but also that it is not too
    complex, so we can dive into all main concepts without too many implementation
    details. A good starting point is the creation of a controller that we can use
    to turn on and off a real **Light Emitting Diode** (**LED**) component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个现实世界的原型应该是一个可以用来控制简单电子元件的Android应用程序。我们必须选择一个不太简单的东西，以便我们可以对其进行实验，同时也不要太复杂，以便我们可以深入了解所有主要概念，而不需要太多实现细节。一个好的起点是创建一个控制器，我们可以使用它来打开和关闭实际的**发光二极管**（**LED**）组件。
- en: However, before we proceed, we have to understand how to create a communication
    between the Android application and the sketch. During the deployment process,
    we used to enable the external OTG port to communicate with the i.MX6 processor
    from our computer. If we disable this option, an internal switch activates a bidirectional
    communication between the i.MX6 and the SAM3X processors. This is possible because
    Arduino Due has full support for USB OTG connection and we are using this connection
    to let Android and Arduino communicate with each other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续之前，我们必须了解如何创建Android应用程序和草图之间的通信。在部署过程中，我们通常会启用外部OTG端口，以便从电脑与i.MX6处理器通信。如果我们禁用这个选项，内部的开关会激活i.MX6和SAM3X处理器之间的双向通信。这是可能的，因为Arduino
    Due完全支持USB OTG连接，我们使用这个连接让Android和Arduino相互通信。
- en: Unfortunately, the above software switch isn't very useful if we don't have
    a communication protocol. This is where the **Accessory Development Kit** (**ADK**)
    plays an important role. It's a reference implementation developed by Google to
    build Android accessories and it provides a set of software libraries. UDOO board
    has the full support of ADK. By combining the internal Android APIs with the external
    Arduino library, we can easily use this functionality to send commands and receive
    data. In this way, our Android sees our Arduino device like an *Android accessory*
    so that the connection is supported in our application and in the whole system.
    We can find further details about ADK at [http://developer.android.com/tools/adk/index.html](http://developer.android.com/tools/adk/index.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们没有一个通信协议，上述软件开关并不十分有用。这就是**Accessory Development Kit**（**ADK**）发挥重要作用的地方。它是谷歌开发的参考实现，用于构建Android配件，并提供了一套软件库。UDOOboard完全支持ADK。通过将内部Android
    API与外部Arduino库相结合，我们可以轻松地使用这些功能发送命令和接收数据。这样，我们的Android将把我们的Arduino设备视为一个*Android配件*，从而在应用程序和整个系统中支持这种连接。我们可以在[http://developer.android.com/tools/adk/index.html](http://developer.android.com/tools/adk/index.html)找到关于ADK的更多详细信息。
- en: Communicating with Arduino
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Arduino通信
- en: 'The first step of this prototype is to start a new sketch and set up the initial
    connection from the Arduino side. On the top of our empty sketch, we should add
    the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原型的第一步是开始一个新的草图，并从Arduino端设置初始连接。在我们空白的草图顶部，我们应该添加以下代码：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `adk.h` header file contains all the required declarations for many utilities
    and functions that we can use, for example, to initialize the ADK connection,
    to send hardware information to Android, and read and write buffered data between
    the two processors. In the preceding code, we're also defining two *macro objects*,
    which, respectively, provide the maximum dimension of the read and write buffer
    and what is the used pinout to turn on and off the LED. We have to keep in mind
    this number because we will reuse it later when we connect our first electronic
    component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`adk.h`头文件包含了所有我们需要的声明，用于许多实用工具和函数，例如初始化ADK连接，向Android发送硬件信息，以及两个处理器之间缓冲数据的读写。在上述代码中，我们还定义了两个*宏对象*，分别提供了读写缓冲区的最大尺寸以及用于打开和关闭LED的引脚。我们需要记住这个数字，因为稍后当我们连接第一个电子元件时会重新使用到它。'
- en: 'Through the protocol used by the ADK, Arduino is recognized by Android like
    an external accessory. To distinguish our accessory among the others, Android
    needs an **accessory descriptor** that we can provide with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ADK使用的协议，Android将Arduino识别为外部配件。为了将我们的配件与其他配件区分开来，Android需要一个**配件描述符**，我们可以使用以下代码提供：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we provide information about the accessory name, the name of the hardware
    manufacturer and the unique identifier of the model. Other than these prototype
    descriptors, we have to define the hardware version and the serial number because
    they are strongly required when we connect the device to the Android application.
    Indeed, the `versionNumber`, the `model` and the `manufacturer` parameters will
    be matched with the values we provide to the Android application later, and if
    there is a mismatch, our sketch will not be recognized by the Android application.
    In this way, we can also maintain a strong binding between the application version
    and the hardware version in order to avoid an older Android application wrongly
    controlling a new hardware release.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了关于配件名称、硬件制造商名称和模型唯一标识符的信息。除了这些原型描述符之外，我们还必须定义硬件版本和序列号，因为当我们将设备连接到Android应用程序时，这些信息是强烈需要的。实际上，`versionNumber`、`model`和`manufacturer`参数将与稍后我们提供给Android应用程序的值进行匹配，如果有不匹配的情况，我们的草图将不会被Android应用程序识别。通过这种方式，我们还可以在应用程序版本和硬件版本之间保持强绑定，以避免旧的Android应用程序错误地控制新的硬件发布。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding descriptor is required to recognize the sketch and the hardware
    from the Android application. However, bear in mind that this is a part of good
    *programming etiquette* and that, for every application and prototype, you should
    always provide version numbering together with a change log. In this book, we
    will use **semantic versioning** and you can find more information about it at
    [http://semver.org](http://semver.org).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述符是Android应用程序识别草图和硬件所必需的。但是，请记住，这是良好*编程礼仪*的一部分，对于每个应用程序和原型，你都应该提供版本编号以及变更日志。在本书中，我们将使用**语义版本控制**，你可以访问[http://semver.org](http://semver.org)了解更多信息。
- en: The latest parameter is the `url` that is used by Android to redirect users
    to a website where they can find further information about the connected accessory.
    Android will show that message every time it does not find an installed application
    capable of managing the interaction with the Arduino accessory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是`url`，Android使用它将用户重定向到一个网站，在那里他们可以找到关于已连接配件的更多信息。每当Android找不到能够管理Arduino配件交互的已安装应用程序时，它都会显示该消息。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In most cases, it's a good idea to set the `url` parameter with a link that
    will download and install the packaged Android application. In this way, if the
    Android application is missing, we are providing a fast way to retrieve and install
    it, and this is particularly useful when we're distributing schematics and sketches
    of our prototypes to other developers. You can find further information about
    how to create a packaged application with Android Studio at [https://developer.android.com/tools/building/building-studio.html](https://developer.android.com/tools/building/building-studio.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将`url`参数设置为可以下载并安装打包的Android应用程序的链接是一个好主意。这样，如果缺少Android应用程序，我们就提供了一种快速获取和安装的方法，这对于将我们原型的原理图和草图分发给其他开发者尤其有用。你可以访问[https://developer.android.com/tools/building/building-studio.html](https://developer.android.com/tools/building/building-studio.html)了解更多关于如何使用Android
    Studio创建打包应用程序的信息。
- en: 'To finish the ADK configuration, we have to add the following code below the
    previous declarations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成ADK配置，我们必须在之前的声明下方添加以下代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are declaring the used `buffer` parameter during read and write operations
    and an `USBHost` object. We use it to initialize the connection in the main `loop()`
    function so that Android receives all the required information during the discovery
    process. In the last line, we are initializing the ADK accessory descriptor with
    defined values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在读写操作期间声明了使用的`buffer`参数和一个`USBHost`对象。我们在主`loop()`函数中使用它来初始化连接，以便在发现过程中Android接收所有必要的信息。在最后一行，我们使用定义的值初始化ADK配件描述符。
- en: 'To start the connection, we should put the following code into the `loop()`function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始连接，我们需要将以下代码放入`loop()`函数中：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Usb.Task()` function call polls connected USB devices for updates to their
    status and waits for 5 seconds to see whether any devices respond to the update
    request. When Android responds to the polling, we use a conditional statement
    to evaluate the `adk.isReady()` function call. It returns `True` when the device
    is connected and ready to communicate with Android, so we know exactly when the
    Android system reads the prototype descriptor and when it notifies the installed
    applications that a new accessory is connected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Usb.Task()`函数调用轮询连接的USB设备以获取它们状态更新，并等待5秒钟以查看是否有任何设备响应更新请求。当Android响应轮询时，我们使用条件语句评估`adk.isReady()`函数调用。当设备连接并准备好与Android通信时，它返回`True`，这样我们就能确切知道Android系统何时读取原型描述符以及何时通知已安装的应用程序连接了新的配件。'
- en: 'Our initial configuration is done and we can upload our sketch into the board.
    When the sketch is uploaded and we disable the OTG external port, Android will
    discover the running accessory and then show a message to notify users that there
    aren''t any available applications that will work with the attached USB accessory.
    It also gives users the opportunity to follow the chosen URL, as you can see in
    the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始配置已完成，现在可以将草图上传到电路板中。当草图上传完毕，我们禁用OTG外部端口时，Android将发现正在运行的配件，然后显示一条消息，通知用户没有可用的应用程序可以与连接的USB配件一起工作。它还给了用户跟随所选URL的机会，如下面的屏幕截图所示：
- en: '![Communicating with Arduino](img/1942OS_02_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![与Arduino通信](img/1942OS_02_07.jpg)'
- en: Writing an Android application controller
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Android应用程序控制器
- en: Our first building block is ready, but at the moment it doesn't have any physical
    actuator that we can use, nor a user interface to control it. For this reason,
    our next step is to create our second Android project through Android Studio called
    **LEDLamp**. As we did in our first application, remember to choose **API level
    19** and a **Blank Activity** that we can call **LightSwitch**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一块构建模块已经准备好了，但目前它还没有任何我们可以使用的物理执行器，也没有用户界面进行控制。因此，下一步是通过 Android Studio
    创建我们的第二个 Android 项目，名为 **LEDLamp**。就像在第一个应用程序中所做的那样，记得选择 **API 级别 19** 和一个**空白活动**，我们可以将其称为
    **LightSwitch**。
- en: When the activity editor shows up, it would be a good idea to change the visual
    preview of the user interface because we're going to use the monitor view instead
    of a common smartphone view. We can change it through the **Preview** tab that
    you can find on the right of the application screen and there we can select **Android
    TV (720p)**from the contextual menu.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动编辑器出现时，最好更改用户界面的可视化预览，因为我们将使用监视器视图而不是普通的智能手机视图。我们可以通过应用程序屏幕右侧的**预览**标签页进行更改，并在上下文菜单中选择
    **Android TV (720p)**。
- en: 'Because we need a really simple activity, we have to change the default layout
    using the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要一个非常简单的活动，所以我们需要使用以下步骤更改默认布局：
- en: 'In the `res/layout/activity_light_switch.xml` file, change the `RelativeLayout`
    parameter in a vertical `LinearLayout` parameter, as you can see in the following
    code that is highlighted:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout/activity_light_switch.xml` 文件中，将 `RelativeLayout` 参数更改为垂直的 `LinearLayout`
    参数，如下所示的高亮代码：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within the preceding `LinearLayout` change the default `TextView` parameter
    with the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `LinearLayout` 中，使用以下代码更改默认的 `TextView` 参数：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We create a title that we place at the top of the layout. Below this view, we
    will place all the available controlled devices, like our first LED.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建一个标题，并将其放置在布局顶部。在此视图下方，我们将放置所有可控制的设备，比如我们的第一个 LED。
- en: 'Below the previous `TextView` add the following `Switch` view:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `TextView` 下面添加以下 `Switch` 视图：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To keep the user interface simple, we need a button that we can use to turn
    the LED on and off. For this purpose, we are going to use a switch button so that
    we can send the action to the microcontroller, and at the same time, give a visual
    feedback of what the actual LED status is.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了保持用户界面简洁，我们需要一个按钮来控制 LED 的开关。为此，我们将使用一个开关按钮，这样我们就可以将动作发送到微控制器，同时提供 LED 实际状态的视觉反馈。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In our Android applications, it's always a good idea to have a visual feedback
    about what the microcontroller is doing. In this way, we can easily know the state
    of the sketch and this may help us to find anomalies. This becomes relevant especially
    when the real-world device doesn't give any immediate feedback to the user.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的 Android 应用程序中，了解微控制器正在做什么的视觉反馈总是好的。这样，我们可以轻松知道草图的状态，这有助于我们查找异常。这特别是在实际设备没有给用户任何即时反馈时尤为重要。
- en: 'Without any further customizations, the following screenshot is the expected
    user interface:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 没有进一步的自定义，以下是预期的用户界面截图：
- en: '![Writing an Android application controller](img/1942OS_02_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![编写 Android 应用控制器](img/1942OS_02_08.jpg)'
- en: To try it in our board, we can proceed with the application deployment like
    we did in the previous chapter, and then we can proceed to write the ADK communication
    logic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在电路板上尝试，我们可以像在前一章中那样进行应用程序部署，然后继续编写 ADK 通信逻辑。
- en: Android Accessory Development Kit
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 配件开发套件
- en: 'To enable Android ADK in our application, we need to add some configurations
    to our `AndroidManifest.xml` file. Because we are using a *special feature* of
    the Android system, which relies on the available hardware, we need to add the
    following declaration at the top of our `manifest` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中启用 Android ADK，我们需要向 `AndroidManifest.xml` 文件添加一些配置。因为我们使用了 Android
    系统的*特殊功能*，这依赖于可用的硬件，所以我们需要在 `manifest` 文件顶部添加以下声明：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the application registers itself into the system, it should declare the
    capability to respond to events raised when a USB accessory is attached. To achieve
    this, we need to add an *intent filter* to our `LightSwitch` activity declaration
    with the highlighted code as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在系统中注册时，它应该声明能够响应在连接 USB 配件时引发的事件。为了实现这一点，我们需要向我们的 `LightSwitch` 活动声明中添加一个*意图过滤器*，如下所示的高亮代码：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Android system requires the same accessory information that we filled in
    the Arduino sketch previously. Indeed, we have to provide the manufacturer, the
    model, and the version of our accessory, and to keep things organized, we can
    create the folder `res/xml/` and put inside an XML file named `usb_accessory_filter.xml`.
    In this file, we can add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统要求我们填写与之前在Arduino草图中的配件信息相同的配件信息。实际上，我们必须提供我们配件的制造商、型号和版本，为了保持组织性，我们可以创建`res/xml/`文件夹并在其中放入一个名为`usb_accessory_filter.xml`的XML文件。在这个文件中，我们可以添加以下代码：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To include the preceding file into the Android manifest, simply add the following
    code below the USB intent filter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将上述文件包含在Android清单中，只需在USB意图过滤器下方添加以下代码：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that our application is ready for the discovery process, we need to include
    some logic to establish the link and start to send data through the ADK.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的应用程序已经准备好进行发现过程，我们需要包含一些逻辑来建立连接并开始通过ADK发送数据。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this prototype, we are going to use the ADK through the Android internal
    API. Starting from [Chapter 4](ch04.html "Chapter 4. Using Sensors to Listen to
    the Environment"), *Using Sensors to Listen to the Environment*, we will use a
    high-level abstraction through an external library that will help us to implement
    our projects more easily and without any boilerplate code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型中，我们将通过Android内部API使用ADK。从[第4章](ch04.html "第4章. 使用传感器聆听环境")，*使用传感器聆听环境*开始，我们将通过一个外部库使用高级抽象，这将帮助我们更容易地实现项目，并且不需要任何样板代码。
- en: 'The next step is to isolate some of the ADK functionalities in a new Java package
    to organize our work better. We need to create a new package named `adk`, and
    we should add in it a new class called `Manager`. In this class, we need to use
    the `UsbManager` class that we got from the Android `Context` parameter, a file
    descriptor, and an output stream to write data in the OTG port. Add the following
    code in the `Manager` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将ADK的一些功能隔离在一个新的Java包中，以便更好地组织我们的工作。我们需要创建一个名为`adk`的新包，并在其中添加一个名为`Manager`的新类。在这个类中，我们需要使用从Android
    `Context`参数中获取的`UsbManager`类、一个文件描述符和用于在OTG端口中写入数据的输出流。在`Manager`类中添加以下代码：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java snippets require many imports at the top of the file, which are intentionally
    missing for better code readability. However, to let everything work as expected,
    we need to write them and use the autocomplete function available in Android Studio.
    When you find a missing import, just place the cursor above the statement colored
    in red and press the *Ctrl*+*Space* keys. We can now choose the right import from
    the suggestion box.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码段需要在文件的顶部导入许多内容，为了更好的代码可读性，这些导入被故意省略了。然而，为了让一切按预期工作，我们需要编写它们并使用Android
    Studio中提供的自动补全功能。当你发现缺失导入时，只需将光标放在红色标记的语句上方，并按*Ctrl*+*Space*键。我们现在可以从建议框中选择正确的导入。
- en: 'We expect the `UsbManager` method as a parameter because we don''t have access
    to the Android `Context`, and we will get it later from the main activity. To
    simplify our work during the ADK communication, the following helpers should be
    contained within our wrapper:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望将`UsbManager`方法作为参数，因为我们无法访问Android `Context`，我们稍后将从主活动中获取它。为了在ADK通信期间简化我们的工作，以下助手应该包含在我们的包装器中：
- en: '`openAccessory()`: When a device is found, it should open a connection with
    it'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openAccessory()`: 当找到设备时，它应该与设备建立连接'
- en: '`closeAccessory()`: If any device is connected, it should close and release
    any used resources'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeAccessory()`: 如果有任何设备连接，它应该关闭并释放任何已使用的资源'
- en: '`writeSerial()`: With a connected device, it should send data through opened
    streams'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeSerial()`: 当设备连接时，它应该通过已打开的流发送数据'
- en: 'The first helper that opens a connection with the accessory and initializes
    the related output stream could be realized with the following method that we
    should add at the bottom of the `Manager` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个助手与配件建立连接并初始化相关输出流可以通过以下方法实现，我们应该将其添加到`Manager`类的底部：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are using the stored `UsbManager` object to get all the available accessories.
    If we have at least one accessory, we open it to initialize a descriptor and an
    output stream that we will use later to send data to the accessory. To close the
    above connection, we could add the second helper as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用存储的`UsbManager`对象来获取所有可用的配件。如果我们至少有一个配件，我们会打开它以初始化一个描述符和一个输出流，我们稍后将会使用它们向配件发送数据。为了关闭上述连接，我们可以按如下方式添加第二个助手：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we have already opened an accessory, we use the created descriptor to close
    the activated streams and then we release the reference from the instance variable.
    Now we can add the latest write helper that includes the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经打开了一个配件，我们使用创建的描述符来关闭激活的流，并从实例变量中释放引用。现在我们可以添加最新的写入助手，其中包括以下代码：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding method writes the given `value` into the enabled output stream.
    In this way, if an accessory is connected, we use the output stream reference
    to write into the OTG port.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法将给定的`value`写入启用的输出流中。这样，如果连接了一个配件，我们使用输出流引用来写入OTG端口。
- en: 'Finally, we need to create a `Manager` class instance in our activity, so we
    can use it to open a communication with Arduino. In the `onCreate` method of the
    `LightSwitch` activity, add the following highlighted code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在活动中创建一个`Manager`类的实例，这样我们就可以使用它来与Arduino打开通信。在`LightSwitch`活动的`onCreate`方法中，添加以下高亮代码：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are querying the system for the USB service, so we can use it inside our
    `Manager` class to access the state and the functions of USB accessories. We store
    the `Manager` class reference inside the class so that we can access our helpers
    in the future.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查询系统中的USB服务，以便我们可以在`Manager`类中使用它来访问USB配件的状态和功能。我们将`Manager`类的引用存储在类内部，以便我们将来可以访问我们的助手函数。
- en: 'Once the `Manager` class is initialized, we should open and close our accessory
    contextually to the opening and the closing of the activity. Indeed, usually,
    it''s a good idea to call the `openAccessory()` and the `closeAccessory()` functions
    in the activity `onResume()` and `onPause()` callbacks. In this way, we''re sure
    that the ADK communication is initialized when we start to use it within our activity
    methods. To achieve this last building block to implement the ADK communication,
    add the following methods below the `onCreate()` member function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Manager`类初始化完成，我们应该根据活动的开启和关闭来上下文地打开和关闭我们的配件。实际上，通常在活动的`onResume()`和`onPause()`回调中调用`openAccessory()`和`closeAccessory()`函数是个好主意。这样，我们可以确保在活动方法中使用ADK通信时，它已经被初始化。为了实现这个实现ADK通信的最后一块拼图，请在`onCreate()`成员函数下面添加以下方法：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that the Android application is ready, we can proceed with the deployment,
    and when we disable the external OTG port, the following message appears:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Android应用程序已经准备好了，我们可以继续部署，当我们禁用外部OTG端口时，会出现以下消息：
- en: '![Android Accessory Development Kit](img/1942OS_02_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Android配件开发套件](img/1942OS_02_09.jpg)'
- en: The Android system has discovered the physical accessory and is asking permission
    to work with it using the LED Lamp application. If we click on **OK**, the application
    will be opened. We can even set our application as *default*; so, whenever the
    accessory starts to communicate with the Android system, our application will
    be launched immediately.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统已经发现了物理配件，并请求使用LED Lamp应用程序与之工作的权限。如果我们点击**确定**，应用程序将被打开。我们甚至可以将我们的应用程序设置为*默认*；这样，每当配件开始与Android系统通信时，我们的应用程序将立即启动。
- en: Fast prototyping a circuit
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速原型设计电路
- en: We have a fully functional communication between Android and Arduino and now
    it's the time to build a real circuit. Our goal is to turn on and off an LED using
    the Android system and this problem is little and self-contained. However, at
    the beginning, we could be a little more ambitious and, instead of turning on
    an LED, we may want to turn on a light bulb in our bedroom. So why create such
    a simple project while we can make things a little more interesting? Because we
    are **fast prototyping** our project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了Android和Arduino之间完全功能的通信，现在是时候构建一个真正的电路了。我们的目标是使用Android系统来开关一个LED，这个问题既小又独立。然而，一开始，我们可以更有野心一些，不是打开一个LED，而是可能想打开卧室的灯泡。那么，当我们能做得更有趣时，为什么要创建这样一个简单的项目呢？因为我们对项目进行**快速原型设计**。
- en: Fast prototyping is a group of techniques that we can use to create our working
    project as soon as possible. This is really helpful because we are removing many
    implementation details, such as the product design, keeping the focus only on
    the core of our project. In our case, we are removing all the problems related
    to turning on a light bulb, like the use of a transistor, a relay, and an external
    battery, and we're focusing on the creation of a light switch that is powered
    by the Android system. When the first prototype is working we can increase the
    requirements, step by step, until we realize the final project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 快速原型制作是一组我们可以使用的技巧，以便尽快创建我们的工作项目。这非常有帮助，因为我们可以移除许多实现细节，比如产品设计，只专注于我们项目的核心。在我们的案例中，我们移除了所有与点亮灯泡相关的难题，比如使用晶体管、继电器和外部电池，我们专注于创建一个由Android系统供电的灯开关。当第一个原型开始工作时，我们可以逐步增加要求，直到实现最终项目。
- en: Using a breadboard
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用面包板
- en: To proceed with our project, we should create a circuit prototype. We can use
    many tools to achieve this goal but one of the most important, at the beginning,
    is the **breadboard**. It can be used to connect our board and other electric
    components without soldering. This allows us to experiment with circuits design
    while reusing the breadboard for other projects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的项目，我们应该创建一个电路原型。我们可以使用许多工具来实现这一目标，但在一开始，最重要的工具之一就是**面包板**。它可用于连接我们的电路板和其他电子组件，无需焊接。这允许我们在设计电路时进行实验，同时还可以将面包板用于其他项目。
- en: 'The following is a typical breadboard:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的面包板：
- en: '![Using a breadboard](img/1942OS_02_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板](img/1942OS_02_10.jpg)'
- en: A breadboard is composed of two identical parts that are separated by a middle
    horizontal row that breaks any connection between the two sides. Each side contains
    a red and a blue row, at the top or at the bottom of the side, and they represent
    the *power bus*. They are connected for the whole horizontal line and we will
    use it to connect the power and ground of the UDOO board. The colors, usually,
    represent the power in red and the ground in blue, but bear in mind that this
    is just a convention and the colors of your breadboard may be different.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板由两个相同的部分组成，中间有一条水平行将两部分隔开，以断开两侧之间的任何连接。每一侧都包含一红一蓝两行，位于侧面的顶部或底部，它们代表*电源总线*。它们在整条水平线上是连接的，我们将使用它来连接UDOOboard的电源和地线。颜色通常用红色表示电源，蓝色表示地线，但请记住，这只是一种约定，你的面包板颜色可能会有所不同。
- en: The remaining five horizontal lines are the *prototyping area* and this is where
    we connect our devices. Despite the power bus, these lines are connected vertically
    while there is no connection between the horizontal line. For instance, if we
    plug a **jump wire** inside the hole A1, a metal strip creates the electrical
    connection with the holes starting from B1 through E1\. On the other hand, the
    holes in the range A2–E2 and F1–J1 aren't connected with our A1–E1 columns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的五条水平线是*原型区域*，这是我们连接设备的地方。与电源总线不同，这些线在垂直方向上是连接的，而水平线之间没有连接。例如，如果我们把一根**跳线**插入A1孔，金属条就会与从B1到E1的孔形成电气连接。另一方面，A2-E2和F1-J1范围内的孔与我们的A1-E1列没有连接。
- en: As our first prototype, we are going to connect our LED to our UDOO using the
    breadboard connections. However, we need another electric component that is called
    as the *resistor*. It creates an opposition to the passage of electrical current
    through the wire and it's necessary; otherwise, too much current can break the
    component. On the other hand, if we make too much electrical resistance, not enough
    current will flow through the component and it will not work. The electrical resistance
    of this component is measured in *Ohm*, and in our case, we need a *220 Ohm* resistor
    power the LED correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个原型，我们打算使用面包板连接将LED连接到我们的UDOOboard上。然而，我们需要另一个叫做*电阻器*的电子组件。它通过电线对电流的通过产生阻力，这是必要的；否则，过多的电流可能会损坏组件。另一方面，如果我们提供过多的电阻，那么通过组件的电流将不足以使其工作。该组件的电阻以*欧姆*为单位测量，在我们的案例中，我们需要一个*220欧姆*的电阻来正确地给LED供电。
- en: 'Now we need to connect our components to the breadboard as we can see in the
    following circuit:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的组件连接到面包板上，正如我们在下面的电路中所看到的那样：
- en: '![Using a breadboard](img/1942OS_02_11.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用面包板](img/1942OS_02_11.jpg)'
- en: 'We need to connect the pinout 2 to the positive line of the power bus while
    the ground should be connected to the negative line. We then connect the LED into
    the prototyping area and put the resistor before the *positive lead*. We can distinguish
    the LED **polarity** *looking at its legs*: the longer leg is the positive lead
    while the smaller is the negative lead. Keeping this in mind, we can connect the
    long leg to the resistor. To close the circuit, we simply connect the resistor
    to the positive line of the power bus and the negative leg of the LED to the ground
    line. We have made our first circuit.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将引脚2连接到电源总线的正线，而地线则应连接到负线。然后我们将LED连接到原型区域，并在其*正极*前放置电阻。我们可以通过观察LED的*腿长*来区分其**极性**：较长的腿是正极，较短的腿是负极。记住这一点，我们可以将长腿连接到电阻上。为了闭合电路，我们只需将电阻连接到电源总线的正线，并将LED的负极连接到地线。这样我们就制作了我们的第一个电路。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The LED should be powered Off but it's possible that a small quantity of current
    flows through it. This could be caused by our Arduino sketch that doesn't disable
    the pin by default. This behavior is safe and we will manage this in the next
    section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: LED应该关闭，但可能仍有一小部分电流流经它。这可能是由于我们的Arduino草图默认没有禁用引脚造成的。这种行为是安全的，我们将在下一节中处理这个问题。
- en: Interacting with external circuits
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与外部电路的交互
- en: 'At this point, we have a working communication and a prototyped circuit. The
    last step we should achieve is to send the turn on and off signal from the Android
    application and to parse and execute this command in the sketch. We can start
    from our sketch in which we need to configure the pinout to work as an output
    pin. These kinds of configurations are done in the `setup()`function; inside it,
    we should add the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经有了工作的通信和原型电路。我们应该实现的最后一步是从Android应用程序发送打开和关闭的信号，并在草图中解析并执行此命令。我们可以从我们的草图中开始，在其中我们需要配置引脚以作为输出引脚工作。这类配置是在`setup()`函数中完成的；在其中，我们应该添加以下代码：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the `pinMode()` function, we are declaring that the chosen pin will work
    as `OUTPUT` so we can control the current flow through it. Because we have previously
    defined the `LED` macro object, it refers to pin 2\. The `digitalWrite()` function
    is another abstraction of the Arduino language and we use it to let current flow,
    or not, into the chosen pin. In this case, we are saying that no current should
    flow through the pin because in the initialization step, we want the LED powered
    off.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pinMode()`函数，我们声明所选择的引脚将作为`OUTPUT`工作，这样我们就可以控制通过它的电流流动。因为我们之前定义了`LED`宏对象，它指的是引脚2。`digitalWrite()`函数是Arduino语言的另一个抽象，我们使用它来允许或阻止电流流经所选择的引脚。在这种情况下，我们表示不应该有电流通过该引脚，因为在初始化步骤中，我们希望LED处于关闭状态。
- en: 'Because the Android application will send us a command that can have only `0`
    and `1` values, we need a function to parse this command so that Arduino knows
    what is the related action. To achieve this, we can simply add an `executor()`
    function at the bottom of our sketch as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Android应用程序将向我们发送一个只能具有`0`和`1`值的命令，我们需要一个函数来解析此命令，以便Arduino知道相关的动作是什么。为了实现这一点，我们可以在草图的底部简单地添加一个`executor()`函数，如下所示：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are creating a switch that parses the `command` parameter. If the value is
    `0`, Arduino uses the `digitalWrite()` function to turn off the LED; however,
    if the value is `1`, it uses the same function to turn the LED on. In any other
    case, we are just discarding the received command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个解析`command`参数的开关。如果该值为`0`，Arduino使用`digitalWrite()`函数关闭LED；然而，如果值为`1`，它使用相同的函数打开LED。在其它任何情况下，我们只需丢弃接收到的命令。
- en: 'At this point, we need to put things together in our main `loop()` function
    inside the `adk.isReady` condition, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在`adk.isReady`条件下的主`loop()`函数中将事物组合在一起，如下所示：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: During the main `loop()` function, if we find an ADK connection, we read any
    messages from the communication channel and we write the result in our `buffer`
    variable through the `adk.read()` function call. If we read at least 1 byte, we
    pass the first value of the bytes array to the `executor()` function. After this
    step, we can upload the sketch into the UDOO board.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`loop()`函数期间，如果我们发现ADK连接，我们从通信通道读取任何消息，并通过`adk.read()`函数调用将结果写入我们的`buffer`变量。如果我们至少读取了1个字节，我们将字节数组的第一个值传递给`executor()`函数。完成此步骤后，我们可以将草图上传到UDOOboard。
- en: Sending commands from Android
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Android发送命令
- en: 'Now that UDOO is ready to take physical actions, we have to complete the Android
    application and implement the command sending within the `LightSwitch` class.
    As the first step, we need to add to our activity a variable to store the LED
    status. At the top of our class, add the `mSwitchLed` declaration:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 既然UDOOS已经准备好进行物理操作，我们就需要完成Android应用程序，并在`LightSwitch`类中实现命令发送。作为第一步，我们需要向我们的活动添加一个变量来存储LED的状态。在我们的类顶部，添加`mSwitchLed`声明：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last thing to do is to create a method that uses the ADK writing wrapper
    to send a command to Arduino. Below the `onCreate()` method, add the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的最后一件事情是创建一个使用ADK写入包装器向Arduino发送命令的方法。在`onCreate()`方法下面，添加以下代码：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are changing the state of the LED and create from it the resulting `command`
    parameter, which could be of `0` or `1` values. We then use the `mManager` to
    write the command into the OTG port. To complete the application, we just need
    to bind the `switchLight` method to our view. Into the `activity_light_switch.xml`
    file, add the `onClick()` attribute to our switch button like follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变LED的状态，并从中创建`command`参数，该参数可能是`0`或`1`的值。然后我们使用`mManager`将命令写入OTG端口。为了完成应用程序，我们只需要将`switchLight`方法绑定到我们的视图上。在`activity_light_switch.xml`文件中，像下面这样为我们的开关按钮添加`onClick()`属性：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This was our final step and we now have our first real-world prototype. We can
    now upload the Android application into the UDOO board and use it to turn on and
    off the LED.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的最后一步，现在我们有了第一个真实世界的原型。现在我们可以将Android应用程序上传到UDOOboard，并使用它来开关LED。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you have learned some of the UDOO characteristics related to
    available input and output pins, and how both processors are connected together
    via the internal serial bus. Moreover, in the first part, we wrote and deployed
    our first sketch into the board.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解到了UDOOS一些与可用输入输出引脚相关的特性，以及两个处理器是如何通过内部串行总线连接在一起的。此外，在第一部分，我们编写并将我们的第一个草图部署到电路板上。
- en: Then, we delved the communication mechanism realized through the ADK and wrote
    a new Arduino sketch capable of establishing a communication with Android using
    the internal OTG port. Doing the same for Android, we created a simple user interface
    to provide a visual feedback during the device usage. We also wrote in our Android
    application some wrappers to easily expose commonly used ADK methods to open and
    close the connection, and to write into the communication channel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了通过ADK实现的通信机制，并编写了一个新的Arduino草图，能够通过内部OTG端口与Android建立通信。为Android做同样的事情，我们创建了一个简单的用户界面，在设备使用期间提供视觉反馈。我们还编写了Android应用程序中的包装器，以便轻松地公开常用的ADK方法来打开和关闭连接，以及写入通信通道。
- en: At the end of the chapter, you learned how to use a breadboard to fast prototype
    a circuit and you built your first one using an LED and a resistor. Then, we added
    all the required code to send the turn on and off signal from our Android application
    and to receive and execute this command from the sketch. This was a more complex
    Hello World application that was really helpful to build our first real-world
    device.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，你学习了如何使用面包板快速原型电路，并构建了你的第一个使用LED和电阻的电路。然后，我们添加了所有必要的代码，从我们的Android应用程序发送开关信号，并从草图中接收并执行此命令。这是一个更复杂的Hello
    World应用程序，它确实有助于构建我们的第一个真实世界设备。
- en: In the next chapter, we will extend the above circuit with a debugging feature
    so that we can test our hardware and see if our device has any broken electronic
    components.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展上述电路的调试功能，以便测试我们的硬件，看看设备是否有任何损坏的电子组件。
