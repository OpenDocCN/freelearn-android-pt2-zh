- en: 'Chapter 2. Interaction Experience: Multitouch, Gestures, and Other Input'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 交互体验：多点触控、手势和其他输入
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下内容：
- en: Detecting supported device input types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测支持的设备输入类型
- en: Detecting whether or not a device supports multitouch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测设备是否支持多点触控
- en: Verifying specific gesture support for common interactions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证常见交互的具体手势支持
- en: Using gestures to zoom a display object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手势放大显示对象
- en: Using gestures to pan a display object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手势平移显示对象
- en: Using gestures to swipe a display object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手势滑动显示对象
- en: Using gestures to rotate a display object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手势旋转显示对象
- en: Accessing raw touchpoint data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问原始触摸点数据
- en: Creating a custom gesture based upon touchpoint data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于触摸点数据创建自定义手势
- en: Emulating the Android long-press interaction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟安卓长按交互
- en: Invoking the virtual keyboard programmatically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化地调用虚拟键盘
- en: Responding to Android soft-key interactions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对安卓软键盘交互
- en: Responding to trackball and D-Pad events
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对轨迹球和 D-Pad 事件
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: The ability to interface with a device through touch and gestures is one of
    the stand-out features of mobile computing and the Flash platform has full support
    for both multitouch and gestures on Android. This chapter will cover different
    ways of intercepting and reacting to user interaction whether it be through simple
    touch points or complex gestures, along with more traditional physical and virtual
    keyboard input. Making good use of this is essential to a smooth experience on
    mobile Android devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过触摸和手势与设备交互的能力是移动计算突出的特点之一，Flash 平台在安卓上完全支持多点触控和手势。本章将介绍拦截和响应用户交互的不同方式，无论是通过简单的触摸点还是复杂的手势，以及更传统的物理和虚拟键盘输入。在移动安卓设备上充分利用这一点对于流畅的体验至关重要。
- en: All of the recipes in this chapter are represented as pure ActionScript 3 classes
    and are not dependent upon external libraries or the Flex framework. Therefore,
    we will be able to use these examples in any IDE we wish.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中的所有示例均表示为纯 ActionScript 3 类，不依赖于外部库或 Flex 框架。因此，我们可以将这些示例应用到我们希望的任何 IDE
    中。
- en: Detecting supported device input types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测支持的设备输入类型
- en: A variety of input types are available across Android devices and depending
    upon the project we are working on, we may need to verify that any particular
    device supports the intended modes of user interaction. Fortunately, there are
    a number of ActionScript classes to assist us in discovering device capabilities
    in regard to user input.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备上有多种输入类型可供选择，根据我们正在从事的项目，可能需要验证特定设备是否支持预期的用户交互模式。幸运的是，有许多 ActionScript 类可以帮助我们发现设备在用户输入方面的功能。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will need to use internal classes to detect whether or not multitouch is
    supported:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用内部类来检测是否支持多点触控：
- en: 'First, import the following classes into your project in order to check various
    input types across devices:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到项目中，以便检查各种设备上的输入类型：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `TextField` 和 `TextFormat` 对象，以允许在设备上输出可见内容：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置 `TextField`，应用 `TextFormat`，并将其添加到 `DisplayList` 中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will simply go through and check the data returned from invoking a
    number of properties off of these classes. In the case of the following example,
    we are performing this within the following method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将简单地通过检查这些类调用一系列属性返回的数据。以下示例中，我们是在以下方法中执行此操作：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下内容：![如何操作...](img/1420_02_01.jpg)
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Flash platform runtimes are able to report certain device capabilities when
    invoked. The data reported will allow us to tailor the user experience, based
    upon what sort of input types are detected by the runtime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，Flash 平台运行时能够报告某些设备功能。报告的数据将允许我们根据运行时检测到的输入类型定制用户体验。
- en: 'Here follows a basic rundown of the four input types that can be reported upon:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是四种可以报告的输入类型的基本概述：
- en: '`flash.system.Capabilities.touchscreenType`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.system.Capabilities.touchscreenType`'
- en: Invoking this method will return a `String` constant of `FINGER, STYLUS`, or
    `NONE`. It informs us whether some sort of direct screen interaction is available
    on the device, and if so, what sort. In the case of Android devices, this will
    always return `FINGER`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法将返回一个`String`常量，值为`FINGER`、`STYLUS`或`NONE`。它告诉我们设备上是否支持某种形式的直接屏幕交互，如果是，是哪种形式。在Android设备上，这将始终返回`FINGER`。
- en: '`flash.ui.Mouse.supportsCursor`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.ui.Mouse.supportsCursor`'
- en: Invoking this method will return a `Boolean` of `true` or `false`. It simply
    informs us whether a persistent mouse cursor is available on the device. In the
    case of Android devices, this will most likely always return `false`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法将返回一个`Boolean`值，为`true`或`false`。它简单地告诉我们设备上是否有持久鼠标光标。在Android设备上，这很可能会始终返回`false`。
- en: '`flash.ui.Keyboard.physicalKeyboardType`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.ui.Keyboard.physicalKeyboardType`'
- en: Invoking this method will return a `String` constant of `ALPHANUMERIC, KEYPAD`,
    or `NONE`. It informs us whether some sort of dedicated physical keyboard is available
    on the device, and if so, what sort. In the case of Android devices, this will
    most likely always return `NONE`, even though certain Android models do have a
    physical keyboard.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法将返回一个`String`常量，值为`ALPHANUMERIC`、`KEYPAD`或`NONE`。它告诉我们设备上是否有某种专用的物理键盘，如果有，是哪种类型。在Android设备上，这很可能会始终返回`NONE`，尽管某些Android型号确实有物理键盘。
- en: '`flash.ui.Keyboard.hasVirtualKeyboard`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.ui.Keyboard.hasVirtualKeyboard`'
- en: Invoking this method will return a `Boolean` of `true` or `false`. It simply
    informs us whether a virtual (software) keyboard is available on the device. In
    the case of Android devices, this will most likely always return `true`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法将返回一个`Boolean`值，为`true`或`false`。它简单地告诉我们设备上是否有虚拟（软件）键盘。在Android设备上，这很可能会始终返回`true`。
- en: Detecting whether or not a device supports multitouch
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测设备是否支持多点触控
- en: When developing projects which target the Android operating system, it is always
    a good idea to make sure that multitouch is actually supported on the device.
    In the case of an Android phone, this will probably always be the case, but what
    about a Google TV or AIR for TV device? Many of these are also Android-based yet
    most televisions do not have any touch control whatsoever. Never assume the capabilities
    of any device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对Android操作系统的项目开发中，确保设备实际上支持多点触控总是一个好主意。在Android手机上，这可能总是如此，但Google TV或AIR
    for TV设备呢？其中许多也是基于Android的，但大多数电视根本没有触摸控制。永远不要假设任何设备的功能。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will need to use internal classes to detect whether or not multitouch is
    supported:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用内部类来检测是否支持多点触控。
- en: 'First, import the following classes into your project:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象，以允许在设备上可见输出：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, simply invoke `Multitouch.supportsGestureEvents` and `Multitouch.supportsTouchEvents`
    to check each of these capabilities as demonstrated in the following method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只需调用`Multitouch.supportsGestureEvents`和`Multitouch.supportsTouchEvents`，即可检查这些功能，如下面的方法所示：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each of these properties will return a `Boolean` value of `true` or `false`,
    indicating device support as shown here:![How to do it...](img/1420_02_02.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些属性中的每一个都将返回一个`Boolean`值，`true`或`false`，表示设备支持，如下所示：![如何操作...](img/1420_02_02.jpg)
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Detecting whether the device supports either touch or gesture events will determine
    how much freedom you, as a developer, have in refining the user experience. If
    either of these items returns as false, then it is up to you to provide (if possible)
    an alternative way for the user to interact with the application. This is normally
    done through `Mouse` events:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 检测设备是否支持触摸或手势事件将决定作为开发者的你，在细化用户体验方面有多少自由度。如果这些项目中的任何一个返回为false，那么就需要你（如果可能的话）提供一种替代方式让用户与应用程序交互。这通常是通过`Mouse`事件完成的：
- en: '**Touch events:** Basic interactions such as a single finger tap.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触摸事件：**如单指轻触等基本交互。'
- en: '**Gesture events:** More complex interpretations of user interaction such as
    pinch, zoom, swipe, pan, and so forth.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手势事件：**更复杂的用户交互解释，如捏合、缩放、滑动、平移等。'
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to note that while a specific device may support either gesture
    events or touch events, when using Flash Platform tools, we must set the `Multitouch.inputMode`
    to one or the other specifically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管特定设备可能支持手势事件或触摸事件，但在使用Flash平台工具时，我们必须将`Multitouch.inputMode`明确设置为其中之一。
- en: Verifying specific gesture support for common interactions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证常见交互中特定手势的支持
- en: When dealing with Android devices, touch and gestures are the main mechanisms
    with which the user interacts with the device. If we want to use some of the predefined
    gestures in Flash Player and AIR, we can do so in the following manner.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Android设备时，触摸和手势是用户与设备交互的主要机制。如果我们想在Flash Player和AIR中使用一些预定义的手势，可以按照以下方式操作。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To discover which specific gestures are supported on a device, perform the
    following actions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现设备支持哪些特定的手势，执行以下操作：
- en: 'First, import the following classes into your project:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对象，以允许在设备上输出可见内容：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the specific input mode for the multitouch APIs to support gestures with
    the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为多触控API设置特定的输入模式以支持手势：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Invoking `Multitouch.supportedGestures` will return a `Vector` of `String`
    objects naming all the supported gestured exposed to Flash on the device:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Multitouch.supportedGestures`将返回一个包含设备上Flash支持的所有手势名称的`String`对象`Vector`：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can then look for a specific gesture or set of gestures to listen for, or
    fall back to other interaction events if necessary.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以寻找特定的手势或手势集进行监听，或者在必要时退回到其他交互事件。
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can perform all of these necessary functions within a single method:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在一个方法内执行所有这些必要功能：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_03.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_03.jpg)
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Flash player and AIR do a marvelous job of distilling information to essential
    details for an Android developer. Knowing which particular gestures are supported
    on a device will allow us to tailor event interactions on our applications and
    provide fallback interactions when necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Flash播放器和AIR在为Android开发者提炼信息至关键细节方面做得非常出色。了解特定设备支持哪些手势，将使我们能够为应用程序定制事件交互，并在必要时提供后备交互。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In our example class, we also provide a check to be sure there are at least
    some gestures supported through `Multitouch.supportedGestures`. Chances are, if
    the device does provide gesture support, we will want to provide a warning to
    the user explaining that the application will not perform optimally because of
    hardware limitations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例类中，我们还通过`Multitouch.supportedGestures`检查以确保至少支持一些手势。如果设备确实提供了手势支持，我们可能需要向用户提供警告，解释应用程序由于硬件限制可能无法达到最佳性能。
- en: Apart from the more common gestures such as zoom, swipe, rotate, and pan, which
    are included in the `flash.events.TransformGestureEvent` package, there are additional,
    yet less common gestures such as two-finger tap, found in the `flash.events.GestureEvent`
    and `flash.events.PressAndTapGestureEvent` classes. These will all be referenced
    by `Multitouch.supportedGestures` if available on the device.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在`flash.events.TransformGestureEvent`包中包含的更常见的诸如缩放、滑动、旋转和平移等手势之外，还有其他较少见的手势，如双指轻触，可以在`flash.events.GestureEvent`和`flash.events.PressAndTapGestureEvent`类中找到。如果设备支持，所有这些都将由`Multitouch.supportedGestures`引用。
- en: Using gestures to zoom a display object
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手势放大显示对象
- en: Pinching and pulling are gestures that are often used on touch screens that
    support multitouch input. Bringing two fingers closer together will shrink an
    object, while spreading two fingers apart makes the object larger on the device.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 捏合和拉扯是在支持多触控输入的触摸屏上经常使用的手势。将两个手指靠近会缩小对象，而将两个手指分开会使对象在设备上变大。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up listeners for zoom gesture events in
    order to scale the `Shape` appropriately:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例在一个`Shape`对象内使用`Graphics` API绘制一个正方形，将其添加到`Stage`中，然后为缩放手势事件设置监听器，以适当缩放`Shape`：
- en: 'First, import the following classes into your project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Declare a `Shape` object, upon which we will perform the gestures:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`对象，我们将在其上执行手势操作：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList:`
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们的`Sprite`的创建并将其添加到`DisplayList`中：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    the `MultitouchInputMode.TOUCH_POINT` constant and register anevent listener for
    the `GESTURE_ZOOM` event. In this case, the `onZoom` method will fire whenever
    the application detects a zoom gesture:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多触点API的特定输入模式设置为支持触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，并注册`GESTURE_ZOOM`事件的事件监听器。在这种情况下，每当应用程序检测到缩放手势时，`onZoom`方法将被触发：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To use the accepted behavior of pinch and zoom, we can adjust the scale of objects
    on stage based upon the scale factor returned by our event listener.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用捏合和缩放的接受行为，我们可以根据事件监听器返回的缩放因子调整舞台上对象的缩放比例。
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_04.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果手势将以以下方式影响我们的视觉对象：![如何操作...](img/1420_02_04.jpg)
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 插图由Gestureworks提供（www.gestureworks.com）。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example, we are listening for the `TransformGestureEvent.GESTURE_ZOOM` event in
    order to set the scale of our `Shape` object. By multiplying the current scale
    properties by the scale values reported through our event, we can adjust the scale
    of our object based upon this gesture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`Multitouch.inputMode`设置为通过`MultitouchInputMode.GESTURE`的手势，因此我们能够监听并响应一系列预定义的手势。在这个例子中，我们监听`TransformGestureEvent.GESTURE_ZOOM`事件，以便设置我们的`Shape`对象的缩放比例。通过将当前的缩放属性与事件报告的缩放值相乘，我们可以根据这个手势调整对象的缩放比例。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Note here that we are drawing our square in such a way that the `Shape` registration
    point is located in the center of the visible `Shape`. It is important that we
    do this, as the `DisplayObject` will scale up and down, based upon the registration
    point and transform point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们绘制正方形的方式是将`Shape`的注册点位于可见`Shape`的中心。我们这样做很重要，因为`DisplayObject`将基于注册点和变换点进行放大和缩小。
- en: When using the drawing tools in Flash Professional, be sure to set the registration
    point of your `MovieClip` symbol to be centered in order for this to work correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Flash Professional中的绘图工具时，请确保将你的`MovieClip`符号的注册点设置为居中，以便正确工作。
- en: See also...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '`TransformGestureEvent.GESTURE_ZOOM` is just one of a set of four primary transform
    gestures available to us when working with the Flash Platform runtimes and Android
    devices. Reference the following recipes for a complete overview of these gestures:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_ZOOM`只是我们在使用Flash Platform运行时和Android设备时可以使用的四个主要变换手势之一。参考以下食谱以获取这些手势的完整概述：'
- en: '*Using gestures to pan a display object*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势平移显示对象*'
- en: '*Using gestures to swipe a display object*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势滑动显示对象*'
- en: '*Using gestures to rotate a display object*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势旋转显示对象*'
- en: Using gestures to pan a display object
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手势平移显示对象
- en: Panning a `DisplayObject` is accomplished by touching the screen with two fingers
    simultaneously, and then moving both fingers across the screen in the direction
    we want to pan the object. This is normally used upon an object that occupies
    more real estate than the screen affords, or an object that has been zoomed in
    so far that only a portion of it is visible on the screen at any given time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 平移`DisplayObject`是通过同时用两个手指触摸屏幕，然后沿着我们想要平移对象的屏幕方向移动两个手指来完成的。这通常用于占据比屏幕更大的对象，或者已经放大到只有部分在给定时间内在屏幕上可见的对象。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up listeners for pan gesture events in order
    to scale the `Shape` appropriately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用`Graphics` API在`Shape`对象内绘制一个正方形，将其添加到`Stage`中，然后为平移手势事件设置监听器，以适当缩放`Shape`。
- en: 'First, import the following classes into your project:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`对象，我们将在这个对象上执行手势操作：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`. We have made extra effort to be sure our `Shape` is much larger
    than the screen so that it can be panned effectively:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们的`Shape`的创建并将其添加到`DisplayList`中。我们特别努力确保我们的`Shape`比屏幕大得多，以便可以有效地进行平移：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for the `GESTURE_PAN` event. In this case, the
    `onPan` method will fire whenever the application detects a zoom gesture:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置特定的输入模式以支持多点触控API的触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，并注册`GESTURE_PAN`事件的事件监听器。在这种情况下，每当应用程序检测到缩放手势时，`onPan`方法将被触发：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now respond to the data being returned by our pan event. In this case,
    we are simply shifting the x and y positions of our `Shape` based upon the pan
    offset data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以响应我们的平移事件返回的数据。在这个例子中，我们只是根据平移偏移数据简单地改变了`Shape`的x和y位置：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_05.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果手势将以以下方式影响我们的视觉对象：![如何操作...](img/1420_02_05.jpg)
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图形由Gestureworks提供（www.gestureworks.com）。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_PAN` event in
    order to shift the x and y position of our `Shape` object. By adjusting the coordinates
    of our `Shape` through the reported offset data, we can adjust the position of
    our object in a way that the user expects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`Multitouch.inputMode`设置为通过`MultitouchInputMode.GESTURE`的手势，因此我们能够监听并响应一系列预定义的手势。在这个例子中，我们监听`TransformGestureEvent.GESTURE_PAN`事件，以便改变我们的`Shape`对象的x和y位置。通过调整我们的`Shape`的坐标通过报告的偏移数据，我们可以按照用户期望的方式调整对象的位置。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that this is often a difficult gesture to perform on certain devices (As
    you must touch the screen with two fingers, simultaneously), and that other devices
    may not even support it. For a fallback, we can always use the `startDrag()` and
    `stopDrag()` methods to simulate a pan.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在某些设备上执行此操作通常很困难（因为你必须同时用两个手指触摸屏幕），而其他设备可能根本不支持它。作为后备，我们总是可以使用`startDrag()`和`stopDrag()`方法来模拟平移。 '
- en: See also...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '`TransformGestureEvent.GESTURE_PAN` is just one of a set of four primary transform
    gestures available to us when working with the Flash Platform runtimes and Android
    devices. Reference the following recipes for a complete overview of these gestures:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_PAN`只是我们在使用Flash Platform运行时和Android设备时可以使用的一组四个主要转换手势之一。参考以下食谱以获取这些手势的完整概述：'
- en: '*Using Gestures to Zoom a DisplayObject*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势缩放DisplayObject*'
- en: '*Using Gestures to Swipe a Display Object*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势滑动显示对象*'
- en: '*Using Gestures to Rotate a Display Object*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势旋转显示对象*'
- en: Using gestures to swipe a display object
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手势滑动显示对象
- en: Swipe is one of the most common gestures on Android devices, and with good reason.
    Whether flipping through a series of photographs, or simply moving between states
    in an application, the swipe gesture is something users have come to expect. A
    swipe gesture is accomplished by simply touching the screen and swiping up, down,
    left, or right across the screen quickly in the opposite direction.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动是Android设备上最常见的动作之一，并且有充分的理由。无论是快速翻阅一系列照片，还是在应用程序的状态之间移动，滑动手势都是用户所期望的。通过简单地触摸屏幕并在相反的方向快速向上、下、左或右滑动，即可完成滑动动作。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up a listener for swipe gesture events in
    order to move the `Shape` instance against the bounds of our screen in accordance
    with the direction of swipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在`Shape`对象内使用`Graphics` API绘制一个正方形，将其添加到`Stage`中，然后设置一个监听器来监听滑动手势事件，以便根据滑动的方向将`Shape`实例移动到屏幕边缘：
- en: 'First, import the following classes into your project:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`对象，我们将对其执行手势操作：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList:`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们的`Shape`的创建并将其添加到`DisplayList`中：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for `TransformGestureEvent.GESTURE_SWIPE` events:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多触点API的特定输入模式设置为支持触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，并注册`TransformGestureEvent.GESTURE_SWIPE`事件的事件监听器：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now respond to the data being returned by our swipe event. In this case,
    we are simply shifting the x and y position of our `Shape` based upon the swipe
    offset data:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以响应滑动事件返回的数据。在这种情况下，我们只是根据滑动偏移数据简单地移动`Shape`的x和y位置：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_06.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果手势将以以下方式影响我们的视觉对象：![如何操作...](img/1420_02_06.jpg)
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的手势图由Gestureworks（www.gestureworks.com）提供。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_SWIPE` event in
    order to shift the x and y position of our `Shape` object. By adjusting the coordinates
    of our `Shape` through the reported offset data, we can adjust the position of
    our object in a way that the user expects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`Multitouch.inputMode`设置为通过`MultitouchInputMode.GESTURE`的手势，因此我们能够监听并响应许多预定义的手势。在这个例子中，我们监听`TransformGestureEvent.GESTURE_SWIPE`事件，以便改变我们的`Shape`对象的x和y位置。通过调整`Shape`的坐标，通过报告的偏移数据，我们可以按照用户期望的方式调整对象的位置。
- en: 'We can see through this example that the `offsetX` and `offsetY` values returned
    by our event listener will each either be 1 or -1\. This makes it very simple
    for us to determine which direction the swipe has registered:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子我们可以看到，事件监听器返回的`offsetX`和`offsetY`值将分别是1或-1。这使得我们很容易确定注册的手势方向：
- en: '**Swipe up:** offsetY = -1'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向上滑动：** offsetY = -1'
- en: '**Swipe down:** offsetY = 1'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向下滑动：** offsetY = 1'
- en: '**Swipe left:** offsetX = -1'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向左滑动：** offsetX = -1'
- en: '**Swipe right:** offsetX = 1'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向右滑动：** offsetX = 1'
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: When reacting to swipe events, it may be a good idea to provide a bit of transition
    animation, either by using built in tweening mechanisms, or an external tweening
    engine. There are many great tweening engines for ActionScript freely available
    as open source software. The use of these engines along with certain gestures
    can provide a more pleasant experience for the user of your applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应滑动事件时，可能需要提供一些过渡动画，使用内置的补间机制或外部补间引擎。有许多优秀的ActionScript补间引擎作为开源软件免费提供。这些引擎与某些手势结合使用，可以为应用程序用户提供更愉快的使用体验。
- en: 'We might consider the following popular tweening engines for use in our application:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在应用程序中使用以下流行的补间引擎：
- en: '**TweenLite:** [http://www.greensock.com/tweenlite/](http://www.greensock.com/tweenlite/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**TweenLite：**[http://www.greensock.com/tweenlite/](http://www.greensock.com/tweenlite/)'
- en: '**GTween:** [http://www.gskinner.com/libraries/gtween/](http://www.gskinner.com/libraries/gtween/)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**GTween：**[http://www.gskinner.com/libraries/gtween/](http://www.gskinner.com/libraries/gtween/)'
- en: See also...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '`TransformGestureEvent.GESTURE_SWIPE` is just one of a set of four primary
    transform gestures available to us when working with the Flash Platform runtimes
    and Android devices. Reference the following recipes for a complete overview of
    these gestures:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_SWIPE`只是我们在使用Flash Platform运行时和Android设备时可用的一组四个主要转换手势之一。参考以下食谱以获取这些手势的完整概述：'
- en: '*Using gestures to zoom a display object*'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势放大显示对象*'
- en: '*Using gestures to pan a display object*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势平移显示对象*'
- en: '*Using gestures to rotate a display object*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势旋转显示对象*'
- en: Using gestures to rotate a display object
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手势旋转显示对象
- en: Rotation is performed by holding two fingers at different points on an object,
    and then moving one finger around the other in a clockwise or counter clockwise
    motion. This results in the rotation of the object on screen. Rotation can be
    used alongside the pan and zoom gestures to provide full control to the user over
    an image or other `DisplayObject`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是通过在物体的不同点按住两个手指，然后一个手指绕另一个手指顺时针或逆时针移动来完成的。这将导致屏幕上的物体旋转。旋转可以与平移和缩放手势结合使用，为用户提供对图像或其他`DisplayObject`的完全控制。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up a listener for `Rotate` gesture events
    in order to appropriately rotate the `Shape` instance around its registration
    point:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在`Shape`对象内使用`Graphics` API绘制一个正方形，将其添加到`Stage`，然后设置一个监听器来监听`Rotate`手势事件，以便围绕其注册点适当地旋转`Shape`实例：
- en: 'First, import the following classes into your project:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`对象，我们将对其执行手势操作：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们的`Shape`的创建并将其添加到`DisplayList`中。
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for the `GESTURE_ROTATE` event. In this case, the
    `onRotate` method will fire whenever the application detects a rotation gesture:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多触点API的特定输入模式设置为支持触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，并为`GESTURE_ROTATE`事件注册一个事件监听器。在这种情况下，每当应用程序检测到旋转手势时，都会触发`onRotate`方法：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now respond to the data being returned by our rotate event. In this
    case, we are simply assigning the `rotation` value returned from our event listener
    to the `rotation` parameter of our `Shape` in order to perform the appropriate
    rotation:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以响应旋转事件返回的数据。在这个例子中，我们只是将从事件监听器返回的`rotation`值简单地赋给我们的`Shape`的`rotation`参数，以执行适当的旋转：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_07.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果手势将以以下方式影响我们的视觉对象：![如何操作...](img/1420_02_07.jpg)
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的手势图由Gestureworks (www.gestureworks.com)提供。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_ROTATE` event
    in order to assign the returned `rotation` value to our `Shape` object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`Multitouch.inputMode`设置为通过`MultitouchInputMode.GESTURE`的手势，因此我们能够监听并响应一系列预定义的手势。在这个例子中，我们正在监听`TransformGestureEvent.GESTURE_ROTATE`事件，以便将返回的`rotation`值赋给我们的`Shape`对象。
- en: There is really no further calculation to make upon this data in most cases,
    but we could perform more advanced rotation interactions by allowing (for instance)
    the rotation of one `DisplayObject` to affect the rotation of an additional `DisplayObject`,
    or even multiple `DisplayObjects` on the `Stage`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，实际上无需对此数据进行进一步计算，但我们可以通过允许（例如）一个`DisplayObject`的旋转影响另一个`DisplayObject`的旋转，甚至影响`Stage`上的多个`DisplayObjects`的旋转，来进行更高级的旋转交互。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note here that we are drawing our square in such a way that the `Shape` registration
    point is located in the center of the visible `Shape`. It is important that we
    do this, as the `DisplayObject` will rotate based upon the registration point
    and transform point.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们是以这种方式绘制正方形，使得`Shape`的注册点位于可见`Shape`的中心。我们这样做很重要，因为`DisplayObject`将基于注册点和变换点进行旋转。
- en: When using the drawing tools in Flash Professional, be sure to set the registration
    point of your `MovieClip` symbol to be centered in order for this to work correctly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Flash Professional的绘图工具时，请确保将你的`MovieClip`符号的注册点设置为居中，以便正确工作。
- en: See also...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '`TransformGestureEvent.GESTURE_ROTATE` is just one of a set of four primary
    transform gestures available to us when working with the Flash Platform runtimes
    and Android devices. Reference the following recipes for a complete overview of
    these gestures:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_ROTATE`只是我们在使用Flash Platform运行时和Android设备时可以使用的一组四个主要变换手势之一。参考以下食谱以获取这些手势的完整概述：'
- en: '*Using gestures to zoom a display object*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势放大显示对象*'
- en: '*Using gestures to pan a display object*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势平移显示对象*'
- en: '*Using gestures to swipe a display object*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用手势滑动显示对象*'
- en: Accessing raw touchpoint data
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问原始触摸点数据
- en: Sometimes the predefined gestures that are baked into Flash Player and AIR are
    not enough for certain application interactions. This recipe will demonstrate
    how to access raw touch data reported by the operating system through Flash Player
    or AIR APIs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Flash Player和AIR内置的预定义手势对于某些应用程序交互来说是不够的。这个示例将演示如何通过Flash Player或AIR API访问操作系统报告的原始触摸数据。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To read raw touch data in your project, perform the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中读取原始触摸数据，请执行以下步骤：
- en: 'First, import the following classes into your project:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和一个`TextFormat`对象，以允许在设备上可见输出：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    We will also register a set of listeners for `TouchEvent` data in the following
    method:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置多触摸API的特定输入模式以支持触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量。我们还在以下方法中为`TouchEvent`数据注册一组监听器：
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To clear out our `TextField` after each touch interaction ends, we will construct
    the following function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在每次触摸交互结束后清除我们的`TextField`，我们将构建以下函数：
- en: '[PRE39]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then read the various properties from the touch event to interpret in
    some way. Events such as pressure, coordinates, size, and more can be derived
    from the event object that is returned:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以从触摸事件中读取各种属性以某种方式解释。可以从返回的事件对象中派生出压力、坐标、大小等事件：
- en: '[PRE40]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_08.jpg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_08.jpg)
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Each touch point that is registered in the device has a number of specific properties
    associated with it. By registering a set of listeners to detect these interactions,
    we can read this data and the application can react appropriately. In our example,
    we are simply exposing these values via `TextField`, but this would be the exact
    data we would need to build a pressure-sensitive gaming mechanic or some other
    custom gesture.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 设备中注册的每个触摸点都关联有一系列特定的属性。通过注册一组监听器来检测这些交互，我们可以读取这些数据，应用程序也可以做出适当的反应。在我们的示例中，我们只是通过`TextField`显示这些值，但这正是构建压力敏感的游戏机制或其他自定义手势所需的确切数据。
- en: Note that on a device that allows more than one touchpoint, we will be able
    to read the data from both touchpoints using the same listener. Multiple touchpoints
    are differentiated by location on the stage and by `touchPointID`. We would use
    these IDs to differentiate between touchpoints when devising complex gestures,
    or simply when we have the need to keep track of each touchpoint in a precise
    way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在一个允许多于一个触摸点的设备上，我们可以使用同一个监听器读取两个触摸点的数据。多个触摸点通过舞台上的位置和`touchPointID`来区分。在设计复杂手势时，或者当我们需要精确地跟踪每个触摸点时，我们会使用这些ID来区分触摸点。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to note that while `Multitouch.inputMode` is set to `MultitouchInputMode.TOUCH_POINT`
    that we will not be able to take advantage of the predefined gestures that Flash
    Player and AIR make available through the simplified gesture API. Setting the
    `Multitouch.inputMode` to `MultitouchInputMode.GESTURE` will allow us to take
    advantage of common, predefined gesture events within our application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`时，我们将无法利用Flash
    Player和AIR通过简化手势API提供的预定义手势。将`Multitouch.inputMode`设置为`MultitouchInputMode.GESTURE`将允许我们在应用程序中使用常见的预定义手势事件。
- en: Creating a custom gesture based upon touchPoint data
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于触摸点数据创建自定义手势
- en: Using raw touch data, we can define custom gestures to develop unique interactions
    used in our application. We do this by making calculations based upon data delivered
    through raw touch events.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始触摸数据，我们可以定义自定义手势以开发应用程序中使用的独特交互。我们通过基于原始触摸事件传递的数据进行计算来实现这一点。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this example, we will create a diagonal swipe gesture that can have four
    separate values returned which let us know the direction of a diagonal swipe.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将创建一个对角线滑动手势，它可以返回四个独立的值，让我们知道对角线滑动的方向。
- en: 'First, import the following classes into your project:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible text output
    upon the device:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和一个`TextFormat`对象，以允许在设备上可见文本输出：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will set up two additional objects to help track our gestures, a `Shape`
    called `drawArea` to draw out the gestures through the graphics API, and `trackBeginObject`,
    which is a simple object we can use to preserve our beginning touch coordinates
    to compare with the coordinates of our touch end:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将设置两个附加对象以帮助跟踪我们的手势，一个名为`drawArea`的`Shape`通过图形API绘制手势，以及`trackBeginObject`，这是一个简单的对象，我们可以使用它来保存我们的初始触摸坐标以与触摸结束时的坐标进行比较：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now set up our `TextField`, apply a `TextFormat,` and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE44]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we will set up our `Shape` within which we will draw out gestures using
    the `Graphics` API:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在其中设置我们的`Shape`，并使用`Graphics` API绘制手势：
- en: '[PRE45]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    In this example, we will register a set of listeners to detect touch movement
    on the `Stage`. This will serve to provide visual feedback for our gesture tracking
    and also preserve our beginning touch coordinates to compare with the coordinates
    of our touch end.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，为多触控API设置特定的输入模式以支持触摸输入。在这个例子中，我们将注册一组监听器来检测`Stage`上的触摸移动。这将有助于为我们的手势跟踪提供视觉反馈，并保存我们的初始触摸坐标以与触摸结束时的坐标进行比较。
- en: 'We will also initialize out tracking `Object` through this same method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也将通过同样的方法初始化我们的跟踪`Object`：
- en: '[PRE46]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Construct a method called `touchBegin` to initialize the beginning of our gesture
    and preserve coordinate data for later comparison. We will make sure that the
    touchpoint being registered is the first touchpoint of what could be multiple
    by testing against the `TouchEvent.isPrimaryTouchPoint` boolean property.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个名为`touchBegin`的方法，以初始化我们手势的开始并保存坐标数据以供稍后比较。我们将确保注册的触摸点是通过测试`TouchEvent.isPrimaryTouchPoint`布尔属性来确定是可能是多个触摸中的第一个触摸点。
- en: '[PRE47]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Construct another method called `touchMove` to accept the touch movement data
    and draw out our visual feedback:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造另一个名为`touchMove`的方法，以接受触摸移动数据并绘制我们的视觉反馈：
- en: '[PRE48]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Construct a final method called `touchEnd` to compare the end touch data coordinates
    with what we preserved at the beginning through our `trackBeginObject` and then
    determine what sort of gesture it is. In this case, we output the results as a
    `String` to a `TextField`, previously created:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个名为`touchEnd`的最终方法，通过我们之前保存的`trackBeginObject`将结束触摸数据坐标与开始时的坐标进行比较，然后确定它是什么样的手势。在这种情况下，我们将结果作为`String`输出到之前创建的`TextField`中：
- en: '[PRE49]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_09.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_09.jpg)
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图形由Gestureworks提供（www.gestureworks.com）。
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we have access to all of the raw touchpoint data, we can track the life cycle
    of a touch interaction from beginning to end with the help of regular ActionScript
    elements such as `Object, Vector`, or `Array` instances. Based upon the data tracked,
    such as coordinate position, touch pressure, and so forth, we can make calculations
    and determine whether or not the interaction qualifies as the gesture we are looking
    to track.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以访问所有原始触摸点数据，因此我们可以利用常规ActionScript元素（如`Object, Vector`或`Array`实例）从开始到结束追踪触摸交互的生命周期。根据追踪的数据，例如坐标位置，触摸压力等，我们可以进行计算并确定交互是否合格为我们想要跟踪的手势。
- en: In the case of our preceding example, we are being fairly loose with our determination
    of a qualifying gesture. To be more stringent, we could also calculate the distance
    of different touch points and even track the time from touch begin to touch end
    to be sure the gesture is exactly what we are looking for, and therefor intentional
    by the user.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们对合格手势的判断相当宽松。为了更加严格，我们还可以计算不同触摸点的距离，甚至追踪从触摸开始到触摸结束的时间，以确保手势正是我们要寻找的，因此是用户有意的。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are actually quite a few gesture libraries that we can use as alternatives
    to those built into the Flash Player and AIR runtimes. Performing a quick web
    search should allow us access to these libraries, many of which are free open
    source software. The most popular 3rd party gesture library is `Gesture Works`,
    which can be downloaded from [http://gestureworks.com/](http://gestureworks.com/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有许多手势库可以作为Flash Player和AIR运行时的内置手势库的替代品。快速进行网络搜索应该可以让我们访问到这些库，其中许多是免费的开放源码软件。最受欢迎的第三方手势库是`Gesture
    Works`，可以从[http://gestureworks.com/](http://gestureworks.com/)下载。
- en: Emulating the Android long-press interaction
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟Android长按交互
- en: One of the most useful interactions built into the Android operating system
    is the long press. This is achieved when a user taps a specific area and holds
    for a few seconds without releasing. While neither Flash Player nor AIR for Android
    have the long-press interaction as part of the multitouch gesture events library,
    it is fairly simple to emulate this interaction through either runtime.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统中内置的最有用的交互之一是长按。当用户轻触特定区域并持续几秒钟而不释放时，就会实现这一功能。虽然Flash Player和Android的AIR都没有将长按交互作为多点触控手势事件库的一部分，但通过这两个运行时模拟这一交互是相当简单的。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will emulate the Android long-press interaction through use of an ActionScript
    `Timer` object along with the use of `TouchPoint` events.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用ActionScript `Timer`对象以及`TouchPoint`事件来模拟Android的长按交互。
- en: 'First, import the following classes into your project:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare a `Sprite` object which we will perform the long-press upon, as well
    as a `Timer` object:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Sprite`对象，我们将在其上进行长按操作，以及一个`Timer`对象：
- en: '[PRE51]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Set up out `Timer` object to measure the amount of time it should take to register
    a long-press; in this case, 1000 milliseconds. Additionally, we will now register
    a listener to detect when the `Timer` cycle has completed:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的`Timer`对象以测量注册长按所需的时间；在这个例子中，是1000毫秒。此外，我们现在注册一个监听器，以检测`Timer`周期是否完成：
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList:`
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们`Sprite`的创建并将其添加到`DisplayList`中：
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    To emulate a long-press, we must start a timer at each instance of a touch interaction
    through `TouchEvent.TOUCH_BEGIN`. The `Timer` will be stopped whenever a `TouchEvent.TOUCH_END`
    or some other touch cancelling event is fired, resetting our "long-press".
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多点触控APIs的特定输入模式设置为支持触摸输入，通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量。为了模拟长按，我们必须在每次触摸交互的开始通过`TouchEvent.TOUCH_BEGIN`启动一个定时器。当触发`TouchEvent.TOUCH_END`或其他触摸取消事件时，将停止`Timer`，重置我们的“长按”。
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Construct a method to modify our `Sprite` upon the start of our touch interaction.
    We will scale the `Sprite` slightly and change the alpha property to indicate
    that something has activated. At this point, we begin measuring the long-press
    through our `Timer:`
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个方法，在触摸交互开始时修改我们的`Sprite`。我们将稍微放大`Sprite`并改变alpha属性以表示已激活某些功能。此时，我们通过`Timer`开始测量长按：
- en: '[PRE55]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `Timer` is set to complete after 1000 milliseconds, once fired. Upon this
    trigger, we can then perform whatever action is necessary within the application.
    In this case, we are making our `Sprite` dragable:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Timer`被设置为在1000毫秒后完成一次触发。在这个触发点上，我们可以在应用程序内执行必要的操作。在这个例子中，我们使我们的`Sprite`可以被拖拽：'
- en: '[PRE56]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The method for a touch end should stop our `Timer` and cancel any drag events
    occurring with our `Sprite`. Here, we also rest the `scale` and `alpha` of our
    `Sprite` to return it to a rest state:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸结束时应该停止我们的`Timer`并取消与我们的`Sprite`发生的任何拖拽事件。在这里，我们将`Sprite`的`scale`和`alpha`恢复到静止状态：
- en: '[PRE57]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_10.jpg)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果手势将以以下方式影响我们的视觉对象：![如何操作...](img/1420_02_10.jpg)
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 插图由Gestureworks提供（www.gestureworks.com）。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our example requires a one second press and hold to trigger a function invocation,
    which causes a `Shape` object to become draggable across the `Stage`. This is
    accomplished by listening for a `TOUCH_BEGIN` event, then monitoring a `Timer`
    to decide whether this is an intentional long-press interaction. If one second
    goes by without a `TOUCH_END` event, then we make the `Shape` draggable. We have
    modified the scale and opacity of the `Shape` once the `Timer` is triggered to
    indicate that it now a draggable object. Releasing the `Shape` will complete the
    interaction.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例需要按住一秒钟来触发函数调用，这导致一个`Shape`对象可以在`Stage`上拖动。这是通过监听`TOUCH_BEGIN`事件，然后监控`Timer`来判断这是否是有意的长按交互来实现的。如果一秒钟内没有`TOUCH_END`事件，那么我们就让`Shape`可拖动。一旦触发`Timer`，我们就修改了`Shape`的缩放和透明度，以表示它现在是一个可拖动的对象。释放`Shape`将完成这个交互。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The most common uses of the long-press are to perform a repositioning of certain
    visual elements, as we have done here, or to invoke a menu operation as Android
    users are very comfortable with using this sort of interaction on their devices.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 长按功能最常见的用途是重新定位某些视觉元素，正如我们在这里所做的那样，或者唤起菜单操作，因为安卓用户非常习惯于在设备上使用这种类型的交互。
- en: Invoking the virtual keyboard programmatically
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化唤起虚拟键盘
- en: In most cases, simply giving focus to a text input field will invoke the virtual
    keyboard. Losing focus will dismiss the virtual keyboard. Perhaps we require our
    application to do this without user interaction, or immediately when entering
    a certain application state for convenience.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只需将焦点放在文本输入字段上就会唤起虚拟键盘。失去焦点将关闭虚拟键盘。也许我们需要应用程序在没有用户交互的情况下这样做，或者在某些应用状态进入时立即这样做以方便用户。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We configure a `Shape` to toggle the Android virtual keyboard on and off through
    a `Tap` touch event assigned to it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了一个`Shape`，通过分配给它的`Tap`触摸事件来切换安卓虚拟键盘的开启和关闭。
- en: 'First, import the following classes into your project:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE58]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Declare a `Shape` alongside a `TextField` and `TextFormat` object. These will
    be used for interaction and visual feedback.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`以及一个`TextField`和`TextFormat`对象。这些将用于交互和视觉反馈。
- en: '[PRE59]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList`. Tapping this `Sprite` will allow us to invoke or hide the virtual
    keyboard. We will also construct a `TextField` and associated `TextFormat` object
    within the `Sprite` to allow us to provide stateful messages to the user.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们`Sprite`的创建并将其添加到`DisplayList`中。点击这个`Sprite`将允许我们唤起或隐藏虚拟键盘。我们还将构建一个`TextField`和相关的`TextFormat`对象在`Sprite`内，以允许我们向用户提供有状态的消息。
- en: '[PRE60]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener on the `DisplayObject`, which will be used to trigger
    the activation and deactivation of the Android virtual keyboard. In this case,
    a `TouchEvent.TOUCH_TAP` event. A touch tap is the touch equivalent of a mouse
    click event. We can also register a number of listeners for a set of virtual keyboard
    events. In order for a `DisplayObject` to be able to invoke the virtual keyboard,
    we will need to set its `needsSoftKeyboard` property to `true`. The `SoftKeyboardEvent`
    listeners we register here are optional.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，为多点触控API设置特定的输入模式以支持触摸输入，并在`DisplayObject`上注册一个事件监听器，这将用于触发安卓虚拟键盘的激活和停用。在这种情况下，是一个`TouchEvent.TOUCH_TAP`事件。触摸点击相当于鼠标点击事件。我们还可以为一系列虚拟键盘事件注册多个监听器。为了让`DisplayObject`能够唤起虚拟键盘，我们需要将其`needsSoftKeyboard`属性设置为`true`。在这里注册的`SoftKeyboardEvent`监听器是可选的。
- en: '[PRE61]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To make use of the `SoftKeyboardEvent` listeners defined in the preceding point,
    we must create a variety of methods to execute once each activity is detected.
    In this way, we can monitor, interact with, or even prevent certain events from
    firing by intercepting the virtual keyboard while in the midst of activating,
    or detecting when the virtual keyboard has completed activation or deactivation
    completely.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用前面定义的`SoftKeyboardEvent`监听器，我们必须创建各种方法，在检测到每次活动时执行。这样，我们可以在激活过程中监听、与虚拟键盘交互，甚至阻止某些事件触发，或者在检测到虚拟键盘完全完成激活或停用时进行拦截。
- en: '[PRE62]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To invoke the virtual keyboard, we simply invoke `requestSoftKeyboard()on` the
    `DisplayObject`, whose `needsSoftKeyboard` property has been set to `true`. Here,
    we are checking to see whether `needsSoftKeyboard` is set to true or not, and
    toggling this property based upon that.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用虚拟键盘，我们只需在 `DisplayObject` 上调用 `requestSoftKeyboard()`，其 `needsSoftKeyboard`
    属性已设置为 `true`。在这里，我们检查 `needsSoftKeyboard` 是否设置为 true，并据此切换此属性。
- en: '[PRE63]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To dismiss the virtual keyboard, the user will need to tap upon a `DisplayObject`,
    whose `needsSoftKeyboard` property has been set to `false`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭虚拟键盘，用户需要点击一个 `DisplayObject`，其 `needsSoftKeyboard` 属性已设置为 `false`。
- en: The result will appear similar to the following:![How to do it...](img/1420_02_11.jpg)
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_11.jpg)
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to invoke the Android virtual keyboard through ActionScript, we must
    set an interactive `DisplayObjects.needsSoftKeyboard` property to `true`. This
    will allow us to register a tap touch listener and invoke `requestSoftKeyboard()`
    upon the tap touch event being fired, revealing the virtual keyboard on screen.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 ActionScript 调用 Android 虚拟键盘，我们必须将交互式 `DisplayObjects.needsSoftKeyboard`
    属性设置为 `true`。这将允许我们注册一个轻触监听器，并在触发轻触事件时调用 `requestSoftKeyboard()`，在屏幕上显示虚拟键盘。
- en: Touching any `DisplayObject` whose `needsSoftKeyboard` property is set to `false`
    (the default state), will dismiss the virtual keyboard. In our preceding example,
    we switch this property from `true` to `false` in order to make the `DisplayObject`
    function as a toggle control.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何 `needsSoftKeyboard` 属性设置为 `false`（默认状态）的 `DisplayObject` 将关闭虚拟键盘。在我们的前一个示例中，我们将此属性从
    `true` 切换到 `false`，以便 `DisplayObject` 作为切换控件。
- en: There's more...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While it is not necessary to use the `SoftKeyboardEvent` class to activate or
    dismiss the Android virtual keyboard through ActionScript, it is included in the
    example class as it allows us to respond to such events with an additional set
    of listener functions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `SoftKeyboardEvent` 类通过 ActionScript 激活或关闭 Android 虚拟键盘并不是必须的，但它包含在示例类中，因为它允许我们使用一组额外的监听器函数来响应这些事件。
- en: Responding to Android soft-key interactions
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应 Android 软键交互
- en: AIR for Android does not include support for invoking the native operating system
    options menu that often appears at the bottom of the screen. However, there are
    ways of simulating the native behaviour, which we will explore in this section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: AIR for Android 不包括支持调用通常出现在屏幕底部的原生操作系统选项菜单。但是，有一些方法可以模拟原生行为，我们将在本节中探讨这些方法。
- en: The normal behaviour of the `back` button, on Android, is to step back through
    the application states until we arrive back home. A further press of the `back`
    button will exit the application. By default, AIR for Android applications behave
    in this way as well. If we want to override this default behaviour, we must set
    up a mechanism to intercept this interaction and then prevent it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，`back` 按钮的正常行为是通过应用程序状态向后退，直到回到主界面。再次按下 `back` 按钮将退出应用程序。默认情况下，AIR
    for Android 应用程序也具有这种行为。如果我们想覆盖这个默认行为，我们必须设置一个机制来拦截此交互并阻止它。
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can respond to soft-key events through standard ActionScript event listeners.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过标准的 ActionScript 事件监听器响应软键事件。
- en: 'First, import the following classes into your project:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE64]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `TextField` 和 `TextFormat` 对象，以允许在设备上显示可见输出：
- en: '[PRE65]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We will then set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置我们的 `TextField`，应用 `TextFormat`，并将其添加到 `DisplayList` 中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE66]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we need to set an event listener on the `Stage` to respond to keyboard
    presses:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `Stage` 上设置一个事件监听器来响应键盘按键：
- en: '[PRE67]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will then write a switch/case statement in our `keyDown` method that will
    perform different actions in response to specific soft-key events. In this case,
    we output the name of a specific menu item to our `TextField:`
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在 `keyDown` 方法中编写一个 switch/case 语句，以对特定的软键事件执行不同的操作。在这种情况下，我们将特定菜单项的名称输出到我们的
    `TextField`：
- en: '[PRE68]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_12.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_12.jpg)
- en: How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We register listeners for these Android device soft-keys just as we would for
    a physical or virtual keyboard in ActionScript. If developing Android applications
    using AIR for Android, we also have access to the `BACK, MENU`, and `SEARCH` constants
    through the `Keyboard` class.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像为物理或虚拟键盘注册监听器一样，为这些Android设备软键注册监听器。如果使用AIR for Android开发Android应用程序，我们还可以通过`Keyboard`类访问`BACK,
    MENU`和`SEARCH`常量。
- en: Registering a keyboard `keyDown` listener and then responding to specific key
    values through a switch/case statement allows us to respond to the interaction
    appropriately. For instance, if the `MENU` soft-key interaction is detected, we
    can reveal an options menu.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注册键盘`keyDown`监听器，然后通过switch/case语句响应特定的键值，使我们能够适当地响应用户交互。例如，如果检测到`MENU`软键的交互，我们可以显示一个选项菜单。
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is also a `HOME` soft-key on Android devices. This key press cannot be
    captured through ActionScript as it exists solely to return the user to the Android
    home screen from any opened application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备上还有一个`HOME`软键。这个按键无法通过ActionScript捕获，因为它仅用于从任何打开的应用程序返回用户到Android主屏幕。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must use the `keyDown` event when we want to cancel the default Android behavior
    of the `BACK` key because the `keyUp` event will fire too late and not be caught
    at all.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要取消`BACK`键的默认Android行为时，必须使用`keyDown`事件，因为`keyUp`事件将触发得太晚，根本无法捕获。
- en: Responding to trackball and D-Pad events
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应轨迹球和D-Pad事件
- en: Some Android devices have additional physical inputs that we can take advantage
    of. For instance, the Motorola Droid has a slider keyboard, which includes a directional
    D-pad and the HTC Nexus One has a built-in trackball control.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Android设备具有我们可以利用的额外物理输入。例如，摩托罗拉Droid有一个滑盖键盘，包括一个方向性的D-pad，而HTC Nexus One有一个内置的轨迹球控制。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can respond to trackball and D-pad events through standard ActionScript event
    listeners.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过标准的ActionScript事件监听器响应轨迹球和D-pad事件。
- en: 'First, import the following classes into your project:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE69]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Declare a `Shape` alongside a `TextField` and `TextFormat` object. These will
    be used for interaction and visual feedback.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Shape`以及一个`TextField`和`TextFormat`对象。这些将用于交互和视觉反馈。
- en: '[PRE70]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will then set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE71]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个方法来处理我们的`Shape`的创建并将其添加到`DisplayList`中。
- en: '[PRE72]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Set an event listener on the `Stage` to respond to keyboard presses:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Stage`上设置一个事件监听器，以响应键盘按键：
- en: '[PRE73]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, we simply need to write a switch/case statement that will perform different
    actions in response to D-pad/trackball events. In this case, we change the position
    of our `Shape` and output the `keyCode` to a `TextField:`
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要编写一个switch/case语句，以响应D-pad/轨迹球事件执行不同的动作。在这种情况下，我们改变`Shape`的位置，并将`keyCode`输出到`TextField`：
- en: '[PRE74]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The result will appear similar to the following:![How to do it...](img/1420_02_13.jpg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下所示：![如何操作...](img/1420_02_13.jpg)
- en: How it works...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We register listeners for these special controls just as we would the `Keyboard.UP,
    Keyboard.DOWN, Keyboard.LEFT, Keyboard.RIGHT`, and `Keyboard.ENTER` keys for any
    physical keyboard. In this example, we are shifting the target `Shape` in each
    direction and rest the location based upon the D-pad/trackball being pressed.
    We are also outputting the `keyCode` value to a text field.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像注册物理键盘上的`Keyboard.UP, Keyboard.DOWN, Keyboard.LEFT, Keyboard.RIGHT`以及`Keyboard.ENTER`键一样，为这些特殊控件注册监听器。在这个例子中，我们根据D-pad/轨迹球被按下，在每个方向上移动目标`Shape`并重置位置。我们还将`keyCode`值输出到文本字段中。
- en: There's more...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is important to note that most Android devices do not have such specialized
    input mechanisms. If we do register events mapped to these keys, we should always
    supply and alternative as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，大多数Android设备没有这种专门的输入机制。如果我们注册了映射到这些键的事件，我们应始终提供一种替代方案。
