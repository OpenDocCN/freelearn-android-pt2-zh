# 第七章。测试食谱

本章通过应用前几章中描述的原则和技术，提供了您将遇到的不同常见情况的实例。这些例子以烹饪书的形式呈现，因此您可以在项目中修改和使用它们。

以下是本章将涉及的主题:

*   安卓单元测试
*   测试活动和应用
*   测试数据库和内容提供者
*   测试本地和远程服务
*   测试用户界面
*   测试异常
*   测试解析器
*   测试内存泄漏

在这一章之后，你将有一个参考来将测试应用到你的项目中，并知道在每种情况下该做什么。

# 安卓单元测试

在某些情况下，您确实需要在与底层系统几乎没有连接的情况下单独测试应用的某些部分。在这种情况下，我们必须选择一个基类，这个基类在层次结构中足够高，可以移除一些依赖关系，但又不足以让我们负责一些基本的基础设施。

这种情况下的候选基类可能是 `AndroidTestCase`。这个例子取自**安卓 CTS** 测试套件([http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html)):

```java
/*
* Copyright (C) 2009 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
package com.android.cts.appaccessdata;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import android.test.AndroidTestCase;
/**
* Test that another app's private data cannot be accessed.
*
* Assumes that {@link APP_WITH_DATA_PKG} has already created the private data.
*/
public class AccessPrivateDataTest extends AndroidTestCase {
/**
* The Android package name of the application that owns the private data
*/
private static final String APP_WITH_DATA_PKG = "com.android.cts.appwithdata";

```

到目前为止，我们有:

*   标准的安卓开源项目版权。
*   包定义。这个测试存在于 `com.android.cts.appaccessdata`中。
*   一些进口货。
*   `AccessPrivateDataTest`的定义，它扩展了 `AndroidTestCase`，因为它是一个不需要系统基础设施的单元测试。在这个特殊的例子中，我们也可以直接使用 `TestCase`，因为我们没有访问上下文。
*   常量 `APP_WITH_DATA_PKG`的定义，表示包含我们试图访问的私有数据的应用的包名:

    ```java
    /**
    * Name of private file to access. This must match the name * of the file created by
    * {@link APP_WITH_DATA_PKG}.
    */
    private static final String PRIVATE_FILE_NAME = "private_file.txt";
    /**
    * Tests that another app's private file cannot be accessed
    * @throws IOException
    */
    public void testAccessPrivateData() throws IOException {
    try {
    // construct the absolute file path to the app's private file
    String privateFilePath = String.format( "/data/data/%s/%s", APP_WITH_DATA_PKG, PRIVATE_FILE_NAME);
    FileInputStream inputStream = new FileInputStream(privateFilePath);
    inputStream.read();
    inputStream.close();
    fail("Was able to access another app's private data");
    } catch (FileNotFoundException e) {
    // expected
    } catch (SecurityException e) {
    // also valid
    }
    }
    }

    ```

在第二部分，我们有:

*   `PRIVATE_FILE_NAME`的定义，包含我们将要尝试访问的文件的名称
*   测试方法 `testAccessPrivateData`，它实际上锻炼了特征

这个测试方法 `testAccessPrivateData()`测试对其他包的私有数据的访问，如果可能的话会失败。为了实现这一点，捕获预期的异常，如果没有发生这种情况 `fail()`将通过自定义消息调用。

# 测试活动和应用

本节展示了一些活动和应用测试的示例。它们涵盖了您将在日常测试中发现的一些常见情况，您可以根据自己的特定需求对它们进行调整。

## 应用和偏好

用安卓的话来说，application 指的是需要维护全局应用状态时使用的基类。这通常用于处理共享首选项。我们期望改变这些偏好值的测试不会影响实际应用的行为。假设测试删除了一个应用的用户帐户信息，该应用将这些值存储为共享首选项。听起来不是个好主意。所以我们真正需要的是模拟 `Context`的能力，它也模拟了 `SharedPreferences`的入口。

我们的第一次尝试可能是使用 `RenamingDelegatingContext`，但不幸的是，它没有模拟 `SharedPreferences`，尽管它很接近，因为它模拟了数据库和文件系统访问。所以，首先我们需要创建一个专门的模拟 `Context`来模拟后者。

### 重命名模拟上下文类

让我们创建专门的 `Context`。类 `RenamingDelegatingContext`是一个很好的起点，因为正如我们之前提到的，数据库和文件系统访问将被嘲笑。问题是如何嘲弄 `SharedPreferences`的访问权。

记住 `RenamingDelegatingContext`顾名思义，将一切委托给一个 `Context`。所以我们问题的根源就在于这个 `Context`。因为它也是一个模拟的 `Context`，所以 `MockContext`似乎是正确的基类。大家可能还记得，在[第 3 章](03.html "Chapter 3. Building Blocks on the Android SDK")、*Android SDK 上的构建块*中，我们看了一下模拟对象，注意到 `MockContext`只能用来注入其他依赖项，所有方法都是无功能的，抛出 `UnsupportedOperationException`。然而，这也是一个我们可以用来检测在这种情况下需要实现的最小方法集的特性。因此，让我们开始创建一个空的 `MockContext`，另一个 `Context`，我们可以命名为 `RenamingMockContext`，代表:

```java
private static class RenamingMockContext extends RenamingDelegatingContext {
private static final String PREFIX = "test.";
public RenamingMockContext(Context context) {
super(new DelegatedMockContext(context), PREFIX);
}
private static class DelegatedMockContext extends MockContext {
public DelegatedMockContext(Context context) {
// TODO Auto-generated constructor stub
}
}
}

```

我们创建了一个模拟 `Context, RenamingMockContext`，它委托给另一个空的 `MockContext, DelegatedMockContext`，并使用了一个重命名前缀。

### 温度转换应用测试类

我们有 `RenamingMockContext`，现在我们需要一个使用它的测试。因为我们将测试一个应用，测试的基类将是 `ApplicationTestCase`。这个测试用例提供了一个框架，在这个框架中，您可以在受控环境中测试应用类。它为应用的生命周期提供基本支持，并提供钩子，通过钩子可以注入各种依赖关系并控制测试应用的环境。我们可以在使用 `setContext()`方法创建 `Application`之前注入 `RenamingMockContext`。

我们在[第 4 章](04.html "Chapter 4. Test Driven Development")、*测试驱动开发*中启动的 `TemperatureConverter`应用将存储小数位作为共享首选项。因此，我们将创建一个测试来设置小数位数，然后检索它来验证其值:

```java
public class TemperatureConverterApplicationTests extends
ApplicationTestCase<TemperatureConverterApplication> {
private TemperatureConverterApplication mApplication;
public TemperatureConverterApplicationTests() {
this("TemperatureConverterApplicationTests");
}
public TemperatureConverterApplicationTests(String name) {
super(TemperatureConverterApplication.class);
setName(name);
}
@Override
protected void setUp() throws Exception {
super.setUp(); final RenamingMockContext mockContext = new RenamingMockContext(getContext());
setContext(mockContext);
createApplication();
mApplication = getApplication();
}
@Override
protected void tearDown() throws Exception {
super.tearDown();
}
public final void testPreconditions() {
assertNotNull(mApplication);
}
public final void testSetDecimalPlaces() {
final int expected = 3;
mApplication.setDecimalPlaces(expected);
assertEquals(expected, mApplication.getDecimalPlaces());
}
}

```

我们使用 `TemperatureConverterApplication`模板参数扩展 `ApplicationTestCase`。很快，我们将创建扩展类 `Application`。

然后我们使用[第三章](03.html "Chapter 3. Building Blocks on the Android SDK")、*在安卓软件开发工具包中讨论的**给定名称构造器**模式。*

在 `setUp()`方法中，我们创建模拟上下文，并使用 `setContext()`方法为此测试设置上下文；我们使用 `createApplication()`创建应用，最后保存对它的引用，因为它将在我们的测试中频繁使用。

关于我们的测试，使用我们之前回顾的**测试先决条件**模式，我们检查最近创建的应用不是空的。

最后是测试，它实际测试设置小数位、检索小数位并验证其值所需的行为。

我们的第一个目标是编译这些测试。稍后我们将重点关注这些测试的成功。为了让它编译，我们需要创建类 `TemperatureConverterApplication`和小数位的 getter 和 setter，它们最终应该使用 `SharedPreferences`来存储和检索特定的首选项:

```java
/**
* Copyright (C) 2010-2011 Diego Torres Milano
*/
package com.example.aatg.tc;
import android.app.Application;
/**
* @author diego
*
*/
public class TemperatureConverterApplication extends
Application {
/**
*
*/
public TemperatureConverterApplication() {
// TODO Auto-generated constructor stub
}
public void setDecimalPlaces(int expected) {
// TODO Auto-generated method stub
}
public Object getDecimalPlaces() {
// TODO Auto-generated method stub
return null;
}
}

```

运行测试时，我们获得了一个与我们没有在任何地方存储小数位的事实相关的失败。我们可以用 `SharedPreferences`这样实现:

```java
/**
* Copyright (C) 2010-2011 Diego Torres Milano
*/
package com.example.aatg.tc;
import android.app.Application;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.preference.PreferenceManager;
/**
* @author diego
*
*/
public class TemperatureConverterApplication extends Application {
private static final String TAG = "TemperatureConverterApplication";
public static final int DECIMAL_PLACES_DEFAULT = 2;
public static final String DECIMAL_PLACES = "decimalPlaces";
private SharedPreferences mSharedPreferences;
/**
*
*/
public TemperatureConverterApplication() {
// TODO Auto-generated constructor stub
}
@Override
public void onCreate() {
super.onCreate();
mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
}
public void setDecimalPlaces(int d) {
final Editor editor = mSharedPreferences.edit();
editor.putString(DECIMAL_PLACES, Integer.toString(d));
editor.commit();
}
public int getDecimalPlaces() {
return Integer.parseInt( mSharedPreferences.getString(DECIMAL_PLACES, Integer.toString(DECIMAL_PLACES_DEFAULT)));
}
}

```

如果我们完成这些步骤，编译并运行测试，我们会发现它们以 `MockContext.getPackageName()`中的 `UnsupportedOperationException`失败。

我们将 `DelegateMockContext`改为覆盖 `getPackageName()`，委托给作为参数传递给构造函数的原始上下文:

```java
private static class RenamingMockContext extends RenamingDelegatingContext {
/**
* The renaming prefix.
*/
private static final String PREFIX = "test.";
public RenamingMockContext(Context context) {
super(new DelegatedMockContext(context), PREFIX);
}
private static class DelegatedMockContext extends MockContext {
private Context mDelegatedContext;
public DelegatedMockContext(Context context) {
mDelegatedContext = context;
} @Override
public String getPackageName() {
return mDelegatedContext.getPackageName();
}
}

```

再次运行测试，这一次我们获得了一个不同的，虽然有些出乎意料的 `UnsupportedOperationException`。调用 `getSharedPreferences()`时收到此异常。因此，下一步是在 `DelegatedMockContext:` 中覆盖此方法

```java
@Override
public SharedPreferences getSharedPreferences( String name, int mode) {
return mDelegatedContext.getSharedPreferences( PREFIX + name, mode);
}

```

每当请求 `SharedPreference`时，该方法将调用委托上下文，为名称添加前缀。应用使用的原 `SharedPreferences`不变。

我们可以通过向 `TemperatureConverterApplication`类提供前面提到的方法来验证这种行为，然后在共享首选项中存储一些值，运行测试，并最终验证该值不受运行测试的影响。

## 测试活动

下一个例子展示了如何使用 `ActivityUnitTestCase<Activity>`基类而不是 `ActivityInstrumentationTestCase2<Activity>`来完全隔离地测试一个活动。这种方法需要更多的注意和关注，但也提供了更大的灵活性和对测试中的 `Activity`的控制。这种测试旨在测试一般的 `Activity`行为，而不是 `Activity`实例与其他系统组件或用户界面相关测试的交互。

我们是从作为 SDK 配套提供的 ApiDemos 示例应用([http://developer . Android . com/resources/samples/API demos/index . html](http://developer.android.com/resources/samples/ApiDemos/index.html))中获取这个示例的。这个示例有点长，所以我们将它分成几个代码片段来提高可读性:

```java
/*
* Copyright (C) 2008 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
* implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
package com.example.android.apis.app;
import com.example.android.apis.R;
import com.example.android.apis.view.Focus2ActivityTest;
import android.content.Context;
import android.content.Intent;
import android.test.ActivityUnitTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.widget.Button;

```

第一个代码片段只包含所需的版权和导入:

```java
/**
* This demonstrates completely isolated "unit test" of an Activity
* class.
*
* <p>This model for testing creates the entire Activity (
* like {@link Focus2ActivityTest}) but does
* not attach it to the system (for example, it cannot launch another
* Activity).
* It allows you to inject additional behaviors via the
* {@link android.test.ActivityUnitTestCase#setActivityContext(
* Context)} and
* {@link android.test.ActivityUnitTestCase#setApplication(
* android.app.Application)} methods.
* It also allows you to more carefully test your Activity's
* performance
* Writing unit tests in this manner requires more care and
* attention, but allows you to test
* very specific behaviors, and can also be an easier way
* to test error conditions.
*
* <p>Because ActivityUnitTestCase creates the Activity
* under test completely outside of
* the usual system, tests of layout and point-click UI
* interaction are much less useful
* in this configuration. It's more useful here to concentrate
* on tests that involve the
* underlying data model, internal business logic, or exercising
* your Activity's life cycle.
*
* <p>See {@link com.example.android.apis.AllTests} for
* documentation on running
* all tests and individual tests in this application.
*/
public class ForwardingTest extends ActivityUnitTestCase<Forwarding> {
private Intent mStartIntent;
private Button mButton;
public ForwardingTest() {
super(Forwarding.class);
}

```

第二个片段包括扩展 `ActivityUnitTestCase<Forwarding>`的测试用例定义，正如我们前面提到的活动类的单元测试。测试中的活动将与系统断开，因此它仅用于测试系统的内部方面，而不是与其他组件的交互。

这里也定义了无参数构造函数，正如我们在前面的例子中提到的:

```java
@Override
protected void setUp() throws Exception {
super.setUp();
// In setUp, you can create any shared test data, // or set up mock components to inject
// into your Activity. But do not call startActivity() // until the actual test methods.
// into your Activity. But do not call startActivity() // until the actual test methods.
mStartIntent = new Intent(Intent.ACTION_MAIN);
}

```

该 `setUp()`方法遵循调用超级方法的模式，并使用用于启动活动的意图初始化字段。在这种情况下，我们将 `Intent`保存为成员 `mStartIntent:`

```java
/**
* The name 'test preconditions' is a convention to
* signal that if this
* test doesn't pass, the test case was not set up
* properly and it might
* explain any and all failures in other tests.
* This is not guaranteed
* to run before other tests, as junit uses reflection
* to find the tests.
*/
@MediumTest
public void testPreconditions() {
startActivity(mStartIntent, null, null);
mButton = (Button) getActivity().findViewById(R.id.go);
assertNotNull(getActivity());
assertNotNull(mButton);
}

```

这就定义了我们之前也解释过的 `testPreconditions()`方法。正如方法的注释中所指出的，请记住这个名称只是一个约定，并不保证执行顺序:

```java
/**
* This test demonstrates examining the way that activity calls
* startActivity() to launch
* other activities.
*/
@MediumTest
public void testSubLaunch() {
Forwarding activity = startActivity( mStartIntent, null, null);
mButton = (Button) activity.findViewById(R.id.go);
// This test confirms that when you click the button, // the activity attempts to open
// another activity (by calling startActivity) and // close itself (by calling finish()).
mButton.performClick();
assertNotNull(getStartedActivityIntent());
assertTrue(isFinishCalled());
}

```

该测试执行点击转发活动的“开始”按钮。该按钮的 `onClickListener`调用 `startActivity()`，其中 `Intent`将组件定义为 `ForwardTarget`类，因此这是将要启动的 `Activity`。

执行此操作后，我们验证用于启动新的 `Activity`的 `Intent`不为空，并且 `finish()`在我们的 `Activity`上被调用。

使用 `startActivity(mStartIntent, null, null)`开始测试活动后，对组件进行验证，以确保它们符合预期。为此，使用 `getActivity()`上的断言验证最近开始的活动是否为“非空”，然后通过 `findViewById()`获得的按钮也验证“非空”值:

```java
/**
* This test demonstrates ways to exercise the Activity's
* life cycle.
*/
@MediumTest
public void testLifeCycleCreate() {
Forwarding activity = startActivity( mStartIntent, null, null);
// At this point, onCreate() has been called, but nothing else
// Complete the startup of the activity
getInstrumentation().callActivityOnStart(activity);
getInstrumentation().callActivityOnResume(activity);
// At this point you could test for various configuration // aspects, or you could
// use a Mock Context to confirm that your activity has made // certain calls to the system
// and set itself up properly.
getInstrumentation().callActivityOnPause(activity);
// At this point you could confirm that the activity has // paused properly, as if it is
// no longer the topmost activity on screen.
getInstrumentation().callActivityOnStop(activity);
// At this point, you could confirm that the activity has // shut itself down appropriately,
// or you could use a Mock Context to confirm that your // activity has released any system
// resources it should no longer be holding.
// ActivityUnitTestCase.tearDown(), which is always // automatically called, will take care
// of calling onDestroy().
}
}

```

这可能是这个测试用例中最有趣的测试方法。这个测试案例演示了如何运行 `Activity`生命周期。启动后 `Activity, onCreate()`被自动调用，然后我们通过手动调用其他生命周期方法来练习它们。为了能够调用这些方法，我们使用这个测试的 `Intrumentation`。

最后，我们不会手动调用 `onDestroy()`，因为它将在 `tearDown().`中为我们调用

接下来，我们进行 `testSubLaunch()`测试。本测试使用 `startActivity(mStartIntent, null, null)`启动被测 `Activity`后，检查各种情况。使用 `findViewById()`获得 `Button`，然后按下 `performClick().`发出 `performClick().`当触摸此按钮时的动作是启动新的 `Activity`，这正是被检查的条件，断言 `getStartedActivityIntent()`返回“不为空”。后一种方法返回测试中的 `Activity`调用 `startActivity(Intent)`或 `startActivityForResult(Intent, int)`时使用的意图。最后一步是验证如果另一个 `Activity`被启动了 `finish()`是否被调用，我们通过验证 `isFinishCalled()`的返回值来验证，如果在被测试的 `Activity`中调用了其中一个结束方法(`finish(), finishFromChild(Activity)`或 `finishActivity(int)`)，返回值为真。

是时候练习使用 `testLifeCycleCreate()`方法的 `Activity`生命周期了。该方法以与先前分析测试相同的方式启动 `Activity`。

之后活动启动，调用其 `onCreate()`方法， `Instrumentation`调用 `getInstrumentation().callActivityOnStart(activity)`、 `getInstrumentation().callActivityOnResume(activity)`等其他生命周期方法，完成被测 `Activity`的启动。

`Activity`现在完全开始了，是时候测试我们感兴趣的方面了。一旦实现了这一点，我们就可以遵循生命周期中的其他步骤。请注意，此示例测试不测试任何特殊情况。

为了完成生命周期，我们将调用 `getInstrumentation().callActivityOnPause(activity)`和 `getInstrumentation().callActivityOnStop(activity)`。正如方法评论中提到的，我们不必担心调用 `onDestory()`，因为它将被 `tearDown()`自动调用。

如果您想要运行测试，一旦您将 `ApiDemos.apk`及其测试安装到设备或仿真器上，您就可以运行以下命令行:

```java
$ adb -e shell am instrument -w -e class com.example.android.apis.app.ForwardingTest com.example.android.apis.tests/android.test.InstrumentationTestRunner

```

输出如下:

**com . example . Android . API . app . forwarding test:...检测测试运行程序的测试结果=...时间:0.614 OK (3 次测试)**

这个测试代表了一个框架，你可以重用它来独立测试你的 `Activities`和测试生命周期相关的案例。模拟对象的注入也有助于测试 `Activity`的其他方面，例如访问系统资源。

# 测试文件、数据库和内容提供者

一些测试用例需要执行数据库或 ContentProviders 操作，很快就需要模拟这些操作。例如，如果我们在真实设备上测试应用，我们不想干扰此类设备上应用的正常运行，主要是当我们更改可能由多个应用共享的值时。

这种情况可以利用另一个不是 `android.test.mock`包的一部分而是 `android.test`的模拟类，即 `RenamingDelegatingContext`。

这个类允许我们模拟文件和数据库操作。构造函数中提供的前缀用于修改这些操作的目标。所有其他操作都委托给委托 `Context`，您也必须在构造函数中指定该委托。

假设我们的 `Activity`在测试中使用了一些我们想以某种方式控制的文件或数据库，也许是为了引入专门的内容来驱动我们的测试，而我们不想这样做，或者我们不能使用真实的文件或数据库。在这种情况下，我们创建 `RenamingDelegatingContext`来指定前缀。我们提供使用这个前缀的模拟文件，并介绍任何我们需要的内容来驱动我们的测试，测试中的 `Activity`你可以不加改动地使用它们吗。

保持我们的 `Activity`不变的好处是，不修改它以从不同的来源读取，这确保了所有测试都是有效的。如果我们引入仅用于测试的变更，我们将无法保证在真实条件下 `Activity`的行为相同。

为了演示这个案例，我们将创建一个极其简单的 `Activity`。

活动 `MockContextExampleActivity`显示 `TextView`内文件的内容。我们要展示的是在 `Activity`正常运行期间，与测试期间相比，它如何显示不同的内容:

```java
package com.example.aatg.mockcontextexample;
import android.app.Activity;
import android.graphics.Color;
import android.os.Bundle;
import android.widget.TextView;
import java.io.FileInputStream;
public class MockContextExampleActivity extends Activity {
public final static String FILE_NAME = "myfile.txt";
private TextView mTv;
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
mTv = (TextView) findViewById(R.id.TextView01);
final byte[] buffer = new byte[1024];
try {
final FileInputStream fis = openFileInput(FILE_NAME);
final int n = fis.read(buffer);
mTv.setText(new String(buffer, 0, n-1));
} catch (Exception e) {
mTv.setText(e.toString());
mTv.setTextColor(Color.RED);
}
}
public String getText() {
return mTv.getText().toString();
}
}

```

这就是我们的简单 `Activity`。它读取 `myfile.txt`文件的内容并将其显示在 `TextView`上。它还显示可能出现的任何错误。

我们需要这个文件的一些内容。创建文件最简单的方法可能如下所示:

```java
$ adb shell echo "This is real data" \> \ /data/data/com.example.aatg.mockcontextexample/files/myfile.txt
$ adb shell echo "This is *MOCK* data" \> \ /data/data/com.example.aatg.mockcontextexample/files/test.myfile.txt

```

我们创建了两个不同的文件，一个名为 `myfile.txt`，另一个名为 `test.myfile.txt`，内容不同。后者表示是模拟内容。

下面的代码演示了这个模拟数据在我们的活动测试中的使用:

```java
package com.example.aatg.mockcontextexample.test;
import com.example.aatg.mockcontextexample. MockContextExampleActivity;
import android.content.Intent;
import android.test.ActivityUnitTestCase;
import android.test.RenamingDelegatingContext;
public class MockContextExampleTest extends ActivityUnitTestCase<MockContextExampleActivity> {
private static final String PREFIX = "test.";
private RenamingDelegatingContext mMockContext;
public MockContextExampleTest() {
super(MockContextExampleActivity.class);
}
protected void setUp() throws Exception {
super.setUp();
mMockContext = new RenamingDelegatingContext( getInstrumentation().getTargetContext(), PREFIX);
mMockContext.makeExistingFilesAndDbsAccessible();
}
protected void tearDown() throws Exception {
super.tearDown();
}
public void testSampleTextDisplayed() {
setActivityContext(mMockContext);
startActivity(new Intent(), null, null);
final MockContextExampleActivity activity = getActivity();
assertNotNull(activity);
String text = activity.getText();
assertEquals("This is *MOCK* data", text);
}
}

```

类 `MockContextExampleTest`扩展了 `ActivityUnitTestCase`，因为我们正在寻找对 `MockContextExampleActivity`的独立测试，并且因为我们将注入一个模拟的上下文；在这种情况下，注入的上下文是作为依赖项的 `RenamingDelegatinContext`。

我们的装置包括模拟上下文 `mMockContext`，使用由. getInstrumentation()获得的目标上下文的 `RenamingDelegatingContext`。getTargetContext()。请注意，仪器运行的环境不同于测试中的 `Activity`的环境。

下面是一个基本的步骤——因为我们想让现有的文件和数据库可以被这个测试访问，我们必须调用 `makeExistingFilesAndDbsAccessible()`。

然后，我们名为 `testSampleTextDisplayed()`的测试使用 `setActivityContext()`注入模拟上下文。

### 类型

在通过调用 `startActivity()`启动被测活动之前，您必须调用 `setActivityContext()`注入模拟上下文**。**

然后 `Activity`由 `startActivity()`使用刚刚创建的 `Intent`启动。

使用 `getActivity()`获得测试中的 `Activity`，并验证其为“非空”值。

我们通过使用添加到 `Activity`中的一个 getter 来获取 `TextView`持有的文本值。

最后，将获得的文本值与 `String` *“这是 MOCK*数据”*进行核对。这里需要注意的是，用于该测试的值是测试文件内容，而不是真实的文件内容。

## 浏览器程序测试

这些测试取自安卓开源项目(AOSP)。源代码可以在 http://android.git.kernel.org/?作为 Browser.git 项目的一部分获得 p =平台/包/应用/浏览器. git 。它们旨在测试浏览器书签内容提供商 BrowserProvider 的某些方面，Browser provider 是安卓平台包含的标准浏览器的一部分。

```java
/*
* Copyright (C) 2010 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
* or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
package com.android.browser;
import android.app.SearchManager;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import java.util.ArrayList;
import java.util.Arrays;

```

第一个代码片段只包含所需的版权和导入:

```java
/**
* Unit tests for {@link BrowserProvider}.
*/
@MediumTest
public class BrowserProviderTests extends AndroidTestCase {
private ArrayList<Uri> mDeleteUris;
@Override
protected void setUp() throws Exception {
mDeleteUris = new ArrayList<Uri>();
super.setUp();
}
@Override
protected void tearDown() throws Exception {
for (Uri uri : mDeleteUris) {
deleteUri(uri);
}
super.tearDown();
}

```

第二个片段包括扩展 `AndroidTestCase`的测试用例定义。类 `BrowserProviderTests`扩展了 `AndroidTestCase`，因为需要一个 `Context`来访问提供商内容。

在 `setUp()`方法中创建的夹具创建一个 `Uris`的 `ArrayList`，用于跟踪要在 `tearDown()`方法中删除的插入的 `Uris`。也许我们可以使用模拟内容提供者来省去所有这些麻烦，保持我们的测试和系统之间的隔离。无论如何， `tearDown()`遍历这个列表并删除存储的 `Uris`。

这里不需要覆盖构造函数，因为 `AndroidTestCase`不是一个参数化的类，我们不需要在其中做任何特殊的事情:

```java
public void testHasDefaultBookmarks() {
Cursor c = getBookmarksSuggest("");
try {
assertTrue("No default bookmarks", c.getCount() > 0);
} finally {
c.close();
}
}
public void testPartialFirstTitleWord() {
assertInsertQuery("http://www.example.com/rasdfe", "nfgjra sdfywe", "nfgj");
}
public void testFullFirstTitleWord() {
assertInsertQuery("http://www.example.com/", "nfgjra dfger", "nfgjra");
}
public void testFullFirstTitleWordPartialSecond() {
assertInsertQuery("http://www.example.com/", "nfgjra dfger", "nfgjra df");
}
public void testFullTitle() {
assertInsertQuery("http://www.example.com/", "nfgjra dfger", "nfgjra dfger");
}

```

下一个测试 `testHasDefaultBookmarks()`，是对默认书签的测试。启动时，光标遍历通过调用 `getBookmarksSuggest("")`获得的默认书签，返回未过滤的书签；这就是为什么查询参数是" "。

然后， `testPartialFirstTitleWord(), testFullFirstTitleWord(), testFullFirstTitleWordPartialSecond()`、 `testFullTitle()`测试书签的插入。为了实现这一点，他们使用书签 `Url`、它的标题和查询来调用 `assertInsertQuery()`。方法 `assertInsertQuery()`将书签添加到书签提供者中，插入作为具有指定标题的参数发布的 `Url`。返回的 `Uri`验证不为空，与默认不完全相同。最后将 `Uri`插入到 `testDown():` 中要删除的 `Uri`实例列表中

```java
// Not implemented in BrowserProvider
// public void testFullSecondTitleWord() {
// assertInsertQuery("http://www.example.com/rasdfe", // "nfgjra sdfywe", "sdfywe");
// }
public void testFullTitleJapanese() {
String title = "\u30ae\u30e3\u30e9\u30ea\u30fc\ u30fcGoogle\u691c\u7d22";
assertInsertQuery("http://www.example.com/sdaga", title, title);
}
public void testPartialTitleJapanese() {
String title = "\u30ae\u30e3\u30e9\u30ea\u30fc\ u30fcGoogle\u691c\u7d22";
String query = "\u30ae\u30e3\u30e9\u30ea\u30fc";
assertInsertQuery("http://www.example.com/sdaga", title, query);
}
// Test for http://b/issue?id=2152749
public void testSoundmarkTitleJapanese() {
String title = "\u30ae\u30e3\u30e9\u30ea\u30fc\ u30fcGoogle\u691c\u7d22";
String query = "\u30ad\u30e3\u30e9\u30ea\u30fc";
assertInsertQuery("http://www.example.com/sdaga", title, query);
}

```

这些测试类似于前面介绍的测试，但在这种情况下，它们使用日语标题和查询。建议在不同的条件下测试应用的组件，例如在使用具有不同字符集的其他语言的情况下。

我们进行了几项测试，旨在验证除英语之外的其他语言和地区对该书签提供程序的使用情况。这些特殊案例涵盖了书签标题中日语的使用。测试 `testFullTitleJapanese(), testPartialTitleJapanese()`和 `testSoundmarkTitleJapanese()`是使用 Unicode 字符之前引入的测试的日语版本:

```java
//
// Utilities
//
private void assertInsertQuery(String url, String title, String query) {
addBookmark(url, title);
assertQueryReturns(url, title, query);
}
private void assertQueryReturns(String url, String title, String query) {
Cursor c = getBookmarksSuggest(query);
try {
assertTrue(title + " not matched by " + query, c.getCount() > 0);
assertTrue("More than one result for " + query, c.getCount() == 1);
while (c.moveToNext()) {
String text1 = getCol(c, SearchManager.SUGGEST_COLUMN_TEXT_1);
assertNotNull(text1);
assertEquals("Bad title", title, text1);
String text2 = getCol(c, SearchManager.SUGGEST_COLUMN_TEXT_2);
assertNotNull(text2);
String data = getCol(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA);
assertNotNull(data);
assertEquals("Bad URL", url, data);
}
} finally {
c.close();
}
}
private Cursor getBookmarksSuggest(String query) {
Uri suggestUri = Uri.parse( "content://browser/bookmarks/search_suggest_query");
String[] selectionArgs = { query };
Cursor c = getContext().getContentResolver().query( suggestUri, null, "url LIKE ?",selectionArgs, null);
assertNotNull(c);
return c;
}
private void addBookmark(String url, String title) {
Uri uri = insertBookmark(url, title);
assertNotNull(uri);
assertFalse( android.provider.Browser.BOOKMARKS_URI.equals(uri));
mDeleteUris.add(uri);
}
private Uri insertBookmark(String url, String title) {
ContentValues values = new ContentValues();
values.put("title", title);
values.put("url", url);
values.put("visits", 0);
values.put("date", 0);
values.put("created", 0);
values.put("bookmark", 1);
return getContext().getContentResolver().insert( android.provider.Browser.BOOKMARKS_URI, values);
}
private void deleteUri(Uri uri) {
int count = getContext().getContentResolver(). delete(uri, null, null);
assertEquals("Failed to delete " + uri, 1, count);
}
private static String getCol(Cursor c, String name) {
int col = c.getColumnIndex(name);
String msg = "Column " + name + " not found, columns: " + Arrays.toString(c.getColumnNames());
assertTrue(msg, col >= 0);
return c.getString(col);
}
}

```

以下是几种实用方法。这些是测试中使用的实用程序。之前我们简单看了 `assertInsertQuery()`，现在我们也来看看其他的方法。

方法 `assertInsertQuery()`调用 `addBookmark()`后的 `assertQueryReturns(url, title, query)`，验证 `getBookmarksSuggest(query)`返回的 `Cursor`包含预期数据。这种期望可以概括为:

*   查询返回的行数大于 0
*   查询返回的行数等于 1
*   返回行中的标题不为空
*   查询返回的标题与方法参数完全相同
*   建议的第二行不为空
*   查询返回的网址不为空
*   此网址与作为方法参数发出的网址完全匹配

这是一个简化的活动图，将帮助我们理解这些方法之间的关系:

![The BrowserProvider tests](img/3500OS_07_01.jpg)

这些测试遵循前面描述的基本结构，并在 UML 活动图中描述。首先调用 `assertInsertQuery()`，依次调用 `addBookmark()`和 `assertQueryReturns()`。然后，调用 `getBookmarksSuggest()`，最后断言以验证我们正在测试的条件。这里最突出的是这些实用方法中断言的使用，这有助于我们沿途测试条件。

这个策略为我们的测试提供了一个有趣的模式。我们需要创建一些实用方法来完成我们的测试，这些方法也可以自己验证几个条件，提高我们的测试质量。

在我们的类中创建 assert 方法允许我们引入特定于领域的测试语言，当测试系统的其他部分时可以重用该语言。

# 测试异常

我们之前提到过这个。在[第 1 章](01.html "Chapter 1. Getting Started with Testing")、*开始*和*测试*中，我们声明您应该测试异常和错误值，而不仅仅是测试阳性病例。

我们之前也介绍过这个测试，但现在我们正在深入研究它:

```java
public final void testExceptionForLessThanAbsoluteZeroF() {
try {
TemperatureConverter.fahrenheitToCelsius( TemperatureConverter.ABSOLUTE_ZERO_F-1);
fail();
}
catch (InvalidTemperatureException ex) {
// do nothing
}
}
public final void testExceptionForLessThanAbsoluteZeroC() {
try {
TemperatureConverter.celsiusToFahrenheit( TemperatureConverter.ABSOLUTE_ZERO_C-1);
fail();
}
catch (InvalidTemperatureException ex) {
// do nothing
}
}

```

每当我们有一个应该生成异常的方法时，我们应该测试这个条件。最好的方法是调用 try-catch 块中的方法，捕获预期的 `Exception`，否则会失败。在这种精确的情况下，我们测试 `InvalidTemperature:`

```java
public void testLifeCycleCreate() {
Forwarding activity = startActivity(mStartIntent, null, null);
// At this point, onCreate() has been called,
// but nothing else
// Complete the startup of the activity
getInstrumentation().callActivityOnStart(activity);
getInstrumentation().callActivityOnResume(activity);
// At this point you could test for various
// configuration aspects, or you could
// use a Mock Context to confirm that your activity has made
// certain calls to the system and set itself up properly.
getInstrumentation().callActivityOnPause(activity);
// At this point you could confirm that the activity has
// paused properly, as if it is
// no longer the topmost activity on screen.
getInstrumentation().callActivityOnStop(activity);
// At this point, you could confirm that the activity
// has shut itself down appropriately,
// or you could use a Mock Context to confirm that your
// activity has released any system
// resources it should no longer be holding.
// ActivityUnitTestCase.tearDown(), which is always
// automatically called, will take care
// of calling onDestroy().
}

```

# 测试本地和远程服务

这个测试也来自一个 ApiDemos 示例应用([http://developer . Android . com/resources/samples/API demos/index . html](http://developer.android.com/resources/samples/ApiDemos/index.html))。

这个想法是扩展 `ServiceTestCase<Service>`类来测试受控环境中的服务:

```java
/*
* Copyright (C) 2008 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
* implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
package com.example.android.apis.app;
import android.app.Notification;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.test.MoreAsserts;
import android.test.ServiceTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.test.suitebuilder.annotation.SmallTest;

```

第一个代码片段只包含所需的版权和导入:

```java
/**
* This is a simple framework for a test of a Service.
* See {@link android.test.ServiceTestCase
* ServiceTestCase} for more information on how to write and
* extend service tests.
*
* To run this test, you can type:
* adb shell am instrument -w \
* -e class com.example.android.apis.app.LocalServiceTest \
* com.example.android.apis.tests/android.test.
* InstrumentationTestRunner
*/
public class LocalServiceTest extends ServiceTestCase<LocalService> {
public LocalServiceTest() {
super(LocalService.class);
}

```

然后，我们像以前一样使用无参数构造函数，使用服务类 `LocalService:`调用超级构造函数

```java
@Override
protected void setUp() throws Exception {
super.setUp();
}

```

现在我们使用 `setUp()`和 `tearDown()`中调用超级方法的模式。

我们没有在这个测试中设置任何特定的夹具，所以我们只是调用超级方法:

```java
/**
* The name 'test preconditions' is a convention to signal that
* if this
* test doesn't pass, the test case was not set up properly and
* it might
* explain any and all failures in other tests. This is not
* guaranteed to run before other tests, as junit uses
* reflection to find the tests.
*/
@SmallTest
public void testPreconditions() {
}

```

我们现在有一个空的 `testPreconditions()`。我们不需要在这里测试任何先决条件:

```java
/**
* Test basic startup/shutdown of Service
*/
@SmallTest
public void testStartable() {
Intent startIntent = new Intent();
startIntent.setClass(getContext(), LocalService.class);
startService(startIntent);
}
/**
* Test binding to service
*/
@MediumTest
public void testBindable() {
Intent startIntent = new Intent();
startIntent.setClass(getContext(), LocalService.class);
IBinder service = bindService(startIntent);
}
}

```

与其他类似情况一样，构造函数调用父构造函数，将此服务类作为参数传递。

接下来是 `testStartable()`测试。使用 `SmallTest`注释对该测试进行分类。接下来，我们使用我们在这里创建的意图启动服务，将它的类设置为被测试服务的类。我们还将检测的上下文用于此意图。这个类允许一些依赖注入，因为每个服务都依赖于它运行的上下文和与之相关的应用。这个框架允许您为这些依赖注入修改的、模拟的或隔离的替换，从而执行真正的单元测试。

当我们简单地按原样运行测试时， `Service`将被注入一个全功能的 `Context`和一个通用的 `MockApplication`对象。

然后我们使用 `startService(startIntent)`方法启动服务，就像它是由 `Context.startService()`启动的一样，提供它提供的参数。如果您使用此方法启动服务，它将被 `tearDown()`自动停止。

另一个测试 `testBindable(),`被归类为 `MediumTest`，将测试服务是否可以绑定。这个测试使用 `bindService(startIntent)`，它启动被测服务，就像它由 `Context.bindService()`启动一样，提供它提供的参数。它将通信信道返回给服务。如果客户端无法绑定到服务，它可能会返回 null。最有可能的是，这个测试应该使用类似 `assertNotNull(service)`的断言来检查服务中的空返回值，以验证服务是否被正确绑定，但事实并非如此。在为类似的情况编写代码时，一定要包括这个测试。

返回的 `IBinder`通常是使用 AIDL 描述的复杂界面。为了使用这个接口进行测试，您的服务必须实现一个 `getService()`方法，如 `samples.ApiDemos.app.LocalService`所示，它实现了那个方法:

```java
/**
* Class for clients to access. Because we know this service
* always runs in the same process as its clients,
* we don't need to deal with IPC.
*/
public class LocalBinder extends Binder {
LocalService getService() {
return LocalService.this;
}
}

```

# 模拟物体的广泛使用

在前面的章节中，我们描述并使用了安卓软件开发工具包中的模拟类。虽然这些类可以覆盖大量的案例，但这还不是全部，您可能需要其他模拟对象来提供您的测试案例。

几个库提供了基础设施来满足我们的嘲笑需求，但是我们现在专注于 EasyMock，这可能是安卓系统中使用最广泛的。

### 注

这不是一个 EasyMock 教程。我们将只是分析它在安卓系统中的使用，所以如果你不熟悉它，我建议你看一下它网站上的文档:[http://easymock.org/](http://easymock.org/)。

EasyMock 是一个在 Apache 2.0 许可下可用的开源软件项目，主要为接口提供 Mock 对象。由于记录期望的方式及其动态生成的模拟对象支持重构，因此非常适合测试驱动开发，并且测试代码在重命名方法或更改其签名时不会中断。

根据其文档，EasyMock 最相关的优势如下:

*   不需要模拟对象的手写类。
*   支持重构安全的模拟对象。当重命名方法或重新排序方法参数时，测试代码不会在运行时中断。
*   支持返回值和异常。
*   支持检查一个或多个模拟对象的方法调用顺序。

为了演示它的用法并建立一种可以在以后为其他测试复制的风格，我们正在完成并扩展之前为我们的应用生成的测试用例。

在我们之前的 `TemperatureConverter`示例中，我们决定扩展 `EditText`来创建 `EditNumber`，一个只接受带符号的十进制数字的文本字段。 `EditNumber`使用 `InputFilter`来提供此功能。在下面的测试中，我们将使用这个过滤器来验证是否实现了正确的行为。

为了创建测试，我们将使用从 `EditText`继承的属性 `EditNumber`，该属性可以添加一个侦听器，实际上是一个 `TextWatcher`，以提供每当 `EditText`的文本改变时调用的方法。这个 `TextWatcher`是测试的合作者，我们本可以将它实现为一个单独的类，但是这很繁琐，可能会引入更多的错误，所以采用的方法是使用 EasyMock 来避免编写它的需要。

这正是我们引入模拟 `TextWatcher`来检查文本更改时的方法调用的方式。

### 注

截至本文撰写之时，安卓支持的 EasyMock 的最新版本是 EasyMock 2.5.2。你可能想尝试一个不同的，但很可能会遇到问题。

我们应该做的第一件事是将 `easymock-2.5.2.jar`添加到测试项目属性中。

下面的截图显示了 easymock JAR 文件是如何被添加到测试项目的 **Java 构建路径**中的:

![Extensive use of mock objects](img/3500_07_02.jpg)

为了在我们的测试中使用 EasyMock，我们只需要从 `org.easymockEasyMock`静态地导入它的方法，这是 EasyMock 2 唯一的非内部的、非弃用的方法:

```java
import static org.easymock.EasyMock.*;

```

最好使用特定的导入，而不是使用通配符，但是在 Eclipse 中创建静态导入语句并不容易。但是，如果我们组织导入(使用 **Source |组织导入**或快捷方式 *Shift+Ctrl+O)* ，Eclipse 将创建具体的语句。

## 导入库

我们在项目的 Java 构建路径中添加了一个 EasyMock 库。这通常不是问题，但有时重建项目会导致我们出现以下错误，从而避免最终的 APK。问题出现在最终 APK 无法创建时，因为存档时出现问题:

**【2010-10-28 01:12:29-温度转换器】生成最终档案时出错:重复条目:许可证**

这取决于项目包含多少库以及它们是什么。

大多数可用的开源库都有类似于 GNU 提议的内容，包括像 LICENSE、NOTICE、CHANGES、COPYRIGHT、INSTALL 等文件。一旦我们试图在同一个项目中包含多个项目以最终建立一个单一的 APK，我们就会发现这个问题。

解决这个问题的方法是重新打包库内容，重命名这些文件；例如， `LICENSE`可以改名为 `LICENSE.<library>`。建议在重新打包的库中添加后缀**安卓**，以跟踪这些变化。

这是重命名这些文件可能需要的步骤示例:

```java
$ mkdir mylib-1.0
$ (cd mylib-1.0; jar xf /path/to/mylib-1.0.jar)
$ mv mylib-1.0/META-INF/LICENSE mylib-1.0/META-INF/LICENSE.mylib
$ mv mylib-1.0/META-INF/NOTICE mylib-1.0/META-INF/NOTICE.mylib
$ (cd mylib-1.0; jar cf /path/to/mylib-1.0-android.jar .)

```

其思想是将通用文件名移动到以库名为后缀的名称，以提供一些唯一性。

## 测试文本已更改测试

该测试将练习 `EditNumber`行为，检查 `TextWatcher`模拟中的方法调用，并验证结果。

我们使用 `AndroidTestCase`是因为我们有兴趣单独测试 `EditNumber`其他组件或 `Activities`。

该测试定义了两个 `String`数组:sai 和 sar。 `sai`代表 `String`阵输入， `sar`代表 `String`阵结果。您可能已经猜到， `sai`包含输入， `sar`包含应用过滤器后输入中相应元素的预期结果。

在现实生活中，您应该为测试中使用的变量选择更具描述性的名称，就像您应该为代码选择的那样，但是这里我们受到空间的限制，因此我们选择了非常短的名称。名字 `saInput`和 `saResult`会是不错的选择:

```java
/**
* Test method for {@link com.example.aatg.tc.EditNumber}.
* Several input strings are set and compared against the
* expected results after filters are applied.
* This test use {@link EasyMock}
*/
public final void testTextChanged() {
final String[] sai = new String[] {
null, "", "1", "123", "-123", "0", "1.2", "-1.2", "1-2-3", "+1", "1.2.3" };
final String[] sar = new String[] {
"", "", "1", "123", "-123", "0", "1.2", "-1.2", "123", "1", "12.3" };
// mock
final TextWatcher watcher = createMock(TextWatcher.class);
mEditNumber.addTextChangedListener(watcher);
for (int i=1; i < sai.length; i++) {
// record
watcher.beforeTextChanged(stringCmp(sar[i-1]), eq(0),
eq(sar[i-1].length()), eq(sar[i].length()));
watcher.onTextChanged(stringCmp(sar[i]), eq(0),
eq(sar[i-1].length()), eq(sar[i].length()));
watcher.afterTextChanged(stringCmp(
Editable.Factory.getInstance().newEditable(sar[i])));
// replay
replay(watcher);
// exercise
mEditNumber.setText(sai[i]);
// test
final String actual = mEditNumber.getText().toString();
assertEquals(sai[i] + " => " + sar[i] + " => " + actual, sar[i], actual);
// verify
verify(watcher);
// reset
reset(watcher);
}
}

```

我们开始创造 `sai`和 `sar`。正如我们之前解释的，它们是两个包含预期输入和结果的 `String`数组。

然后我们使用 `createMock(TextWatcher.class)`创建一个模拟 `TextWatcher`，并将其分配给 `mEditNumber`，即在测试夹具中创建的 `EditNumber`。

我们创建一个循环来迭代 `sai`数组的每个元素。

接下来，我们采取使用模拟对象通常需要的七个常见步骤:

1.  使用 `createMock(), createNiceMock(),`或 `createStrictMock()`创建模拟。
2.  记录预期行为；将记录所有调用的方法。
3.  重放，当对象的行为真的像模拟对象时，将对象的状态从记录更改为播放。
4.  通常通过调用被测类的方法来练习这些方法。
5.  使用断言测试已执行方法的结果。对于较简单的情况，此步骤是可选的。
6.  验证是否实际遵循了指定的行为。如果不是这种情况，我们将收到一个例外。
7.  重置可用于重用模拟对象，清除其状态。

在记录步骤中，我们声明了我们期望在模拟对象上调用的所有方法及其参数。我们使用比较器作为参数。

我们将使用一个特殊的 `Comparator, stringCmp()`，因为我们有兴趣比较安卓使用的不同类别的 `String`内容，比如 `Editable, CharSequence, String`等等。

另一个比较器 `eq()`需要一个等于给定值的 `int`。后者是 EasyMock 为所有原语类型和 `Object`提供的，但是我们需要实现 `stringCmp()`，因为它支持一些安卓特有的用法。

EasyMock 有一个预定义的匹配器，可以帮助我们创建比较器:

```java
public static <T> T cmp(T value, Comparator<? super T> comparator, LogicalOperator operator)

```

`cmp`比较器方法需要一个参数，该参数将使用运算符使用提供的比较器进行比较。将要进行的比较是 `comparator.compare(actual, value) operator 0`，其中运算符可以是 EasyMock 的 `LogicalOperator enum`中的逻辑运算符值之一，表示<、< =、>、> =、或==。

正如你可能已经意识到的，它在测试中的频繁使用可能非常复杂，并且可能导致错误，所以为了简化这个过程，我们将使用一个我们称之为 `StringComparator:`的帮助类

```java
public static final class StringComparator<T> implements Comparator<T> {
/* (non-Javadoc)
* @see java.util.Comparator#compare( java.lang.Object, java.lang.Object)
*
* Return the {@link String} comparison of the arguments.
*/
@Override
public int compare(T object1, T object2) {
return object1.toString().compareTo(object2.toString());
}
}

```

这个类实现了 `Comparator<T>`接口，这个接口有一个抽象的方法叫做 `compare`。我们通过在对象转换为字符串后返回作为参数传递的对象的比较结果来实现这个方法。请记住，应用于字符串的 `compareTo(String string)`使用字符的 Unicode 值将指定为参数的字符串与字符串进行比较。它的返回值是:

*   如果字符串包含相同顺序的相同字符，则为 0(零)
*   如果此字符串中第一个不相等的字符的 Unicode 值小于指定字符串中相同位置的字符的 Unicode 值，或者如果此字符串是指定字符串的前缀，则为负整数
*   如果此字符串中第一个不相等的字符的 Unicode 值大于指定字符串中相同位置的字符的 Unicode 值，或者如果指定字符串是此字符串的前缀，则为正整数

我们可以直接使用这个比较器来调用 `EasyMock.cmp()`，但是为了进一步简化，我们将创建一个通用的静态方法 `stringCmp:`

```java
/**
* Return {@link EasyMock.cmp} using a {@link StringComparator} and
* {@link LogicalOperator.EQUAL}
*
* @param <T> The original class of the arguments
* @param o The argument to the comparison
* @return {@link EasyMock.cmp}
*/
public static <T> T stringCmp(T o) {
return cmp(o, new StringComparator<T>(), LogicalOperator.EQUAL);
}

```

该方法将使用特定类型的正确比较器并使用 `EQUAL`作为运算符来调用 `EasyMock.cmp()`。

这就是为什么在我们的测试中，我们可以简单地使用:

```java
watcher.beforeTextChanged(stringCmp(sar[i-1]), …

```

## 介绍哈姆克雷斯特

虽然前面的方法是有效的，但更通用的方法是引入 **hamcrest** ，这是一个匹配器对象库(也称为约束或谓词)，允许以声明方式定义*匹配*规则，以便在其他框架中使用。Hamcrest 还为 EasyMock 2 提供适配器。

我们将重温之前的例子，为我们的匹配者介绍 hamcrest。

为了能够使用 hamcrest，我们需要将其包含到 **Java 构建路径**中。

### 注

在这个例子中，我们使用了最新版本的 hamcrest-1.2。为了避免几个 `LICENSE.txt`文件冲突，我们不使用 `hamcrest-1.2-all.jar`而是使用前面描述的单个组件和方法。

从[http://code.google.com/p/hamcrest.](http://code.google.com/p/hamcrest.)T2 下载哈姆克雷斯特库

您需要包含以下 JAR 文件:

*   `hamcrest-core`
*   `hamcrest-library`
*   `hamcrest-integration`

以下屏幕截图显示了添加 hamcrest 库后的新项目属性:

![Introducing Hamcrest](img/3500_07_03.jpg)

### 哈姆克雷斯特火柴人

哈姆克雷斯特有一个有用的媒人库。以下是一些最重要的问题:

*   **核心**T2】
    *   **任何东西:**永远匹配；如果你不在乎被测对象是什么的话，这很有用
    *   **描述为:**装饰器添加自定义故障描述
    *   **为:**装饰器，提高可读性
*   **逻辑**
    *   **allOf:** 匹配如果所有匹配者匹配，则短路(像 Java & & )
    *   **任意一个:**匹配如果有匹配者匹配，短路(像 Java ||)
    *   **不是:**匹配如果包装的火柴不匹配，反之亦然
*   **物体**T2】
    *   **相等:**使用 `Object.equals` 测试对象相等
    *   **hasostring:**Test `Object.toString`
    *   **实例，可配合类型:**测试类型
    *   **注意 null 值，null 值:**测试 null
    *   **相同实例:**测试对象身份
*   **豆子**T2】
    *   **hasProperty:** 测试 JavaBeans 属性
*   **收藏**T2】
    *   **阵列:**对照匹配器阵列测试阵列的元素
    *   **测试包含条目、键或值的地图**
    *   **hasItem，hasItems:** 测试包含元素的集合
    *   **hasiteminaray:**测试包含元素的数组
*   **号**T2】
    *   **关闭:**测试浮点值接近给定值
    *   **大阪、大阪府、莱森、莱森奥奎托:**考试订购，列支敦士登，列支敦士登，列支敦士登，列支敦士登，列支敦士登，列支敦士登，列支敦士登，列支敦士登，列支敦士登。【列支敦士登，列支敦士登】
*   **正文**T2】
    *   **相等忽略大小写:**测试字符串相等忽略大小写
    *   **等于忽略空白:**测试字符串是否相等，忽略空白运行的差异
    *   **包含字符串，结束开关，开始开关:**测试字符串匹配

### 哈斯特林火柴人

我们的下一步是创建匹配器来取代以前使用的 `stringCmp()`比较器。 `EasyMock2Adapter`是 hamcrest 提供的适配器类:

```java
import org.hamcrest.integration.EasyMock2Adapter;
import org.hamcrest.object.HasToString;
/**
* Create an {@link EasyMock2Adapter} using a
* {@link HasToString.hasToString}
*
* @param <T> The original class of the arguments
* @param o The argument to the comparison
* @return o
*/
public static <T> T hasToString(T o) {
EasyMock2Adapter.adapt(
HasToString.hasToString(o.toString()));
return o;
}

```

实现这个匹配器后，仍然需要以下步骤。我们需要调整 `testTextChanged()`方法来包含这个新创建的匹配器，而不是 `stringCmp():`

```java
// record
watcher.beforeTextChanged(hasToString(sar[i-1]), eq(0),
eq(sar[i-1].length()), eq(sar[i].length()));
watcher.onTextChanged(hasToString(sar[i]), eq(0),
eq(sar[i-1].length()), eq(sar[i].length()));
watcher.afterTextChanged(hasToString(
Editable.Factory.getInstance().newEditable(sar[i])));

```

# 单独测试视图

我们在这里分析的测试也属于 ApiDemos 项目。它演示了当行为本身不能被隔离时，如何测试符合 `Layout`的 `Views`的一些属性。测试焦点就是其中一种情况。

为了避免创建完整的 `Activity`，本测试将扩展 `AndroidTestCase:`T2】

```java
/*
* Copyright (C) 2008 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*/
package com.example.android.apis.view;
import com.example.android.apis.R;
import android.content.Context;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.SmallTest;
import android.view.FocusFinder;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;

```

与前面的案例一样，我们从所需的版权和导入开始:

```java
/**
* This exercises the same logic as {@link Focus2ActivityTest} but in
* a lighter weight manner; it doesn't need to launch the activity,
* and it can test the focus behavior by calling {@link FocusFinder}
* methods directly.
*
* {@link Focus2ActivityTest} is still useful to verify that, at an
* end to end level, key events actually translate to focus
* transitioning in the way we expect.
* A good complementary way to use both types of tests might be to
* have more exhaustive coverage in the lighter weight test case,
* and a few end to end scenarios in the functional {@link
* android.test.ActivityInstrumentationTestCase}.
* This would provide reasonable assurance that the end to end
* system is working, while avoiding the overhead of
* having every corner case exercised in the slower,
* heavier weight way.
*
* Even as a lighter weight test, this test still needs access to a
* {@link Context} to inflate the file, which is why it extends
* {@link AndroidTestCase}.
*
* If you ever need a context to do your work in tests, you can
* extend {@link AndroidTestCase}, and when run via an {@link
* android.test.InstrumentationTestRunner},
* the context will be injected for you.
*
* See {@link com.example.android.apis.app.ForwardingTest} for
* an example of an Activity unit test.
*
* See {@link com.example.android.apis.AllTests} for
* documentation on running
* all tests and individual tests in this application.
*/
public class Focus2AndroidTest extends AndroidTestCase {

```

正如我们之前提到的，该测试扩展了 `AndroidTestCase`以在可能的情况下提供 `ActivityInstrumentationTestCase<Activity>`的轻量级替代。

您可能考虑过只使用 `TestCase`，但不幸的是这是不可能的，因为我们需要一个 `Context`来通过 `LayoutInflater`膨胀 XML 布局， `AndroidTestCase`将为我们提供这个组件:

```java
private FocusFinder mFocusFinder;
private ViewGroup mRoot;
private Button mLeftButton;
private Button mCenterButton;
private Button mRightButton;
@Override
protected void setUp() throws Exception {
super.setUp();
mFocusFinder = FocusFinder.getInstance();
// inflate the layout
final Context context = getContext();
final LayoutInflater inflater = LayoutInflater.from(context);
mRoot = (ViewGroup) inflater.inflate(R.layout.focus_2, null);
// manually measure it, and lay it out
mRoot.measure(500, 500);
mRoot.layout(0, 0, 500, 500);
mLeftButton = (Button) mRoot.findViewById(R.id.leftButton);
mCenterButton = (Button) mRoot.findViewById(R.id.centerButton);
mRightButton = (Button) mRoot.findViewById( R.id.rightButton);
}

```

夹具设置如下:

1.  `FocusFinder`是一个提供算法的类，用来寻找下一个可聚焦的 `View`。它实现了单例模式，这就是为什么我们使用 `FocusFinder.getInstance()`来获取对它的引用。这个类有几个方法来帮助我们找到我们提到的可聚焦和可触摸的项目，给定各种条件，比如在给定的方向上最近或者从特定的矩形中搜索。
2.  然后我们得到 `LayoutInflater`并膨胀测试中的布局。
3.  由于我们的测试与系统的其他部分隔离，我们需要考虑的一件事是，我们必须手动测量和布局组件。
4.  然后，我们使用*查找视图*模式，并将找到的视图分配给字段:

    ```java
    /**
    * The name 'test preconditions' is a convention to signal
    * that if this test doesn't pass, the test case was not
    * set up properly and it might explain any and all failures
    * in other tests. This is not guaranteed to run before
    * other tests, as junit uses reflection to find the tests.
    */
    @SmallTest
    public void testPreconditions() {
    assertNotNull(mLeftButton);
    assertTrue("center button should be right of left button",
    mLeftButton.getRight() < mCenterButton.getLeft());
    assertTrue("right button should be right of center button",
    mCenterButton.getRight() < mRightButton.getLeft());
    }

    ```

一旦配置了夹具，我们就在测试中描述前提条件，正如我们前面提到的，测试名为 `testPreconditions()`。但是，因为测试是使用反射找到的，所以不能保证它会以特定的顺序运行，因为所有的测试方法都是通过评估它们的名称是否以 test 开头来查找的。

这些前提条件包括验证组件在屏幕上的相对位置。在这种情况下，使用它们相对于父对象的边。

在前一章中，我们列举了我们库中所有可用的断言，您可能还记得，为了测试 `Views`位置，我们在 `ViewAsserts`类中有一套完整的断言。但是，这取决于布局的定义方式:

```java
@SmallTest
public void testGoingRightFromLeftButtonJumpsOverCenterToRight() {
assertEquals("right should be next focus from left", mRightButton, mFocusFinder.findNextFocus( mRoot, mLeftButton, View.FOCUS_RIGHT));
}
@SmallTest
public void testGoingLeftFromRightButtonGoesToCenter() {
assertEquals("center should be next focus from right", mCenterButton, mFocusFinder.findNextFocus( mRoot, mRightButton, View.FOCUS_LEFT));
}
}

```

方法 `testGoingRightFromLeftButtonJumpsOverCenterToRight()`，顾名思义，测试当焦点从右向左按钮移动时，右按钮获得的焦点。为了实现这种搜索，采用了在 `setUp()`方法期间获得的 `FocusFinder`的实例。这个类有一个 `findNextFocus()`方法来获得给定方向的视图接收焦点。获得的价值与我们的期望相比较。

类似地，测试 `testGoingLeftFromRightButtonGoesToCenter()`测试焦点向另一个方向移动。

# 测试解析器

在许多情况下，您的安卓应用依赖于外部 XML、JSON 消息或从网络服务获得的文档。这些文档用于本地应用和服务器之间的数据交换。在许多用例中，XML 或 JSON 文档是从服务器获得的，或者是由本地应用生成并发送到服务器的。理想情况下，这些活动调用的方法必须被隔离测试，以进行真正的单元测试，为了实现这一点，我们需要在 APK 的某个地方包含一些模拟文件来运行测试。

但问题是我们能把这些文件放在哪里？

我们来看看。

## 安卓资产

首先，可以在 Android SDK 文档中找到对资产定义的简要回顾:

> “资源”和“资产”之间的区别表面上看不太大，但总的来说，您使用资源存储外部内容的频率要比使用资产的频率高得多。真正的区别是，放置在资源目录中的任何东西都可以从你的应用中很容易地从由安卓编译的 R 类中访问。然而，放在资产目录中的任何东西都将保持其原始文件格式，为了读取它，您必须使用资产管理器以字节流的形式读取文件。因此，将文件和数据保存在资源中(res/)使它们易于访问。

显然，资产是我们需要用来存储文件的东西，这些文件将被解析以测试解析器。

因此，我们的 XML 或 JSON 文件应该放在资产文件夹中，以防止编译时的操作，并能够在应用或测试运行时访问它们的原始内容。

但是要小心；我们需要将它们放在我们的**测试项目**的资产文件夹中，因为它们不是应用的一部分，我们不希望它们与应用打包在一起。

## 解析器活动

这是一个极其简单的演示案例的活动。我们的活动从服务器获取一个 XML 或 JSON 文档，然后解析它。假设我们有一个 `parseXml`方法:

```java
package com.example.aatg.parserexample;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserFactory;
import android.app.Activity;
import android.os.Bundle;
import java.io.InputStream;
import java.io.InputStreamReader;
public class ParserExampleActivity extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
}
public String parseXml(InputStream xml) {
try {
XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
factory.setNamespaceAware(true);
XmlPullParser parser = factory.newPullParser();
parser.setInput(new InputStreamReader(xml));
int eventType = parser.getEventType();
StringBuilder sb = new StringBuilder();
while (eventType != XmlPullParser.END_DOCUMENT) {
if(eventType == XmlPullParser.TEXT) {
sb.append(parser.getText());
}
eventType = parser.next();
}
return sb.toString();
}
catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return null;
}
}

```

这是一个过于简单的活动示例，其中包含一个解析器方法来说明资产的使用。您的实际应用可能看起来非常不同，您的解析器可以实现为一个外部类，该类可以单独测试并在稍后阶段集成。

## 解析器测试

该测试为 `ParserExampleActivity`类实现了一个 `ActivityInstrumentationTestCase2`

```java
package com.example.aatg.parserexample.test;
import com.example.aatg.parserexample.ParserExampleActivity;
import android.test.ActivityInstrumentationTestCase2;
import java.io.IOException;
import java.io.InputStream;
public class ParserExampleActivityTest extends ActivityInstrumentationTestCase2<ParserExampleActivity> {
public ParserExampleActivityTest() {
super(ParserExampleActivity.class);
}
protected void setUp() throws Exception {
super.setUp();
}
protected void tearDown() throws Exception {
super.tearDown();
}
public final void testParseXml() {
ParserExampleActivity activity = getActivity();
String result = null;
try {
InputStream myxml = getInstrumentation().getContext(). getAssets().open("my_document.xml");
result = activity.parseXml(myxml);
} catch (IOException e) {
fail(e.getLocalizedMessage());
}
assertNotNull(result);
}
}

```

几乎所有的方法都是默认方法的简单实现，我们唯一感兴趣的方法是 `testParseXml().`首先，通过调用 `getActivity()`获得活动。然后获得一个 `InputStream`，由 `getInstrumentation().getContext().getAssets()`从资产中打开文件 `my_document.xml`。请注意 `Context`以及由此获得的资产来自测试包，而不是来自测试中的 `Activity`。

接下来，使用最近获得的 `InputStream`调用活动 `parseXml()`方法。如果有一个 `Exception, fail()`被调用，如果一切顺利，我们测试结果不为空。

然后，我们应该在名为 `my_document.xml`的资产中提供我们想要用于测试的 XML。

内容可以是:

```java
<?xml version="1.0" encoding="UTF-8"?>
<!-- place this file in assets/my_document.xml -->
<my>This is my document</my>

```

# 测试内存泄漏

有时，内存消耗是衡量测试目标良好行为的一个重要因素，无论它是活动、服务、内容提供者还是其他组件。

为了测试这种情况，我们可以使用一个实用程序测试，您可以主要在运行测试循环后从其他测试中调用该测试:

```java
public final void assertNotInLowMemoryCondition() {
//Verification: check if it is in low memory
ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
((ActivityManager)getActivity().getSystemService( Context.ACTIVITY_SERVICE)).getMemoryInfo(mi);
assertFalse("Low memory condition", mi.lowMemory);
}

```

这个断言可以从其他测试中调用。一开始它使用 `getMemoryInfo()`从 `ActivityManager`获取 `MemoryInfo`，之后使用 `getSystemService()`获取实例。如果系统认为自己当前内存不足，字段 `lowMemory`将设置为真。

在某些情况下，我们想更深入地了解资源使用情况，我们可以从流程表中获得更详细的信息。

我们可以创建另一个助手方法来获取过程信息，并在测试中使用它:

```java
public final String captureProcessInfo() {
String cmd = "ps";
String memoryUsage = null;
int ch; // the character read
try {
Process p = Runtime.getRuntime().exec(cmd);
InputStream in = p.getInputStream();
StringBuffer sb = new StringBuffer(512);
while ((ch = in.read()) != -1) {
sb.append((char) ch);
}
memoryUsage = sb.toString();
} catch (IOException e) {
fail(e.getLocalizedMessage());
}
return memoryUsage;
}

```

为了获得该信息，使用 `Runtime.exec()`执行一个命令(在这种情况下，使用 `ps`，但您可以根据需要对其进行调整)。这个命令的输出被连接在一个稍后返回的 `String`中。我们可以使用返回值将其打印到我们测试中的日志中，或者我们可以进一步处理内容以获得摘要信息。

这是一个记录输出的例子:

```java
Log.d(TAG, captureProcessInfo());

```

当运行该测试时，我们获得关于正在运行的进程的信息:

【T10】11-12 21:10:29.182:调试/活动测试(1811):用户 PID PPID VSIZE RSS WCHAN PC 名称

**11-12 21:10:29.182:DEBUG/activity test(1811):root 1 0 312 220 c 009 b 74c 0000 ca4c S/init**

【T10】11-12 21:10:29.182:除错/活动测试(1811):根 2 0 0 c0c 004 e 72c 00000000s kthread

【T10】11-12 21:10:29.182:除错/活动测试(1811):根 3 2 0 c0c 003 FDC 8 00000000s ksmicrosoftirqd/0

**11-12 21:10:29.182:DEBUG/activity test(1811):root 4 2 0 0 c 004 B2C 4 0000000S 事件/0**

**11-12 21:10:29.182:DEBUG/activity test(1811):root 5 2 0 0 c 004 B2C 4 0000000S khelper**

**11-12 21:10:29.182:DEBUG/activity test(1811):root 6 2 0 0 c 004 B2C 4 0000000S 挂起**

**11-12 21:10:29.182:DEBUG/activity test(1811):root 7 2 0 0 c 004 B2C 4 0000000S kblock d/0**

【T10】11-12 21:10:29.182:除错/活动测试(1811):根 8 2 0 c 004 B2 c 4 00000000s cqueue

**11-12 21:10:29.182:DEBUG/activity test(1811):root 9 2 0 0 c 018179 c 0000000S ksperiod**

**[……]**

为了简洁起见，输出被删除了，但是您将获得系统上运行的进程的完整列表。

获得的信息简要说明如下:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

圆柱

 | 

描述

 |
| --- | --- |
| 用户 | 这是文本用户标识。 |
| PID | 流程的流程标识号。 |
| PPID 是 | 父进程标识。 |
| vsize-vsize-vsize-vsize-vsize-vsize-vsize | KiB 进程的虚拟内存大小。这是进程保留的虚拟内存。 |
| 简易资讯聚合 | 常驻集大小，任务使用的非交换物理内存(以页为单位)。这是进程在页面中实际占用的内存量。这不包括尚未按需加载的页面。 |
| WCHAN | 这是流程等待的“通道”。它是系统调用的地址，如果需要文本名称，可以在名称列表中查找。 |
| 个人电脑 | 当前 EIP(指令指针)。 |
| 状态(无标题) | 进程状态。

*   代表在可中断状态下睡觉
*   跑步用 r
*   测试已停止的进程
*   僵尸的 z

 |
| 名字 | 命令名。Android 中的应用进程以其包名命名。 |

# 总结

在这一章中，介绍了几个真实世界的测试示例，涵盖了广泛的案例。您可以在创建自己的测试时使用它们作为起点。

我们介绍了各种测试方法，您可以将其扩展到自己的测试中。我们使用了模拟上下文，并展示了如何在各种情况下使用 `RenamingDelegatingContext`来改变测试获得的数据。我们还分析了将这些模拟上下文注入到测试依赖项中。

然后，我们使用 `ActivityUnitTestCase`完全隔离地测试活动。我们使用 `AndroidTestCase`单独测试了视图。我们演示了使用 EasyMock 2 来模拟对象，并结合 Hamcrest 来提供比较器。最后，我们分析了潜在的内存泄漏。

下一章重点关注使用持续集成自动化测试过程。