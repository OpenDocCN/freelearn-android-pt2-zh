# 第一章。安卓入门版的瞬间春天

欢迎来到安卓入门版的即时*春天。这本书是专门为您提供使用 Spring for Android 轻松开发 Android 所需的所有信息而编写的。您将了解 Spring 为 Android 提供的不同功能，并开始使用这些功能构建您的第一个应用程序。*

这本书包含以下几节:

*那么，安卓的春天是什么？*描述 Spring for Android 对 Spring Framework 进行了扩展，有助于简化原生 Android 应用程序的开发；它目前(版本 1.0.0.RELEASE)具有 REST 客户端(RestTemplate)和 OAuth 支持(Spring Social)。

*将其集成到安卓应用中*教授如何将 Spring for Android 与 Eclipse IDE 和 ADT(安卓开发工具)以及 Maven 集成。

*快速入门–休息模板*将向您展示如何使用 Spring for Android 休息模板模块的一些核心功能；例如，创建一个 REST 客户端。在本节结束时，您将能够使用消息转换器和/或 HTTP 基本身份验证来检索、更新、创建和删除 REST 资源。

*快速入门–OAuth*将向您展示如何将 Spring 的一些核心功能用于 Android Auth 模块；例如，创建一个到 Google+的 OAuth 连接来读取用户配置文件。在本节结束时，您将能够建立一个 OAuth 连接来验证您的用户和应用程序。

*你应该了解的人和地方*——每个开源项目都是围绕一个社区展开的。除了针对安卓超级贡献者的 Spring Twitter 提要之外，本部分还为您提供了许多指向项目页面和论坛的有用链接，以及许多有用的文章、教程和博客。

# 那么，安卓的春天是什么？

在第一部分中，我们将详细介绍 Spring for Android 的主要方面:`RestTemplate`、`Auth`，以及 Spring for Android 不是什么。

## 剩馀模板

`RestTemplate`模块是基于 Java 的 REST 客户端`RestTemplate`的一个端口，最初出现在 2009 年的 Spring for MVC 中。像其他 Spring 模板的对应物(`JdbcTemplate`、`JmsTemplate`等等)一样，它的目标是给 Java 开发人员(以及安卓开发人员)带来一个低级 Java API 的高级抽象；在这种情况下，它简化了 HTTP 客户端的开发。

在其安卓版本中，`RestTemplate`依赖于核心的 Java HTTP 设施(`HttpURLConnection`)或 Apache HTTP 客户端。根据你运行应用所使用的安卓设备版本，安卓的`RestTemplate`可以为你挑选最合适的。这是根据安卓开发者的推荐。

### 注

参见。这篇博客文章解释了为什么在某些情况下，Apache HTTP 客户端比`HttpURLConnection`更受欢迎。

`RestTemplate` for Android 还支持 gzip 压缩和不同的消息转换器，将你的 Java 对象从和转换成 JSON、XML 等等。

## 认证/春季社交

Spring Android `Auth`模块的目标是让 Android 应用程序使用 **OAuth** (版本 1 或 2)获得对网络服务提供商的授权。

OAuth 可能是最流行的授权协议(值得一提的是，它是一个开放标准)，目前被脸书、推特、谷歌应用(以及许多其他应用)用来让第三方应用访问用户账户。

安卓的 Spring`Auth`模块基于几个 Spring 库，因为它需要安全地(通过密码学)保存(通过 JDBC)一个通过 HTTP 获得的令牌；以下是 OAuth 所需库的列表:

*   **春季安全加密**:加密令牌
*   **Spring Android OAuth** :这扩展了`Spring Security Crypto`为 Android 增加了一个专用加密器，以及基于 SQLite 的持久性提供者
*   **春季安卓休息模板**:与 HTTP 服务交互
*   **春季社交核心**:OAuth 工作流抽象

在执行 OAuth 工作流时，我们还需要浏览器将用户带到服务提供商身份验证页面，例如，下面是 Twitter OAuth 身份验证对话框:

![Auth/Spring Social](img/1905_01_02.jpg)

## 安卓的什么春天不是

SpringSource(Android Spring 背后的公司)在 Java 开发人员中非常有名。他们最受欢迎的产品是面向 Java 的 Spring 框架，其中包括依赖注入框架(也称为控制框架的反转)。安卓的 Spring 并没有给安卓平台带来控制权的倒置。

在其第一个版本(1.0.0.M1)中，Android 的 Spring 为 Android 带来了一个通用的日志门面；作者在下一个版本中删除了它。

# 将其集成到安卓应用中

安卓的 Spring 包含在多个 JAR 库中，这些 JAR 库应该链接到项目。这些 JAR 库不是标准安卓发行版的一部分。例如，我们将需要以下 JAR 库来使用 Spring For Android `RestTemplate`消费一个 JSON REST API:

![Integrating it in an Android app](img/1905_02_01.jpg)

## 添加或使用 RestTemplate 的最小依赖关系

您可以使用集成开发环境来手动满足依赖关系(以及它们的传递依赖关系)。手动依赖管理的替代方法是使用 **Maven** 自动构建项目。我们将在本节后面解释 Maven 构建。

## 安卓的 Eclipse 和 Spring 入门

Eclipse 当然是开发安卓应用最流行的 IDE 之所以如此，其中一个原因是因为谷歌维护的**安卓开发工具** ( **ADT** )提供了 Eclipse 插件，方便安卓开发(调试器、自定义 XML 编辑器等)。

### 注

IntelliJ IDEA 社区版为安卓提供开箱即用的支持；Netbeans 还让你安装`nbandroid`插件，方便安卓应用的开发。

我们需要执行以下步骤来开始使用 Eclipse:

1.  从[http://www.eclipse.org/downloads](http://www.eclipse.org/downloads)下载最新版本(从 3.6.2 版本开始 ADT 兼容 Eclipse 在撰写本文时，Juno 4.2 是最新的版本)。比起其他可用的版本，更喜欢 Java 开发人员的*Eclipse IDE*。
2.  一旦你把它下载到你的机器上，打开它。选择一个工作区位置(你的项目所在的位置)并安装 ADT 插件:点击**帮助** | **Eclipse 市场...**并在文本框中输入 **adt** (如下截图所示)，然后按*进入*；现在点击**安装**按钮，选择【Eclipse 安卓开发工具。

### 注

您不必选择 NDK 支持功能，它为原生安卓开发(使用 C 或 C++语言)提供支持，因为 Spring For 安卓库只是 Java 库。

![Getting started with Eclipse and Spring for Android](img/1905_02_02.jpg)

### 安装 ADT 插件

Eclipse 会多次提示您有关许可证的问题，并最终要求您重新启动它。

1.  When you're back in your workspace, make sure you have an (up-to-date) Android SDK installed on your machine: click on the icon with an Android robot coming out of a box, and install or update the Android SDK (you don't need all Android versions, you can just install the most popular ones such as 2.2 aka Froyo, 2.3.3 aka Gingerbread, 4.0.3 aka Ice Cream Sandwich and 4.1 aka Jelly Bean); restart Eclipse when you're done.

    ![Installing the ADT plugin](img/1905_02_03.jpg)

    安卓软件开发工具包管理器，用于管理安卓工具和平台

2.  If you haven't done so already, you also need to create an **Android Virtual Device** (**AVD**) so that you can deploy your Android apps to it (you could also connect your phone or tablet via USB to deploy your apps on it); for that matter, click on the icon representing an Android robot in a device screen and create a new AVD, as shown in the following screenshot:

    ![Installing the ADT plugin](img/1905_02_04.jpg)

    创建新的 AVD

    ### 注

    你可以从官方网站上找到更多关于 ADT 插件的细节:[http://developer.android.com/tools/sdk/eclipse-adt.html](http://developer.android.com/tools/sdk/eclipse-adt.html)。

3.  We finally need to download the Spring for Android JARs, go to the Spring for Android website: [http://www.springsource.org/spring-android](http://www.springsource.org/spring-android) and click on the **Download** button (you can skip the registration in the following screen). Now choose the latest Spring for Android release (at the time of writing: 1.0.1.RELEASE) and unzip it on your machine; we will need the libraries in the next step:

    ![Installing the ADT plugin](img/1905_02_04_bis.jpg)

    Spring for Android 官方下载页面

### 第一个示例应用

现在，我们准备使用 Spring 为 Android 创建我们的第一个应用程序:

1.  Click on **File** | **New...** | **Android Application**, give your project name and accept the defaults in the following dialogs:

    ![First example app](img/1905_02_05.jpg)

2.  A new window named **New Android Application** will pop up, as shown in thefollowing screenshot:

    ![First example app](img/1905_02_05.jpg)

    从 Eclipse 创建一个安卓应用程序

3.  When asked for a new activity, choose the default **BlankActivity**, as shown in the following screenshot:

    ![First example app](img/1905_02_05-bis.jpg)

4.  Now copy the JARs `spring-android-core-{version}.jar` and `spring-android-rest-template-{version}.jar` from the Spring for Android ZIP file you downloaded before, to the `$Project_home/libs` folder of your new project; you should have the following project structure:

    ![First example app](img/1905_02_06.jpg)

    第一个示例应用

5.  For this first sample app to use Spring for Android to request a web service (we will use [http://ifconfig.me/all](http://ifconfig.me/all)), we will just need to perform a `GET` method on this URL and we will receive the client info: IP, User Agent, and so on. We will then need to declare our intention to access the network. This works by adding the following `permission` tag just before the `application` tag in the Android manifest file:

    ```java
    (...)<uses-sdk
            android:minSdkVersion="8"
            android:targetSdkVersion="15" />
    <uses-permission android:name="android.permission.INTERNET"/>
    <application (...)
    ```

    ### 类型

    安卓清单位于项目的根目录:`AndroidManifest.xml`。

    忘记这样做将导致日志 cat 视图(收集所有日志的地方)中出现模糊的消息，如`Fatal Exception`；有关权限的更多信息，请参见[。](http://developer.android.com/guide/topics/security/permissions.html)

    HTTP 协议定义了方法或动词，以指示要在远程资源上执行的操作:`GET`获取资源，`POST`存储资源，`PUT`更新资源，`DELETE`删除资源都是 HTTP 动词的示例，您可以通过阅读本文了解更多关于它们的信息:[http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)。

6.  Then, we adjust the activity layout by removing the default "hello world" (`android:text="@string/hello_world"`) and replacing it by an anchor that we will use to print the response of the web service (`android:id="@+id/hello_text"`):

    ```java
    <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent" >
        <TextView
            android:id="@+id/result_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerHorizontal="true"
            android:layout_centerVertical="true"
            tools:context=".MainActivity" />
    </RelativeLayout>
    ```

    活动布局见`res/layout/activity_main.xml`。

7.  Finally, we can rework `MainActivity` itself (only the `onCreate()` method needs to be updated):

    ```java
      @Override
      public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final TextView resultTextView = 
                (TextView) findViewById(R.id.result_text);
        AsyncTask<String, Void, String> simpleGetTask =  
                    new AsyncTask<String, Void, String>() {
          @Override
          protected String doInBackground(String... params) {
            //executed by a background thread

           //create a new RestTemplate instance
            RestTemplate restTemplate = new RestTemplate();

            //add the String message converter, since the result of
                 // the call will be a String
            restTemplate.getMessageConverters().add(
                         new StringHttpMessageConverter());

            // Make the HTTP GET request on the url (params[0]),
                 // marshaling the response to a String
            return
                    restTemplate.getForObject(params[0],String.class);
            }

          @Override
          protected void onPostExecute(String result) {
            // executed by the UI thread once the background 
                 // thread is done getting the result
            resultTextView.setText(result);
          }
        };
        String url = "http://ifconfig.me/all";
        // triggers the task; it will update the resultTextView once
          // it is done
        simpleGetTask.execute(url);
      }
    ```

    ### 注

    如果 Eclipse 抱怨缺少导入，同时按*Shift*+*Ctrl*+*O*自动添加所需的导入。

    在这个片段中，我们首先获得了对我们的`result_text`文本视图的引用，并将其设置为一个名为`resultTextView`(因为我们需要通过内部类来访问它)的`final`变量。

    接下来，我们创建了一个匿名的内部类，扩展`AsyncTask`来实现命中 web 服务的所有逻辑(创建`RestTemplate`实例，添加`String`转换器并调用`getForObject`，并将结果设置为文本视图(使用`setText`方法)。当我们调用`simpleGetTask.execute(url)`时，网址被添加到`doInBackground(String... params)`中的参数数组中(所以在这种情况下`params[0]`就是`url`)。

    ### 注

    如果我们直接编写代码在`onCreate()`方法中命中 web 服务，应用程序甚至无法启动，因为安卓平台阻止开发人员在 UI(主)线程中执行 HTTP 请求(原因很好:那些与网络相关的操作通常需要时间来完成，并且会在操作过程中冻结 UI)。

    ```java
    @Override
    public void onCreate(Bundle savedInstanceState) {
     TextView resultTextView = (TextView) findViewById(R.id.result_text);
     String url = "http://ifconfig.me/all";
     RestTemplate restTemplate = new RestTemplate();
     RestTemplate.getMessageConverters().add(new  StringHttpMessageConverter());
     String result = restTemplate.getForObject(url, String.class);
     resultTextView.setText(result);
    }
    ```

    ### 类型

    不要这样做！您不能从用户界面(主)线程执行与 HTTP 相关的调用。

    ### 注

    关于`AsyncTasks`的更多信息可以在官方文档中找到:[http://developer . Android . com/reference/Android/OS/asynctask . html](http://developer.android.com/reference/android/os/AsyncTask.html)以及一般安卓系统中的线程和进程:[http://developer . Android . com/guide/components/process-and-threads . html](http://developer.android.com/guide/components/processes-and-threads.html)。

8.  We are now ready to launch this first Spring for Android based app!

    右键单击项目名称并选择**运行方式...** | **安卓应用**:

    ![First example app](img/1905_02_06-bis.jpg)

9.  Eclipse will start your previously created AVD and will automatically run the app, you should see something similar to the following screenshot:

    ![First example app](img/1905_02_07.jpg)

    主活动截图来自自动视频显示器

恭喜你！你已经成功运行了你的第一个基于安卓的春季应用程序！

## 使用 Maven 为安卓应用构建 Spring

在前面的例子中，我们只给`libs`文件夹添加了两个 JARs 但是如果你需要其他的依赖项，比如`MessageConverters`(去解组 JSON，XML 响应)`Auth`模块，或者你的项目中任何其他现有的库，管理你的依赖项将很快成为一个负担！

Maven 可以帮助你管理你的依赖关系(简单来说，你在一个名为`pom.xml`的文件中指定它们，它会自动从互联网上获取它们，包括它们的传递依赖关系)以及更多:发布操作、测试运行、头生成等等。Maven 是一个模块化的开源构建工具，有大量插件！

### 注

当使用安卓 Maven 插件时，您应该在您的环境中添加以下变量`ANDROID_HOME`(链接您的安卓主目录)并将`ANDROID_HOME/platform-tools`添加到您的路径中。这在[中有详细的解释。](https://code.google.com/p/maven-android-plugin/wiki/GettingStarted)

首先，让我们将 **m2e** (Maven to Eclipse)插件添加到 Eclipse 中:就像我们为 ADT 插件所做的那样，打开**帮助** | **Eclipse** 市场并搜索**Maven**；选择**Eclipse Maven 集成**，点击**安装**并确认对话框；在过程结束时重新启动 IDE。

![Using Maven to build a Spring for Android app](img/1905_02_08.jpg)

为 Eclipse 安装 Maven 集成

现在将名为`spring-for-android-first-example-maven`的项目导入到您的工作区:您可以从 GitHub 克隆它，也可以解压缩`examples.zip`档案；然后，从 Eclipse 中，点击**文件** | **导入…** 并选择**现有 Maven 项目**，然后点击**下一步**。

![Using Maven to build a Spring for Android app](img/1905_02_09.jpg)

导入现有 Maven 项目

浏览到您克隆或解压项目的目录，点击**下一步**按钮:

![Using Maven to build a Spring for Android app](img/1905_02_10.jpg)

浏览到您的 maven 项目

M2e 将向您展示将基于 Maven 的项目集成到您的 IDE 中所需的 m2e 连接器列表(基本上那些连接器告诉 m2e 如何生成和编译源代码)；点击**完成**并接受以下对话框；重启 Eclipse。

### 注

这里最重要的连接器是 m2e-安卓连接器:它使 m2e 能够与 ADT 集成，更多信息请参见[http://rgladwell.github.com/m2e-android/](http://rgladwell.github.com/m2e-android/)。

该项目应该可以很好地导入，您可以像以前的项目一样在您的 AVD 上部署该项目(右键单击该项目，然后选择**运行为** | **安卓应用程序**)。

让我们来看看`pom.xml`文件(与上一个项目相比唯一的附加文件)，右键单击它并选择**用…** | **Maven POM 编辑器**打开；点击视图底部的 **pom.xml** 选项卡。

```java
(...)<dependencies>
        <dependency>
            <groupId>com.google.android</groupId>
            <artifactId>android</artifactId>
            <version>4.0.1.2</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>org.springframework.android</groupId>
          <artifactId>spring-android-rest-template</artifactId>
          <version>${spring-android-version}</version>
        </dependency>
    </dependencies>
    <build>
        <finalName>${project.artifactId}</finalName>
        <sourceDirectory>src</sourceDirectory>
        <plugins>
            <plugin>
        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                <artifactId>android-maven-plugin</artifactId>
                <version>3.3.0</version>
                <extensions>true</extensions>
                <configuration>
                    <sdk>
                        <!-- platform or api level (api level 4 = platform 1.6)-->
                        <platform>15</platform>
                    </sdk>
                </configuration>
            </plugin>
        </plugins>
    </build>(...)
```

您可以在依赖项部分看到；安卓平台和安卓的 Spring`RestTemplate`神器(无需为安卓核心指定 Spring！请记住，Maven 会自动获取可传递的依赖项)，在插件部分，Android-Maven 插件(由于`extensions=true`属性，它扩展了 Android 项目的 Maven)被配置为需要 Android 4.0.3 (API 级别 15)。

Maven 的核心是一个命令行工具，如果你在你的机器上下载并解压 Maven，你可以去 Maven 项目的根目录(也就是`pom.xml`所在的地方)键入具有不同目标的 Maven 命令:

*   `mvn clean install`:编译、运行测试并打包
*   `mvn clean install android:run`:在 AVD 中启动你的应用

### 注

要查看所有可用的目标，您可以键入`mvn help:describe -Dplugin=com.jayway.maven.plugins.android.generation2:maven-android-plugin`。

您也可以在 Eclipse 中模拟命令行 Maven，右键单击项目并选择**作为** | **Maven 构建运行...**，明确你的目标。

Maven 安装说明可以在网上找到:[http://www . sonatype . com/books/mvn ref-book/reference/installation-section-maven-install . html](http://www.sonatype.com/books/mvnref-book/reference/installation-sect-maven-install.html)。

要了解更多关于 Maven 的信息，我强烈建议在[http://www.sonatype.com/books/mvnref-book/reference/](http://www.sonatype.com/books/mvnref-book/reference/)阅读免费的在线 Maven 书籍，该书甚至有专门的安卓章节。

现在，我们准备为基于安卓的应用程序开发一些更丰富的 Spring！

# 快速启动–剩馀模板

既然我们的工作空间已经建立，并且我们已经成功部署了我们的第一个基于安卓`RestTemplate`的 Spring 应用程序，让我们从`RestTemplate`中探索一些更多的功能。

本节依赖于几个示例应用程序。我们将讨论每个代码示例的所有要点。请随意将项目导入您的集成开发环境并浏览代码。

### 注

从现在开始，我将使用 Maven 来管理依赖关系，但是您不必这样做。每个项目在其`README.md`文件中都有一个依赖列表:下载它们(或者从你的 Spring for Android ZIP 存档`libs`文件夹中获取它们)，并将其添加到`libs`文件夹中！

## 不同的消息转换器

在前一节中，我们已经使用了一个消息转换器:`StringHttpMessageConverter`。每个消息转换器都支持读取和写入某些媒体类型(通常称为 MIME 类型)；`StringHttpMessageConverter`支持读取各种文档(MIME */*)和写入文本(MIME 文本/纯文本)。让我们发现更复杂的消息转换器。

### 注

**MIME** ( **多用途互联网邮件扩展**)，不仅用于描述电子邮件的内容，还广泛用于描述通过 HTTP 交换的文档内容([http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME))。

### mapping Jackson httpmessageconverter

JSON 消息在 REST 网络服务中非常常见。最初是为 JavaScript 语言(`JavaScriptObjectNotation`)设计的；它们是轻量级的，也是人类可读的。

`Ifconfig.me`可以返回一个 JSON 响应，如果你使用这个 URL:[http://ifconfig.me/all.json](http://ifconfig.me/all.json)。

在第一个示例的代码中，让我们将`StringHttpMessageConverter`替换为`MappingJacksonHttpMessageConverter`:

```java
AsyncTask<String, Void, IfConfigMeJson> simpleGetTask =  
  new AsyncTask<String, Void, IfConfigMeJson>() {
  @Override
  protected IfConfigMeJson doInBackground(String... params) {
    String url = params[0];
    RestTemplate restTemplate = new RestTemplate();
    MappingJacksonHttpMessageConverter jacksonConverter = 
         new MappingJacksonHttpMessageConverter();
    restTemplate.getMessageConverters().add(jacksonConverter);
    return restTemplate.getForObject(url,
           IfConfigMeJson.class);
  }

  @Override
  protected void onPostExecute(IfConfigMeJson result) {
    String resultAsString =  new StringBuilder()
                      .append("Your current IP is : ")
                      .append(result.getIpAddr()).toString();
    resultTextView.setText(resultAsString );
  }

};

String url = "http://ifconfig.me/all.json";
//triggers the task
simpleGetTask.execute(url);
```

如您所见，我们还引入了一个名为`IfConfigMeJson`的模型类:该类定义了 JSON 消息属性(`{"connection":"keep-alive","ip_addr":"70.30.43.43", [..]}`)和一个 **POJO** ( **普通旧 Java 对象**:一个带有成员变量及其访问器的简单类)之间的映射，这样我们就可以在我们的 Java 代码中轻松访问响应的每个属性(在下面的示例中:`result.getIpAddr()`):

```java
public class IfConfigMeJson {
  private String connection;
  @JsonProperty("ip_addr")
  private String ipAddr;
  public String getConnection() {
    return connection;
  }
  public void setConnection(String connection) {
    this.connection = connection;
  }
  public String getIpAddr() {
    return ipAddr;
  }
  public void setIpAddr(String opAddr) {
    this.ipAddr = opAddr;
  }
```

### 注

Jackson 自动将 JSON 属性与 Java 字段匹配，只要它们的名称相同(在 Java 中是 CamelCase，在 JSON 中是下划线)。您肯定已经注意到，我们将 JSON 属性`ip_addr`与字段`ipAddr`进行了映射，以遵守 Java 命名约定，这要归功于字段定义之前 Jackson 的`@JsonProperty`注释。另一方面，我们可以将类的字段声明为公共的，并删除访问器。

当您运行应用程序时，您只会看到以下屏幕截图:

![MappingJacksonHttpMessageConverter](img/1905_03_01.jpg)

应用程序使用`MappingJacksonHttpMessageConverter`

在本节中，我们在`pom.xml`文件中为`jackson-mapper-asl`添加了一个依赖项:

```java
<dependency>
<groupId>org.codehaus.jackson</groupId>
  <artifactId>jackson-mapper-asl</artifactId>
  <version>${jackson-version}</version>
</dependency>
```

### 注

还有另一个 JSON 消息转换器可用，`GsonHttpMessageConverter`，使用谷歌 Gson 库代替杰克逊，可以替代使用。

### simple xmlhttpmessageconverter

另一个值得一提的消息转换器是`SimpleXmlHttpMessageConverter`:它将 XML 响应和请求映射到 POJOs，就像`MappingJacksonHttpMessageConverter`映射 JSON 一样。

例如，让我们请求`Ifconfig.me` XML 服务:[http://ifconfig.me/all.xml](http://ifconfig.me/all.xml)。

在我们前面例子的`MainActivity`类中，让我们将`MappingJacksonHttpMessageConverter`替换为`SimpleXmlHttpMessageConverter`:

```java
AsyncTask<String, Void, IfConfigMeXml> simpleGetTask =  
   new AsyncTask<String, Void, IfConfigMeXml>() {
   @Override
   protected IfConfigMeXml doInBackground(String... params) {
      String url = params[0];
RestTemplate restTemplate = new RestTemplate();
      SimpleXmlHttpMessageConverter xmlConverter = 
           new SimpleXmlHttpMessageConverter();
      restTemplate.getMessageConverters().add(xmlConverter);
      return restTemplate.getForObject(url, IfConfigMeXml.class);
   }

   @Override
   protected void onPostExecute(IfConfigMeXml result) {
       String resultAsString =  new StringBuilder()
                  .append("Your current IP is : ")	
                  .append(result.getIpAddr()).toString();
       resultTextView.setText(resultAsString );
   }

};

String url = "http://ifconfig.me/all.xml";

```

再一次，你会注意到我们依赖一个名为`IfConfigMeXml.java`的类来允许`SimpleXml`在 XML 响应和 Java 代码之间进行映射。以下是 XML 响应:

```java
<info>
<forwarded/>
<ip_addr>70.43.43.43</ip_addr>
[...]
</info>
```

以下是 Java 代码:

```java
@Root (name="info")
public class IfConfigMeXml {

  @Element(required=false)
  private String forwarded;

  @Element(name="ip_addr")
  private String ipAddr;
  [...]
}
```

注释类似于我们用于 JSON 消息转换器的注释。

`@Root`注释定义了根 XML 标签的名称:在这种情况下为`info`。

在每个字段前添加`@Element`注释，让`SimpleXml`知道这些字段映射到了 XML 标签:如果`required`设置为 false，则表示标签可能为空；如果指定了`name`，则表示 POJO 字段与 XML 标签名称不匹配。

如果您运行该应用程序，您将获得与我们在前面示例中完全相同的输出。

### 注

在本节中，我们向`SimpleXml`框架添加了一个依赖项。不幸的是，这种依赖关系对 stax 和 xpp3 具有可传递的依赖关系，而安卓应用程序不需要这种依赖关系。

我们必须显式过滤一些可传递的依赖项，让 Maven 知道不要将它们添加到类路径中。

```java
<dependency>
  <groupId>org.simpleframework</groupId>
  <artifactId>simple-xml</artifactId>
  <version>${simple-version}</version>
  <exclusions>
    <!-- StAX is not available on Android -->
    <exclusion>
      <artifactId>stax</artifactId>
      <groupId>stax</groupId>
    </exclusion>
    <exclusion>
      <artifactId>stax-api</artifactId>
      <groupId>stax</groupId>
    </exclusion>
    <!-- Provided by Android -->
    <exclusion>
      <artifactId>xpp3</artifactId>
      <groupId>xpp3</groupId>
    </exclusion>
  </exclusions>
</dependency>
```

### rshanelttpmmessageconverter

这个消息转换器是关于解析 RSS 提要的；像往常一样，我们将把它注入到我们的`RestTemplate`实例中，但是这次我们将从博客提要中读取条目。

```java
final WebView resultTextView = (WebView) findViewById(R.id.result_text);
AsyncTask<String, Void, Channel> simpleGetTask =  new AsyncTask<String, Void, Channel>() {
   @Override
   protected Channel doInBackground(String... params) {
      RestTemplate restTemplate = new RestTemplate();
      // Configure the RSS message converter.
       RssChannelHttpMessageConverter rssChannelConverter = new RssChannelHttpMessageConverter();
      rssChannelConverter.setSupportedMediaTypes(
         Collections.singletonList(MediaType.TEXT_XML));

        // Add the RSS message converter to the RestTemplate instance
        restTemplate.getMessageConverters().add(rssChannelConverter);

      // Make the HTTP GET request on the url (params[0]), marshaling //the response to a String
      return restTemplate.getForObject(params[0], Channel.class);
   }

   @Override
   protected void onPostExecute(Channel result) {
      //get the latest article from the blog
      Item item = (Item) result.getItems().get(0);

      // load the content of the article into the WebView
      resultTextView.loadData(item.getContent().getValue(), "text/html", "UTF-8");
   }
};
String url = "http://blog.dahanne.net/feed/";
```

我们不必在这里创建一个 POJO 映射类，因为结果总是一个`Channel`——一个为我们提供方法来访问提要的不同属性:项目、语言、发布日期等等的类。在这个例子中，我们只阅读了第一项的内容——我博客上的最新文章！

提要如下所示:

```java
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
   <title>Anthony Dahanne's blog</title>
   <description>A blog</description>
   [...]
   <item>
      <title>Article 1</title>
      <description>content of the article</description>
      [...]
   </item>
   [...]
</channel>
</rss>
```

设备上的结果如下:

![RssChannelHttpMessageConverter](img/1905_03_02.jpg)

RSS 源第一项的内容

### 注

您可能已经注意到，我将以前的文本视图切换为网络视图，能够解释超链接等 HTML 代码。

`RssChannelHttpMessageConverter`没有默认支持的类型，所以我们增加了媒体类型`text/xml`作为支持的类型。

### 注

对于这个 RSS 提要示例，我们必须添加对安卓罗马提要阅读器的依赖；这个库没有在 Maven Central 上发布，这意味着我们还必须声明它的工件部署到的存储库。

```java
<dependency>
   <groupId>com.google.code.android-rome-feed-reader</groupId>
   <artifactId>android-rome-feed-reader</artifactId>
   <version>${android-rome-version}</version>
</dependency>

<repositories>
   <repository>
      <id>android-rome-feed-reader-repository</id>
      <name>Android ROME Feed Reader Repository</name>
      <url>https://android-rome-feed-reader.googlecode.com/svn/maven2/releases</url>
   </repository>
</repositories>
```

## Gzip 加密

为了在传输过程中节省带宽，作为每个请求的一部分，您可以告诉服务器您支持 gzip 加密。如果服务器支持 gzipping 响应，它就会这样做。

安卓`RestTemplate`的 Spring，从姜饼(2.3)开始依赖安卓`java.net.HttpURLConnection`，默认发送`Accept-Encoding : gzip`头；所以默认情况下 gzip 压缩是打开的。

否则，您只需要在请求的头部指定您可以支持 gzip。让我们看一个具体的例子——杰克逊例子，这次我们只展示了客户端支持的编码机制:

```java
@Override
protected IfConfigMeJson doInBackground(String... params) {

   HttpHeaders requestHeaders = new HttpHeaders();
   requestHeaders.setAcceptEncoding(ContentCodingType.IDENTITY);
// Add the gzip Accept-Encoding header   
//requestHeaders.setAcceptEncoding(ContentCodingType.GZIP);
   HttpEntity<?> requestEntity = 
        new HttpEntity<Object>(requestHeaders);
   RestTemplate restTemplate = new RestTemplate();
   MappingJacksonHttpMessageConverter jacksonConverter = 
        new MappingJacksonHttpMessageConverter();
   restTemplate.getMessageConverters().add(jacksonConverter);
   ResponseEntity<IfConfigMeJson> response = 
        restTemplate.exchange(params[0], HttpMethod.GET, 
                      requestEntity, IfConfigMeJson.class);
   return response.getBody();
}
```

使用`Identity`，我们声明除了原始文本，我们不支持任何其他内容。

### 注

当您显式或隐式请求 gzip 时，`java.util.zip.GzipInputStream`将自动用于解码响应。

你有没有注意到我们用的不是`getForObject(url,Pojo.class)`而是`exchange(url,GET,requestEntity,Pojo.class)`？`exchange()`方法是一种更通用的方法，允许定制请求。

让我们看看在执行这段代码期间交换的请求/响应:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

请求(身份，然后是 GZIP)

 | 

回应(身份和 GZIP)

 |
| --- | --- |
| `GET/all.json HTTP/1.1``Accept: application/json``Accept-Encoding: identity``Content-Length: 0``Host: ifconfig.me:80``Connection: Keep-Alive` | `HTTP/1.1 200 OK``Date: Fri, 02 Nov 2012 02:41:04 GMT``Server: Apache``Vary: Accept-Encoding``Connection: close``Transfer-Encoding: chunked``Content-Type: application/json``13c``{"connection":"Keep-Alive","ip_addr:[...],"encoding":"identity"}``0` |
| `GET /all.json HTTP/1.1``Accept: application/json``Accept-Encoding: gzip``Content-Length: 0``User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.0.4; sdk Build/MR1)``Host: ifconfig.me:80``Connection: Keep-Alive``X-Forwarded-For: 192.168.1.111` | `HTTP/1.1 200 OK``—îPq``Date: Fri, 02 Nov 2012 02:42:08 GMT``Server: Apache``Vary: Accept-Encoding``Content-Encoding: gzip``Content-Length: 258``Connection: close``Content-Type: application/json``­ã/%êAOÑ0 ÖÔ˛``"ì&À–"ß5ﬁ'ãâg2€él•¥§4�ˇªÖΩÕ&#124;3ÔeÊ˝2È¨%9kgŸ/{&ö"ì—+±/"SáJ˘àk` |

### 注

分析来回于设备的请求和响应通常很方便；您可以使用开源软件“膜”作为 HTTP 代理([http://www.membrane-soa.org/soap-monitor/](http://www.membrane-soa.org/soap-monitor/))创建一个新的简单代理，该代理侦听 localhost:2000 并重定向到您的目标 web 服务(例如， [http://ifconfig.me](http://ifconfig.me) )。

在安卓代码中，只需将你的网络服务网址替换为`computer_ip:2000`(可能是`192.168.1.1:2000`):你就会看到你的安卓应用和网络服务网址之间的所有流量。

## HTTP 基本认证

顾名思义，这种身份验证方案非常基本且不安全。您只需提供用户名和密码来访问一个领域(通常是网站的一部分)。

正如我们对编码所做的那样，我们可以通过一个头来提供凭证:用户名和密码将是 Base64 编码的。

### 注

Base64 编码绝不提供安全性。你可以像编码一样容易地解码它！有关 Base64 的更多信息，请参见[https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64)。

例如，我们将尝试访问显示**你好世界**的网页；前提是您发送了正确的凭据。页面为[http://restfulapp.appspot.com/helloworld](http://restfulapp.appspot.com/helloworld)，凭证为用户名–`s4a`和密码–`s4a`(可以在网页浏览器中尝试)。

让我们试着用 Spring 为安卓的`RestTemplate`访问这个页面吧！

```java
AsyncTask<String, Void, String> simpleGetTask =  new AsyncTask<String, Void, String>() {
   @Override
   protected String doInBackground(String... params) {
      // Set the credentials for creating a Basic Auth request
      HttpAuthentication authHeader = 
          new HttpBasicAuthentication("s4a", "s4a");
      HttpHeaders requestHeaders = new HttpHeaders();
      requestHeaders.setAuthorization(authHeader);
      HttpEntity<?> requestEntity = 
          new HttpEntity<Object>(requestHeaders);

      RestTemplate restTemplate = new RestTemplate();

      restTemplate.getMessageConverters()
              .add(new StringHttpMessageConverter());

      try {
          // Make the GET request to the Basic Auth protected URL
          ResponseEntity<String> response = 
                restTemplate.exchange(params[0], HttpMethod.GET, 
                       requestEntity, String.class);
          return response.getBody();
      } catch (HttpClientErrorException e) {
         // Handle 401 Unauthorized response
         Log.e("MainActivity",e.getLocalizedMessage(),e);
         return "Wrong credentials";
      }
   }

   @Override
   protected void onPostExecute(String result) {
      // executed by the UI thread		 
      resultTextView.setText(result);
   }

};
```

我们设置`Accepted-Encoding`的方式在前面的例子中，我们将 **HttpBasicAuthentication** 头设置为`RestTemplate`头。

让我们看看在执行这段代码期间交换的请求/响应:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

请求

 | 

反应

 |
| --- | --- |
| `GET/helloworld HTTP/1.1``Accept: text/plain, */*``Authorization: Basic czRhOnM0YQ==``Content-Length: 0``User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.0.4; sdk Build/MR1)``Host: restfulapp.appspot.com:80``Connection: Keep-Alive``Accept-Encoding: gzip` | `HTTP/1.1 200 OK``Content-Type: text/plain; charset=iso-8859-1``Vary: Accept-Encoding``Date: Fri, 02 Nov 2012 03:33:06``Server: Google Frontend``Cache-Control: private``Transfer-Encoding: chunked``d``Hello, world``0` |

### 注

字符串`czRhOnM0YQ==`是`s4a:s4a`的 Base64 编码。

我们将在下一节介绍一种更好的方法来验证和授权用户和用户的应用程序:*快速启动–OAuth*。

## RESTful 食谱应用

让我们来研究一下 RESTful 菜谱应用程序的案例:一个安卓应用程序，用于与 RESTful 服务进行交互，以创建、更新、阅读和删除菜谱。

配方有点简单–它是一个 POJO，包含以下字段:

*   一个 ID ( `Integer`)
*   一个标题(`String`)
*   配方描述(`String`)
*   a 类:通常是主菜、主菜或甜点(`String`)
*   一个作者(`String`)

我们将用作后端服务的在线网络应用程序是基于泽西(参考 JAX-RS 实现库)的 JAX-RS(REST 服务的 JEE 规范)应用程序，并部署在谷歌应用引擎上——它可能是用 Ruby、Python 或任何其他语言编写的。

### 注

如果你已经研究过记事本应用，安卓样本的一部分，你会熟悉 RESTful 食谱应用:它是以记事本应用代码为基础编写的，取代了从嵌入式 SQLite 数据库到 REST 在线服务的持久性。

### recipliest 活动:列出服务器上存储的所有食谱

当用户启动应用程序时，他首先想看到的是可用食谱的列表。

该活动使用`ListView`，以`ListAdapter`为背景，向用户显示它们。

但是首先，它需要从服务器获取它们:

*   我们需要一个模型(`Recipe.java` ):

    ```java
    public class Recipe {

       private Long id;
       private String title;
       private String description;
       private String type;
       private String author;
    }
    ```

*   和嵌套在异步任务中的`RestTemplate`实例:

    ```java
    private class GetRecipesTask extends RecipeAbstractAsyncTask <Void, Void, List<Recipe>> {

       @Override
       protected void onPreExecute() {
          showProgressDialog("Loading recipes. Please wait...");
       }

       @Override
       protected List<Recipe> doInBackground(Void... params) {
          HttpHeaders requestHeaders =  
                   prepareHeadersWithMediaTypeAndBasicAuthentication();

          // Populate the headers in an HttpEntity object		
          HttpEntity<?> requestEntity = 
                   new HttpEntity<Object>(requestHeaders);

          // Create a new RestTemplate instance
          RestTemplate restTemplate = new RestTemplate();
          restTemplate.getMessageConverters()
    .add(new MappingJacksonHttpMessageConverter());

          try {
             // Perform the HTTP GET request
             ResponseEntity<Recipe[]> responseEntity = 
                restTemplate.exchange(
                   "http://www.restfulapp.appspot.com/rest/recipes/",
                   HttpMethod.GET, requestEntity,
       Recipe[].class);
             return Arrays.asList(responseEntity.getBody());
          }
          catch (RestClientException e) {
             Log.e(TAG, e.getMessage(), e);
             exception = e;
             return null;
          }
       }

       @Override
       protected void onPostExecute(List<Recipe> result) {
          dismissProgressDialog();
          if(result != null) {
             recipes = result;
          } else {
             String message = exception != null ? 
                exception.getMessage() : "unknown reason";
             Toast.makeText(RecipesList.this, 
                "A problem occurred during the reception of all recipes
                : " +message , Toast.LENGTH_LONG).show();
              recipes = new ArrayList<Recipe>();
          }
          ListAdapter adapter = new RecipeAdapter(RecipesList.this, 
             R.layout.recipeslist_item, recipes ) ;
          setListAdapter(adapter );
       }
    }
    ```

每当我们需要更新食谱列表时，这个任务就会被执行:

*   创建(或恢复)活动时:`onResume()`
*   当我们从成功的更新操作中回来时:`onActivityResult()`

你可能已经注意到这个 AsyncTask 扩展了`RecipeAbstractAsyncTask`，一个定义异常的类，和一个实用方法`prepareHeadersWithMediaTypeAndBasicAuthentication()`:

```java
protected HttpHeaders prepareHeadersWithMediaTypeAndBasicAuthentication() {
      HttpHeaders requestHeaders = new HttpHeaders();
      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
      acceptableMediaTypes.add(MediaType.APPLICATION_JSON);
      requestHeaders.setAccept(acceptableMediaTypes);
      HttpAuthentication authHeader = new HttpBasicAuthentication("s4a", "s4a");
      requestHeaders.setAuthorization(authHeader);
      return requestHeaders;
   }
```

顾名思义，它准备请求头以包含所需的基本身份验证，以及来自服务器的期望的`MediaType`对象。

回到`GetRecipesTask`:我们准备请求头，我们创建一个新的`RestTemplate`实例——配置为使用 Jackson 来(取消)序列化消息，我们执行 GET 请求:

```java
// Perform the HTTP GET request
               ResponseEntity<Recipe[]> responseEntity = restTemplate.exchange(getString(R.string.recipe_resource_url), HttpMethod.GET, requestEntity, Recipe[].class);
```

### 注

`R.string.resource_url`值在`strings.xml`中定义，定义为等于:[http://www.restfulapp.appspot.com/rest/recipes/](http://www.restfulapp.appspot.com/rest/recipes/)。

因为我们想要得到一个食谱列表，给`ResponseEntity`对象的类型是一个数组。

另一个需要注意的重要事情是异常处理程序: **RestClientException** 不同于它的名字，它是一个包装服务器和客户端异常。如果你想告诉你的用户哪里出了问题，你最好抓住这个异常，并保持它，直到你在`onPostExecute()`方法中执行代码时回到 UI 线程。

### 注

注意`RestClientException`是`RuntimeException`的子类，所以不需要显式的捕捉。如果不这样做，这个异常可能会在抛出时终止您的活动。

说到用户界面，这个任务使用其执行前和执行后的方法，通过使用`ProgresDialogs`和`Toasts`来保持用户对加载状态的更新。

### 注

从应用程序外部手动调试 REST 资源可能很有用； **cURL** 应用程序(可在[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)下载)可能是最受欢迎的工具。

对于本节中调用的每个 HTTP 请求，我现在将包括它匹配的 cURL 命令行。

```java
curl --user s4a:s4a  -H "Accept: application/json" -i http://www.restfulapp.appspot.com/rest/recipes 
[{"id":0,"title":"Montreal's Poutine","description":"French fries are covered with fresh cheese curds, and topped with brown gravy.","type":"MAIN_DISH","author":"Anthony"},{"id":1,"title":"a title","description":"a description","type":"a type","author":"an author"}]
```

![RecipeList activity: listing all recipes stored on the server](img/1905_03_03.jpg)

收件人列表活动概述

### 收件人活动

该活动负责获取、更新、创建和删除食谱。

![RecipeEditor activity](img/1905_03_04.jpg)

更新模式下的收件人活动

*   GETting a recipe

    当用户点击 RecipeList 活动的创建图标或某个配方标题时，他/她将被引导至 RecipeEditor 活动。

    如果用户想要创建一个新的配方，他/她会看到空的字段，但是如果他/她想要看到一个配方，他们会在填充字段之前首先从服务器获取它；感谢内部`GetRecipeTask`:

    ```java
    // Perform the HTTP GET request
    Log.i(TAG,"Getting the recipe with id : "+params[0] + " : " +url + params[0]);
    ResponseEntity<Recipe> responseEntity = restTemplate.exchange(url + params[0], HttpMethod.GET, requestEntity,	Recipe.class);
    return responseEntity.getBody();
    ```

    这里没有什么新东西，我们想得到一个配方，通过它的 ID ( `params[0])`)来识别。

    ```java
    curl --user s4a:s4a  -H "Accept: application/json" -i http://www.restfulapp.appspot.com/rest/recipes/0
    {"id":0,"title":"Montreal's Poutine","description":"French fries are covered with fresh cheese curds, and topped with brown gravy.","type":"MAIN_DISH","author":"Anthony"}
    ```

*   PUTting a recipe

    要更新一个配方，我们必须用 PUT HTTP 动词请求配方资源。

    为此，我们再次拥有一个专用的 AsyncTask: `UpdateRecipeTask`，它将实例化一个`RestTemplate`实例，携带更新后的配方(一旦用户按下`Save`按钮，我们就调用`updateNote()`方法，将视图的内容与当前配方的模型同步)。

    ```java
    // Create a new RestTemplate instance
    RestTemplate restTemplate = new RestTemplate();
    restTemplate.getMessageConverters()
       .add(new MappingJacksonHttpMessageConverter());

    // Populate the headers in an HttpEntity object HttpEntity<Recipe> requestEntity = new HttpEntity<Recipe>(recipe,requestHeaders);
    try {
       // Perform the HTTP PUT request
       Log.i(TAG,"Updating the recipe with id : "
          +recipe.getId() + " : " + url);
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url, HttpMethod.PUT, requestEntity,
          Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.OK) {
          throw new HttpServerErrorException(
             responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    ```

    你可以在这里看到真正重要的部分是`RequestEntity`，它包装了我们的食谱:`RestTemplate`将把它传递给杰克逊，杰克逊将把它转换成 JSON 字符串。

    如果服务器没有响应 HTTP Status 200 (OK)，我们可以认为出了问题，并保留用户界面的异常。

    ```java
    curl --user s4a:s4a  -H "Accept: application/json" -H "Content-type: application/json"  -X PUT -d '{"id":"0", "title":"a title","description":"a description","type":"a type","author":"an author"}'  -i http://www.restfulapp.appspot.com/rest/recipes/
    ```

*   POSTing a recipe

    要创建一个配方，我们必须用 POST HTTP 动词请求配方资源。

    在 REST 文献中，您还将阅读 PUT HTTP 动词的用法来创建实体；但是有一个条件——你必须提供 ID(这样一行中的几个 PUT 不会改变资源状态。PUT 和 GET 和 DELETE 一样是幂等的，和 DELETE 和 POST 一样不安全)。

    ### 注

    在我们的例子中，我们创建了一个新的资源，所以 POST 很好地反映了我们的意图。

    来看看`CreateRecipeTask`，和`UpdateRecipeTask`很像:

    ```java
    // Populate the headers in an HttpEntity object 
    HttpEntity<Recipe> requestEntity = 
       new HttpEntity<Recipe>(recipe,requestHeaders);
    try {
       // Perform the HTTP POST request
       Log.i(TAG,"Posting the recipe with id : "
          +recipe.getId() + " : to " +url);
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url, HttpMethod.POST, requestEntity,
          Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.CREATED) {
          throw new HttpServerErrorException(
             responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    return null;
    ```

    需要注意的一些有趣的事情是:配方没有设置任何标识，因为用户是从零开始创建配方的。网络服务将为这个配方分配一个标识(并且应该返回创建的资源的 URI)；预期状态不是 200，而是 201 ( `HttpStatus.CREATED`)。

    ```java
    curl --user s4a:s4a  -H "Accept: application/json" -H "Content-type: application/json"  -X POST -d '{"title":"a title","description":"a description","type":"a type","author":"an author"}'  -i http://www.restfulapp.appspot.com/rest/recipes/
    ```

*   DELETing a recipe

    要删除一个配方，我们必须用 DELETE HTTP 动词请求配方资源。

    名为`DeleteRecipeTask`的 AsyncTask 与`GetRecipeTask`类似，它只需要将配方的 ID 附加到资源 URI(不需要像我们在 PUT 和 POST 中那样携带整个配方)。

    ```java
    try {
       // Perform the HTTP DELETE request
       Log.i(TAG,"Deleting the recipe with id : "
          +recipe.getId() + " : from " +url +recipe.getId() );
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url+recipe.getId(), 
          HttpMethod.DELETE, requestEntity,	Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.NO_CONTENT) {
          throw new HttpServerErrorException(
          responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    ```

    这个请求期望有一个带有 204 个 HTTP 代码的响应，这意味着请求是成功的，但是没有什么可返回的(`HttpStatus.NO_CONTENT`)。

    ### 注

    作为对成功的删除请求的响应，HTTP 代码 200 应该没问题。

    查看您的 web 服务文档(或者更好的方法，例如用 cURL 进行实验)，对应该返回的 web 服务做出最好的假设。

    ```java
    curl --user s4a:s4a  -H "Accept: application/json" -X DELETE   -i http://www.restfulapp.appspot.com/rest/recipes/1
    ```

## Android 注释

你可能听说过这个在[https://github.com/excilys/androidannotations/](https://github.com/excilys/androidannotations/)提供的项目，该项目旨在减少在安卓应用程序中注入视图、活动、提供者、服务等所需的代码量。

项目负责人已经决定使用 Spring for Android 的`RestTemplate`作为支持 REST 注释的 REST 客户端库。

### 注

安卓注释基于**注释处理器工具** ( **apt** )，现在是 Java 6 编译器的一部分；每个带注释的类将触发子类的生成(名称相同，文件名后附加一个`_`，例如`OriginalActivity_.java`)，该子类将包含注释保存下来的所有样板代码！

所以，除了`@Eactivity`(允许活动使用安卓注释)、`@ViewById`(注入你的观点)，你还有`@Get`、`@Post`、`@Put`等等。

让我们看看如何通过 JSON 示例从安卓注释中受益(从`Ifconfig.me`获取 IP 地址)。

```java
@EActivity(R.layout.activity_main)
public class MainActivity extends Activity {

   private IfConfigMeJson all;

   //inject the view to the activity layout
    @ViewById(R.id.result_text)
    TextView resultTextView;

    //inject the Rest service that wraps RestTemplate
    @RestService
   IfConfigMeRestClient restClient;

    //Use the Rest Service in a background thread
    @Background
    @AfterInject
    void getAllInfo() {
       all = restClient.getAll();
    }

    //wait a few seconds for the service to finish
   @UiThread(delay = 5000)
   @AfterViews
   void afterViews() {
      resultTextView.setText("Your IP is : "+all.getIpAddr());
   }

}
```

代码肯定少了，对吧？

您可能已经注意到，我们正在使用一个名为`IfConfigMeRestClient`的新类:

```java
@Rest(rootUrl = "http://ifconfig.me", converters = 
      { MappingJacksonHttpMessageConverter.class })
public interface IfConfigMeRestClient {

   @Get("/all.json")
   @Accept(MediaType.APPLICATION_JSON)
   IfConfigMeJson getAll();

}
```

此类配置`RestTemplate`，提供转换器类、使用的 HTTP 动词、映射类(`IfConfigMeJson`)和接受的媒体类型。

安卓注释为安卓的`RestTemplate`提供了对 Spring 的良好支持(关于基于`RestTemplate`的注释的列表，请参见[https://github.com/excilys/androidannotations/wiki/Rest-API](https://github.com/excilys/androidannotations/wiki/Rest-API)，我建议您尝试一下，看看您是否更喜欢在基于安卓的 Spring 项目中使用它。

### 注

如果你从零开始使用安卓注释开始一个项目，我建议你仔细遵循那些环境说明:[https://github . com/excilys/androidannocations/wiki/Building-Project-Maven-Eclipse](https://github.com/excilys/androidannotations/wiki/Building-Project-Maven-Eclipse)。

# 快速启动–OAuth

**OAuth** 正如维基百科所说，是一个开放的授权标准。

OAuth 允许用户与网站或桌面或移动应用程序共享托管在服务提供商上的数据或资源。

当然，如果你把你的凭证(用户名和密码)给了那些网站或应用程序，他们可以代表你访问你的数据；但是你会相信第三方应用程序或网站来保护你的凭证(你数字生活的钥匙)的安全吗？如果这个应用或网站是恶意的呢？还是简单的无担保？你读过多少次网站的用户凭证被盗，或者在数据库中以纯文本形式保存密码的故事？

OAuth 就是这个意思；让第三方应用程序或网站对您的数据进行有限访问(通过授权或范围列表:`access user email`、`access user profile`、`can post messages on user behalf`等)，由服务提供商托管(著名的 OAuth 服务提供商有谷歌、脸书、推特、雅虎！、GitHub、LinkedIn 等等)而从来没有给他们你的凭证。

## 依靠服务提供商开发网站或应用

你有没有注意到某些网站上那些用脸书登录的**或者用谷歌**登录的**按钮(比如[【Deezer.com】](http://Deezer.com)[【StackOverFlow.com】](http://StackOverFlow.com)等等)，或者你有没有在安卓设备上用第三方推特 app(比如 Twicca)请求你的推特凭证？**

所有这些网站和应用程序都使用 OAuth 来访问您的数据:

*   首先，他们为你省去了创建和记住其他证书的麻烦。它们甚至通过访问您的数据(如您的个人资料图片、活动信息等)来丰富您的用户体验。
*   此外，他们聚集了更多的受众(因为用户不必经历繁琐的帐户创建过程)，并且他们不必管理身份验证凭据(及其风险)或授权。

通常，如果一个网站或应用程序创建者想要从提供 OAuth 授权的服务中获益，他/她必须向 OAuth 服务提供商(谷歌、脸书等)注册，后者将依次为他/她提供一个**客户 ID** 和**客户秘密**值:

![Developing a website or an app relying on a service provider](img/1905_04_01.jpg)

使用谷歌应用编程接口控制台注册一个新的应用程序，并将其与一个客户端标识和一个客户端密码相关联

让我们来看看这个客户端标识和客户端密码是如何让应用程序访问用户数据的。

## OAuth 舞蹈

安卓应用程序(或任何其他已安装的应用程序)依赖于像谷歌这样的 OAuth 2.0 服务提供商。让我们通过以下五个简单的步骤来看看 OAuth 授权过程的工作流程:

1.  The user launches the app for the first time; it will generate the token request – a URL to the service provider, including the app client ID and client secret, and also the several authorizations needed for the app (user info, userinfo e-mail, and so on).

    谷歌 OAuth 2.0 服务提供商的一个例子:

    ```java
    https://accounts.google.com/o/oauth2/auth?
    client_id=508046100884-o6jgcn8e7c1g5gklhc8gibr80ouio8df.apps.googleusercontent.com&
    response_type=code&
    redirect_uri=http://localhost&
    scope=https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/plus.me
    ```

2.  这个网址是由安卓 Chrome 浏览器加载的，很可能是由于网络视图而嵌入到应用程序中的。用户被要求接受或拒绝应用程序要求的授权。
3.  In return, if the user grants the app, the app will intercept the response from the embedded browser that contains an authorization code.

    谷歌 OAuth 2.0 服务提供商的回应示例:

    ```java
    http://localhost/?code=4/urIB_wqrOqGpX-2w1UPXD8dHQAYO.ArEX_6EbNP0ZuJJVnL49Cc98lfsNdgI
    ```

4.  The app will finally exchange this authorization code for a token (if the lifetime of the token is limited, the app will also receive a refresh token and the expire time). This access token will be saved securely by the app.

    谷歌 OAuth 2.0 服务提供商的令牌请求/响应示例。

    **请求**:

    ```java
    POST /o/oauth2/token HTTP/1.1
    Host: accounts.google.com
    Content-Type: application/x-www-form-urlencoded

    code=4/v6xr77ewYqhvHSyW6UJ1w7jKwAzu&
    client_id=8819981768.apps.googleusercontent.com&
    client_secret={client_secret}&
    redirect_uri=https://oauth2-login-demo.appspot.com/code&
    grant_type=authorization_code
    ```

    **回应**:

    ```java
    {
      "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
      "expires_in":3920,
      "token_type":"Bearer",
      "refresh_token":"1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI"
    }
    ```

5.  The app will finally be able to interact with the resource (such as a REST service), provided it sends a valid token along with each of its requests.

    使用谷歌 OAuth 2.0 服务提供商令牌的请求示例:

    ```java
    GET /oauth2/v1/userinfo HTTP/1.1
    Authorization: Bearer 1/fFBGRNJru1FQd44AzqT3Zg
    Host: googleapis.com
    ```

### 注

大多数(如果不是全部的话)OAuth 2.0 服务提供商将只接受 HTTPS 的授权服务呼叫，以确保令牌不会被拦截。

![The OAuth dance](img/1905_04_02.jpg)

从[https://developers.google.com/accounts/docs/OAuth2](https://developers.google.com/accounts/docs/OAuth2)访问谷歌用户信息服务的 OAuth 工作流程

### 注

你可以阅读[https://developers . Google . com/accounts/docs/OAuth 2 installedapp](https://developers.google.com/accounts/docs/OAuth2InstalledApp)了解谷歌 OAuth 2.0 服务提供商的具体情况，或者[http://developers . Facebook . com/docs/concepts/log in/log in-architecture/](http://developers.facebook.com/docs/concepts/login/login-architecture/)了解脸书 OAuth 2.0 服务提供商的具体情况。

强烈建议在开始使用客户端应用程序之前阅读 OAuth 服务提供者文档(它们都有一些细微的区别，例如请求令牌的参数、回调 url 等)。

## 安卓授权模块的春天

安卓的 Spring`Auth`模块同时支持 OAuth 1.0a 和 OAuth 2.0。

简而言之:

*   OAuth 2.0 允许更好地支持非网络应用程序(如安卓应用程序)
*   OAuth 2.0 不再要求开发人员使用加密技术
*   OAuth 2.0 访问令牌是*短命*(感谢刷新令牌)

### 注

想要了解更多关于 OAuth 2.0 的信息，可以阅读他博客上 *Eran Hammer* 的几篇文章:[http://hueniverse.com/2010/05/introducing-oauth-2-0/](http://hueniverse.com/2010/05/introducing-oauth-2-0/)

安卓`Auth`模块的春天取决于以下几点:

*   安卓核心的 Spring(常用类:`Base64`、`StringUtils`、资源抽象等等)
*   安卓的春天`RestTemplate` (REST API 抽象出下面的 HttpClient)
*   Spring Social Core(包装 OAuth 流的 OAuth 1.0 和 2.0 API:请求授权代码、请求令牌等等)
*   Spring Security Crypto(支持对称加密、密钥生成和密码编码)

`Auth`模块本身为安卓定义了加密和 SQL 类(使您能够将授权令牌安全地保存到 SQLite 安卓数据库中)。

### 注

安卓的`Auth`spring 目前只包含七个类，分别是关于支持在安卓设备上持久化 OAuth 令牌；所有的 OAuth 代码都在 Spring Social Core 中。

为了让推特、脸书和谷歌应用开发者的生活更轻松，Spring Social 有了扩展，分别命名为 Spring Social 推特、Spring Social 脸书和 Spring Social 谷歌。这些定义了访问每个社交网络中的用户信息、帖子、联系人和议程的 API。

## 一个使用谷歌的 OAuth 示例

我们将构建一个显示一个谷歌用户信息的安卓应用:我们将使用 Spring for Android `Auth`当然，但更重要的是 Spring Social 和 Spring Social Google。

### 注

官方文件的例子是关于脸书和推特的。如果你想创建一个与这些社交网络互动的应用，看看 https://github.com/SpringSource/spring-android-samples 的安卓春季示例。

我们来看看这个项目的`pom.xml`文件，特别是 Spring Social Google 的收录情况:

```java
<dependency>
  <groupId>org.springframework.social</groupId>
  <artifactId>spring-social-google</artifactId>
  <version>1.0.0.M1</version>
  <exclusions>
    <!-- Exclude in favor of Spring Android RestTemplate -->
    <exclusion>
      <artifactId>spring-web</artifactId>
      <groupId>org.springframework</groupId>
      </exclusion>
      <exclusion>
      <artifactId>spring-core</artifactId>
      <groupId>org.springframework</groupId>
    </exclusion>
  </exclusions>
</dependency>
[...]
<repository>
  <id>spring.social.google</id>
  <name>Spring Social Google</name>
  <url>https://github.com/GabiAxel/maven/raw/master/</url>
</repository>
```

你会注意到这里(在`repository`部分)，这个模块并不是由 Spring Source 托管的，因为它实际上是一个没有 Spring Source 背书的社区项目。

### 注

这个`pom.xml`文件包含很多排除项；这是因为使用的大多数库都是在开发 Java SE 时考虑到的，这就是为什么它们依赖 Spring Core、Spring MVC 等等。安卓核心的 Spring 和`RestTemplate`为这些模块提供了必要的依赖。

现在我们来看看`AndroidManifest.xml`文件:

```java
[...]
<application
    android:name=".MainApplication"
    android:icon="@drawable/app_notes"
    android:label="@string/app_name" >
    <activity
        android:name=".GoogleActivity"
        android:label="@string/title_main" >
        [...]
    </activity>
    <activity
        android:name=".GoogleWebOAuthActivity"
        android:excludeFromRecents="true"
        android:noHistory="true" />
    <activity android:name=".GoogleProfileActivity" />
</application>
```

在我们的例子中，我们将首次使用一个`Application`类，在这里命名为`MainApplication`。

### 注

`GoogleWebOAuthActivity`将嵌入一个浏览器，只会启动进行认证。我们不希望此活动成为应用程序历史的一部分，也不希望用户能够返回；这就是为什么我们增加了`android:noHistory="true"`和`android:excludeFromRecents="true"`。更多信息可在[获取。](http://developer.android.com/guide/topics/manifest/activity-element.html)

本课程将用于准备我们应用程序中最重要的两个工厂(它们将在所有活动中访问):`ConnectionFactoryRegistry`和`ConnectionRepository`:

```java
public class MainApplication extends Application {
  private ConnectionFactoryRegistry connectionFactoryRegistry;
  private SQLiteOpenHelper repositoryHelper;
  private ConnectionRepository connectionRepository;

  // ***************************************
  // Application Methods
  // ***************************************
  @Override
  public void onCreate() {
    // create a new ConnectionFactoryLocator and populate it with Google ConnectionFactory
    this.connectionFactoryRegistry = new ConnectionFactoryRegistry();
    this.connectionFactoryRegistry.addConnectionFactory(new GoogleConnectionFactory(getClientId(),
        getClientSecret()));

    // set up the database and encryption
    this.repositoryHelper = new SQLiteConnectionRepositoryHelper(this);
    this.connectionRepository = new SQLiteConnectionRepository(this.repositoryHelper,
        this.connectionFactoryRegistry, AndroidEncryptors.text("password", "5c0744940b5c369b"));
  }
```

如您所见，在`onCreate()`方法中，我们初始化:

*   `ConnectionFactoryRegistry`:使用来自`ConnectionFactoryRegistry`的客户端 ID 和应用程序的客户端机密，我们将可以访问`GoogleConnectionFactory`，这是`OAuth2ConnectionFactory`的谷歌服务扩展，允许访问所有 OAuth 操作
*   `ConnectionRepository`:这将负责持久化`ConnectionFactoryRegistry`，这样就可以检索 OAuth 令牌，而不需要每次都做整个 OAuth 工作流

### 注

您可能已经注意到在数据库初始化期间使用了 salt 和密码(加密)。

这将阻止恶意应用程序访问设备数据库来检索用户 OAuth 令牌。一个简短的提醒:该应用将永远无法访问用户的谷歌密码。对服务提供商(在本例中为谷歌)的身份验证总是从设备浏览器执行。

让我们来看看那个项目的主要活动，`GoogleActivity`将在启动时启动:

```java
@Override
public void onStart() {
  super.onStart();
  if (isConnected()) {
    showGoogleOptions();
  } else {
    showConnectOption();
  }
}

private boolean isConnected() {
  return connectionRepository.findPrimaryConnection(Google.class) != null;
}
```

如果用户已连接，此活动将显示与用户配置文件相关的条目列表；如果用户尚未连接，则仅显示一个**连接**按钮(由于`GoogleConnectionFactoryRegistry`保存在数据库中，因此只需在`ConnectionRepository`中查找类型为`Google`的连接就足以知道是否已经获取了访问令牌)。

![An OAuth example using Google](img/1905_04_03.jpg)

用户尚未登录时的谷歌活动

所以，在我们没有连接的情况下，录下**连接**将调用`displayGoogleAuthorization()`，这将启动`GoogleWebOAuthActivity`。

`GoogleWebOAuthActivity`肯定是这个 app 最重要的活动。它负责 OAuth 2.0 身份验证和授权。

```java
@Override
public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);

  //javascript is mandatory
  getWebView().getSettings().setJavaScriptEnabled(true);

  // Using a custom web view client to capture the access token
  getWebView().setWebViewClient(new GoogleOAuthWebViewClient());

  this.connectionRepository = getApplicationContext().getConnectionRepository();
  this.connectionFactory = getApplicationContext().getGoogleConnectionFactory();
}

@Override
public void onStart() {
  super.onStart();

  // display the Google authorization page
  getWebView().loadUrl(getAuthorizeUrl());
}

// ***************************************
// Private methods
// ***************************************
private String getAuthorizeUrl() {
  String redirectUri = getString(R.string.google_oauth_callback_url);
  String scope = getString(R.string.google_scope);

  // Generate the Google authorization url to be used in the browser 
  OAuth2Parameters params = new OAuth2Parameters();
  params.setRedirectUri(redirectUri);
  params.setScope(scope);
  return this.connectionFactory.getOAuthOperations().buildAuthorizeUrl(GrantType.AUTHORIZATION_CODE, params);
}
```

创建此活动时，它将相关联的 WebView(您会注意到此活动扩展了`AbstractWebViewActivity`，将 Chrome Browser 实例注入到 WebView 中)配置为接受 JavaScript(服务提供商和 Google OAuth 2.0 要求 JavaScript 对用户进行身份验证)，并注入一个自定义的`WebViewClient`对象，我们将使用该对象来拦截 OAuth 流(稍后将详细介绍)。

然后，当活动开始时，我们要求 WebView(嵌入式 Chrome 浏览器)请求该应用的授权码(参见*OAuth dance*部分的第 1 步)。

这个请求是使用回调网址、应用程序所需的授权范围以及客户端标识和密码(这两个在我们创建`ConnectionFactoryRegistry`时已经给了 Spring OAuth)构建的。

```java
<resources>
    <string name="google_app_id">508046100884-o6jgcn8e7c1g5gklhc8gibr80ouio8df.apps.googleusercontent.com</string>
    <string name="google_app_secret">RuUyrF5qoGYWTFm1r_o8Gs4F</string>
    <string name="google_oauth_callback_url">http://localhost</string>
    <string name="google_scope">https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/plus.me</string>
</resources>
```

### 注

这里的回拨网址是 [http://localhost](http://localhost) ，因为谷歌 OAuth 2.0 服务商给出了 [http://localhost](http://localhost) 和`urn:ietf:wg:oauth:2.0:oob`之间的选择。

这将影响持有授权码的响应；它是查询字符串参数的一部分还是在浏览器的标题栏中。详情可阅读[https://developers . Google . com/accounts/docs/oauthiinstalledapp # choosingredirecturi](https://developers.google.com/accounts/docs/OAuth2InstalledApp#choosingredirecturi)。

如果用户还没有从他的设备验证任何谷歌网络服务，他/她应该会看到一个对话框邀请他/她验证:

![An OAuth example using Google](img/1905_04_04.jpg)

仅当用户尚未通过其设备上任何谷歌服务的验证时，此对话框才会出现

不过，在所有情况下，用户都会看到这个授权对话框，其中列出了应用程序请求的所有*范围*:

![An OAuth example using Google](img/1905_04_05.jpg)

Google OAuth 2.0 服务提供商授权对话框

### 注

如果用户拒绝授权，那么正如预期的那样，授权过程将被终止。

根据服务提供商的不同，此对话框可能会有所不同。

一旦用户接受了请求的授权，`GoogleWebOAuthActivity`将检测到网络客户端被重定向到本地主机(**回叫 URI** ，授权代码:

```java
private class GoogleOAuthWebViewClient extends WebViewClient {

  private static final String LOCALHOST = "localhost";
  private static final String CODE = "code";

  /*
   * The WebViewClient has another method called shouldOverridUrlLoading which does not capture the javascript 
   * redirect to the success page. So we're using onPageStarted to capture the url.
   */
  @Override
  public void onPageStarted(WebView view, String url, Bitmap favicon) {
    // parse the captured url
    Uri uri = Uri.parse(url);
     // log the url : very interesting for debugging the OAuth workflow
    Log.d(TAG, url);

    /*
     * The WebViewClient is launched to load an URL from the provider that will ask the user whether or not he accepts our app to access his data.
     * Once the provider successfully gets the approval from the user, it will redirect this WebViewClient to the callback_uri, with a query parameter named "code" : this is the authorization code
     */
    String host = uri.getHost();
    String code = uri.getQueryParameter(CODE);

    // The WebViewClient is redirected to the callback_uri, let's trade the authorization code for the access token
    if (LOCALHOST.equals(host)) {
      if(!exchangeAuthorizationCodeForAccessToken.getStatus().equals(AsyncTask.Status.RUNNING)) {
        exchangeAuthorizationCodeForAccessToken.execute(code);
        Toast.makeText(getApplicationContext(), "Redirecting you to the app main activity", Toast.LENGTH_LONG).show();
        //preparing to quit this activity for the main activity
        getWebView().setVisibility(View.INVISIBLE);
      }
    }
  }
}
```

`exchangeAuthorizationCodeForAccessToken.execute(code)`将执行以下 AsyncTask(我们将从我们的 app 发回授权代码，使用`RestTemplate`，依靠 Java `UrlConnection`，所以我们需要从后台线程对这个调用进行编码):

```java
private AsyncTask<String, Void, Void> exchangeAuthorizationCodeForAccessToken =  new AsyncTask<String, Void, Void>() {

  private Exception exception;

  @Override
  protected Void doInBackground(String... params) {
    // executed by a background thread
    //params[0] should contain the authorization code
    try {
      AccessGrant exchangeForAccess = connectionFactory.getOAuthOperations().exchangeForAccess(params[0], getString(R.string.google_oauth_callback_url), null);
      Connection<Google> connection = connectionFactory.createConnection(exchangeForAccess);
      connectionRepository.addConnection(connection);
    } catch (DuplicateConnectionException e) {
      Log.e(TAG,"something went wrong when adding the accessToken to the connection repository",e);
      exception = e;
    } catch (Exception e) {
      Log.e(TAG,"something went wrong when adding the accessToken to the connection repository",e);
      exception = e;
    }
    return null;
  }

  @Override
  protected void onPostExecute(Void result) {
    // executed by the UI thread once the background thread is done getting the result
    if(exception != null) {
      Toast.makeText(getApplicationContext(), exception.getMessage(), Toast.LENGTH_LONG).show();
    }
      // we go back to the main activity to display the options
      displayGoogleOptions();
  }

};
```

一旦调用了`exchangeForAccess`方法，我们检索用户令牌并将其保存在`ConnectionRepository`类中。

我们的应用程序终于被授权访问用户的谷歌个人资料！

![An OAuth example using Google](img/1905_04_06.jpg)

用户尚未登录时的谷歌活动

如果用户点击**简介**，他将启动`GoogleProfileActivity`，正如您所料，我们将从中获得用户简介。

为此，我们使用名为`FetchProfileTask`的 AsyncTask，它将访问两个谷歌网络服务:`UserOperations`(读取用户的主要个人资料和他/她的个人资料图片)和`PersonOperations`(读取他/她的谷歌+个人资料，这里我们将只访问关于我的**描述):**

```java
@Override
protected LegacyGoogleProfile doInBackground(Void... params) {

    LegacyGoogleProfile userProfile = google.userOperations().getUserProfile();
    aboutMe = google.personOperations().getGoogleProfile().getAboutMe();
    profileBitmap = BitmapFactory.decodeStream(new URL(userProfile.getProfilePictureUrl()).openConnection().getInputStream());
    return userProfile;

}
```

该信息然后被注入到视图中:

![An OAuth example using Google](img/1905_04_07.jpg)

谷歌个人资料活动显示用户个人资料图片、“关于我”的描述和一些个人资料信息

# 你应该了解的人和地方

如果你需要安卓系统的 Spring(或者一般的 REST 或者 OAuth)的帮助，以下是一些人和地方，它们将被证明是无价的。

## 官方网站

*   主页:[http://www.springsource.org/spring-android](http://www.springsource.org/spring-android)
*   手册和文档:[http://static . springsource . org/spring-Android/docs/1.0 . x/reference/html single/](http://static.springsource.org/spring-android/docs/1.0.x/reference/htmlsingle/)
*   博客:[http://blog.springsource.org/category/android/](http://blog.springsource.org/category/android/)
*   源代码:[https://github . com/springsource/spring-Android](https://github.com/SpringSource/spring-android)
*   官方示例的源代码:[https://github.com/SpringSource/spring-android-samples](https://github.com/SpringSource/spring-android-samples)
*   Android Maven 插件:[http://code . Google . com/p/maven-Android 插件/](http://code.google.com/p/maven-android-plugin/)

## 文章和教程

*   OAuth 解释:[http://hueniverse.com/oauth/guide/](http://hueniverse.com/oauth/guide/)
*   谷歌服务的 OAuth:[http://support.google.com/a/bin/answer.py?hl=en&答案=61017](http://support.google.com/a/bin/answer.py?hl=en&answer=61017)
*   关于远程连接的官方 Android 文档:[http://developer . Android . com/training/basic/network-ops/connecting . html](http://developer.android.com/training/basics/network-ops/connecting.html)

## 社区

*   官方论坛:[http://forum.springsource.org/forumdisplay.php?88-Android](http://forum.springsource.org/forumdisplay.php?88-Android)
*   官方 bug 追踪器:[https://jira.springsource.org/browse/ANDROID](https://jira.springsource.org/browse/ANDROID)

## 博客

*   安卓团队博客:[http://android-developers.blogspot.ca/](http://android-developers.blogspot.ca/)

## 推特

*   关注推特上安卓的春天:[https://twitter.com/springandroid](https://twitter.com/springandroid)
*   在推特上关注罗伊·克拉克森(安卓首席开发者之春):[https://twitter.com/royclarkson](https://twitter.com/royclarkson)
*   欲了解更多开源信息，请访问:http://twitter.com/#!/packtopensource**