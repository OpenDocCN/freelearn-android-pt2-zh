# 第二章。绘制螺纹

线程是可由操作系统独立管理的最小指令序列。通常，单个任务是在单个进程中的单个线程中实现的，但是，如果我们想要改变正常行为并希望多个任务同时运行，我们将使用多线程。线程共享相同的进程资源，但独立执行。如果系统只有一个处理器，可能会出现任务同时处理的情况，但事实并非如此。实际上，对于单个处理器，处理线程的分配是从一个线程切换到另一个线程的，但是这种切换是如此之快，以至于它看起来是同时被处理的。如果系统有多个处理器，两个线程可以同时执行——彼此并行。多线程是一种执行模型，其中在单个进程中可以执行多个线程。线程可以有多种使用方式，每种都有自己的重要性；例如，或者同时执行多个任务，或者如果需要在后台处理某些事情，而前端保持响应和活动状态，则从主线程转移负载。这是安卓应用程序的理想情况，因为我们必须保持最大可能的负载远离主线程，并保持前端的响应和活动。如果我们不这样做，并保留消耗大量处理器功率和内存的繁重操作，应用程序可能会无响应，甚至要求我们强制关闭。

这一章的目的是为了明确对 Android 中线程的理解。我们不会深入挖掘线程及其编码的细节，但会对 Android 中的线程有一个基本的了解。这有什么已知的问题？为什么安卓线程在画图和 Canvas 方面很重要？我们将看到一个简单的代码结构，通过它我们希望我们的任务在另一个线程上运行。

在安卓系统中，所有应用程序都运行在一个线程上。所有指令都按顺序运行，这意味着除非第一条指令完成，否则第二条指令不会启动。这个主线程也被称为 **UI** ( **用户界面**)线程，因为它负责绘制屏幕上的所有对象或视图，并处理所有事件，如屏幕触摸和按钮点击。现在的问题是，如果我们有两个操作被安排在同一个默认线程或 UI 线程中运行，而第一个操作完成的时间太长，系统会要求用户强制关闭应用程序或等待进程完成。这个场景叫做 **ANR** ( **应用不响应**)。

# 画螺纹的需要

我们知道我们将处理图像、绘图和其他图形处理，我们也知道它们对系统资源的要求相当高。因此，我们希望非常仔细地设计我们的应用程序，牢记性能。如果我们忽略了这一点，将我们所有的图像、位图、图形和其他图形处理项目放在默认的 UI 线程上，会怎么样？这是新的安卓开发人员的工作方式——将所有内容保存在默认活动的代码中，这意味着将所有负载保持在用户界面线程上。默认活动是我们希望在应用程序运行时首先加载的活动。UI 线程是执行我们的应用程序的主要线程。这是应用程序大部分代码运行的线程。应用程序组件如`Activities`、`Services`、`ContentPorviders`和`BroadcastReceivers`在此线程中创建。这种情况下会发生什么？即使我们的应用程序是这个星球上最有用、最有吸引力的应用程序，也不会持续一天。每次用户运行我们的应用程序，它最终都会无响应。玩家在 Play Store 上的一些愤怒的评论，我们的应用就完成了。我们将失去这个想法，因为到那时它将是公开的，我们也将失去我们的观众。为了解决这个问题，我们将把所有的辛苦和繁重的工作从主 UI 线程转移到另一个线程。理想情况下，当它运行时，看起来所有的线程都是并行运行的，但这只是在多个 CPU 的情况下。如果只有一个 CPU 但支持多线程，系统会决定启动哪个线程和停止哪个线程，但不会永久停止任何线程。因此，控件将在运行的线程之间切换，看起来好像所有线程都在并行运行。

# 安卓多线程的问题

我们将把我们繁重的、消耗资源的操作放在一个单独的线程上，但是在安卓中，这产生了一个问题，这就是为什么不允许其他线程更新负责所有用户界面元素和进程的主用户界面线程的原因。为了解决这个问题，我们需要将其与 UI 线程的当前状态同步。安卓提供了一个专门处理这个问题的类。叫做`AsyncTask`班。我们将在本章后面讨论这个问题。

# 线程类

`Thread`和`Runnable`类是使我们能够使用多线程的基本类，但是它们的功能非常有限，但是仍然为`AsyncTask`、`HandlerThread`、`IntentService.Thread`和`ThreadPoolExecuter`提供了基础。这些类自动管理线程，并且可以并行运行多个线程。

以下是`Runnable`类的一段示例代码:

```java
public class ImageReSize implements Runnable {
  public void run(){
    //the main functionality of the thread comes here
  }
}
```

如果我们希望我们的线程在后台运行，我们将在前面提到的`run()`方法中添加以下一行:

```java
Android.os.Process.setThreadPriority(Android.os.Process.THREAD_PRIORITY_BACKGROUND);
```

假设我们有自己的`Runnable`课。我们仍然不能在用户界面上显示任何东西，因为只有用户界面线程执行用户界面对象，比如视图。运行在用户界面线程上的对象可以访问其他对象。现在，在我们的线程上运行的任务不在用户界面线程上，因此它们不能访问用户界面对象。为了让我们的任务能够访问用户界面线程上的用户界面对象，我们必须使用能够将数据从后台线程移动到用户界面线程的东西。如果一个线程在后台运行，它需要在 UI 上做一些改变，它不能自己做，而是会使用`runOnUiThread`提供的工具，这将使我们能够在主 UI 线程上的后台线程内部运行代码。可选地，我们可以使用`Handler`对象。

### 类型

**下载示例代码**

您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

## 在 UI 线程上运行的处理程序对象

要对在 UI 线程上运行的`Handler`对象进行编码，首先应该在 UI 线程上定义一个`Handler`对象，然后将数据存储在一个`Task`对象中。对象的状态应该发送到对象的层次结构中。当我们完成这些后，数据应该被移动到 UI 线程。我们这样做是为了实现我们的目标，即在后台的另一个线程上运行任务，并在需要时与主用户界面线程通信，以获得我们想要的输出。然而，这需要大量的努力。

![Handler objects that run on the UI thread](graphics/5396_02_01.jpg)

## 异步任务

为了显著减少的工作量和复杂性，安卓提供了`AsyncTask`类。这个类会将我们的任务分配到后台的另一个线程上运行，需要时会自动与 UI 线程进行通信，节省了我们花费在`Handler`对象上的时间和精力。为了完成这项工作，我们将创建一个类来扩展`AsyncTask`，加入我们的功能，并执行我们的应用程序。`AsyncTask`会为我们做很多。

# 总结

在本章中，我们了解了以下内容:

*   一个简单安卓应用的线程结构
*   用户界面线程的角色及其功能
*   需要让大量消耗资源的操作远离主用户界面线程
*   不是用户界面线程的线程的限制
*   如何使用`Handler`对象处理问题并与 UI 线程通信
*   实现`Runnable`接口的类的代码结构，使我们能够使用线程
*   安卓以`AsyncTask`类的形式提供给我们的设施；我们也了解了它的重要性

在下一章中，我们将学习`Drawable`类和使用来自资源和 XML 的图像在画布上绘图。在`View`和`SurfaceView`上的绘制以及圆等基本形状的绘制也将包括在内。