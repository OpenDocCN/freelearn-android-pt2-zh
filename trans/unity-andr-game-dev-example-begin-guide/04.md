# 第四章。设置舞台–摄像机效果和灯光

*在上一章中，您了解了任何游戏的基本构建模块:网格、材质和动画。我们创建了一个坦克战游戏，利用了所有这些区块。*

*在本章中，我们将展开坦克战游戏。我们将从添加天空盒和距离雾开始。相机效果的探索继续，目标指示器覆盖使用第二个相机。坦克的涡轮增压效果将完善我们对相机效果的看法。继续看看照明，我们将完成我们的坦克环境，增加光照图和阴影。*

在本章中，我们将涵盖以下主题:

*   Skyboxes
*   距离雾
*   使用多个摄像头
*   调整视野
*   添加灯光
*   创建光照贴图
*   添加饼干

我们将直接从[第 3 章](03.html "Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations")、*任何游戏的支柱——网格、材质和动画*中借用这个项目。所以，在 Unity 中打开它，我们就可以开始了。

# 相机效果

有许多伟大的相机效果，你应该添加给你的游戏最后一个伟大的点睛之笔。在本章中，我们将介绍几个易于添加的选项。这些也将给我们的坦克游戏一个伟大的成品外观。

## 天箱和距离雾

当相机渲染游戏的一帧时，它从清除屏幕开始。默认情况下，Unity 中的相机通过用纯蓝色着色所有内容来实现这一点。所有的游戏网格都被绘制在这个空白的屏幕上。对于一场激动人心的坦克大战来说，蓝色相当无聊。所以，幸运的是，Unity 允许我们改变颜色。但是，粉色并不比蓝色好，只好换个清屏的方法。这就是天箱的作用。skybox 只是构成任何游戏背景天空的一系列图像的一个奇特的词。距离雾与 skybox 配合使用，可以缓解模型和背景之间的视觉过渡。

# 行动时间-添加天空框和距离雾

显然，我们首先需要的是一个天箱。我们可以创造自己的；然而，Unity 为我们提供了几款非常适合我们需求的优秀产品。

1.  在统一编辑器的顶部，选择**资产**，然后选择**导入包**。在该列表的大约一半位置，选择**天空盒**。
2.  经过一点点处理后，会弹出一个新窗口。Unity 中的包只是已经在 Unity 中设置的一组压缩资产。该窗口显示内容，并允许我们有选择地导入它们。我们都想要，所以只需点击这个窗口右下角的**导入**。
3.  一个新的文件夹`Standard Assets`将被添加到**项目**窗口。这包含一个文件夹，`Skyboxes`，其中包含各种 skybox 材质。选择其中任何一个。您可以在**检查器**窗口中看到，它们是使用天空框着色器的普通材质。它们各有六个图像，每个方向一个。
4.  要将您选择的 skybox 添加到游戏中，首先要确保加载了正确的场景。如果没有，只需在**检查器**窗口中双击即可。这是必要的，因为我们将要更改的设置是特定于每个场景的。
5.  转到统一编辑器顶部，选择**编辑**，然后选择**渲染设置**。新的设置组将出现在**检查器**窗口中。
6.  目前我们关注的是倒数第五的数值**天箱材质**。只需将天箱素材拖放到**天箱素材**槽中，就会自动更新。可以在**游戏**窗口查看变化。
7.  为了增加距离雾，我们也在**渲染设置**中调整它。要打开它，只需点击**雾**复选框。
8.  下一个设置**雾色**，允许我们为雾选择一种颜色。选择一种接近天空盒子一般颜色的颜色是很好的。
9.  **雾模式**是一个下拉的选项列表，指定了 Unity 将用于计算距离雾的方法。几乎所有情况下 **Exp2** 的默认都是合适的。
10.  The next three settings, **Fog Density**, **Linear Fog Start**, and **Linear Fog End**, all determine how much fog there is and how close it starts. **Fog Density** is used for the **Exponential** and **Exp2** fog modes while the others are used for the **Linear** fog mode. Settings that put the fog at the edge of sight are generally good.

    ![Time for action – adding a skybox and distance fog](img/2014OT_04_01.jpg)

## *刚刚发生了什么？*

我们导入了几个 sky box并将其添加到场景中。距离雾设置也被打开和调整。现在，我们的场景开始看起来像一个真正的游戏。

## 目标指标

另一个相当有趣的相机效果是使用多个相机。第二个摄像头可以用来制作 3D 图形用户界面、小地图或者安全摄像头弹出窗口。在下一部分中，我们将创建一个指向附近目标的系统。使用第二个摄像头，我们将使它出现在玩家的坦克上方。

# 行动时间–创建指针

我们将从创建一个指向目标的对象开始。我们将制作一个可以重复使用的预制构件。但是，你需要一个模型让玩家看到。我们将使用扇形网格。尺寸不是特别重要；我们稍后会调整比例。让我们执行以下步骤来创建指针:

1.  创建并导入网格后，将其添加到场景中。
2.  创建一个空的`GameObject`并将其重命名为`IndicatorSlice`。
3.  Make your mesh a child of `IndicatorSlice` and position it so that it points along the GameObject's z axis. `IndicatorSlice` will be centered in our indicator. Each slice that is created will have its z axis pointing in the direction of a target.

    ![Time for action – creating the pointer](img/2014OT_04_02.jpg)

4.  现在，我们需要创建一个新的脚本来控制我们的指标。在**项目**窗口中创建一个名为**目标指示器**的新脚本。
5.  我们从一对变量开始这个脚本。第一个将包含该指示器将指向的目标的参考。该指标也将根据目标距离的远近而增减。第二个变量将控制指示器开始增长的距离。

    ```java
    public Transform target;
    public float range = 25;
    ```

6.  下一个功能将用于在创建指示件时设置`target`变量。

    ```java
    public void SetTarget(Transform newTarget) {
      target = newTarget;
    }
    ```

7.  最后一组代码进入`LateUpdate`功能。使用`LateUpdate`功能，以便在我们的坦克在`Update`功能中移动后，指示器可以指向目标。我们用一个检查来启动函数，以确保目标变量有一个值。如果为空，则指示器切片被破坏。`Destroy`功能可以用来移除游戏中存在的任何物体。`gameObject`变量由`MonoBehaviour`类自动提供，并保存对脚本组件所附加的`GameObject`的引用。摧毁它也会摧毁一切属于它的孩子(或附属于它的东西)。

    ```java
    public void LateUpdate() {
      if(target == null) {
        Destroy(gameObject);
        return;
      }
    ```

8.  代码的下一位设置指示器切片的比例。从下面的代码片段中可以看到，第一行代码使用`Vector3.Distance`来确定两个位置之间的距离。下一个代码行确定切片的垂直比例，即 y 轴。它是通过使用一些精心应用的数学和`Mathf.Clamp01`函数来实现的。该函数将提供的值限制在 0 和 1 之间。最后一行代码设置指示器切片的局部比例。通过调整局部比例，我们只需改变父对象的比例，就可以轻松控制整个指标有多大。

    ```java
    float distance = Vector3.Distance(transform.position, target.position);
    float yScale = Mathf.Clamp01((range - distance) / range);
    transform.localScale = new Vector3(1, yScale, 1);
    ```

9.  这个脚本的最后一组代码。`transform.LookAt`功能只是一种旋转`GameObject`的奇特的自动方式，因此它的 z 轴指向世界上的一个特定点。然而，我们希望所有的指示器切片平放在地面上，不要指向空中任何可能在我们上方的目标。所以，我们收集目标的位置。通过将变量的 Y 值设置为切片的位置，我们可以确保切片保持平坦。当然，最后一行关闭了`LateUpdate`功能。

    ```java
    Vector3 lookAt = target.position;
    lookAt.y = transform.position.y;
    transform.LookAt(lookAt);
    }
    ```

10.  这是这个脚本的最后一段代码。返回到 Unity，将`TargetIndicator`脚本添加到场景中的`IndicatorSlice`对象。
11.  为了完成指示器，创建一个它的预置。
12.  最后，从场景中删除`IndicatorSlice`对象。游戏开始时，我们将动态创建切片。那需要预制构件，但不是场景中的那个。

## *刚刚发生了什么？*

我们创建了一个物体的预设，我们将使用它来指示目标的方向。创建并附加的脚本将旋转预设的每个实例以指向目标。它还会调整刻度，以指示目标离玩家有多远。

# 行动时间-控制指示器

我们现在需要创建一个脚本来控制指示器切片。这将包括根据需要创建新切片。此外，它所连接的`GameObject`将作为我们刚刚创建的指示器切片的中心点旋转。

1.  创建一个新的脚本并命名为`IndicatorControl`。
2.  我们从一对变量开始这个脚本。第一个将包含对刚刚创建的预制体的引用。这将允许我们随时生成它的实例。第二个是静态变量，这意味着无需引用场景中存在的组件就可以轻松访问它。当游戏开始时，它将被场景中这个脚本实例的引用所填充。

    ```java
    public GameObject indicatorPrefab;
    private static IndicatorControl control;
    ```

3.  目标将使用下一个函数。很快，我们将在游戏开始时更新目标的脚本来调用这个函数。该函数是静态的，就像变量一样，并从检查是否有对其中任何对象的引用开始。如果为空，等于空，则使用`Object.FindObjectOfType`尝试填充变量。通过告诉它我们想要找到什么类型的对象，它会在游戏中搜索并尝试找到一个。这是一个相对缓慢的过程，不应该经常使用，但是我们使用这个过程和变量，这样我们就可以始终确保系统可以找到脚本。`CreateSlice`函数的第二部分检查以确保我们的静态变量不是空的。如果是，它会告诉实例创建一个新的指示器切片，并将其传递给目标。

    ```java
    public static void CreateSlice(Transform target) {
      if(control == null) {
        control = Object.FindObjectOfType(typeof(IndicatorControl)) as IndicatorControl;
      }

      if(control != null) {
        control.NewSlice(target);
      }
    }
    ```

4.  这个脚本还有一个功能。`NewSlice`函数顾名思义，它在被调用时创建新的指示器切片。首先使用`Instantiate`功能创建一个传递给它的`GameObject`副本。函数的第二行使新切片成为控件转换的子切片。下一行只是将新切片的局部位置清零。这样，它将在创建后正确居中。最后一行使用切片的`SendMessage`函数调用我们之前创建的`SetTarget`函数，并将其传递给所需的目标对象。

    ```java
    public void NewSlice(Transform target) {
      GameObject slice = Instantiate(indicatorPrefab) as GameObject;
      slice.transform.parent = transform;
      slice.transform.localPosition = Vector3.zero;
      slice.SendMessage("SetTarget", target);
    }
    ```

5.  现在脚本已经创建，我们需要使用它。创建一个空的`GameObject`并命名为`IndicatorControl`。
6.  新的`GameObject`需要成为你的坦克的孩子，然后在每个轴上将其位置设置为零。
7.  将我们刚刚创建的脚本添加到`IndicatorControl`。
8.  最后，选择`GameObject`后，添加对`IndicatorSlice`预制体的引用。通过将预制构件从**项目**窗口拖到**检查器**窗口的适当位置来完成。

## *刚刚发生了什么？*

我们创建了一个脚本来控制目标指示器切片的生成。我们在最后创建的`GameObject`也将允许我们轻松控制整个指示器的大小。我们几乎完成了目标指标。

# 行动时间-使用第二个摄像头

如果你现在玩这个游戏，它看起来还是一样的。这是因为目标尚未调用创建指示器切片。当我们完成目标指示器时，我们还将在这一部分添加第二个摄像头。

1.  Start by opening the `Target` script and adding the following line of code to the end of the `Awake` function. This line tells the `IndicatorControl` script to create a new indicator slice for this target.

    ```java
    IndicatorControl.CreateSlice(transform);
    ```

    ![Time for action – working with a second camera](img/2014OT_04_03.jpg)

2.  现在玩游戏时，你可以看到指示器在工作。但是，它可能太大了，肯定出现在油箱内部。一个糟糕的解决方案是移动`IndicatorControl`物体，直到整个物体出现在坦克上方。然而，当爆炸发生时，物体开始在空中飞行，它们会再次模糊目标指示器。更好的解决方案是增加第二个摄像头。现在从统一编辑器顶部选择**游戏对象**，然后选择**创建其他**，最后选择**相机**。
3.  另外，让相机成为`Main Camera`的孩子。务必将新相机的位置和旋转值设置为零。
4.  默认情况下，Unity 中的每个摄像头都有各种组件:**摄像头**、**照明弹层**、 **GUI 层**和**音频监听器**。除了**摄像头**组件之外，其他的对于每一个其他摄像头来说一般都不重要，整个场景中应该只有一个**音频监听器**组件。从相机中取出多余的组件，只留下**相机**组件。
5.  在我们使用相机做其他事情之前，我们需要更改`IndicatorSlice`预设所在的图层。图层用于引起对象之间的选择性交互。它们主要用于物理和渲染。首先在**项目**窗口中选择预设。
6.  在**检查器**窗口的顶部是带有下拉列表的**图层**标签，该下拉列表显示**默认**。点击下拉列表，选择**添加图层...**从列表中。
7.  图层列表现在将出现在**检查器**窗口中。这些都是游戏中用到的图层。前几个保留给 Unity 使用；因此，它们是灰色的。剩下的给我们用。点击**用户层 8** 右侧，命名为**指标**。
8.  再次选择`IndicatorSlice`预设。这次从**图层**下拉列表中选择新的**指示器**图层。
9.  Unity 会询问我们是否也要更改所有子对象的图层。我们希望整个对象渲染在这个层上，所以选择**是的，改变孩子**，我们将能够这样做。
10.  现在，回到我们的第二个摄像头。选择它，在**检查器**窗口中查看。
11.  **相机**组件的第一个属性是**清除旗帜**。这个选项列表规定了在绘制游戏中的所有模型之前，相机将在背景中填充什么。第二个摄像头不会遮挡第一个摄像头绘制的所有内容。我们从**清除标志**下拉列表中选择**仅深度**。这意味着，它不会将 skybox 放在背景中，而是将已经渲染的内容保留下来，并在顶部绘制新的东西。
12.  下一个属性**剔除遮罩**，控制相机渲染哪些层。前两个选项**无**和**一切**用于取消选择和快速选择所有图层。对于该相机，取消选择所有其他图层，以便只有**指示器**图层旁边有一个复选标记。
13.  The last thing to do is to adjust the scale of `IndicatorControl` so that the target indicator is not too large or small.

    ![Time for action – working with a second camera](img/2014OT_04_04.jpg)

## *刚刚发生了什么？*

我们创建了一个系统来指示潜在目标的方向。为此，我们使用了第二个摄像头。通过调整**剔除蒙版**属性中的图层，我们可以让相机只渲染场景的一部分。此外，通过将**清除旗帜**属性更改为**仅深度**，第二个相机可以在第一个相机绘制的基础上进行绘制。

## 来个围棋英雄——调整位置

通过移动摄像机可以改变指示器的绘制位置。如果您要移动`IndicatorControl`对象，它将改变计算目标的距离和方向的方式。移动并调整第二个摄像头的角度，以便目标指示器有一个更令人满意的视图。

当你移动第二个摄像头时，或者当你使用下一部分的助推时，你可能注意到目标指示器仍然可以在坦克中看到。调整主摄像机，使其不呈现目标指示器。这与我们如何让第二个相机只渲染目标指示器非常相似。

## 涡轮增压

我们将在本章中看到的最后一个相机效果是涡轮增压。这将是屏幕上的一个按钮，它将在短时间内推动玩家快速前进。相机效果的出现是因为对**视野**属性的简单调整可以让它看起来好像我们走得更快。电影也使用类似的方法，让追车看起来更快。

# 行动时间——利用助推效应

在这一部分，我们将只制作一个脚本。它将以类似于我们在上一章中创建的`ChassisControls`脚本的方式移动坦克。不同的是，我们不需要按下按钮就能启动。我们开始吧。

1.  首先创建一个新的脚本并调用它`TurboBoost`。
2.  要开始脚本，我们需要四个变量。首先是对`CharacterController`的引用。我们需要这个来移动。第二个是我们在推进的同时会有多快。第三个是多久，以秒为单位，我们将提高。最后一个在内部使用，表示我们是否可以提升，以及何时应该停止。

    ```java
    public CharacterController controller;
    public float boostSpeed = 50;
    public float boostLength = 5;
    public float startTime = -1;
    ```

3.  下一段代码返回给我们的好朋友，`OnGUI`函数。这里我们只是在屏幕上画一个按钮，和之前几次一样。如果按下按钮，它会调用我们马上要写的`StartBoost`功能。

    ```java
    public void OnGUI() {
      Rect turboRect = new Rect(10, Screen.height – 220, 75, 75);
      if(GUI.Button(turboRect, "Turbo"))
        StartBoost();
    }
    ```

4.  `StartBoost`功能相当简单。它检查 `startTime`变量是否小于零。如果是，变量设置为`Time.time`提供的当前时间。小于零意味着我们目前没有提高。

    ```java
    public void StartBoost() {
      if(startTime < 0)
        startTime = Time.time;
    }
    ```

5.  我们要使用的最后一个功能是`Update`功能。它从检查`startTime`开始，看看我们目前是否在提升。如果我们不提升，函数会提前退出。下一行代码检查以确保我们有我们的`CharacterController`参考。如果变量是空的，那么我们就不能让坦克移动。

    ```java
    public void Update() {
      if(startTime < 0) return;
      if(controller == null) return;
    ```

6.  下一行代码应该看起来很熟悉。这是让坦克移动的线。

    ```java
    controller.Move(controller.transform.forward * boostSpeed * Time.deltaTime);
    ```

7.  以下几行代码实际上应用了相机效果。首先是检查我们是否处于助推的前半秒。如果是，我们通过调整`fieldOfView`值来过渡相机。`Camera.main`值只是 Unity 提供给场景中使用的主摄像头的参考。 `Mathf.Lerp`函数获取一个起始值，并根据 0 到 1 之间的第三个值将其移向目标值。利用这一点，摄像机的`fieldOfView`在半秒钟内朝着我们的目标移动。这组代码的后半部分检查我们的提升的最后半秒，并使用相同的方法将`fieldOfView`值转换回默认值。

    ```java
    if(Time.time – startTime < 0.5f)
      Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 130, (Time.time - startTime) * 2);
    else if(Time.time – startTime > boostLength - 0.5f)
      Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 60, (Time.time – startTime – boostLength + 0.5f) * 2);
    ```

8.  最后一段代码检查我们是否完成了提升。如果是，将`startTime`设置为负一，表示我们可以开始另一次助推。当然，最后一个大括号关闭了`Update`功能。

    ```java
    if(Time.time > startTime + boostLength)
      startTime = -1;
    }
    ```

9.  我们快完成了。将脚本添加到你的坦克中，连接`CharacterController`参考。
10.  Try it out.

    ![Time for action – using the boost effect](img/2014OT_04_05.jpg)

## *刚刚发生了什么？*

我们创造了涡轮增压。上一章使用的相同移动方法将坦克移动到这里。通过调整相机的**视场**属性，我们让它看起来像坦克移动得更快。

## 有一个围棋英雄——造型和控制

这里简单而明显的挑战是设计按钮的样式。为了给它增加趣味，试着改变它，这样在增强时有一个标签，在不增强时有一个按钮。标签和按钮可以各有各的风格。

玩游戏时你可能会注意到的另一件事是，你仍然可以在助推时转身。尝试在`ChassisControls`脚本中添加一个检查来锁定控件，如果我们正在增强的话。您需要添加对`TurboBoost`脚本的引用。

对于额外的额外挑战，尝试增加一个冷却时间。让玩家不能一直使用提升。另外，如果坦克撞到什么东西，试着取消助推。这是一个大问题，所以你将从一个提示开始:看一看`OnControllerColliderHit`。

# 灯光

Unity 提供了多种灯光类型来点亮游戏世界。分别是**方向灯**、**聚光灯**、**点光源**、**面光源**。它们每一个都以不同的方式投射光线，并详细解释如下:

*   **方向灯**:这个功能很像太阳。它把所有的光都投射到一个方向。光的位置不重要，只有旋转。光以一个方向投射在整个场景上。这使得它非常适合最初为场景添加光线。
*   **聚光灯**:这个功能就像舞台上的一样。光以锥形的形状向特定的方向投射。正因如此，它也是最复杂的光型供系统计算。Unity 在计算灯光的方式上有了显著的改进，但是应该避免过度使用这些灯光。
*   **点光**:这是主要的光类型，将会在你的游戏中使用。向各个方向发光。这个功能就像一个灯泡。
*   **区域灯**:这是专用灯。它从平面向单一方向发光。可以把它想象成用来为酒店或餐馆做广告的大霓虹灯招牌。由于其复杂性，这些灯光只能在烘焙阴影时使用。游戏运行时，计算量太大，无法使用。

谈论灯光时，下一个明显的问题涉及阴影，尤其是实时阴影。虽然实时阴影为场景增加了很多东西，并且在任何平台上都是技术上可行的，但它们非常昂贵。除此之外，它们还是 Unity Pro 的一大特色。总的来说，这让它们对你的普通手机游戏来说有点太多了。

另一方面，有一些完全可行的替代方案，成本几乎没有实时阴影高，而且看起来也更真实。首先是为了你的环境。一般来说，游戏中的环境在特定的场景中从不移动，也从不改变。为此，我们有光照图。它们是包含阴影数据的额外纹理。使用 Unity 你可以在制作游戏时创建这些纹理。然后，当游戏运行时，它们会自动应用，您的阴影会出现。然而，这不适用于动态对象(任何移动的东西)。

对于动态对象，我们有 cookies。这些不是你奶奶的饼干。在照明中，饼干是一个黑白图像，在游戏中投射到网格上。这类似于皮影。影子木偶使用一个切口来阻挡一部分光线，而饼干使用黑白图像来告诉光线它可以投射光线的地方。

Cookies 还可以用来创建其他静态和动态的好效果，例如覆盖整个场景的云朵。也许是从笼子里投射出来的光。或者，你可以用它们来制作手电筒不均匀的焦点。

# 行动时间-增加更多灯光

给场景添加额外的灯光相当简单。此外，只要坚持使用点光源，渲染它们的成本就会很低。

1.  在统一编辑器的顶部，选择**游戏对象**，然后选择**创建其他**，最后选择**点光源**。
2.  选择新灯光后，在**检查器**窗口中有一些我们关心的属性。
    *   **范围**:这就是物体发出远光的方式。从这一点发出的光在中心最亮，当它达到范围的程度时，就会消失。在**场景**视图中，该范围还被表示为黄色线球。
    *   **颜色**:这简直就是光的颜色。默认为白色；然而，这里可以使用任何颜色。该设置在所有灯光类型之间共享。
    *   **强度**:这是光的亮度。光的强度越大，中心的光就越亮。该设置也在所有灯光类型之间共享。
3.  创建和定位几个更多的灯，沿着街道排列它们以增加一些环境的趣味性。
4.  Using *Ctrl* + *D* will duplicate the selected object. This can greatly speed up the creation process.

    ![Time for action – adding more lights](img/2014OT_04_06.jpg)

5.  添加这些灯时，您可能注意到了它们的一个主要缺点。实时影响一个表面的灯光数量是有限制的。通过使用更复杂的网格，可以在一定程度上避免这种情况。更好的选择是使用光照贴图，我们将在下一节中看到。
6.  再次在 Unity 编辑器顶部，选择**游戏对象**，然后选择**创建其他**，这次选择**聚光灯**。
7.  再次选择新灯光，在**检查器**窗口中查看。
    *   **光斑角度**:这是这种类型的光独有的。它决定了光发射的光锥有多宽。与**范围**一起，在**场景**视图中由黄色线锥表示。
8.  Add a few spotlights around the fountain in the center of our tank battle city.

    ![Time for action – adding more lights](img/2014OT_04_07.jpg)

9.  场景中有如此多的物体开始扰乱**层级**窗口，使得很难找到任何东西。要整理，可以使用空`GameObjects`。创建一个并命名为`PointLights`。
10.  通过使你所有的点光源都成为这个空的`GameObject`的子级，**层次**窗口变得明显不那么杂乱。

## *刚刚发生了什么？*

我们给游戏增加了几个灯光。通过改变灯光的颜色，我们让场景看起来和玩起来都更加有趣。然而，照明系统的缺点暴露出来。我们使用的城市非常简单，一次可以影响一架飞机的灯光数量是有限制的。虽然我们场景的外观仍然得到了改善，但许多令人印象深刻的东西都被这个缺点偷走了。

## 光图

光照贴图非常适合复杂的照明设置，这些设置太贵或者在运行时根本不起作用。它们还允许你在游戏世界中添加详细的阴影，而不会牺牲实时阴影。然而，它只适用于在游戏过程中不移动的物体。

# 行动时间-创建光照图

光照贴图对于任何游戏环境都是一个很棒的效果，但是我们需要明确告诉 Unity 哪些对象不会移动，然后使用光照贴图。

1.  首先要做的是使我们的环境网格保持静态。要做到这一点，首先要选择你所在城市的一部分。
2.  在对象名称字段右侧的**检查器**窗口的右上角有一个复选框和一个**静态**标签。选中此框将使对象成为静态的。
3.  Make all of the city's meshes static.

    ### 类型

    如果您有任何类型的分组(就像我们刚才对灯光所做的那样)，这一步可以更快地完成，而不是逐个选择每个复选框。

    1.  选择您所在城市的根对象，它是我们城市的所有部分、建筑和街道的父对象。
    2.  现在去选择**静态**复选框。
    3.  在新弹出窗口中，选择**是，更改子对象**以使所有子对象也变为静态。
4.  当 Unity 生成光照贴图时，任何未展开的网格或其紫外位置在归一化紫外空间之外的网格都将被跳过。在**模型导入设置**窗口中，有一个选项让统一自动生成光照贴图坐标，**生成光照贴图**。如果您正在为您的环境使用`TankBattleCity`，现在应该打开该选项。
5.  转到统一编辑器的顶部，选择底部附近的**窗口**，然后选择**光照贴图**。
6.  看着这个窗口，你的大部分时间都会花在**烘焙**页面上。选择窗口顶部的**烘焙**切换到它。
7.  **模式**规定了系统将渲染何种类型的光照贴图。为了节省处理速度和文件大小，从右侧的**模式**下拉列表中选择**单一光照贴图**。这意味着只创建一组**远**光照贴图，而不是同时创建**近**和**远**。使用**双重光照贴图**也需要特殊的着色器，而这些着色器在大多数时候是不会用到的。
8.  **质量**是一组预设，指示光照贴图看起来有多好。**高**明显最好，**低**处理最快。对于我们的目的来说， **Low** 看起来足够好，应该选择。
9.  **分辨率**是一个物体在单个光照图上占据的空间。在输入字段的右边，它读取每个世界单位的纹理元素。纹理元素只是用于光照贴图的一种奇特的像素类型。它是世界上一个单位空间在光照图上所占的像素数。这里设置为 30 将保持期望的质量水平，同时使整个事情运行得更快。
10.  页面底部是**烘焙场景**按钮。点击此按钮将开始渲染过程。一个加载栏将出现在 Unity 的右下角，以便您可以监控进度。
    1.  如果你仍然在调整灯光和设置，并希望看到游戏的一部分会是什么样子，从选择你希望看到的网格开始。
    2.  接下来，点击**烘焙场景**按钮右侧的小箭头。
    3.  From the new drop-down list, select **Bake Selected**. This will run an identical process to **Bake Scene**, except it will only be for the selected objects rather than the entire scene.

        ### 类型

        请注意，这个过程可能需要一段时间。尤其是随着环境的复杂性和灯光数量的增加，这将需要越来越长的时间来运行。而且，除非你有一台高级计算机，否则当 Unity 运行时，你没什么可做的。

11.  如果你点击了按钮，并意识到你犯了一个错误，不要烦恼。选择**烘焙场景**后，按钮变为**取消**。此时，可以选择它并停止该过程继续进行。然而，一旦纹理被创建，并且 Unity 开始导入它们，就没有停止的可能。
12.  **烘焙场景**的左边是**晴**。此按钮是删除和移除场景中当前正在使用的所有光照贴图的最快和最简单的方法。这无法撤消。
13.  为了给你的建筑添加阴影，在你的场景中选择**方向灯**并查看**检查器**窗口。
14.  从**阴影类型**下拉列表中，选择**软阴影**。这只是为这个灯打开阴影。如果您使用的是 Unity Pro，它还会为该灯光打开实时阴影。打开阴影的灯光越多，渲染成本就越高。
15.  When all of your lights and settings match your desires, select **Bake Scene** and gaze in wonder at the now beautiful scene before you.

    ![Time for action – creating a lightmap](img/2014OT_04_08.jpg)

## *刚刚发生了什么？*

我们在游戏世界中加入了光照贴图。仅仅处理这一步所需要的时间长度使得很难进行细微的调整。然而，我们的照明已经大大改善了一些点击。而在灯光被网格打破之前，我们现在有了平滑的颜色和光线。

## 拥有围棋英雄——理智和速度

玩游戏的时候，只有一种光是人们不会质疑的来源:太阳。如果看不到光源，每隔一盏灯看起来都很奇怪。创建一个网格，并将其添加到游戏中，给你正在使用的灯光一个理由。这可能是一些像火把一样的东西，或者灯柱，甚至是发光的外星粘性球。不管它们最终是什么，拥有它们增加了那种完整的感觉，这使得好看的游戏和好看的游戏有所不同。

作为第二个挑战，看看你的光照图的质量。玩一下我们讨论过的各种质量设置，看看有什么不同。此外，在你注意到任何像素化之前，找出分辨率有多低。在较小的移动设备屏幕上运行时，设置是否可以更低？去看看。

## 饼干

饼干是给游戏中的灯光增加趣味的好方法。他们使用纹理来调整光线的发射方式。这种效果可以覆盖广泛的用途，从闪闪发光的晶体到笼状工业灯，在我们的例子中，还有头灯。

# 行动时间-使用前照灯

通过给我们的坦克前灯，我们给了玩家在他们的世界里控制光线的能力。使用饼干，我们可以让它们看起来比光圈更有趣。

1.  首先创建一个**聚光灯**。
2.  将灯放在水箱前面并指向远处。
3.  在**检查器**窗口中，将**强度**属性的值增加到三。这将使我们的大灯像真正的大灯一样明亮。
4.  现在我们需要一些饼干质地。在统一编辑器的顶部，选择**资产**，然后选择**导入包**，最后选择**轻饼干**。
5.  在新窗口中，选择**导入**，等待加载栏完成。
6.  我们现在有几个选择。在`Standard Assets`文件夹中，创建了一个包含新纹理的新文件夹`Light Cookies`。将`Flashlight`从**项目**窗口拖放到**检查器**窗口中**聚光灯**上的 **Cookie** 字段。就这么简单，往灯里加一块饼干。
7.  To finish it off, duplicate the light for the second headlight and make them both children of the tank. What good is having headlights if they don't come with us?

    ![Time for action – applying headlights](img/2014OT_04_09.jpg)

## *刚刚发生了什么？*

我们用饼干为我们的坦克创造了一对前灯。这正是其他游戏，尤其是恐怖游戏，创造手电筒效果的方式。

## 有一个围棋英雄——增加一个开关

尝试制作一个脚本，让玩家打开和关闭前灯。它应该是一个切换灯光的简单按钮。看看作为光的一部分提供的使能变量。

作为一个更简单的挑战，创建一个位于坦克炮塔上的灯。也给它一盏灯。有了这个，玩家可以指向他们射击的地方，而不仅仅是坦克指向的方向。

# 水滴影

斑点阴影是为角色添加阴影的一种更简单、更便宜的方法。他们从远古时代就存在了。正常的阴影是一个物体在另一个表面上的实心的、深色的投影。阴影的轮廓与物体的轮廓完全匹配。这使得计算角色何时开始随机移动变得昂贵。

斑点阴影是字符或对象下面的黑色纹理污点。它通常没有一个明确定义的形状，也从来没有匹配对象的轮廓，它应该是阴影。斑点阴影通常也不会改变大小。这使得计算变得非常容易，成为许多代电子游戏的首选。这也意味着，对于处理速度可能很快成为问题的移动设备来说，这是一个更好的选择。

# 行动时间——带阴影的坦克

我们要给我们的坦克增加一个斑点阴影。团结已经为我们做了大部分工作；我们只需要把它加到油箱里。

1.  我们从导入统一的斑点阴影开始。转到 Unity 编辑器顶部，选择**资产**、**导入包**，最后选择**投影仪**。
2.  在新窗口中选择**导入**，在**项目**窗口中查看在`Standard Assets`下创建的名为`Projectors`的新文件夹。
3.  Drag the `Blob Shadow Projector` prefab from the **Project** window to the scene and position it above the tank.

    ![Time for action – a tank with a shadow](img/2014OT_04_10.jpg)

4.  不幸的是，阴影出现在我们的坦克顶部。要解决这个问题，我们需要再次利用图层。所以，选择坦克。
5.  从**图层**下拉列表中，选择**添加图层...**。
6.  点击**用户层 9** 的右侧，给它命名`PlayerTank`。
7.  再次选择您的坦克，但这次从**图层**下拉列表中选择`PlayerTank`。
8.  当新窗口弹出时，一定要选择**是，换子**换整个坦克的图层。如果没有，斑点阴影可能会出现在坦克的某些部分，而不是其他部分。
9.  Now, select `Blob Shadow Projector` from the **Hierarchy** window.

    ### 类型

    斑点阴影由**投影仪**组件创建。该组件的功能类似于**相机**组件。然而，它把一个图像放在世界上，而不是把世界变成一个图像，放在你的屏幕上。

10.  看一下**检查器**窗口。我们现在关心的是**忽略图层**的值。现在设置为**无**。
11.  点击**无**，从**图层**下拉列表中选择`PlayerTank`。这将使投影仪忽略坦克，只让斑点阴影出现在它下面。
12.  The next step is to change the size of the shadow to roughly match the size of the tank. Adjust the value of the **Field of View** attribute until the size is about right. A value of about 70 seems to be a good place to start from.

    ![Time for action – a tank with a shadow](img/2014OT_04_11.jpg)

13.  最后一步是让`Blob Shadow Projector`成为坦克的孩子。我们需要能够把自己的影子带在身边；我们不想失去它。

## *刚刚发生了什么？*

我们给了坦克一个阴影。阴影非常适合让物体，尤其是角色看起来像是真的在接触地面。我们使用的斑点阴影比实时阴影好，因为它处理得更快。

## 有一个围棋英雄——让它变成方块

斑点阴影的纹理是圆形的，但是我们的坦克大部分是方形的。尝试为斑点阴影创建自己的纹理，并使用它。某种矩形应该很好用。

如果你设法添加你自己的纹理到斑点阴影，那么看看那门大炮怎么样？大炮突出了我们的坦克，破坏了它原本的方形轮廓。使用附加在炮塔上的第二个斑点阴影为大炮投射阴影。它的纹理也必须是矩形。

# 总结

在这一点上，你应该对相机效果和灯光非常熟悉。

在这一章中，我们从使用多个摄像头开始。然后我们玩了一个涡轮增压相机效果。这一章以我们城市的灯光继续。当我们使用灯光地图时，灯光有了很大的改善。我们最后看了一些饼干和斑点阴影，用于一些特殊的照明效果。

在下一章，将会看到为我们的游戏创造敌人。我们将使用 Unity 的寻路系统让他们四处移动并追逐玩家。在这之后，如果玩家希望保持他们的分数，他们将需要更加积极。