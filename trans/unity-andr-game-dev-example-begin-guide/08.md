# 第八章。特效–声音和粒子

*在上一章中，我们从太空战斗机游戏中短暂休息，了解了 Unity 中的物理和 2D 游戏。我们创造了愤怒的小鸟的克隆体。这些鸟利用物理原理在空中飞行，摧毁猪和它们的结构。我们利用视差滚动来制造令人愉悦的背景效果。我们还创建了一个关卡选择屏幕来加载游戏的各种场景。*

*在这一章，我们回到太空战斗机游戏。我们将增加许多特殊效果来丰富游戏体验。我们从了解 Unity 在处理音频时提供的控制开始。我们继续给游戏添加一些背景音乐，当任何东西离得太近时，就会发出警告声。接下来，我们学习粒子系统，为我们的飞船创建引擎轨迹。最后，我们结合这一章的效果来创造子弹爆炸和爆炸。*

在本章中，我们将涵盖以下主题:

*   导入音频剪辑
*   玩 SFX
*   了解 2D 和 3D SFX
*   创建粒子系统

打开你的太空战斗机项目，我们将开始。

# 理解音频

与其他资产一样，Unity 团队努力使音频工作变得轻松和无痛苦。Unity 能够导入和利用多种音频格式，允许您将文件保存为可以在其他程序中编辑的格式。

## 导入设置

音频剪辑有少量重要设置。它们可以让你轻松控制文件的类型和压缩。

![Import settings](img/2014OT_08_01.png.jpg)

以下是我们在导入音频剪辑时必须使用的设置:

*   **音频格式**:这个控制文件是包含在**原生**格式还是在最终游戏中被**压缩**。**原生**虽然文件大小更大，但最适合短音效，因为它们可以快速加载和播放。**压缩**更适合较长的声音和音乐。在最终构建中，它们的足迹会更小。
*   **3D 声音**:此复选框控制文件是在 2D 播放还是在 3D 播放。无论播放器在哪里，2D 的声音都会以恒定的音量播放——非常适合背景音乐和画外音。3D 声音将根据它们与玩家的距离进行音量调节——非常适合爆炸和枪战。
*   **强制单声道**:此复选框将使 Unity 将立体声文件更改为单声道文件。
*   **加载类型**:这个控制在玩游戏的时候如何加载文件。
    *   **载入内存**:将一个**原生**文件直接载入内存播放。
    *   **从光盘流式传输**:这将在音频播放时流式传输音频，例如从网络流式传输音乐或视频。
    *   **加载时解压缩**:这将在第一次需要文件时移除对文件的压缩。这个选项的开销使得它对于大文件来说是一个非常糟糕的选择。
    *   **压缩在内存中**:这只是在文件播放时进行解压缩。当它刚刚被保存在内存中时，文件保持压缩状态。
*   **硬件解码**:这个只用于 iOS 设备，降低处理成本。
*   **无间隙循环**:这个调整了压缩方法，去掉了一些方法会给文件带来的小爆音。
*   **压缩**:这是每秒将文件压缩到的数据量，导致文件变小。最好找到一个值，使文件大小最小化，同时损失最少的质量。

## 音频监听器

为了在游戏中真正听到任何东西，每个场景都需要一个**音频监听器**组件。默认情况下，`Main Camera`对象(首先包含在任何新场景中)和您可能创建的任何新相机都附加了一个**音频监听器**组件。您的场景中一次只能有一个 **音频监听器**组件。如果不止一个，或者你试图在没有声音的时候播放声音，Unity 会用抱怨填满你的控制台日志。**音频监听器**组件还提供了关闭任何 3D 音效的精确位置。

## 音频源

**音源**组件就像一个扬声器，控制播放任何音效的设置。如果片段是 3D 的，则该对象相对于**音频监听器**组件的位置和所选模式决定了片段的音量。

![Audio Source](img/2014OT_08_02.png.jpg)

以下是**音频源**组件的各种设置:

*   **音频剪辑**:这是这个**音源**组件默认播放的声音文件。
*   **静音**:这是一个快速的方式来切换播放声音的音量。
*   **旁路效果**:这允许切换应用到这个**音源**组件的任何特殊滤镜。
*   **在清醒状态下播放**:这将会使在场景加载或对象产生时，立即开始播放**音频剪辑**。
*   **循环**:这将导致播放片段在播放时重复。
*   **优先级**:这决定了正在播放的文件的相对重要性。 **0** 对音乐最重要最好，而 **256** 最不重要。根据系统的不同，一次只能播放这么多声音。要播放的文件列表从最重要的开始，并在达到此限制时结束，如果声音超过限制允许的数量，则排除那些具有最低值的文件。
*   **音量** : 这决定了剪辑的播放音量。
*   **Pitch**: This scales the playback speed of the clip.

    ![Audio Source](img/2014OT_08_03.png.jpg)

*   **3D 声音设置**:这个包含了一组特定于 3D 音频片段播放的设置。**音量**、**声相**和**传播**选项可以使用组末的图表进行调整。这允许人们在播放器接近**音频源**组件时创建更动态的过渡。
    *   **多普勒水平**:这决定了多少多普勒效应应用于移动的声音。
    *   **Volume Rolloff**: This controls how the volume fades with distance.

        **对数衰减**:这是声音在距离声源中心很短的距离内突然快速衰减。

        **线性衰减**:这是一个随距离的均匀衰减，在**最小距离**值处最大，在**最大距离**值处最安静。

        **自定义衰减**:这允许您通过调整群组末端的图形来创建自定义衰减。当调整图形时，也会自动选择它。

    *   如果**音频监听器**组件比**最小距离**值更近，音频将以当前音量播放。在此距离之外，声音将根据**衰减模式**衰减。
    *   **声相级别**:这是应用到这个**音源**组件的 3D 效果的百分比。这会影响衰减和多普勒效应。
    *   **扩散**:这将调整声音覆盖的扬声器空间面积。当使用一个或两个以上的扬声器时，这变得更加重要。
    *   超过**最大距离**值时，声音将根据组底部的图形停止转换。
*   **2D 声音设置**:这将特定于 2D 音频剪辑的设置分组。
    *   **平移 2D** :这将调整每个扬声器发出的声音的均匀程度，并向左侧或右侧扬声器称重

## 添加背景音乐

现在我们已经知道了可用的音频设置，是时候将这些知识付诸行动了。我们将从添加一些背景音乐开始。这必须是 2D 音效，这样无论**音源**组件在哪里，我们都能舒适地听到。我们还将创建一个简短的脚本来淡化音乐，以减少音效轰炸播放器的突然性。

# 行动时间-添加背景音乐

让我们从一个单一的脚本开始，来控制我们的背景音乐。

1.  我们将从创建一个新的脚本并将其命名为`FadeIn`开始。
2.  这个脚本从三个变量开始。首先是脚本必须达到的目标量。第二个是转换所需的秒数。最后是过渡开始的时间。

    ```java
    public float maxVolume = 1f;
    public float fadeLength = 1f;
    private float fadeStartTime = -1f;
    ```

3.  接下来，我们利用`Awake`功能。首先查看由 Unity 自动提供的`audio`变量，检查附加的**音源**组件。如果找不到，则`gameObject`被破坏，功能退出。

    ```java
    public void Awake() {
      if(audio == null) {
        Destroy(gameObject);
        return;
      }
    ```

4.  `Awake`功能通过将其音量设置为`0`并播放(如果还没有)来结束。

    ```java
      audio.volume = 0;

      if(!audio.isPlaying)
        audio.Play();
    }
    ```

5.  为了引起随时间的转变，我们使用`Update`函数。它将首先检查`fadeStartTime`变量是否在零以下，如果是，将其设置为当前时间。这使我们能够避免因场景启动初始化而导致的打嗝。

    ```java
    public void Update() {
      if(fadeStartTime < 0)
        fadeStartTime = Time.time;
    ```

6.  该函数接下来检查转换时间是否已经结束。如果有，**音源**组件的音量设置为`maxVolume`，脚本被销毁以释放资源。

    ```java
    if(fadeStartTime + fadeLength < Time.time) {
      audio.volume = maxVolume;
      Destroy(this);
      return;
    }
    ```

7.  最后，通过计算渐变开始后经过的时间量并除以过渡长度来计算当前进度。产生的进度百分比乘以`maxVolume`的值，并应用于**音频源**组件的音量。

    ```java
      float progress = (Time.time – fadeStartTime) / fadeLength;
      audio.volume = maxVolume * progress;
    }
    ```

8.  回到 Unity，我们需要创建一个新的空`GameObject`并命名为`Background`。
9.  向这个对象添加我们的`FadeIn`脚本和一个**音频源**组件。
10.  如果您还没有，请在您的**项目**面板中创建一个`Audio`文件夹，并导入章节的**启动资源**中包含的四个声音文件。
11.  选择`Background`声音文件，在导入设置中取消选中**三维声音**复选框。
12.  在**层级**窗口中选择您的`Background`对象，并将`Background`声音拖到**音频剪辑**槽中。
13.  确保在**音源**组件上勾选了**唤醒播放**和**循环**复选框。**音量**选项也需要设置为 **0** ，都是为了让文件在整个游戏中播放，但启动时不出声。

## *刚刚发生了什么？*

我们在游戏中加入了背景音乐。为了使声音恒定不变，不具有方向性，我们将音乐用作 2D 声音。我们还创建了一个脚本，以便在游戏开始时淡入音乐。这为玩家进入游戏提供了便利，防止了声音的突然冲击。

## 玩个围棋英雄——设定一些情绪

背景音乐为游戏增加了很多体验。没有一些恐怖的音乐，一个恐怖的场景就不会那么恐怖。没有令人生畏的音乐，老板们就不会那么令人生畏了。为你的其他游戏寻找一些好的背景音乐。一些轻松愉快的东西对《愤怒的小鸟》来说会很好，而一部更加工业化和快节奏的作品会让你在坦克战游戏中心跳加速。

## 创建报警系统

为了理解 3D 音频效果，我们将创建一个警报系统。随着物体接近船只，警报的音量会增加。3D 效果将指示物体相对于船只的方向。当玩家看不到周围的一切时，这给了他们所需的反馈。有几种方法可以达到这种效果，但是这种方法将展示我们随着时间的推移调整**音频源**组件的能力。

# 行动时间-警告玩家

一个附着在我们空间物体上的脚本会在物体接近时警告玩家。

1.  我们从创建一个新的脚本开始，并将其命名为`Alarm`。
2.  这个脚本从一个变量开始。它将保持声音开始渐强的距离值。

    ```java
    public float warningDist = 100f;
    ```

3.  接下来，我们创建`Update`函数。首先检查**音源**组件，如果没有，则提前退出该功能。`audio`变量保存对附加的**音频源**组件的引用。

    ```java
    public void Update() {
      if(audio == null) return;
    ```

4.  该功能继续计算到玩家的距离。因为玩家从不移动，所以我们可以只使用位置到原点的距离来简化。我们还使用`sqrMagnitude`，这是向量长度的平方，因为它的计算速度要快得多。如果对象在范围之外，音量设置为`0`，功能退出。

    ```java
    float distance = transform.position.sqrMagnitude;
    if(distance > warningDist * warningDist) {
      audio.volume = 0;
      return;
    }
    ```

5.  最后，我们通过将距离除以`warningDist`值的平方并从 1 中减去结果来计算新体积。当接近最大音量时，这将产生一个圆形曲线。

    ```java
    float volume = 1 – (distance / (warningDist * warningDist));
    audio.volume = volume;
    }
    ```

6.  我们现在需要将脚本添加到相关对象中。在敌舰和小行星的预设中，添加`Alarm`脚本和**音频源**组件。
7.  对于**音频剪辑**值，选择`Alarm`剪辑。此外，确保勾选了**唤醒播放**和**循环**复选框。
8.  接下来，我们不想让警报压倒我们游戏中的其他声音，所以将**优先级**选项设置为 **192** 。
9.  要防止该对象在产生时发出任何噪音，请将**音量**选项设置为 **0** 。
10.  为了让脚本完全控制**音源**组件的音量，请展开**三维声音设置**组件。选择**线性滚降**为**音量滚降**和 **495** 为**最小距离**选项。

## *刚刚发生了什么？*

我们创建了一个脚本来警告玩家当物体靠得太近时。当他们靠近播放器时，音频源的音量会增大。当他们离开播放器时，音量会减小。通过利用 3D 音频剪辑，我们可以指示玩家接近的物体来自哪里。

## 有围棋英雄——差异化

当物体靠得太近时，我们可以分辨出来，这很好，但是直到我们看到它时，我们才能分辨出它是什么。找一些替代的警报声音。对于玩家必须应对的每种类型的对象，给它一个不同的声音。这样，玩家将知道他们是需要开始拉一些棘手的机动来躲避子弹，还是他们正在进入小行星场，需要小心翼翼地飞行来避免碰撞。

# 理解粒子系统

粒子系统大大增加了游戏的最终外观。它们可以采取火、魔波、雨或你能想象到的许多其他效果的形式。他们往往很难创造好，但很值得努力。请记住，尤其是在使用移动平台时，少即是多。较大的粒子比大量的粒子更有效。如果你的粒子系统曾经在一个小空间中包含数千个粒子，或者被复制到自身上以增加效果，你需要重新思考设计并找到一个更有效的解决方案。

## 粒子系统设置

每个粒子系统都包含大量的组件，每个组件都有自己的设置。大多数可用的设置都可以选择**常量**、**曲线**、**两个常量**之间的随机、**两个曲线之间的随机**。**常量**将是一个特定的值。**曲线**将是一个随时间沿曲线变化的设定值。这两个随机设置在各自的值类型之间选择一个随机值。起初这可能看起来令人困惑，但随着我们研究它们，它们会变得更容易理解。

正如你将能够在中看到的随后的图像和描述，我们将研究并了解粒子系统的每一部分。

正如您将在下面的截图中看到的，我们将研究并了解粒子系统的每一部分:

![Particle system settings](img/2014OT_08_04.png.jpg)

1.  The first portion, the **Initial** module, of the particle system holds all the settings used by every emitter in Unity.
    *   **持续时间**:这是发射器持续的时间。一个循环系统将在这段时间后重复。非循环系统将在这段时间后停止发射。
    *   **循环**:此复选框指示系统是否循环。
    *   **预循环**:如果勾选此复选框，将启动一个循环系统，就好像它已经有机会循环一段时间一样。这在火把应该已经点燃的情况下是有用的，而不是在玩家进入房间时开始。
    *   **启动延迟**:这将在初始触发时的给定秒数内停止粒子系统的发射。
    *   **开始寿命**:这是单个粒子开始的秒数。
    *   **起始速度**:这是粒子在产生时最初移动的速度。
    *   **起始大小**:这决定了一个粒子在产生时有多大。使用更大的粒子总是比使用更多的粒子更好。
    *   **开始旋转**:这个会旋转发射的粒子。
    *   **开始颜色**:这是粒子产生时的颜色色调。
    *   **重力乘数**:这给了粒子或多或少的重力效果。
    *   **继承速度**:这将导致粒子在运动时获得其变换动量的一部分。
    *   **模拟空间**:这决定了粒子是会随着游戏对象的移动而停留在游戏对象上(也就是局部)，还是会停留在世界上原来的位置。
    *   **在唤醒状态下播放**:如果选中此复选框，一旦发射器产生或场景开始，它将会以的形式开始发射。
    *   **最大粒子数**:这限制了该系统一次支持的粒子总数。这个值只有在粒子发射的速率或者它们的寿命足够长到超过它们的破坏速率时才会起作用。

    ![Particle system settings](img/2014OT_08_05.png.jpg)

2.  The **Emission** module controls how fast the particles are emitted.
    *   **速率**:如果设置为**时间**，这是每秒创建的粒子数。如果设置为**距离**，这是系统移动时每单位距离的粒子数量。
    *   **爆发**:仅当**速率**选项设置为**时间**时使用。它允许您在系统的时间线中设置发射特定数量粒子的时间点。

    ![Particle system settings](img/2014OT_08_06.png.jpg)

3.  The **Shape** module controls how the system emits particles.
    *   **Shape**: This dictates what form the emission point will take. Each option comes with a few more value fields that determine its size.

        **球体**:这是粒子向各个方向发射的点。**半径**决定球体的大小。**从外壳发射**表示粒子是从球体表面发射还是从体积内部发射。

        **半球**:这是，顾名思义，半个球体。**半径**和**从外壳中发射**的工作原理与它们对**球体**的工作原理相同。

        **圆锥体**:这个向一个方向发射粒子。**角度**决定形状是更接近圆锥体还是圆柱体。**半径**决定形状发射点的大小。**发射自**将决定粒子从哪里发射。**底座**从该形状的底座圆盘发射。**基壳**从圆锥体的底部发射，但围绕形状的表面。**体积**将从形状内部的任何地方发射，**体积壳**从形状的表面发射。

    *   **盒子**:这发射出立方体形状的粒子。**X 框****框 Y****框 Z** 确定框的尺寸。
    *   **网格**:这允许你选择一个模型作为发射点。系统的所有粒子都将从**网格**的表面发出。
    *   **随机方向**:这决定了粒子的方向是由所选形状的表面法线决定的，还是随机选择的。

    ![Particle system settings](img/2014OT_08_07.png.jpg)

4.  The **Velocity over Lifetime** module allows you to control the momentum of the particles after they have been spawned.
    *   **X** 、 **Y** 和 **Z** :这些定义了沿着粒子动量的每个轴每秒的单位数
    *   **空间**:这决定了速度是局部应用于系统的变换，还是相对于世界

    ![Particle system settings](img/2014OT_08_08.png.jpg)

5.  The **Limit Velocity over Lifetime** module dampens a particle's movement if it exceeds the specified value.
    *   **分离轴**:这允许定义每个轴的唯一值，以及该值是本地的还是相对于世界的
    *   **速度**:这是在施加阻尼之前粒子移动的速度
    *   **阻尼**:这是切割粒子的速度百分比。它是一个介于 0 和 1 之间的值

    ![Particle system settings](img/2014OT_08_09.png.jpg)

6.  The **Force over Lifetime** module adds a constant amount of movement to each particle over the course of its life.
    *   **X** 、 **Y** 和 **Z** :这些定义了沿着每个轴施加多大的力
    *   **空间**:这决定了力是施加在系统的局部变换还是世界空间
    *   如果 **X** 、 **Y** 和 **Z** 是随机值，**随机化**将导致在每一帧随机选取施加的力的大小，从而对随机值进行统计平均

    ![Particle system settings](img/2014OT_08_10.png.jpg)

7.  **终生颜色**模块允许您定义粒子产生后过渡的一系列颜色。
8.  The **Color by Speed** module causes the particle to transition through the defined range of colors as its speed changes.
    *   **颜色**:这是要过渡的一组颜色
    *   **速度范围**:这定义了粒子在**颜色**范围的最小和最大端点的速度

    ![Particle system settings](img/2014OT_08_11.png.jpg)

9.  **终生尺寸**模块在粒子的一生中改变粒子的尺寸。
10.  The **Size by Speed** module adjusts the size of each particle based on how fast it is going.
    *   **大小**:这是粒子过渡经过的调整
    *   **速度范围**:这定义了每个**尺寸**的最小值和最大值

    ![Particle system settings](img/2014OT_08_12.png.jpg)

11.  **生命周期内的旋转**模块在粒子产生后随着时间旋转粒子。
12.  The **Rotation by Speed** module rotates particles more as they go faster.
    *   **角速度**:这是要应用的转数
    *   **速度范围**:这是**角速度**值的最小和最大范围，如果没有设置为**常数**

    ![Particle system settings](img/2014OT_08_13.png.jpg)

13.  **外力**模块倍增风区物体的效果。风区模拟风对粒子系统和统一树的影响。
14.  The **Collision** module allows particles to collide and interact with the physical game world.
    *   If set to **Planes**, you are able to define a number of flat surfaces for the particles to collide with. This is faster to process than World collisions.

        **平面**:这是定义要碰撞的曲面的变换列表。粒子只会与变换的局部正 y 面碰撞。该点另一侧的任何粒子都将被破坏。

        **可视化**:这为您提供了将平面视为**实体**曲面或**网格**曲面的选项。

        **缩放平面**:这将调整**可视化**选项的大小。它不影响要碰撞的表面的实际大小。

        **粒子半径**:用于定义计算粒子与平面碰撞的球体大小。

    *   If set to **World**, the particles will collide with every collider in your scene. This can become a lot for the processor to handle.

        **碰撞**:这定义了将要碰撞的图层列表。只有在此列表中选中的图层上的碰撞器将用于碰撞计算。

        **碰撞质量**:这定义了这个粒子系统的碰撞计算有多精确。**高**将精确计算每个粒子。**中**将使用近似值和每帧有限数量的新计算。**低**只是计算次数少于**中**。

        如果**碰撞质量**设置为**中**或**低**，**体素尺寸**表示系统估计碰撞点的精确度。

    *   **阻尼**:当粒子与表面碰撞时，这将从粒子中移除定义的速度分数。
    *   **反弹**:这允许粒子保持其速度的规定分数，特别是沿着被击中表面的法线。
    *   **寿命损失**:这是寿命的百分比。当粒子碰撞时，这个百分比的生命从粒子中消失。当粒子的寿命随着时间或通过碰撞下降到零时，它就被移除了。
    *   如果碰撞后，粒子的速度低于**最小杀伤速度**值，则粒子被破坏。
    *   如果勾选了**发送碰撞信息**复选框，附着在粒子系统和被碰撞物体上的脚本将在发生碰撞的每一帧被警告。每个帧只发送一条消息，而不是每个粒子。

    ![Particle system settings](img/2014OT_08_14.png.jpg)

15.  The **Sub Emitters** module allows additional particle systems to be spawned at points in the life of each particle of this system.
    *   在**出生**列表中的任何粒子系统都将在粒子第一次创建时产生并跟随它。这可以用来制造火球或烟迹。
    *   **碰撞**列表会在粒子撞击某个物体时产生粒子系统。这可以用于雨滴飞溅。
    *   **死亡**列表在粒子被破坏时产生粒子。它可以用来引发烟花爆炸。

    ![Particle system settings](img/2014OT_08_15.png.jpg)

16.  The **Texture Sheet Animation** module causes the particle to flip through a number of particles over the course of its life. The texture used is defined in the **Renderer** module.
    *   **平铺**:这定义了工作表中的行数和列数。这将决定可用的总帧数。
    *   **动画**:这给你**整张**和**单排**的选择。如果设置为**单行**，所使用的行可以随机选择，也可以使用**随机行**复选框和**行**值指定。
    *   **帧随时间变化**:这定义了粒子如何在帧之间转换。如果设置为**常量**，系统将只使用单帧。
    *   **循环**:这是粒子在其生命过程中循环通过动画的次数。

    ![Particle system settings](img/2014OT_08_16.png.jpg)

17.  **渲染器**模块指示如何在屏幕上绘制粒子。
    *   **Render Mode**: This defines which method a particle should use to orient itself in the game world.

        **广告牌**:这个会一直对着镜头。

        **拉伸广告牌**:这将在相机处面向粒子，但根据相机的速度、粒子的速度或特定值拉伸它们。

        **水平广告牌**:这是游戏世界 XZ 平面上的平面。

        **垂直广告牌**:这个会一直对着玩家，但是会一直沿着 y 轴保持直线。

        如果设置为**网格**，可以定义一个模型作为粒子而不是平面使用。

    *   **法线方向**:通过调整每个平面的法线，用于粒子的光照和阴影。值为 **1** 将法线直接指向相机，而值为 **0** 将法线指向屏幕中心。
    *   **材质**:这定义了用于渲染粒子的材质。
    *   **排序模式**:这决定了粒子应该按照距离或年龄的顺序被吸入。
    *   **排序软糖**:这将导致粒子系统比正常绘制更早。该值越高，越早在屏幕上绘制。这会影响系统出现在其他粒子系统或部分透明对象的前面还是后面。
    *   **投射阴影**:这决定了粒子是否会阻挡光线。
    *   **接收阴影**:这决定了粒子是否受到其他物体投射阴影的影响。
    *   **最大粒径**:这是单个颗粒允许填充的屏幕空间总量。无论粒子的真实大小如何，它都不会超过屏幕的这个空间。

## 创建引擎轨迹

为了加强玩家对他们的船正在移动的印象，我们需要为船的引擎创建一些轨迹。即使船没有移动，排气也会像船在移动一样拖出来。通过使粒子系统成为构成飞船的一组物体的一部分，发动机尾迹将会移动并留下人们所期望的粒子。

# 行动时间-增加发动机轨迹

仅使用一个粒子系统就可以轻松添加发动机轨迹并控制。

1.  首先，我们需要创建一个新的粒子系统。通过前往统一编辑器顶部并导航至**游戏对象** | **创建其他** | **粒子系统**来完成此操作。
2.  将新粒子系统重命名为`EngineTrail`。
3.  首先我们来看看**初始**模块。我们需要勾选**循环**和**预激活**复选框。这将使飞船看起来像是在整个游戏中移动，并消除系统在其他情况下需要创建的效果。
4.  接下来，我们需要控制粒子行进的距离。为此，将**启动寿命**选项设置为 **3** ，将**启动速度**选项设置为 **1** 。
5.  为了让粒子在空间中保持合适的大小和位置，我们需要将**起始大小**选项设置为 **0.8** ，并为**模拟空间**选择**世界**。
6.  现在我们进入**形状**模块。我们希望粒子直接从引擎中飞出。因此，我们将 **0** 的值用于**角度**选项，将 **0.2** 的值用于**半径**选项。
7.  随着时间的推移，废气的颜色会变淡，密度会消散。要达到此效果，激活**终生颜色**和**终生尺寸**模块。
8.  For the **Color** option, set the **Alpha** option to **0** at the beginning of the gradient and **255** a short way in. As to colors, select a vibrant blue at the beginning, transitioning to white, and then gray at the end.

    ![Time for action – adding engine trails](img/2014OT_08_17.png.jpg)

9.  For the **Size** option, select a linear slope that is maximum at the beginning and minimum at the end. This is most easily done by clicking on the curve, to the right of the **Size** label, and selecting the third option from the bottom of the **Particle System Curves** window at the bottom of the **Inspector** window.

    ![Time for action – adding engine trails](img/2014OT_08_18.png.jpg)

10.  现在，在**场景**窗口中，复制`EngineTrail`对象三次，并将其放置在船的引擎后面。一定要旋转它们，这样粒子就会从船上发射出去。
11.  Finally, make all of them children of the player's ship. If this step is skipped, they will not follow the ship as it moves.

    ![Time for action – adding engine trails](img/2014OT_08_19.png.jpg)

## *刚刚发生了什么？*

我们将我们所学到的关于粒子系统的知识付诸实践，为我们的宇宙飞船的引擎创造轨迹。因为他们是飞船的孩子，在世界空间中模拟，他们随着飞船移动，并如人们所期望的那样离开。

## 有一个围棋英雄——更多的轨迹

敌舰也有发动机。试着在敌舰上增加路径。小心选择要模拟的局部或世界空间。因为飞船移动是为了让它看起来像玩家在移动，所以在世界空间中模拟可能会有一些不寻常的副作用。

如果你之前给玩家一个涡轮增压效果，现在是时候给它增加一些额外的效果了。尝试在玩家加速时改变步道的长度。也许这艘船在推进时会使用一种特殊的燃料。如果它燃烧不同的颜色，那么当玩家加速时，轨迹必须是不同的颜色，或者一系列的颜色。

# 放在一起

到目前为止，我们已经了解了音频效果和粒子系统。他们每个人都可以为场景增加很多东西，设定气氛，给游戏一种与众不同的感觉。但是有许多影响不能独立存在。例如，除非你既有视觉效果又有听觉效果，否则爆炸不会给人留下深刻的印象。

## 爆炸

在敌人爆炸的时候消灭他们，这要令人满意得多。它需要粒子效应和声音效应来产生适当的爆炸。我们将从创建一个爆炸预制开始。然后我们会更新玩家的射击，在小行星和敌舰被摧毁时产生爆炸。

# 行动时间-增加爆炸

单个粒子系统和脚本将允许我们创造一些可以在任何地方使用的漂亮的爆炸。

1.  我们首先需要一些新的纹理来使爆炸看起来像火。幸运的是，Unity 提供了大量的基本粒子纹理。要将它们包含在您的项目中，请转到 Unity 编辑器的顶部，导航到**资产** | **导入包** | **粒子**。
2.  在结果窗口中，选择**导入**，等待 Unity 完成导入。这个包是一个伟大的资源，包括纹理和完整的粒子系统。然而，所有包含的粒子系统都使用旧系统，该系统将在接下来的几个版本中逐步淘汰 Unity。尽管如此，我们仍然可以充分利用所包含的材料。
3.  创建一个新的`particleSystem`对象并命名为`Explosion`。
4.  首先在**初始**模块，我们需要让效果持续一小段时间。将**持续时间**设置为 **0.5** ，将**开始寿命**选项设置为 **1** 。
5.  To keep the particles close together, use a value of **0.5** for the **Start Speed** option.

    ### 类型

    当我们完成这个系统时，它不会循环。然而，如果我们现在让它循环，就更容易看到我们在做什么。

6.  接下来，我们需要更多的粒子，所以转到**发射**模块。将**费率**选项设置为 **120** 生成适量。
7.  爆炸一般是圆形的，接下来我们需要调整**形状**模块。选择**球体**进行**形状**设置，并将**半径**选项设置为 **0.5** 。
8.  Now for the **Color over Lifetime** module. An explosion is bright at the beginning and fades to brown, followed by black as it burns. For the **Color** option, start with an army green color, followed by faded yellow, then medium brown, and finally black at the end. Also, cause **Alpha** to fade in at the beginning and out at the end. This keeps the particles from popping in and out of existence.

    ![Time for action – adding explosions](img/2014OT_08_20.png.jpg)

9.  接下来，我们需要一种用于粒子的火材料。对于**渲染器**模块中的**材质**设置，选择**火烟**材质。也可以去**标准资产** | **颗粒** | **来源** | **材料**在你的**项目**窗口找到。
10.  一旦我们对系统的外观感到满意，请确保在**初始**模块中勾选了**唤醒播放**复选框和**循环**复选框。
11.  就像小行星和敌舰一样，爆炸需要在玩家移动时围绕他们移动。当它完成发射时，它也需要自我毁灭。所以，创建一个新的脚本并命名为`Explosion`。
12.  这个脚本很短，只有包括两个功能。第一个功能`Update`，检查`particleSystem`对象是否丢失或播放完毕。如果两者都是真的，那`gameObject`就毁了。

    ```java
    public void Update() {
      if(particleSystem == null || !particleSystem.isPlaying)
        Destroy(gameObject);
    }
    ```

13.  第二个功能`LateUpdate`，简单的使用`PlayerShip.Rotate`功能，我们在[第六章](06.html "Chapter 6. Specialties of the Mobile Device – Touch and Tilt")*移动设备的特长–触摸和倾斜*中创建的功能，为玩家的移动移动爆炸。这和玩家移动时我们移动小行星和敌舰的方式是一样的。

    ```java
    public void LateUpdate() {
      PlayerShip.Rotate(transform);
    }
    ```

14.  返回 Unity，将脚本添加到`Explosion`对象。
15.  接下来，向对象添加一个**音频源**组件。
16.  对于这个组件，我们需要勾选**唤醒播放**复选框。同样选择**线性衰减**用于**音量衰减**模式，选择 **10** 用于**最小距离**，两者都位于**三维声音设置**下。
17.  当然，还要为源音频剪辑选择**爆炸**音效。这些设置将导致爆炸产生后立即播放声音。
18.  要完成爆炸的创建，请将对象变成预设对象，并从场景中删除该实例。
19.  接下来，我们需要更新`TouchShoot`脚本来利用爆炸。现在打开它。
20.  首先，我们添加一个变量来保存对爆炸的引用。

    ```java
    public GameObject explosion;
    ```

21.  在我们使用`Physics.Raycast`功能的那一行之后，在我们破坏拍摄对象之前，添加这一行。如果有对爆炸的引用，它会使用`Instantiate`函数生成爆炸的新实例，并将其位置和旋转设置为被拍摄对象的位置和旋转。

    ```java
    if(explosion != null) Instantiate(explosion, hit.transform.position, hit.transform.rotation);
    ```

22.  Back in Unity, find the instance of the `TouchShoot` script component on the player's ship. Add the reference to the `Explosion` prefab in the new **Explosion** slot.

    ![Time for action – adding explosions](img/2014OT_08_21.png.jpg)

## *刚刚发生了什么？*

我们制造了一场爆炸。Unity 为我们提供了大量的粒子纹理，我们可以用它们来创建大量的效果。也有一些粒子系统已经被创造出来，包括爆炸。然而，那次爆炸使用的是旧系统，在很长一段时间内不会包含在 Unity 中。我们还更新了我们的敌舰和小行星，这样当它们被玩家摧毁时就会产生爆炸。

## 加油英雄——更多类型的爆炸

一次爆炸是可以的，但是奇怪的是小行星爆炸的方式和飞船一样。不同的气体、燃料和岩石成分都以不同的颜色和不同的能量燃烧。为你周围的不同物体制造更多的爆炸。改变颜色和大小，以适应什么是爆炸。此外，探索其他声音效果，提供不同的听觉线索，什么是爆炸。最后，尝试创建一个多重爆炸系统。也许玩家的射击导致了第一次爆炸，连锁反应导致了武器舱和发动机舱的爆炸。为了实现这一点，看看如何使用子发射器，或者在飞船被摧毁时在飞船周围产生几个不同的粒子系统。

## 制造激光冲击波

能够摧毁物体并看到它们爆炸是很棒的。它给玩家一个简单动作的奖励。然而，当一个人发射任何种类的枪时，你期望它会有反应，不管是否有东西被击中。为此，我们将为玩家的船创建一个枪口闪光类型的效果。每次他们敲击屏幕开火，一些粒子系统就会闪烁，并播放声音效果。

# 行动时间-增加激光爆炸

枪口闪光通常由两部分组成。第一种是直线爆炸，沿着枪管向前。第二个是一个围绕第一个底座的风扇。

1.  首先，创建一个新的`particleSystem`对象，并将其重命名为`LineBlast`；我们现在开始做第一部分。
2.  闪光不会持续很长时间，所以在**初始**模块中找到**持续时间**选项，并将其设置为 **0.1** 。
3.  接下来，我们需要将**开始寿命**选项设置为 **0.1** ，这样粒子不会在屏幕上停留很长时间。
4.  闪光不会离开枪口，所以将**开始速度**选项设置为 **1** ，保持粒子接近。
5.  这些粒子的大小需要与我们船的枪口大小相适应。将**起始尺寸**选项设置为 **0.2** 以保持较小。
6.  如果我们的激光爆炸只是白色，那就没意思了，所以将**开始颜色**值更改为适合您的激光的颜色。
7.  **初始**模块的最后一项是取消选中**唤醒播放**复选框，防止系统在加载时立即触发。
8.  接下来我们需要调整**发射**模块。闪光是突发的，因此将**速率**选项设置为 **0** 。
9.  点击**突发**列表右侧的 **+** 号进行突发。一个值 **5** 会很好用。
10.  接下来，我们调整**形状**模块，使粒子沿直线发射。为此，将**角度**选项设置为 **0** ，将**半径**选项设置为 **0.01** 。
11.  最后，我们需要调整**渲染器**模块。若要拉伸粒子，请将**渲染模式**选项更改为**拉伸广告牌**，并将**长度比例**选项设置为 **-4.5** 。
12.  既然我们对这个系统的外观感到满意，取消勾选**初始**模块中的**循环**复选框。
13.  现在创建第二个`particleSystem`对象，并将其重命名为`SpreadBlast`。
14.  这些粒子的寿命应该和第一个系统的粒子一样长。因此，在**初始**模块中，将**持续时间**选项设置为 **0.1** 、**起始寿命**至 **0.1** 、**起始速度**至 **1** 、**起始尺寸**至 **0.2** ，取消勾选**清醒时播放**。
15.  要使这些粒子区别于线条，请将**开始颜色**值设置为稍暗的颜色。
16.  接下来，在**发射**模块中，将**速率**选项设置为 **0** ，并将**爆发**选项添加为**粒子**值 **30** 。
17.  对于**形状**模块，将**角度**选项设置为 **60** ，将**半径**选项设置为 **0.01** 。这导致粒子在产生时散开。
18.  对于**渲染器**模块，将**渲染模式**选项设置为**拉伸广告牌**，将**长度比例**选项设置为 **-3** 。
19.  最后，一旦我们对系统外观满意，再次取消选中**初始**模块中的**循环**复选框。
20.  在我们设置粒子系统之前，我们需要创建一个脚本。新建一个并命名为`LaserBlast`。这个脚本将触发粒子系统和音频剪辑播放。
21.  这个脚本从一个变量开始。该变量保存当脚本被告知触发时要触发的系统列表。

    ```java
    public ParticleSystem[] particles = new ParticleSystem[0];
    ```

22.  接下来我们有脚本中唯一的功能，`Fire`。首先要确保同一个`GameObject`上有一个**音源**组件。如果存在，`PlayOneShot`将使用源的剪辑调用。此功能会播放一次传递的文件，而不会阻止其他片段的播放。

    ```java
    public void Fire() {
      if(audio != null)
        audio.PlayOneShot(audio.clip);
    ```

23.  该功能通过循环粒子系统列表并使用`Play`触发它们(如果它们存在)来继续。

    ```java
      for(int i=0;i<particles.Length;i++) {
        if(particles[i] != null)
          particles[i].Play();
      }
    }
    ```

24.  接下来，我们需要更新`TouchShoot`脚本。当玩家触摸屏幕时，需要调用`LaserBlast`脚本上的`Fire`功能。为此，我们首先添加`lasers`变量来保存需要触发的对象列表。

    ```java
    public LaserBlast[] lasers = new LaserBlast[0];
    ```

25.  在`Update`函数的开始，我们添加`didFire boolean`值。它将防止激光每帧被触发一次以上。

    ```java
    bool didFire = false;
    ```

26.  接下来，我们在`if`语句后将布尔设置为真，检查触摸的相位值是否等于`TouchPhase.Began`。

    ```java
    didFire = true;
    ```

27.  在 `Update`函数的末尾，如果`didFire boolean`为真，我们将很快编写的`Fire`函数将被调用。

    ```java
    if(didFire) Fire();
    ```

28.  最后，对于脚本，我们添加了`Fire`功能。这个函数只是在`lasers`数组中循环，如果它们存在的话，就调用它们的`Fire`函数。

    ```java
    private void Fire() {
      for(int i=0;i<lasers.Length;i++) {
        if(lasers[i] != null)
          lasers[i].Fire();
      }
    }
    ```

29.  既然我们已经有了所有的片段，我们需要把它们放在一起。首先创建一个新的空`GameObject`并命名为`LaserBlast`。
30.  接下来，使`LineBlast`和`SpreadBlast`粒子系统成为这个新对象的子对象。务必将他们的位置和旋转设置为`0`。
31.  将我们的`LaserBlast`脚本添加到同名对象中，并将两个粒子系统添加到脚本组件的**粒子**列表中。
32.  接下来，向对象添加一个**音频源**组件。选择**音频剪辑**值的**激光**音效。
33.  最后对于该对象，展开**三维声音设置**组，选择**线性衰减**作为**音量衰减**值；否则，我们将无法听到它。
34.  将激光发射器放在玩家飞船的喷嘴前。根据需要复制它以涵盖所有要点。此外，确保它们的局部 z 轴沿着喷嘴指向前方。
35.  接下来，让所有你的`LaserBlast`物体成为玩家飞船的孩子，这样他们就可以继续跟着飞船移动。
36.  Finally, add the objects to the **Lasers** list on the `TouchShoot` script component.

    ![Time for action – adding laser blasts](img/2014OT_08_22.png.jpg)

## *刚刚发生了什么？*

我们为玩家制作了激光爆破。每当玩家触摸屏幕时，它们就会被触发。通过这种方式，玩家可以知道他们正在射击，即使他们没有击中任何东西。这是一个快速和短暂的效果，但增加了很多最终的体验。

## 加油英雄——更多类型的激光

玩家可以发射激光，现在敌人也需要。给敌舰增加一些激光冲击波。还有，是时候用更好的东西代替他们的球形子弹了。创建一个等离子球来代替球形子弹。一个较小的环形爆炸版本可以适用于这个球。当球飞向球员时，一个适当颜色的引擎轨迹可以用于球的轨迹。在子弹上加上警报可能也是个好主意。这样玩家就知道他们什么时候会被轰出游戏。

# 总结

在本章中，我们学习了 Unity 中的特效，特别是音频和粒子系统。我们从了解 Unity 如何处理音频文件开始。通过添加背景音乐和警报系统，我们将学到的东西付诸实践。我们继续了解粒子系统，并为玩家的飞船创建了引擎轨迹。最后，我们把这两种技能组合在一起，创造了爆炸和激光爆炸。粒子系统和音频效果为游戏的最终润色和外观增加了很多。

在下一章中，我们将通过查看 Unity 中的优化来一起完成我们的体验。我们将看看为跟踪性能提供的工具。我们还将创建自己的工具来跟踪脚本性能的特定部分。我们还将创建自己的工具来跟踪脚本性能的特定部分。我们将探索资产压缩和其他我们可以改变的点，以最大限度地减少应用程序占用空间。最后，将讨论减少滞后的关键点。