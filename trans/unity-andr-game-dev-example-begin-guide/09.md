# 第九章。最佳化

*在上一章中，我们了解了游戏的特效。我们在太空战斗机游戏中加入了背景音乐。我们也为我们的船创造了引擎痕迹。结合音频效果和粒子系统，我们创造了一些爆炸和枪爆炸。总之，这丰富了游戏体验，给了我们一个非常完整的游戏外观。*

*在本章中，我们探讨了我们的优化选项。我们从查看应用程序占用空间以及如何减少它开始。我们接着看比赛的表现。我们查看 Unity 提供的工具，并自己创建另一个工具。通过使用遮挡剔除，我们可以进一步提高游戏的性能。最后，我们将探讨一些可能导致滞后的关键领域，以及如何将它们的影响降至最低。*

在本章中，我们将涵盖以下主题:

*   最小化应用程序占用空间
*   跟踪性能
*   最小化滞后
*   闭塞

在这一章中，我们将致力于我们的太空战斗机和坦克战游戏。从开启太空战斗机项目开始。

# 最小化应用程序占用空间

一个成功游戏的关键之一是游戏本身的大小。许多用户会很快卸载任何看起来不必要大的应用程序。此外，所有的移动应用商店都会根据应用程序本身的大小限制如何向用户提供游戏。熟悉最小化游戏尺寸的选项是控制游戏分配的关键。

当致力于最小化足迹时，首先要注意的是 Unity 在构建游戏时如何处理资产。游戏中实际上只包括在构建场景中某处使用的资产。如果它不在场景本身中或被场景中的资源引用，它将不会被包括在内。这意味着你可以有资产的测试版本，或者不完整的版本；只要它们没有被引用，它们就不会影响你游戏的最终构建大小。

Unity 还允许您将您的资产保存在您处理它们所需的格式中。完成最终构建后，所有资产都将转换为适合其类型的版本。这意味着您可以将模型保持为您的建模程序所固有的格式。或者把你的图片保存为 Photoshop 文件，或者你工作的任何其他格式，在游戏搭建的时候会适当的转换成`JPG`或者`PNG`。

## 编辑日志

当你最终准备好来处理你的游戏足迹时，就有可能找出到底是什么导致你的游戏比预期的要大。在**控制台**窗口的右上角是一个下拉菜单按钮。这个菜单里面是**打开编辑日志** 。

![Editor log](img/2014OT_09_07.jpg)

编辑器日志是 Unity 运行时输出信息的位置。这包括有关当前版本、许可证检查和任何资产导入的信息。日志还将包含游戏中包含的文件大小和资产的详细信息。

![Editor log](img/2014OT_09_08.jpg)

我们可以看到最终版本的各个方面。每个资产类别都有一个总构建大小的大小和百分比。我们还提供了游戏中实际包含的每个资产的列表，在添加到构建之前，按照它们的文件大小进行组织。当寻找可以做得更小的资产时，这些信息变得非常有用。

## 资产压缩

在模型、纹理和音频的**导入设置**中，有一些选项会影响导入资产的大小和质量。一般来说，受影响的变化是质量下降。然而，尤其是在移动设备上工作时，在设备上的差异明显之前，资产质量可能会降低到计算机所需的水平以下。一旦你了解了每种类型的资产的可用选项，你将能够就游戏质量做出最佳决策。当使用这些选项中的任何一个时，在引入不需要的工件之前，寻找一个最小化尺寸的设置。

### 车型

不管你用什么程序或方法来创建你的模型，最终它们总是一个顶点位置和三角形的列表，有一些纹理的参考。模型的大部分文件大小来自顶点位置列表。为了确保你游戏中的模型是最高质量的，从你选择的建模程序开始。删除所有多余的顶点和面。这不仅会导致在构建最终游戏时文件变小，还会减少在编辑器中工作时的导入时间。

模型的**导入设置**由三页组成，从而有更多的选项来调整质量。每个页面选项卡都对应于模型的相关部分，允许我们对它们进行微调。

### 模型选项卡

在**模型**选项卡上，我们能够影响网格的导入方式。说到优化我们对车型的使用，这里有许多选择是成功的关键。一旦你的游戏按照你想要的方式来看和玩，我们应该好好看看下面截图中显示的设置:

![Model tab](img/2014OT_09_03.jpg)

**型号**标签下的设置说明如下:

*   **网格压缩**:这个选项让我们选择应该对模型应用多少压缩。这种效果相当于合并顶点，以减少必须为网格存储的整体细节量。此设置可能会在网格中引入不希望的奇怪现象。所以，总是选择不引入任何工件的最高设置。
*   **读/写使能**:这个选项只有当你想在游戏运行时通过脚本操纵网格时才有用。如果您从未使用任何脚本接触过网格，请取消选中此框。虽然不影响最终的构建大小，但这将影响运行游戏所需的内存。
*   **优化网格**:该选项使 Unity 对描述模型的三角形列表重新排序。这总是好的一离开就被查了。您可能想要取消选中它的唯一原因是，如果您正在根据三角形的特定顺序操纵游戏或网格。
*   **生成对撞机**:这个选项几乎都是可以不选的。该选项将向模型中的每个网格添加网格碰撞器组件。在游戏中处理物理时，这些计算相对昂贵。如果可能的话，你应该总是使用一组非常简单的盒子碰撞器和球体碰撞器。
*   **生成光照贴图 UVs** :这个选项应该只在处理需要静态阴影的对象时使用。如果对象没有，它将引入多余的顶点信息并膨胀资产。
*   **法线**:材质使用这个选项来决定顶点朝向哪个方向，以及光照应该如何影响它。如果网格从不使用需要**法线**信息的材质，请确保将其设置为**无**。
*   **切线**:材质使用这个选项来伪造凹凸贴图和类似特效的细节。就像**法线**设置一样，如果你不需要它们，不要导入它们。如果**法线**设置为**无**，该设置将自动灰显，不再导入。

### 装备标签

以下是显示**装备**标签的截图:

![Rig tab](img/2014OT_09_09.jpg)

在优化你的动画装备时，真的只有两件事要记住。首先，如果资产没有动画，那么不要导入它。通过将**动画类型**设置为**无**，Unity 将不会尝试导入装备或任何无用的动画。要记住的第二件事是去除任何不必要的骨头。导入到统一后，从装备中删除对动画或角色没有实际影响的所有对象。Unity 会将您可能用于制作动画的任何反向运动学转换为正向运动学，因此在 Unity 中可以删除一次用于反向运动学的参考线。

### 动画选项卡

与**装备**标签一样，如果模型没有动画，不要导入动画。取消选中**导入动画**框，当第一次导入资产时，将避免任何额外的组件被添加到您的统一游戏对象中。此外，如果任何额外的动画意外添加到您的最终构建中，它们会迅速使您的应用程序变得过大。

![Animations tab](img/2014OT_09_06.jpg)

**动画**选项卡下的设置说明如下:

*   **动漫。压缩** :此选项调整 Unity 如何处理动画中多余的关键帧。对于大多数情况，默认选项效果很好。
    *   **关闭**:只有需要高精度动画的时候才应该使用这个选项。这是最大和最昂贵的设置选择。
    *   **关键帧减少**:该选项将根据随后的错误设置减少动画使用的关键帧数量。本质上，如果关键帧对动画没有明显的影响，它将被忽略。
    *   **关键帧缩小和压缩**:该选项与前一选项相同，但额外压缩动画的文件大小。然而，在运行时，动画仍然需要与前一个选项相同的处理器资源来计算。
*   **旋转误差**:此选项是执行关键帧缩小时，将被忽略的关键帧之间的不同度数。
*   **位置误差**:该选项是执行关键帧缩小时关键帧之间将被忽略的移动距离。
*   **缩放误差**:该选项是在执行关键帧缩小时，动画中关键帧之间将被忽略的大小调整量。

### 纹理

在计算机图形学中处理纹理时，最好使用 2T2 的**次方。2 的幂是任何一个值，它和它的后半部分可以被二等分，直到一。这很重要，因为它们对计算机来说计算和处理速度更快。默认情况下，Unity 会将任何不符合此要求的纹理转换为最接近的 2 次方。**

![Textures](img/2014OT_09_04.jpg)

Unity 中可用的各种**纹理**设置解释如下:

*   **纹理类型**:此选项影响此图像将被视为何种类型的纹理。最好选择最适合图像预期用途的类型。
    *   **纹理**:这个选项是最常见也是默认的设置。这应该用于你的正常模型纹理。
    *   **普通贴图**:此选项用于凹凸贴图等特效。使用这种类型纹理的材质还需要模型导入设置中的法线和切线信息。
    *   **图形用户界面**:如果图像将出现在图形用户界面中，而不是出现在任何型号上，则应使用该选项。
    *   **反射**:这些纹理用于创建模拟真实物体反射属性的立方体贴图。
    *   **Cookie** :这些纹理用在灯光上，改变灯光从灯光对象发出的方式。
    *   **Advanced**: This option gives full control over all of the settings concerned with importing images. You will only need this setting if you have special purposes for your textures.

        当**纹理类型**选项设置为**高级**时，**读/写启用**框变为可用。只有当你计划在游戏运行时从你的脚本中操作纹理时，这才应该被选中。如果未选中，Unity 不会在 CPU 中维护数据副本，从而为游戏的其他部分释放内存。

*   **生成 Mip 贴图**:这个选项是另一个**高级**设置，可以让你控制创建更小的版本的纹理。然后，当纹理在屏幕上很小时，使用它们，减少了在屏幕上绘制纹理和使用它的对象所需的处理量。
*   **过滤模式**:该选项适用于所有纹理类型。当你非常靠近它时，它会影响图像的外观。**点**会使图像看起来像块状，而**双线性**和**三线性**会模糊像素。总的来说，**点**最快；**三线性**最慢，但效果最好。
*   **最大尺寸**:这个选项可以调整在游戏中使用时图像的大小。这允许您处理非常大的图像，但以适当的小尺寸将它们导入 Unity。一般来说，大于 **1024** 的数值是很差的选择；不仅仅是因为内存需求的增加，还因为大多数移动设备上的显卡无法处理更大的纹理。选择尽可能小的尺寸将对最终构建中纹理的足迹大小有很大影响。
*   **格式**:该选项调整应该如何导入图像以及每个像素可以容纳多少细节。**压缩的**最小，而**真彩**提供的细节最多。

### 音频

赋予游戏品质的声音总是会给游戏的最终尺寸增加很多。这是一个游戏离不开的资产之一，但在适当的水平上很难包括在内。在您的音频程序中处理它们时，请尽可能缩短它们以最小化它们的大小。音频导入设置都会影响它们在构建大小中的足迹，或者运行游戏所需的内存。

![Audio](img/2014OT_09_05.jpg)

Unity 中可用的各种**音频**设置解释如下:

*   **音频格式**:该设置改变了文件在你的游戏中的存储方式。**原生**提供更高的质量，而**压缩**导致文件大小更小。作为移动平台的一个特殊功能，由于移动设备中的一些特殊硬件，压缩音频可以比其他平台检索得相对更快。
*   **3D 声音**:该设置决定了文件是否会受到其在游戏中相对于**音频监听器**的位置的影响。如果不选中此项，可以避免一些计算，从而减少游戏每一帧所需的处理。
*   **强制为单声道**:此设置将立体声音频转换为单声道。虽然大多数设备在技术上能够播放立体声，但它们并不总是拥有 T2 所需要的多扬声器来发挥作用。选中此框可以通过删除额外的音频通道来显著减小音频的文件大小。
*   **加载类型**:这个设置会影响游戏运行时系统内存的使用量，来处理音频文件的加载。**加载解压**使用最多的内存，最适合小而短的声音。**内存压缩**只在文件播放时进行解压缩，使用中等内存，最适合中等大小的文件。**从光盘流出**意味着只有当前正在播放的文件部分存储在运行时存储器中。这就像从互联网上流式传输视频或音乐。此选项最适合大型文件，但一次只能由少数人使用。
*   **压缩(kbps)** :此设置调整音频文件中的细节量。较小的值将减小文件大小，但也会降低质量。值越大，文件越大，质量越好。如果音频已经应用的压缩量小于此处的值，则该设置对声音没有影响。一般来说，最好选择最小的尺寸，同时保持所需的质量水平。

## 玩家设置

打开游戏的**玩家设置**，进入 Unity 的工具栏，导航至**编辑** | **项目设置** | **玩家**。在**各平台设置**中，对于安卓系统，我们在**其他设置**下还有另外几个选项会影响我们游戏的最终大小和速度。

### 渲染

以下是显示 **渲染**设置的截图:

![Rendering](img/2014OT_09_10.jpg)

Unity 中可用的各种**渲染**设置解释如下:

*   当我们制作光照贴图时，我们需要将一些对象设置为静态。这告诉统一，这些物体将永远不会移动，并允许它们被光照贴图。它还允许 Unity Pro 用户利用**静态批处理**，通过对相同的对象进行分组，Unity 可以显著加快渲染速度。然后，对于每个组，它在多个位置呈现一个对象，而不是单独呈现每个对象。这个设置可能会给你的最终构建尺寸增加一些额外的围长，因为 Unity 需要保存关于静态对象的额外信息来使它工作。
*   **动态配料**的工作原理与**静态配料**相同，主要有两个区别。首先，它对 Unity Pro 和 Basic 用户都可用。其次，它对没有标记为静态的对象进行分组。

### 优化

**优化**设置为，如下图所示:

![Optimization](img/2014OT_09_11.jpg)

Unity 中可用的各种**优化**设置解释如下:

*   **Api 兼容级别**:该设置决定了。要包含在最终版本中的。**。Net 2.0** 将包含所有可用的功能，占用空间最大。**。Net 2.0 子集**是函数的一小部分，只包括那些你的程序最可能使用的函数。除非你需要一些特殊的功能，**。Net 2.0 子集**应该永远是你选择的选项。
*   **剥离等级**:该设置是 Unity Pro 独有的功能。它允许您通过在编译之前移除所有多余的代码来减少最终构建的大小。为了便于参考，系统功能被分组到所谓的库中。**剥离组件**从最终版本中移除未使用的库。使用 micro mscorlib 选项执行与前一选项相同的功能，但使用了最小化形式的库。虽然这个库非常小，但是它拥有更少的函数供您的代码使用。然而，除非你的游戏很复杂，否则应该不会有什么不同。
*   **优化网格数据**:该设置将从所有没有被应用到它们的任何材质使用的网格中移除额外的信息。这包括**法线**、**切线**以及其他一些信息。除非你有一个非常特殊的情况，这是一个很好的选择。

# 跟踪性能

Unity 为我们提供了许多工具，使我们能够确定我们的游戏运行得有多好。我们将覆盖的第一个对 Unity Pro 和 Basic 用户来说都是现成的。然而，信息相当有限，尽管仍然有用。第二种仅适用于 Unity Pro 用户。它提供了更多关于性能的细节和信息。最后，我们将创建自己的工具，允许我们详细查看脚本的性能。

## 编辑统计

在**游戏**窗口的右上角，有一个标有**统计**的按钮。点击此按钮将打开一个窗口，给我们关于游戏如何运行的信息。关于游戏运行速度的信息很少。这个窗口中的大部分信息都与游戏的渲染效果有关，主要包括屏幕上当前有多少对象，有多少动画，以及它们占用了多少内存。

![Editor statistics](img/2014OT_09_02.jpg)

统一编辑器中的各种统计信息解释如下:

*   在统一编辑器**统计**窗口的右上角是当前的 **FPS** ( **每秒帧数** )和最后一帧渲染所用的时间(毫秒)。这些值不受 Unity 编辑器其余部分渲染的影响，尽管在编辑器中运行游戏会稍微影响性能。一般来说，如果你能让你的游戏运行在 60 FPS 以上，你的游戏在你的目标平台上会运行得相当好。
*   **主线程**统计数据为我们提供了以毫秒为单位的时间，用于运行帧的代码和将所有内容渲染到屏幕上。这是处理一帧游戏所需的总时间。
*   在**主线**的右边，我们有**渲染器**。此统计数据是仅渲染帧所需的毫秒数。这个时间已经包含在**主线**统计中。
*   **绘制调用**统计是必须在屏幕上绘制的唯一对象的数量。这大致等于摄像机当前可见的对象数量。所以，相机后面的东西没有画出来，也不会增加这个值。
*   通过批处理统计保存的**与**抽号**的数量密切相关。稍后我们将了解更多关于批处理的信息。但是，就目前而言，批处理是一个特殊的分组过程，它减少了**绘制调用**的数量，使游戏渲染更快。**
*   最终，三维图形中的每个模型都是由一系列三角形组成的。 **Tris** 是摄像机看到和渲染的三角形总数。
*   模型文件中的大部分信息都与每个顶点的位置有关。 **Verts** 是摄像机看到并渲染的顶点总数。每个模型的顶点数量越少，渲染到屏幕上的速度就越快。
*   **使用的纹理**统计的第一个数字是此帧中使用的唯一纹理的总数。其次是它们占用的内存总量。通过降低纹理质量或组合纹理，可以减少这一统计数据，让游戏运行得更快。
*   **渲染纹理**统计是一种特殊类型的纹理，用于特殊效果，如安全摄像头和实时反射。此统计数据显示了可见的总数以及它们所需的内存量。
*   **切换**统计本质上等于**渲染纹理**统计做了多少工作。更少的**渲染纹理**和更简单的材料将减少这个数量和渲染时间的成本。
*   **屏幕**是**游戏**窗口的当前宽度和高度，以像素为单位。它还会显示以该大小渲染所需的内存量。较小的尺寸导致游戏的细节较少，但也使游戏更容易渲染。
*   **VRAM 使用率**统计数据给出了当前使用的视频内存的大概最小和最大值。它还在括号中提供了当前可用的视频内存总量。有了这个统计数据，并知道目标设备中可用的视频内存量，您就可以确定游戏的图形是否足够简单，可以在该设备上运行。
*   **VBO 总数**统计是游戏当前渲染的唯一网格的总数。你可能使用的每一个独特的模型都会增加这个统计数据。
*   当使用实时阴影时，使用**阴影脚轮**统计。实时阴影很贵。如果可能，它们不应在移动设备上使用。但是，如果你必须拥有它们，尽量减少投射阴影的物体的数量。将其限制为移动足够大的对象，以便用户可以看到阴影。小型静态物体尤其不需要投射阴影。
*   **可见蒙皮网格**统计数据是摄像机视图中当前操纵对象的总数。**蒙皮网格**通常是你的角色，也是其他任何动画角色。
*   **动画**统计提供了当前场景中播放的动画总数。
*   **网络**统计组只有在多人游戏中连接到其他玩家时才可见。这些信息通常相当于游戏连接了多少人，以及这些连接有多快。

## 轮廓仪

在**窗口** | **探查器**下的 Unity 工具栏中找到的**探查器**窗口，是分析游戏运行情况的绝佳工具。它为我们提供了一个丰富多彩的系统各部分的细分，以及它正在做多少工作。这个工具唯一真正不幸的地方是，它只适用于 Unity Pro 用户。

![The Profiler](img/2014OT_09_12.jpg)

通过首先打开 **Profiler** 窗口，然后我们可以在窗口中玩我们的游戏，并观看工具给我们一个关于正在发生的事情的相当详细的细分。我们可以点击任何一个点，在窗口的底部看到关于那个框架的详细信息。提供的信息是针对您点击的车道、 **CPU 使用率**、**渲染**、**内存**等。

**CPU 使用率**信息在试图查找我们游戏中耗时过长的部分时特别有用。加工成本的激增很容易凸显出来。通过点击一个尖刺，我们可以看到游戏的每个部分在使那个框架昂贵的过程中所做的分解。对于这些部分中的大部分，我们可以深入了解导致问题的确切对象或功能。然而，我们只能进入功能层面。仅仅因为我们知道代码中的某个问题通常在哪里，Profiler 就不会告诉我们该函数的哪个部分导致了这个问题。

为了实际工作，剖析器需要连接到游戏的每个部分。这在你的游戏速度上引入了一点额外的成本。因此，在分析所提供的信息时，最好考虑相对成本，而不是将每个成本作为一个精确的值。

## 跟踪脚本性能

Unity 提供的所有这些工具都很棒，但并不总是正确的解决方案。Unity Basic 用户无权访问探查器。此外，剖析器和编辑器统计数据都相当一般化。我们可以通过 Profiler 获得更多的细节，但并不总是足够的。在下一部分，我们将创建一个特殊的脚本，能够跟踪任何脚本的特定部分的性能。它绝对应该成为开发人员工具包中的常规部分。

# 行动时间-跟踪脚本

我们将在太空战斗机游戏中创建这个脚本:

1.  首先，我们需要一个特殊的类来记录我们的性能统计数据。创建一个新的脚本并命名为`TrackerStat`。
2.  To begin this script, we first need to change the class definition line. We do not want or need to extend the `MonoBehaviour` class. So, find the following line of code:

    ```java
    public class TrackerStat : MonoBehaviour {
    ```

    并且，将其更改为以下内容:

    ```java
    public class TrackerStat {
    ```

3.  这个脚本从四个变量开始。第一个将被用作 ID，允许我们通过提供不同的键值一次跟踪多个脚本。第二个将跟踪被跟踪的代码位所花费的平均时间。第三个只是被跟踪代码被调用的总次数。第四个是代码执行的最长时间。

    ```java
    public string key = "";
    public float averageTime = 0;
    public int totalCalls = 0;
    public float longestCall = 0;
    ```

4.  接下来，我们还有两个变量。这些将完成实际跟踪脚本执行时间的工作。首先是跟踪开始的时间。第二个是标记跟踪已经开始的标志。

    ```java
    public float openTime = 0;
    public bool isOpen = false;
    ```

5.  这个脚本的第一个功能是`Open`。当我们想要开始跟踪一点代码时，调用这个函数。它首先检查代码是否已经被跟踪。它使用`Debug.LogWarning`向**控制台**窗口发送警告，如果是。接下来，它设置标记代码被跟踪的标志。最后，该函数通过使用`Time.realtimeSinceStartup`来跟踪它被调用的时间，这是游戏开始后的实际秒数。

    ```java
    public void Open() {
      if(isOpen) {
        Debug.LogWarning("Tracking is already open. Key: " + key);
      }

      isOpen = true;
      openTime = Time.realtimeSinceStartup;
    }
    ```

6.  下一个函数`Close`与上一个函数相反。当我们到达我们想要跟踪的代码的末尾时，它被调用。跟踪应该停止的时间传递给它。这样做是为了最大限度地减少执行的多余代码量。和前面的函数一样，它检查跟踪是否正在进行，发出另一个警告，如果没有，则提前退出。接下来，`isOpen`标志通过设置为`false`来清除。最后，计算追踪开启后的时间量，并调用`AddValue`功能。

    ```java
    public void Close(float closeTime) {
      if(!isOpen) {
        Debug.LogWarning("Tracking is already closed. Key: " + key);
        return;
      }
      isOpen = false;
      AddValue(closeTime - openTime);
    }
    ```

7.  这个脚本的最后一个功能是`AddValue`。这个函数被传递给`callLength`，被跟踪的代码段所用的时间长度。然后它使用一些数学方法来增加`averageTime`的价值。接下来，该功能将当前`longestCall`与新值进行比较，并选择最长的值。最后，功能增加`totalCalls`。

    ```java
    public void AddValue(float callLength) {
      float totalTime = averageTime * totalCalls;
      averageTime = (totalTime + callLength) / (totalCalls + 1);

      longestCall = longestCall < callLength ? callLength : longestCall;

      totalCalls++;
    }
    ```

8.  接下来，我们需要创建另一个新的脚本并将其命名为`ScriptTracker`。这个脚本将允许我们进行实际的性能跟踪。
9.  这个脚本从一个变量开始。此变量维护当前正在跟踪的所有统计信息。注意这里`static`的用法；它允许我们从游戏中的任何地方轻松更新列表。

    ```java
    private static TrackerStat[] stats = new TrackerStat[0];
    ```

10.  这个脚本的第一个函数`Open`允许我们开始跟踪代码的执行。它使用`static`标志，所以任何脚本都可以轻松调用该函数。一个`key`值被传递给函数，允许我们对呼叫进行分组跟踪。该功能首先创建一个变量来保持 stat 的`index`以开始跟踪。接下来，它在当前的`stats`集合中循环寻找匹配的`key`值。如果找到一个，`index`变量用该值更新，并退出循环。

    ```java
    public static void Open(string key) {
      int index = -1;

      for(int i=0;i<stats.Length;i++) {
        if(stats[i].key == key) {
          index = i;
          break;
        }
      }
    ```

11.  `Open`功能通过检查是否找到状态来继续。`index`变量只有在通过整个电流回路`stats`并且找不到匹配的`key`时才会小于零。如果没有找到，我们调用`AddNewStat`，它将很快创建，以创建新的统计数据进行跟踪。`index`然后设置为新状态。最后，使用 stat 的`Open`功能触发 stat 开始跟踪。

    ```java
      if(index < 0) {
        AddNewStat(key);
        index = stats.Length – 1;
      }

      stats[index].Open();
    }
    ```

12.  `AddNewStat`功能传递给要创建的 stat 的`key`。首先将`stats`列表存储在一个临时变量中，并将`stats`列表的大小增加一。然后每个值从`temp`列表转移到更大的`stats`列表。最后，创建一个新的 stat，将其分配到`stats`列表中的最后一个槽，并设置`key`。

    ```java
    private static void AddNewStat(string key) {
      TrackerStat[] temp = stats;
      stats = new TrackerStat[temp.Length + 1];

      for(int i=0;i<temp.Length;i++) {
        stats[i] = temp[i];
      }

      stats[stats.Length – 1] = new TrackerStat();
      stats[stats.Length – 1].key = key;
    }
    ```

13.  接下来，我们有`Close`功能。该功能被传递给要关闭的 stat 的`key`值。它从找到调用函数的时间开始，最大限度地减少被跟踪的多余代码量。它继续在`stats`列表中循环寻找匹配的`key`。如果找到一个，则调用 stat 的`Close`函数并退出该函数。如果未找到匹配项，则调用`Debug.LogError`向**控制台**窗口发送错误消息。

    ```java
    public static void Close(string key) {
      float closeTime = Time.realtimeSinceStartup;

      for(int i=0;i<stats.Length;i++) {
        if(stats[i].key == key) {
          stats[i].Close(closeTime);
          return;
        }
      }

      Debug.LogError("Tracking stat not found. Key: " + key);
    }
    ```

14.  这个脚本的最后一个静态函数是`Clear`。它只会清空统计列表，为新的追踪做好准备。

    ```java
    public static void Clear() {
      stats = new TrackerStat[0];
    }
    ```

15.  脚本的最后一步是`OnGUI`功能。这个功能会让我们在游戏进行的时候看到我们的统计数据。在其中，我们大量使用了`GUILayout`类及其功能。`GUILayout`自动整理各种 GUI 元素，让我们花更少的时间整理，更多的时间分析。我们首先使用`BeginVertical`开始元素的垂直列表。`BeginHorizontal`用于开始元素的水平列表。`Label`功能是然后用来为我们统计的每一行创建标题。我们正在使用`GUILayout.Width`功能给每个标签一个特定的宽度，使布局看起来更好。接下来，调用`EndHorizontal`关闭水平列表。每次呼叫`BeginHorizontal`都必须与一个`EndHorizontal`配对，否则 Unity 会有很多抱怨。

    ```java
    public void OnGUI() {
      GUILayout.BeginVertical();

      GUILayout.BeginHorizontal();
      GUILayout.Label("Key", GUILayout.Width(150));
      GUILayout.Label("Average", GUILayout.Width(100));
      GUILayout.Label("Total", GUILayout.Width(50));
      GUILayout.Label("Longest", GUILayout.Width(100));
      GUILayout.EndHorizontal();
    ```

16.  接下来，我们循环查看我们的统计列表。对于每个，我们创建一个水平列表，并使用`Label`在屏幕上绘制每个 stat。`ToString`功能用于将数字转换为标签所需的字符串。

    ```java
      for(int i=0;i<stats.Length;i++) {
        GUILayout.BeginHorizontal();

        GUILayout.Label(stats[i].key.ToString(), GUILayout.Width(150));
        GUILayout.Label(stats[i].averageTime.ToString(), GUILayout.Width(100));
        GUILayout.Label(stats[i].totalCalls.ToString(), GUILayout.Width(50));
        GUILayout.Label(stats[i].longestCall.ToString(), GUILayout.Width(100));

        GUILayout.EndHorizontal();
      }
    ```

17.  `OnGUI`功能通过创建一个按钮来完成，当点击该按钮时会调用`Clear`功能。最后，调用`EndVertical`函数结束元素的垂直列表。对`BeginVertical`的每个呼叫必须与对`EndVertical`的呼叫配对，正如横向列表一样。

    ```java
      if(GUILayout.Button("Clear"))
        Clear();

      GUILayout.EndVertical();
    }
    ```

18.  要测试这些脚本，打开你的`PlayerShip`脚本。在`Rotate`功能的开头，添加以下一行开始跟踪运行时间。

    ```java
    ScriptTracker.Open("PlayerShip_Rotate");
    ```

19.  在 `Rotate`功能接近尾声的时候，我们需要用同一个键调用`Close`功能。

    ```java
    ScriptTracker.Close("PlayerShip_Rotate");
    ```

20.  Finally, create an empty game object and add your `ScriptTracker` script to it. Start the game and take a look at the results.

    ![Time for action – tracking scripts](img/2014OT_09_01.jpg)

## *刚刚发生了什么？*

我们创建了一个工具来测试代码的特定部分。通过在对函数的调用中包装任何一位代码，并发送一个唯一的标识，我们可以确定执行代码需要多长时间。通过平均对脚本的调用，并包装代码的不同部分，我们可以准确地确定脚本的哪些部分需要最长的时间来完成。我们还可以找出代码的部分是否被调用了太多次。这两种情况都是开始寻找最小化处理和延迟的理想点。

在部署游戏之前，请务必删除对该工具的任何引用。如果留在最后一级，它会给 CPU 增加不必要的负载。这种对游戏的不利影响可能会使游戏无法进行。始终记得清除专门用于编辑器调试的工具的任何使用。

# 最小化滞后

滞后是用来描述应用程序运行速度低于预期的模糊概念之一。作为开发人员，我们不断与提供最高质量的体验作斗争，同时保持用户期望的速度和响应能力。它本质上相当于用户设备上的处理器是否能够处理提供游戏体验的成本。游戏中一些简单的物体会导致快速处理。几个复杂对象的处理成本最高。

# 闭塞

遮挡对于有很多物体的游戏来说很棒。在它的基本形式中，任何偏离到相机侧面或后面的东西都不会被看到，因此不会被画出来。在 Unity Pro 中，我们可以设置遮挡剔除。这将计算相机实际能看到什么，而不是画出任何被阻挡在视野之外的东西。使用这些工具时必须达到一个平衡。无论如何，计算看不见的东西的成本需要低于仅仅绘制那些对象的成本。根据经验，如果有许多较小的对象经常被较大的对象遮挡，遮挡剔除是正确的选择。

# 行动时间——封锁坦克

我们将在坦克战游戏中增加遮挡剔除，因为它是唯一一个有足够大的东西来阻挡物体的游戏:

1.  所以，现在打开坦克战游戏。如果你完成了挑战，并添加了额外的碎片和障碍，这一部分将对你特别有效。
2.  进入统一工具栏打开遮挡窗口，导航至**窗口** | **遮挡剔除**。该窗口是您修改游戏中与遮挡相关的各种设置的主要访问点。
3.  Switch to the **Bake** page and we can take a look at the options associated with occlusion culling.

    ![Time for action – occluding tanks](img/2014OT_09_13.jpg)

    *   **Technique**: This setting will determine what method to use when setting up occlusion culling.

        **仅 PVS**:此设置将仅计算场景的静态对象，以应用遮挡剔除。这个选项对于处理器来说是最不密集的，但是只有当场景中只有很少的移动对象时才是好的。

        **PVS 和动态对象**:这个设置会预先计算相机可以看到哪些对象。对于动态对象，系统将创建门户。它们用于从摄像机中剔除位于入口相对两侧的物体。

        **自动入口生成**:该设置将基于入口剔除静态和动态对象。在提供最高精度的同时，该选项的处理器成本也最高。

        **查看像元大小**:该设置设置遮挡计算的详细程度。较小的值将导致更好的剔除，但会导致文件大小增加以存储额外的信息。

        **近裁剪平面**和**远裁剪平面**:这些设置被系统用来估计相机在空间的任何一点都能看到什么。它们应该设置为游戏中所有摄像机中最小的**近剪辑平面**和最大的**远剪辑平面**。

        **记忆极限**:当选择了 **PVS 技术**时，使用该设置。它有助于指导计算中可以包含多少细节。

4.  选择 **PVS 和动态对象**查看**技术**和`5`查看单元格大小。
5.  为了使遮挡系统与动态对象一起工作，我们需要设置多个遮挡区域。要创建它们，创建一个空的**游戏对象**和添加一个**遮挡区域**组件，在 Unity 的工具栏**组件** | **渲染** | **遮挡区域**下找到。
6.  They need to cover the area where any dynamic objects will be located. Create and position enough areas to cover the streets of our game. Their size can be edited just as when working with **Box Collider** components. Be sure to make them tall enough to cover all of your targets.

    ![Time for action – occluding tanks](img/2014OT_09_15.jpg)

7.  点击**遮挡**窗口底部的**烘焙**。统一编辑器的右下角会出现一个进度条，告诉你计算需要多长时间。这个过程通常需要很长时间，尤其是当你的游戏变得越来越复杂的时候。
8.  When the baking process has completed, the **Occlusion** window should have switched to the **Visualization** tab and the camera should be selected in your **Scene** window. If not, select them now. In the **Scene** view, Unity will give us a preview of how occlusion culling is working. Only those objects that can be seen will be visible while the rest are turned off.

    ![Time for action – occluding tanks](img/2014OT_09_14.jpg)

## *刚刚发生了什么？*

我们经历了设置遮挡剔除的基本过程。我们看了一下**遮挡**窗口，了解了那里可用的设置。遮挡剔除对于减少场景中的绘制调用数量非常有用。然而，这种减少需要与存储和检索遮挡计算的成本相平衡。这种平衡是通过选择合适的**技术**和合适的**观察细胞大小**来实现的。现在使用不同的值，找到一个单元格大小，在不提供太多信息的情况下给出适当的细节。

## 要记住的要点

以下是处理和避免游戏延迟的提示列表。并非所有这些都适用于您制作的每一款游戏，但对于每个项目来说，它们都值得牢记:

*   创建材质时，尽可能避免透明着色器。它们渲染起来有点贵。而且，如果你避免深度排序，你可以为自己省下一大堆麻烦。
*   每个对象使用一种材质。游戏中的抽奖次数越多，每一帧的渲染时间就越长。每个网格都是针对其上的每个材质绘制一次，即使该材质看起来没有任何作用。通过保持每个对象只有一种材质，尤其是在移动平台上，您可以最大限度地减少绘图调用的次数，并最大限度地提高渲染速度。
*   尽可能组合纹理。不是你制作的每一个纹理都会利用整个图像。只要可能，组合同一场景中物体的纹理。这最大限度地提高了图像的使用效率，同时减少了最终的构建大小和使用这些纹理所需的内存量。
*   使用空游戏对象将对象分组到你的**层次结构**中。虽然不是专门为了减少延迟，但它会让你的项目更容易处理。尤其是对于大型复杂的关卡，你将能够花更少的时间在场景中搜索对象，而花更多的时间制作一个伟大的游戏。
*   **控制台**窗口是你的朋友。在担心你的游戏不起作用之前，先看看 Unity 中的**控制台**窗口或底部的栏。两者都将显示 Unity 对您的游戏当前设置方式的任何抱怨。这里的信息为你指出了解决任何问题的正确方向。如果您不确定这些消息想要告诉您什么，请在谷歌上搜索该消息，您应该能够从许多其他 Unity 用户中轻松找到解决方案。如果您的代码似乎不起作用，并且 Unity 没有对此进行抱怨，请使用 `Debug.Log`功能将消息打印到**控制台**。这将让您找到代码可能意外退出的地方，或者不应该出现的值。
*   设备测试很重要。在编辑器中工作很棒，但是没有什么比在目标设备上测试更好的了。当游戏在设备上运行时，您可以获得更好的游戏体验。编辑器总是引入少量额外的处理开销。此外，您正在使用的计算机将永远比您打算部署到的移动设备更强大。

# 总结

在本章中，我们了解了 Unity 中的优化选项。我们首先看了我们游戏中使用的资产的各种设置，用于在保持质量的同时降低文件大小。接下来，我们了解了一些影响整体游戏的设置。之后，我们探索了跟踪游戏性能的选项。我们首先看了 Unity 提供的一些工具来跟踪性能。然后，我们创建了一个自己的工具来详细跟踪脚本性能。然后我们看了一些在游戏中最小化延迟的选项，包括利用遮挡剔除。现在我们已经了解了所有这些工具和选项，请浏览我们创建的游戏并优化它们。让他们成为最好的自己。

在这本书里，我们学到了很多东西。我们从学习 Unity、Android 以及如何让它们协同工作开始。我们的旅程继续探索统一的图形用户界面系统，并创建了一个井字游戏。然后，我们了解了任何游戏所需的基本资产，同时开始创建一个坦克战游戏。我们的坦克战游戏随后增加了一些特殊的相机效果和一些照明。我们通过引入一些敌人并让他们追逐玩家来结束坦克战游戏的创建。太空战斗机游戏的创建教会了我们在游戏中可以使用的触摸和倾斜控制。在游戏的短暂休息中，我们看到了愤怒的小鸟克隆体的创建，同时了解了物理学和 Unity 中 2D 游戏的可能性。然后我们回到太空战斗机游戏，通过添加声音和粒子效果来增加一些抛光。最后，我们的旅程以学习优化我们的游戏而结束。谢谢你读这本书。享受你与 Unity 的经历，并创造你一直梦想的令人敬畏的游戏。