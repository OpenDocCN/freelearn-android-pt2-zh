# 第三章。任何游戏的支柱——网格、材质和动画

*上一章我们学习了 GUI。我们首先创建了一个简单的井字游戏来学习基本的部分。接下来是设计图形用户界面来改变游戏的外观。最后，我们调整了游戏，这样它会自动扩展以适应任何大小的屏幕。*

*这一章讲的是任何游戏的核心:网格、材质、动画。没有这些积木，一般没有什么可以展示给玩家。当然，您可以在图形用户界面中使用平面图像。但是，这有什么乐趣呢？如果你打算选择一款 3D 游戏引擎，不妨充分利用它的功能。*

*为了理解网格、材质和动画，我们将创建一个坦克战游戏。这个项目将在其他几章中使用。到本书结束时，这将是我们将创建的两个强大的游戏之一。对于这一章，玩家将驾驶坦克绕过一个小城市，他/她将能够向动画目标射击，我们将添加一个计数器来跟踪分数。*

本章涵盖以下主题:

*   导入网格
*   创造材质
*   动画片
*   创建预设
*   光线追踪

我们将在这一章开始一个新的项目，所以跟随第一部分开始。

# 设置

虽然这个项目最终会变得比以前的项目大得多，但实际的设置是相似的，不会过于复杂。这个项目还需要一些启动资产；它们将在设置过程中描述。由于这些资产的复杂性和特殊性，建议使用现在提供的资产。

# 行动时间-设置

正如我们在前面两章所做的，我们将需要创建一个新的项目，这样我们就可以创建我们的下一个游戏。显然，首先要做的是启动一个新的 Unity 项目。出于组织目的，将其命名为`Ch3_TankBattle_CS`。

1.  这个项目也会变得比我们以前的项目大得多，所以我们应该创建一些文件夹来保持东西的有序。首先，创建六个文件夹。顶层文件夹将是`Models`、`Scripts`和`Prefabs`文件夹。在`Models`中，创建`Environment`、`Tanks`和`Targets`。有了这些文件夹，项目就更容易管理了。任何完整的模型都可以由一个网格文件、一个或多个纹理、每个纹理的材质以及可能的几十个动画文件组成。
2.  在我们走得太远之前，如果您还没有这样做，最好将您的目标平台更改为安卓。每次目标平台变更，项目中的所有资产都需要重新导入。这是由 Unity 执行的自动步骤，但是随着项目的增长，这将花费越来越多的时间。通过在项目中有任何东西之前设置我们的目标平台，我们节省了大量的时间。
3.  我们也将利用统一的一个非常强大的部分。预设是特殊的对象，它使创建游戏的过程变得更加容易。这个名字的意思是预制的——预先创建并复制。这对我们来说意味着，我们可以完全为我们的坦克设定一个射击目标，并把它变成一个预制的。然后，我们可以在整个游戏世界中放置这个预置的实例。如果我们需要改变目标，我们需要做的就是修改原来的预设。对一个预制构件所做的任何改变也在该预制构件的任何实例上进行。不用担心；使用时更有意义。
4.  我们还需要为这个项目创建一些网格和纹理。首先，我们需要一辆坦克。在没有坦克的情况下打一场坦克战有点难。提供的坦克有一个炮塔和一门大炮，它们是独立的部件。我们还将使用一个技巧来使坦克的履带看起来像是在移动，这样它们中的每一个都是独立的零件，并且也使用独立的纹理。
5.  为了我们战斗的地点，一个城市的一部分被创造出来。将使用一些可平铺的纹理，而不是对城市应用特定的纹理。此外，城市周围有一堵墙，以防止玩家从世界上消失。
6.  最后，我们需要一个动画目标。提供的那个像人的手臂一样被装配起来，用一只靶心作为手。它有四个动画。第一个从卷曲位置开始，到伸展位置。第二个与第一个相反，从伸展位置到卷曲位置。第三个从伸展位置开始向后甩，好像打在前面，回到卷曲位置。最后一个就像第三个一样，但它像从后面被击中一样向前移动。这些是相当简单的动画，但它们将很好地帮助我们了解 Unity 的动画系统。

## *刚刚发生了什么？*

这里发生的事情很少，我们只是创建了项目并添加了一些文件夹。还有一些关于我们将用于本章项目的资产的讨论。

# 导入网格

有几种方法可以将资产导入 Unity。对于资产组，我们将讨论最简单，当然也是最好的方法。

# 行动时间-输入油箱

我们开始吧。

1.  在统一编辑器中，通过右键单击您的`Tanks`文件夹并从菜单中选择**在浏览器中显示**来启动。
2.  This opens the folder that contains the asset that was selected. In this case, the `Models` folder is opened in the Windows folder browser. We just need to put our tank and its textures into the `Tanks` folder.

    ### 类型

    本章提供的文件有`Tank.blend`、`Tanks_Type01.png`和`TankTread.png`文件。此外，在 Unity 中使用`.blend`文件需要在您的系统上安装 Blender。Blender 是一个免费的建模程序，可在[http://www.blender.org](http://www.blender.org)获得。Unity 利用它来将前面提到的文件转换成它可以充分利用的文件。

3.  当我们返回 Unity 时，我们添加的文件将被检测到，它们将被自动导入。这是 Unity 最棒的地方之一。没有必要明确告诉 Unity 导入。如果项目资产中有变化，它就会这样做。
4.  您可能还会注意到在 Unity 导入我们的坦克时创建了一个额外的文件夹和一些文件。每当导入新网格时，默认情况下，Unity 会尝试将其与材质配对。在下一节中，我们将更详细地讨论 Unity 中的材质。目前，它是一个跟踪如何在网格上显示纹理的对象。基于网格中的信息，Unity 在项目中查找具有正确名称的材质。如果找不到，将在网格旁边创建一个`Materials`文件夹，并在其中创建缺失的材质。创建这些材质时，Unity 还会搜索合适的纹理。这就是为什么在添加网格的同时向文件夹中添加纹理很重要，这样它们就可以一起导入了。如果您没有在坦克的同时添加纹理，那么关于创建材质的部分将描述如何向材质添加纹理。

## *刚刚发生了什么？*

我们刚刚将我们的坦克导入 Unity。真的很简单。对项目的任何资产或文件夹所做的更改都会被 Unity 自动检测到，任何需要的内容都会被适当地导入。

# 油箱导入设置

将任何资产导入 Unity 时，都是通过使用一组默认设置来完成的。这些设置中的任何一个都可以从**检查器**窗口进行更改。选择新坦克后，我们将在此查看模型的导入设置。

![Tank import settings](img/2014OT_03_01.png.jpg)

*   统一编辑器的顶部有三个选项卡: **【模型】****装备** 和**动画**。**模型**页面处理网格本身，而**装备**和**动画** 用于导入动画。目前我们只关心**型号**页面，如果还没有选择就选择它。
*   **导入设置**窗口的**网格**部分以**比例因子**属性开始。这个值告诉 Unity 默认情况下网格有多大。建模程序中的一个通用单位或一米在 Unity 中转换为一个单位。这种坦克是以通用单位制造的，所以坦克的比例因子是 1。如果你在制作坦克的时候用厘米来计算，比例因子应该是 0.01，因为一厘米是一米的百分之一。
*   下一个选项 **网格压缩**，将在最后一章当我们回顾游戏的优化时变得很重要。压缩设置得越高，游戏中的文件就越小。然而，这将开始引入奇怪的你的网格，因为统一的工作，使其更小。现在，让它**关闭**。
*   **读/写使能** 如果你想在游戏进行中改变网格，那么它是很有用的。这可以让你做一些非常酷的事情，比如可破坏的环境，在那里你的脚本根据它们被射击的位置把网格分成碎片。然而，这也意味着 Unity 必须在内存中保留网格的副本，如果系统很复杂，这可能真的会开始滞后。这超出了本书的范围，因此取消选中该选项是一个好主意。
*   **优化网格** 是一个很好的选择，除非你正在用网格做一些具体而花哨的事情。打开它，Unity 会在幕后施展一些特殊的魔法。在计算机图形学和尤其是 Unity 中，每一个网格最终都是在屏幕上绘制的一系列三角形。此选项允许 Unity 对文件中的三角形重新排序，以便更快、更容易地绘制整个网格。
*   下一个选项 **生成对撞机**，如果用**物理学**做复杂的事情，这是一个有用的选项。Unity 有一组简单的碰撞器形状，应该尽可能使用，因为它们更容易处理。然而，有些情况下，他们不会完全完成工作，例如，碎石或半管碰撞形状太复杂，无法用一系列简单的形状来制作。这就是为什么 Unity 有一个**网格碰撞器**组件。选中此选项后，模型中的每个网格都将添加一个**网格碰撞器**组件。在本章中，我们将坚持使用简单的碰撞器，因此关闭**生成碰撞器**选项。
*   **交换 UVs** 和**生成光照贴图 UVs** 主要用于处理光照，尤其是光照贴图。Unity 可以处理模型上的两组紫外线坐标。通常，第一个用于纹理，第二个用于光照贴图或阴影纹理。如果顺序不对，**换 UVs** 会换，所以现在第二套先来。如果你需要一个光照贴图的解包，但是没有创建，那么**生成光照贴图紫外线**会为你创建一个。在这个项目中，我们不使用光照贴图，所以这两者都可以保持关闭。
*   下一部分选项 **法线&切线**，从**法线**选项开始。这定义了 Unity 如何获得网格的法线。默认情况下，它们是从文件导入的；但是也可以选择让 Unity 根据网格的定义方式来计算它们。或者，如果我们将此选项设置为**无**，Unity 将不会导入法线。**法线**如果我们想让我们的网格受到实时光照的影响，或者利用法线贴图，那么就需要法线。我们将在本项目中使用实时照明，因此将其设置为**导入**。
*   如果网格具有法线贴图，则使用**切线**、**平滑角度**和**分割切线**。需要切线来确定灯光如何与法线贴图的曲面交互。默认情况下，Unity 会为您计算这些。只能从少数文件类型导入切线。平滑角度根据两个面之间的角度决定边缘的阴影是平滑还是锐利。 **分割切线**选项用于处理一些特定的照明问题。如果照明被接缝破坏，启用此选项将修复它。普通地图非常适合让低分辨率游戏看起来像高分辨率游戏。然而，由于使用它们所需的所有额外文件和信息，它们对于移动游戏来说并不理想。因此，我们不会在本书中使用它们，所有这些选项都可以关闭以节省内存。
*   最后一节**材质**定义了 Unity 应该如何寻找材质。第一个选项 **进口材质**，是决定一种材质是否应该进口。如果关闭，将应用默认的白色材质。此材质不会出现在您项目的任何地方；这是一个隐藏的默认值。对于没有任何纹理的模型，例如碰撞网格，可以将其关闭。对于我们的坦克和几乎每一个其他情况，这应该留在。
*   最后两个选项 **材质命名**和**材质搜索** 协同工作来命名和查找网格的材质。在它们的正下方，有一个文本框，描述了 Unity 将如何开始搜索材质。正在搜索的材质的名称可以是建模程序中使用的纹理的名称、在建模程序中创建的材质的名称，或者是模型加上材质的名称。如果找不到纹理名称，将使用材质名称。默认情况下，统一进行**递归向上**搜索。这意味着我们首先查看`Materials`文件夹，然后查看同一文件夹中的任何材质。然后，我们检查父文件夹中是否有匹配的材质，接下来是上面的文件夹。这种情况一直持续到我们找到具有正确名称的材质或者到达根资源文件夹。或者，我们可以选择只查看模型旁边的`Materials`文件夹来检查整个项目。这些选项的默认值都很好。一般来说，它们不需要改变。它们最容易通过 Unity Editor 脚本进行更改，这在本书中不会涉及。
*   Next, we have a pair of buttons: **Revert** and **Apply**. Whenever changes are made to the import settings, one of these two buttons must be chosen. The **Revert** button cancels the changes and switches the import settings back to what they were before changes were made. **Apply** confirms the changes and re-imports the model with the new settings. If these buttons are not selected, Unity will complain with a pop up and force a choice before letting you mess with anything else.

    ![Tank import settings](img/2014OT_03_02.png.jpg)

*   最后，我们有两种类型的预览。如果添加到**场景**视图并被选中， **导入对象**部分是对象在 **检查器**窗口中的预览。**预览**窗口是模型在**场景**视图中的样子。您可以在此窗口中单击并拖动来旋转对象，并从不同角度观察它。还有，这个窗口里有一个蓝色的小按钮。单击此按钮，您将能够向对象添加标签。然后，这些标签也可以在**项目**窗口中搜索。

## 设置油箱

既然我们已经进口了坦克，我们需要安装它。我们将调整坦克的布局，并创建一些脚本。

# 行动时间——创造坦克

此时，我们坦克的创建将主要包括坦克部件的创建和布置。

1.  首先将坦克从**项目**窗口拖到**层级**窗口。您会注意到坦克的名称在**层级**窗口中以蓝色显示。这是因为它是一个预制实例。项目中的任何模型都很大程度上像一个预制构件。但是，我们希望我们的坦克不只是坐在那里。所以，作为静态网格的预置是没有帮助的。因此，在**层级**窗口中选择您的坦克，我们将通过移除`Animator`组件开始使其有用。为此，在**检查器**窗口中选择`Animator`组件右侧的档位。从新的下拉列表中，选择**移除组件**，该组件将被移除。
2.  If you are using the tank provided by default, selecting the different parts of it will reveal that all the pivot points are at the base. This will not be useful for making our turret and cannon pivot properly. The easiest way to solve this is by adding new empty `GameObject` to act as pivot points.

    ### 类型

    场景中的任何物体都是`GameObject`。任何空的`GameObject`都只有一个**变换**组件。

3.  在统一编辑器的顶部，**创建空的**是**游戏对象**按钮下的第一个选项。它创造了我们需要的物品。创建两个空`GameObjects`，一个放在炮塔底部，另一个放在炮塔底部。另外，将它们分别重命名为`TurretPivot`和`CannonPivot`。如果选择了对象，这可以通过位于**检查器**窗口顶部的文本框来完成。
4.  In the **Hierarchy** window, drag `TurretPivot` onto `Tank`. This changes the parent of `TurretPivot` to `Tank`. Then, drag the object, that is, the turret mesh, onto `TurretPivot`. In code, we will be rotating the pivot point, not the mesh directly. When a parent object moves or rotates, all of the children objects move with it. When you make this change, Unity will complain about the change to the original hierarchy of the object; just checking to make sure it is a change you want to do and not an accident.

    ![Time for action – creating the tank](img/2014OT_03_03.png.jpg)

5.  因为失去与预设的连接可能会破坏游戏，统一只是想确定我们真的希望它发生。所以，点击**继续**，我们就可以完成坦克的工作了，没有其他来自 Unity 的抱怨。我们也需要让`CannonPivot`成为`TurretPivot`的孩子，让大炮成为`CannonPivot`的孩子。
6.  为了完成我们的层次变化，我们需要放置摄像机。因为我们想让它看起来好像玩家真的在坦克里，所以相机应该放在坦克的后面和上面，稍微向下倾斜，聚焦在前方几个坦克长度的地方。一旦定位，也使其成为`TurretPivot`的孩子。

## *刚刚发生了什么？*

我们设置了我们的坦克将使用的基本结构。通过以这种方式利用多个物体，我们可以彼此独立地控制它们的运动和动作。在这一点上，我们可以独立地倾斜、旋转和瞄准每一个零件，而不是只有一个指向前方的刚性坦克。

### 类型

此外，坦克应该在你想要整个东西旋转的点的上方居中。如果你的不是，你可以在**层次**窗口中选择基本坦克对象下的所有东西，并移动它。

# 行动时间-记分

一个记录玩家分数的短脚本将构成这一小段的重点。

1.  为了让这个坦克工作，我们需要三个脚本。第一个相当简单。创建一个新的脚本并命名为`ScoreCounter`。顾名思义，它将跟踪分数。在`Scripts`文件夹中创建它，并清除默认功能，就像我们到目前为止制作的其他脚本一样。
2.  在新脚本中添加以下代码行:

    ```java
    public static int score = 0;
    ```

    *   在很大程度上，从上一章来看，这应该很熟悉。首先我们定义一个整数计数器。因为它是静态的，其他脚本(例如我们将为目标创建的脚本)将能够修改这个数字并给我们评分。
3.  我们接下来使用`OnGUI`函数定义一个`Rect`类，并使用`GUI.Box`函数显示分数。盒子就像标签，但默认情况下它是黑色背景。这将使我们移动时更容易看到。

    ```java
    public void OnGUI() {
      Rect scoreRect = new Rect(0, 0, 100, 30);
      GUI.Box(scoreRect, "" + score);
    }
    ```

## *刚刚发生了什么？*

我们刚刚创建了一个非常简单的脚本。它会全程跟踪我们的得分。此外，其他脚本将更新计数器来给玩家打分，而不是自己增加分数。

# 行动时间-控制底盘

一个普通的坦克原地旋转，可以轻松的前后移动。我们将通过创建一个单独的脚本来让我们的坦克做到这一点。

1.  第二个剧本叫做`ChassisControls`。它会让我们的坦克移动。也在`Scripts`文件夹中创建它。
2.  脚本的前三行定义了坦克需要移动的变量。我们还可以在**检查员**窗口中更改它们，以防我们的坦克太快或太慢。第一行定义了一个变量，该变量保存与`CharacterController`组件的连接。这个组件可以很容易地移动坦克，但会被墙壁和其他碰撞器阻挡。接下来的两行代码定义了我们移动和旋转的速度:

    ```java
    public CharacterController characterControl;
    public float moveSpeed = 10f;
    public float rotateSpeed = 45f;
    ```

3.  现在让我们把我们的好朋友`OnGUI`加入到这个组合中。这应该看起来很熟悉。我们正在创建四个按钮，它们将位于屏幕的左下角。当按下前两个按钮时，我们调用一个函数，这个函数会移动我们的坦克，并给它一个值来表示它的移动速度。正值会让我们前进，负值会让我们后退。最后两个按钮做同样的事情，除了用旋转代替移动。正值将向右旋转，负值将向左旋转油箱。这些按钮也是`RepeatButtons`。普通按钮每次按下只会激活一次。只要按住重复按钮，它就会处于活动状态。好的一面是，它将允许我们的坦克移动按钮被按下的每一帧。不利的一面在于`RepeatButton`和`OnGUI`功能的工作方式。如果其中一个按钮处于活动状态，在`OnGUI`功能中该按钮之后将不会绘制任何内容。有点烦，但适合我们现在的需求。

    ```java
    public void OnGUI() {
      Rect fore = new Rect(50, Screen.height – 150, 50, 50);
      if(GUI.RepeatButton(fore, "f")) {
        MoveTank(moveSpeed);
      }

      Rect back = new Rect(50, Screen.height – 50, 50, 50);
      if(GUI.RepeatButton(back, "b")) {
        MoveTank(-moveSpeed);
      }

      Rect left = new Rect(0, Screen.height – 100, 50, 50);
      if(GUI.RepeatButton(left, "l")) {
        RotateTank(-rotateSpeed);
      }

      Rect right = new Rect(100, Screen.height – 100, 50, 50);
      if(GUI.RepeatButton(right, "r")) {
        RotateTank(rotateSpeed);
      }
    }
    ```

4.  只剩下两个功能了。我们从定义我们的`MoveTank`函数开始下面一行代码。它需要通过一个速度值来指示走多远和往哪个方向走。刚才提到过；正值将向前，负值将向后。

    ```java
    public void MoveTank(float speed) {
    ```

5.  为了在三维空间中移动，我们需要一个向量——一个既有方向又有大小的值。因此，我们定义了一个运动矢量，并将其设置为坦克的前进方向，乘以坦克的速度，再乘以自上一帧以来的时间。如果你还记得几何类的话， 3D 空间有三个方向:x、y、z，在 Unity 中，以下约定适用:x 向右，y 向上，z 向前。**变换**组件保存对象的位置、旋转和缩放。我们可以通过调用 Unity 提供的`.transform`值来访问 Unity 中任何对象的**变换**组件。**变换**组件还提供了一个正向值，该值将为我们提供一个相对于对象指向前方的矢量。此外，我们希望以规则的速度移动，例如每秒一定数量的米，因此我们利用`Time.deltaTime`。这是由 Unity 提供的一个值，它保存自游戏的最后一帧在屏幕上绘制以来的秒数。把它想象成一本翻翻书。为了让它看起来像一个人在页面上行走，他需要在每一页上稍微移动。在游戏中，页面不会定期翻转。因此，我们必须通过翻转到新页面所需的时间来修改我们的运动。这有助于我们保持平稳的步伐。

    ```java
      Vector3 move = characterControl.transform.forward * speed * Time.deltaTime;
    ```

6.  接下来，我们要留在地面上。一般来说，你想在游戏中控制的任何角色都不会自动获得巨石所具有的所有物理特性，比如重力。例如，在跳跃时，你暂时移除重力，这样角色就可以上升。这就是为什么下一行代码通过减去重力的正常速度来简单实现重力，并再次使其与我们的帧速率保持同步:

    ```java
      move.y -= 9.8f * Time.deltaTime;
    ```

7.  最后，对于 `MoveTank`功能，我们实际上做了移动。`CharacterController`组件有一个特殊的`Move`功能，可以移动角色，但会通过碰撞来约束角色。我们只需要通过将`Move`向量传递给它，告诉它我们要将该帧移动多远以及向哪个方向移动。当然，最后一个大括号结束了这个函数。

    ```java
      characterControl.Move(move);
    }
    ```

8.  `RotateTank`功能是最后一个。该函数还需要一个速度值来指示旋转的速度和方向。我们从定义另一个向量开始；但是，不是定义移动的方向，而是决定旋转的方向。在这种情况下，我们将围绕向上的方向旋转。然后，我们将它乘以我们的速度和`Time.deltaTime`，以便移动得足够快并跟上我们的帧速率。

    ```java
    public void RotateTank(float speed) {Vector3 rotate = Vector3.up * speed * Time.deltaTime;
    ```

9.  函数的最后一位实际上是旋转的。**变换**组件提供`Rotate`功能。旋转，尤其是在 3D 空间中，会变得很奇怪，并且很快变得困难。`Rotate`功能为我们处理所有这些；我们只需要为它提供用于旋转的值。另外，不要忘记使用大括号来关闭函数。

    ```java
      characterControl.transform.Rotate(rotate);
    }
    ```

## *刚刚发生了什么？*

我们创建了一个脚本来控制我们坦克的运动。它会在屏幕上画一组按钮，这样我们的坦克就可以前后移动了。这是通过使用`CharacterController`组件的特殊`Move`功能来完成的。我们还使用了由**变换**组件提供的特殊`Rotate`功能，使用另一组按钮旋转我们的坦克。

# 行动时间——控制炮塔

这个脚本将允许玩家旋转他们的炮塔并瞄准大炮。

1.  我们需要为坦克创建的最后一个脚本是`TurretControls`。这个脚本将允许玩家左右旋转炮塔，上下倾斜大炮。和所有其他的一样，在`Scripts`文件夹中创建它。
2.  我们定义的前两个变量将包含指向炮塔和大炮枢轴的指针，也就是我们为坦克创建的空`GameObjects`。第二组是我们的炮塔和大炮旋转的速度。最后我们有一些极限值。如果我们不限制加农炮的旋转速度，它只会不停地旋转，穿过我们的坦克。对于坦克来说，这不是最现实的行为，所以我们必须对它进行一些限制。极限在 300 度范围内，因为正前方是零度，下方是 90 度。我们希望它是向上的角度，所以它在 300°的范围内。我们还使用 359.9，因为 Unity 会将 360 更改为零，这样它就可以继续旋转。

    ```java
    public Transform turretPivot;
    public Transform cannonPivot;

    public float turretSpeed = 45f;
    public float cannonSpeed = 20f;

    public float lowCannonLimit = 315f;
    public float highCannonLimit = 359.9f;
    ```

3.  下一步是创建`OnGUI`功能来绘制按钮并让玩家控制炮塔。该功能与我们为`ChassisControls`脚本制作的`OnGUI`功能几乎相同。区别在于`Rects`类将移动到屏幕右下角，我们称之为`RotateCannon`和`RotateTurret`函数。当我们发送一个速度到`RotateCannon`时，我们需要一个正值上升，一个负值到下降。`RotateTurret`将在很大程度上像`RotateTank`功能一样发挥作用；正速度将向右旋转，负速度将向左旋转。

    ```java
    public void OnGUI() {
      Rect up = new Rect(Screen.width – 100, Screen.height – 150, 50, 50);
      if(GUI.RepeatButton(up, "u")) {
        RotateCannon(cannonSpeed);
      }

      Rect down = new Rect(Screen.width – 100, Screen.height – 50, 50, 50);
      if(GUI.RepeatButton(down, "d")) {
        RotateCannon(-cannonSpeed);
      }

      Rect left = new Rect(Screen.width – 150, Screen.height – 100, 50, 50);
      if(GUI.RepeatButton(left, "l")) {
        RotateTurret(-turretSpeed);
      }

      Rect right = new Rect(Screen.width – 50, Screen.height – 100, 50, 50);
      if(GUI.RepeatButton(right, "r")) {
        RotateTurret(turretSpeed);
      }
    }
    ```

4.  接下来是 `RotateTurret`功能。它的工作方式与`RotateTank`功能完全相同。然而，我们并没有查看`CharacterController`组件的`Transform`变量，而是对在函数开始时定义的`turretPivot`变量进行操作。

    ```java
    public void RotateTurret(float speed) {
      Vector3 rotate = Vector3.up * speed * Time.deltaTime;
      turretPivot.Rotate(rotate);
    }
    ```

5.  最后一个函数`RotateCannon`随着旋转变得更加肮脏。错误完全在于需要限制大炮的旋转。打开功能后，第一步是计算我们要旋转这个框架多少。我们使用浮点值而不是向量，因为我们必须自己设置旋转。

    ```java
    public void RotateCannon(float speed) {
      float rotate = speed * Time.deltaTime;
    ```

6.  Next, we define a variable that holds our current rotation. We do this because Unity will not let us act on the rotation directly. Unity actually keeps track of rotation as a quaternion. This is a complex method of defining rotations that is beyond the scope of this book. Luckily, Unity gives us access to an x, y, z method of defining rotations called `EulerAngles`. It is a rotation around each of the three axes in 3D space. The `localEulerAngles` value of a **Transform** component is the rotation relative to the parent `GameObject`.

    ```java
    Vector3 euler = cannonPivot.localEulerAngles;
    ```

    ### 类型

    它被称为`EulerAngles`是因为*莱昂哈德·欧拉*，一位瑞士数学家，他定义了定义旋转的方法。

7.  接下来，我们使用`Mathf.Clamp`功能一次调整旋转并应用极限。`Mathf`是一组有用的数学函数。`Clamp`函数取一个值，使其不低于也不高于传递给该函数的其他两个值。因此，我们首先发送我们的 x 轴旋转，这是从`euler`的当前 x 旋转中减去`rotate`的结果。因为正旋转是绕着一个轴顺时针旋转，所以我们必须用正值减去我们的旋转来向上而不是向下。接下来，我们将下限传递给`Clamp`函数，然后是上限:我们在脚本顶部定义的`lowCannonLimit`和`highCannonLimit`变量。

    ```java
    euler.x = Mathf.Clamp(euler.x – rotate, lowCannonLimit, highCannonLimit);
    ```

8.  最后，我们必须将新的旋转应用到大炮的枢轴点上。这只是将**变换**组件的`localEulerAngles`值设置为新值。同样，一定要使用大括号来关闭函数。

    ```java
      cannonPivot.localEulerAngles = euler;
    }
    ```

## *刚刚发生了什么？*

我们创建了一个脚本来控制坦克的炮塔。通过使用屏幕上的按钮，玩家能够倾斜大炮和旋转炮塔。这个脚本的功能与我们之前创建的`ChassisControls`脚本非常相似。不同之处在于限制了大炮的倾斜量。

# 行动的时间到了——将各个部分组合在一起

这是最后一个剧本了。我们有我们的坦克和脚本；下一步是将它们放在一起。

1.  现在，我们需要将它们添加到我们的油箱中。还记得上一章我们是如何将`Tic-tac-toe`脚本添加到相机中的吗？首先在**层级**窗口中选择你的坦克。在它们工作之前，我们首先需要将`CharacterController`组件添加到我们的油箱中。所以，到 Unity 编辑器顶部选择**组件**，然后选择**物理**，最后点击**角色控制器**选项。
    *   You will notice that a green capsule also appears on the tank in the Scene view; at the same time the new component is added. This capsule represents the space that will collide and interact with other colliders. The values on the CharacterController component let us control how it interacts with other colliders. For most cases, the defaults for the first four are just fine.

        **坡度限制**:该属性向我们展示了控制器可以向上移动的坡度有多陡。

        **步长偏移**:这个属性告诉我们一个步长在开始阻挡移动之前可以有多高。

        **蒙皮宽度**:这个定义了另一个对撞机在完全停止之前，可以穿透这个控制器的对撞机多远。这主要用于物体之间的挤压。

        **最小移动距离**:该属性用于限制抖动。这是在框架实际移动之前必须应用的最小移动量。

        **中心**、**半径**和**高度**:这些属性定义了您在场景视图中看到的胶囊的大小。它们用于碰撞。

        ![Time for action – putting the pieces together](img/2014OT_03_04.png.jpg)

2.  最后三个价值观是我们现在关心的。我们需要调整这些值以使其与我们坦克的值尽可能接近。诚然，太空舱是圆形的，我们的坦克是方形的，但是`CharacterController`组件是移动有碰撞的角色最简单的方法，也是最常用的方法。将`2.3`的值用于**半径**属性和**中心**属性的 **Y** 部分；其他一切都可以保持默认值。
3.  现在是时候给我们的坦克添加脚本了。通过在**层次结构**窗口中选择坦克，并将`ChassisControls`、`TurretControls`和`ScoreCounter`脚本拖到**检查器**窗口上来完成此操作。这和我们在前面几章中做的一样。
4.  在坦克工作之前，我们需要完成创建我们在脚本中开始的连接。首先点击`CharacterController`组件的名称，并将其拖动到我们新的`ChassisControls`脚本组件上的**角色控制**值。Unity 允许我们在 Unity 编辑器中连接对象变量，这样它们就不需要硬编码了。
5.  我们还需要连接我们的炮塔和大炮枢轴点。因此，单击并将点从**层次结构**窗口拖动到`TurretControls`脚本组件上的相应变量。
6.  将场景保存为`TankBattle`并试用。

## *刚刚发生了什么？*

我们刚刚组装好坦克。除非在使用移动控件的同时查看**场景**视图，否则很难判断坦克在移动。不过，炮塔控制可以在**游戏**视图中看到。除了没有一个参考点来判断我们的坦克是否在移动之外，它运行得相当好。下一步和下一部分将为我们添加我们的城市提供参考点。

## 有一个围棋英雄——大炮对准

当你第一次尝试倾斜大炮时，你可能会注意到一个快速的跳跃。这样的行为很烦人，让游戏看起来很破。试着调整大炮来修理它。如果你有问题，看看大炮开始旋转。

# 创建材质

在 Unity 中，材质是如何在屏幕上绘制模型的决定性因素。它们可以简单到把它涂成蓝色，也可以复杂到用波浪反射水。在本节中，我们将介绍材质控制的细节。我们还将创建我们的城市和一些简单的材质来纹理化它。

# 行动的时刻——创造城市

创造一个城市给我们的坦克和玩家一个很好的游戏场所。

1.  For the purposes of this section, no part of the provided city was given a specific texture. It was just unwrapped and some tile-able textures were created. So, we need to start by importing the city and the textures to the `Environment` folder. Do it the same way that we imported the tank.

    ### 类型

    文件有`TankBattleCity.blend`、`brick_001.png`、`brick_002.png`、`brick_003.png`、`dirt_001.png`、`dirt_003.png`、`pebbles_001.png`、`rocks_001.png`、`rubble_001.png`、`water_002.png`。

2.  因为城市被打开，Unity 仍然为它创建了一个单一的材质。然而，纹理从未在任何建模程序中应用。所以，材质是纯白色的。我们有几个额外的纹理，所以我们需要整个城市不止一个材质。创造新材质很简单；就像创建新脚本一样。右键单击`Environment`文件夹中的`Materials`文件夹，选择**创建**，然后选择**材质**，大约在菜单的中间位置。
3.  This will create a new material in the folder and immediately allow us to name it. Name the material, `Pebbles`.

    ![Time for action – creating the city](img/2014OT_03_05.png.jpg)

4.  选择新材质后，查看**检查器**窗口。当我们选择了一个材质时，我们可以选择改变它的外观。
    *   在**检查器**窗口的最顶部，我们有材质的名称，后面是一个**着色器**下拉列表。着色器本质上是一个简短的脚本，它告诉显卡如何在屏幕上绘制一些东西。您将最常使用**漫反射**着色器，因此默认情况下它始终处于选中状态。这是您可以从凹凸贴图着色器、镜面、透明和大量其他选项中进行选择的地方。如果您要创建一些自定义着色器，也可以在这里找到它们。
    *   下一个小块只有当 Unity 有什么要警告你的时候才会出现。在这种情况下，出于性能原因，它建议我们使用不同的着色器。不过，那是对[第九章](09.html "Chapter 9. Optimization")、*优化*的讨论，所以我们暂时不予理会。
    *   然后，我们有**主色**值，旁边有一个彩色方块。点击该方块，将打开**颜色选择器**窗口，让我们选择任何我们想要的颜色。该颜色值会改变材质绘制的纹理的颜色。因为我们还没有纹理，你会注意到它只是在**预览**窗口中改变了球的颜色。
    *   **基础(RGB)** 值在**主色**值下。这就是质感。右边的框中有**无(纹理)**和一个**选择**按钮，是该材质正在使用的纹理的预览框。要给材质添加纹理，可以从**项目**窗口拖动一个到这个框中，或者点击**选择**按钮。该按钮会打开一个新窗口，其中包含当前项目中每个纹理的缩略图。您可以滚动浏览或使用搜索栏查找所需的纹理，然后双击选择它。
    *   在盒子的左边，我们有**平铺**和**偏移**控制。**平铺**值决定了纹理在 x 和 y 方向的归一化紫外线空间中重复的次数。**偏移**是纹理在归一化的紫外空间中从零开始的距离。您可以选择数字字段和输入值来修改它们。这样做，注意下面的**预览**窗口，你会看到它们是如何改变纹理的。平铺纹理最常用于大的表面，在这些表面上纹理非常相似，只是重复而已。
    *   我们的**预览**窗口位于**检查器**窗口的底部。它的功能就像我们看到的坦克网一样。然而，使这个特别的是这个窗口右上角的两个按钮。左边的一个滚动一组预览形状。通过点击它，您将能够看到纹理在球体、立方体、圆柱体或圆环体上的外观。另一个按钮在两种照明类型之间切换。
5.  通过从**项目**窗口拖动`pebbles_001`纹理并将其放到**基础(RGB)** 预览框中，将`pebbles_001`纹理添加到该材质中。
6.  材质的**平铺**使用 30 的值，而**主色**选项使用浅棕褐色，这样纹理的大小就可以调整到合适的大小，看起来也更加美观。
7.  要查看我们的新素材，首先将您的城市拖到**层级**窗口，以便将其添加到**场景**视图。通过右击并拖动，您可以在您的**场景**视图中四处查看。看看城市的街道。
8.  现在，将您的新素材从**项目**窗口拖到您的**场景**视图中。当拖动材质的时候，你应该会看到网格发生变化，看起来就像是在使用材质一样。一旦你过了马路，放开你的鼠标左键。材质现在被应用于网格。
9.  然而，我们目前有一整个城市的四分之一的纹理。所以，创造更多的材质，并在城市的其他地方使用剩余的纹理。为每个额外的纹理创建一个新的材质，加上四个额外的`brick_002`，这样，我们可以为每个建筑高度创建不同的颜色。
10.  Apply your new materials to the city, either by comparison with the following figure or through your own artistic whim:

    ![Time for action – creating the city](img/2014OT_03_06.png.jpg)

    ### 类型

    当尝试到达中央喷泉时，如果你的坦克挡路，在**层级**窗口中选择你的坦克，并使用**场景**视图中的**小控件**选项将其拖离。

    *   如果你现在试着玩这个游戏，你可能会注意到我们有几个问题。首先，我们只有四分之一的城市；如果你建立了自己的城市，也许你会拥有更多。这个城市仍然没有碰撞，所以我们在移动的时候会直接掉进去。还有，坦克对这个城市来说有点大，太黑了，看不清我们要去哪里。开灯是解决这个问题最快的办法。
11.  在统一编辑器的顶部，选择**游戏对象**，然后选择**创建其他**，最后选择**方向灯**。这将创建一个向单一方向发光的对象。下一章将解释灯光以及如何控制它们，所以细节将留到以后。
12.  改变我们坦克的尺寸也很简单。在**层次**窗口中选择它，并在我们的**变换**组件中查找**比例**标签。在**刻度**下改变 **X** 、 **Y** 和 **Z** 值会改变我们坦克的尺寸。一定要均匀地改变它们，否则当我们开始旋转水箱时会出现一些奇怪的情况。0.5 的值使油箱足够小，可以通过小街道。
13.  Next up is collision for the city. For the most part, we will be able to get away with simple collision shapes that are faster to process. However, the circular center of the city will require something special. Start by double-clicking on the walls of one of the square buildings in the **Scene** view.

    ### 类型

    当处理预设时，城市仍然是，点击组成预设的任何对象将选择根预设对象。一旦一个预制体被选中，点击它的任何一部分都会选择那个单独的部分。因为这种行为不同于非预制对象，所以在**场景**视图中选择对象时需要注意。

14.  选中一组墙，进入 Unity 编辑器顶部，选择**组件**，然后选择**物理**，最后选择**箱式对撞机**。
15.  因为我们正在将碰撞器添加到特定的网格中，Unity 会尽最大努力自动将碰撞器适配到形状中。对我们来说，这意味着新的`BoxCollider`组件的尺寸已经适合建筑。继续添加`BoxColliders`到其余的方形建筑和外墙。我们的街道本质上只是一个平原，所以一个`BoxCollider`的组成部分对他们来说也同样适用。尽管尖尖的在顶部，喷泉中心的方尖碑本质上只是一个盒子；所以，再来一个`BoxCollider`会很适合它。
16.  我们还有最后一栋建筑和喷泉环要处理。这些不是盒子、球体或胶囊。所以，我们简单的对撞机不会工作。选择最后一栋建筑的墙壁，靠近中央喷泉的那栋。从选择**箱式对撞机**的地方往下几个选项，有一个**网格对撞机**选项。这将为我们的对象添加一个`MeshCollider`组件。这个组件顾名思义；它需要一个网格，并把它变成一个对撞机。通过将其添加到特定网格中，`MeshCollider`组件会自动选择该网格进行碰撞。你也应该在中心建筑周围的短壁架和喷泉周围的环形墙上加上`MeshColliders`。
17.  最后要解决的问题是我们城市小区的重复建设。首先选择层次结构中的根`city`对象`TankBattleCity`，并从中移除`Animator`组件。这个城市不会有生气，所以它不需要这个组件。
18.  现在，在**层级**窗口中右键点击城市，选择**复制**。这将创建所选对象的副本。
19.  再复制两次城市区，我们将拥有我们城市的四个部分。唯一的问题是它们都处于完全相同的位置。
20.  我们需要旋转其中的三块来制作一个完整的城市。选择一个，将**变换**组件中的 **Y 旋转**值设置为`90`。这将绕垂直轴旋转 90 度，给我们半个城市。
21.  我们将把剩下的部分设置为`180`，另一部分设置为`270`，从而完成这座城市。
22.  That leaves one last thing to do. We have four center fountains. In three of the four city pieces, select the three meshes that make up the center fountain (the `Obelisk`, `Wall`, and `Water`) and click on the *Delete* key on your keyboard. Confirm that you want to break the prefab connection each time, and our city will be complete.

    ![Time for action – creating the city](img/2014OT_03_07.png.jpg)

## *刚刚发生了什么？*

现在试试这个游戏。我们可以绕着城市行驶，转动炮塔。太有趣了。我们创造了材质并使城市有了纹理。在使其有可能与建筑物和道路碰撞后，我们复制了该部分，这样我们就可以拥有整个城市。

## 加油英雄——装饰城市

现在您已经具备了导入网格和创建材质所需的所有技能，挑战在于装饰城市。创建一些碎石和坦克陷阱，并练习将它们导入到 Unity，并在场景中设置它们。如果你真的想超越自我，那就去尝试创造你自己的城市吧。从世界上选择一些东西，或者从你的想象中选择一些东西。一旦它被创造出来，我们就可以释放里面的坦克。

# 行动时间-移动踏板

1.  只剩下一件事要做，然后我们将完成材质，并可以继续使游戏更加有趣。还记得材质的**偏移**值吗？事实证明，我们可以用一个脚本来控制它。首先打开`ChassisControls`脚本。
2.  首先，我们需要在脚本的开头添加一些变量。前两个将保存对我们的坦克踏板渲染器的引用，这是网格对象的一部分，用于跟踪应用于网格的材质并实际进行绘制。这就像`characterControl`变量如何保存对我们的`CharacterController`组件的引用一样。

    ```java
    public Renderer rightTread;
    public Renderer leftTread;
    ```

3.  后两个变量将跟踪应用于每个胎面的偏移量。我们将它存储在这里，因为它是一个比试图从每一帧的线程材质中查找它更快的引用。

    ```java
    private float rightOffset = 0;
    private float leftOffset = 0;
    ```

4.  要使用新值，需要将这些行添加到`MoveTank`功能的末尾。这里的第一行根据我们的速度调整右踏板的偏移，并与我们的帧速率保持同步。第二行利用`Renderer`组件的材质值来查找我们的坦克踏板材质。材质的`mainTextureOffset`值是材质中主要纹理的偏移量。就我们的漫射材质而言，它是唯一的纹理。然后，我们必须将偏移设置为新的`Vector2`值，该值将包含我们的新偏移值。`Vector2`就像我们以前搬家用的`Vector3`一样，只是在 2D 空间而不是 3D 空间工作。纹理是平的，因此 2D 空间。代码的最后两行与另外两行做了相同的事情，但针对的是左油箱踏板。

    ```java
    rightOffset += speed * Time.deltaTime;
    rightTread.material.mainTextureOffset = new Vector2(rightOffset, 0);
    leftOffset += speed * Time.deltaTime;
    leftTread.material.mainTextureOffset = new Vector2(leftOffset, 0);
    ```

5.  要连接到踏板的`Renderer`组件，请执行与枢轴点相同的操作:将踏板网格从**层次结构**窗口拖动到**检查器**窗口中的相应值。一旦完成，一定要保存并试用。

## *刚刚发生了什么？*

我们更新了我们的`ChassisControls`脚本，使坦克履带移动。当坦克行驶时，纹理会向适当的方向平移。这是用于在水中制造波浪和其他移动纹理的相同类型的功能。

## 有一个围棋英雄——用踏板转弯

材质的运动与坦克的速度不太匹配。弄清楚如何为坦克履带增加速度值。此外，如果它们在坦克旋转时向相反的方向移动，那会很酷。真正的坦克转弯是让一只脚向前，另一只脚向后。

# 动画

我们将讨论的下一个主题是动画。当我们在 Unity 中探索动画时，我们将为我们的坦克创建一些射击目标。Unity 动画系统 Mecanim 的大部分力量在于与人形角色合作。但是，设置和动画人型角色本身就是一本书，所以这里不做介绍。然而，我们仍然可以用 Mecanim 学习和做很多事情。

*   Before we continue with the explanation of the animation import settings, we need an animated model to work with. We have one last set of assets to import to our project. Import the `Target.blend` and `Target.png` files into the `Targets` folder of our project. Once imported, adjust the **Import Settings** window on the **Model** page for the target, just as we did for the tank. Now switch to the **Rig** tab.

    ![Animations](img/2014OT_03_08.png.jpg)

*   The **Animation Type** attribute tells Unity what type of skeleton the current model is going to use when animating.
    *   **人形**选项在这个页面上添加了更多的按钮和开关来处理人形角色。但同样，它太复杂了，无法在此涵盖。
    *   一个**通用**装备仍然使用 Mecanim 和它的许多特性。真的，这只是任何在结构上不像人的动画骨架。
    *   第三个选项 **Legacy** ，利用 Unity 的旧动画系统。但是，这个系统将在接下来的几个统一版本中逐步淘汰，所以它也不会被覆盖。
    *   最后一个选项**无**，表示该对象不会被动画化。您可以为坦克和城市选择该选项，因为它还可以防止 Unity 添加该`Animator`组件，并节省最终项目大小的空间。
    *   **根节点**值是模型文件中每个对象的列表。其目的是选择动画装备的基础对象。对于该目标，选择位于第二个**甲胄**选项下方的**骨骼 _ 手臂 _ 上肢**。

    ![Animations](img/2014OT_03_09.png.jpg)

*   导入设置的最后一页**动画**，包含了我们从文件中获取动画到统一所需的一切。在**目标导入设置**窗口的顶部，我们有**导入动画**复选框。如果一个对象没有去动画，关闭这个选项是一个好主意。这样做还可以节省项目空间。
*   下面的选项**烘焙动画**仅在动画包含运动学并且来自 3Ds Max 或 Maya 时使用。这个目标来自 Blender，所以这个选项是灰色的。
*   接下来的四个选项， **Anim。压缩**、**旋转误差**、**位置误差**和**缩放误差**主要用于平滑抖动动画。几乎在所有时候，违约都是合适的。
*   The **Clips** section is what we are really concerned about. This will be a list of every animation clip that is currently being imported from the model. On the left-hand side of the list, we have the name of the clip. On the right-hand side, we can see the start and end frames of the clip.
    *   Unity 将为每个新模型添加**默认拍摄**动画剪辑。这是保存文件时从建模程序的默认预览范围生成的剪辑。
    *   在 Blender 中，还可以为每个装备创建一系列动作。默认情况下，它们由 Unity 作为动画剪辑导入。在这种情况下，创建 **ArmatureAction** 剪辑。
    *   在夹子的右侧下方有一个小标签，上面有 **+** 和 **-** 按钮。这两个按钮分别在末尾添加一个剪辑和删除选定的剪辑。

    ![Animations](img/2014OT_03_10.png.jpg)

*   选择一个片段后，将出现下一个部分。它以一个文本字段开始，用于更改剪辑的名称。
*   文本字段下方有**取源**下拉列表。该列表与默认动画相同。很多时候，你只会用**默认取**；但是如果你的动画曾经出现错误或丢失，试着先改变**来源获取**下拉列表。
*   然后，我们有一个小的时间线，后面是动画剪辑的开始和结束帧的输入栏。单击并拖动时间线中的两个蓝色标志将改变输入栏中的数字。
*   接下来我们有**弧线姿态**和**循环偏移**。如果我们想要我们的动画重复，勾选**循环姿势**旁边的框。动画循环时，**循环偏移**将变为可用。该值允许我们调整循环动画开始的帧。
*   接下来的三个小部分，**根变换旋转**、**根变换位置(Y)** 和**根变换位置(XZ)** ，允许我们通过动画控制角色的移动。
    *   所有这三个部分都有一个**烘焙成姿势**选项。如果不选中这些选项，动画中根节点的移动(我们在**装备**页面下选择了它)会转化为整个对象的移动。这样想:假设你要动画一个角色运行到动画程序的右边和里面，你实际上移动了他们，而不是像平常一样在原地动画。在 Unity 的旧动画系统中，角色的物理部分要移动碰撞器，就必须用代码移动`GameObject`。所以，如果你使用那个动画，角色会看起来像移动了一样，但是不会有碰撞。有了这个新系统，当动画播放时，整个角色都会移动。然而，这需要一个不同的和更复杂的设置才能完全工作。所以，它没有被选择在坦克上使用，尽管我们可以使用它。
    *   Each of the three sections also has a **Based Upon** drop-down option. The choice of this option dictates the object's center for each of the sections. There are more choices if you are working with humanoid characters, but for now we only have two.

        选择**根节点**意味着根节点对象的枢轴点是中心。

        选择**原点**意味着动画程序定义的原点是对象的中心。

    *   前两个部分还有一个**偏移**选项，用于纠正运动中的错误。为角色设置行走循环动画时，如果角色稍微向一侧拉，调整**根变换旋转**下的**偏移**选项将会对其进行校正。
*   我们动画剪辑的最后一个选项是**变换蒙版**选项。通过单击左侧的箭头，可以展开模型中所有对象的列表。每个对象旁边都有一个复选框。播放此剪辑时，未选中的对象将不会被动画化。这在挥手动画的情况下很有用。这样的动画只需要移动手臂和手，所以我们会取消所有可能构成角色身体的对象。然后，我们可以对动画进行分层，使我们的角色能够在站立、行走或跑步时挥手，而不需要创建三个额外的动画。
*   最后，我们有我们的**恢复**按钮、**应用**按钮和底部的**预览**窗口。就像所有其他导入设置一样，我们必须在进行更改时点击其中一个按钮。右上角的速度滑块和左上角的大**播放**按钮使这个**预览**窗口变得特别。通过点击这个按钮，我们可以预览选定的动画。这让我们能够检测到我们之前谈到的运动中的错误，并且通常确保动画是我们想要的。

## 目标的动画

所以，现在描述已经完全不存在了，让我们用它来做点什么。我们从为目标设置动画开始。

# 行动时间-设置目标动画

利用我们刚刚获得的知识，我们现在可以设置目标的动画。

1.  首先，如果您错过或跳过了它，请确保将`Target.blend`和`Target.png`文件导入到`Targets`文件夹中。另外，在导入设置的**装备**页面上，将**动画类型**属性设置为**通用**，将**根节点**属性设置为 **Bone_Arm_Upper** 。
2.  我们总共需要六个动画。通过点击**剪辑**部分的 **+** 按钮，您可以再添加四个动画。如果添加过多，点击 **-** 按钮移除多余的剪辑。
3.  所有这些剪辑都应该有一个**默认拍摄**的**源拍摄**下拉列表，并且所有的**烘焙成姿势**选项都应该被选中，因为目标不会从它的起始位置移动。
4.  首先，让我们创建我们的闲置动画。选择第一个剪辑并将其重命名为`Idle_Retract`。因为它是一个机械物体，所以我们可以用一个非常短的动画来摆脱它；太短了，我们只使用第一帧。将起始帧设置为`0.9`，将结束帧设置为`1`。
5.  我们还需要打开**循环姿势**，因为空闲动画当然是循环的。
6.  扩展空闲动画的创建方式几乎完全相同。选择第二个剪辑并将其重命名为`Idle_Extend`。这里的开始帧是`14`，结束帧是`14.1`。另外，这个动画需要循环。
7.  我们接下来的两个动画是关于目标伸展和收缩的。它们将被称为`Extend`和`Retract`，因此重命名接下来的两个剪辑。`Extend`动画将从第`1`帧开始，到第`13`帧结束。`Retract`动画从第`28`帧开始，到第`40`帧结束。这两者都不会循环。
8.  最后两个动画也不会循环。它们是用来射击目标的。一个是前面中弹，一个是后面中弹。`Hit_Front`动画将从`57`帧到`87`帧。`Hit_Back`动画将从`98`帧到`128`帧。
9.  一旦完成所有更改，请务必点击**应用**否则将不会保存。

## *刚刚发生了什么？*

我们设置了将由我们的目标使用的动画。总共有六个。它们现在看起来不多，但是如果没有它们，下一部分就会丢失。

## 状态机

为了让我们在 Unity 中控制这些新的动画，我们需要设置一个状态机。状态机只是一个奇特的对象，它跟踪对象能做什么，以及如何在这些事情之间转换。从实时策略游戏的构建者的角度来考虑它。构建器具有行走状态，在移动到下一个施工现场时使用。当它到达那里时，它切换到构建状态。如果敌人出现，建造者将进入逃跑状态，直到敌人消失。最后，还有一个空闲状态，用于构建器无所事事的时候。在 Unity 中，当使用动画和 Mecanim 时，这些被称为动画师控制器。

# 行动时间–创建目标状态机

状态机的使用允许我们更加关注目标正在做什么，同时让 Unity 处理*它将如何做*部分。

1.  创建一个动画控制器很简单，就像我们为脚本和素材所做的那样。该选项位于**创建**菜单的底部。在`Targets`文件夹中创建一个并命名为`TargetController`。
2.  Double-click on `TargetController` to open a new window.

    ![Time for action – creating the target state machine](img/2014OT_03_11.png.jpg)

3.  **动画师**窗口是我们编辑状态机的地方。
    *   在窗口的左上角，有一个面包屑痕迹，你可以在一个网站上找到，让我们一眼就能看到我们在状态机中的位置。
    *   右上角的**自动直播链接**按钮控制着我们在游戏中实时查看状态机更新的能力。这对于调试角色的过渡和控制非常有用。
    *   在面包屑轨迹下面，有一个图层列表和一个用于添加新图层的按钮。每个状态机至少有**基础层**。添加额外的层将允许我们混合状态机。假设我们有一个人在完全健康的情况下正常行走。当他的健康下降到一半以下时，他开始跛行。如果这个角色只剩下百分之十的健康，他就会开始爬行。这将通过使用层来实现。
    *   窗口左下角有**参数**列表。点击 **+** 按钮将向列表中添加一个新参数。这些参数可以是布尔值、浮点值、向量值和整数值。状态之间的转换最常由参数的变化触发。任何使用状态机的脚本都可以修改这些值。
    *   最后，中间的绿色方框中有**任意状态**，允许角色从任意动作过渡到特定动作。当一个角色的生命值降到零度以下，我们希望他们进入死亡状态。**任意状态**框将保存这个转换，它将能够将角色从任何其他状态中拉出，并将其置于死亡状态。
4.  要创建一个新的状态，右键单击我们的**动画制作**窗口内的网格。鼠标悬停在**创建状态**上，选择**清空**。这为我们的状态机创建了一个新的空状态。通常新的状态是灰色的，但是因为这是我们机器中的第一个状态，所以它是橙色的，这是默认状态的颜色。
5.  Every state machine will start in its default state. Click on the state to select it, and we can take a look at it in the **Inspector** window.

    ![Time for action – creating the target state machine](img/2014OT_03_12.png.jpg)

    *   顶部有一个用于更改州名的文本字段。
    *   在此之下，您可以添加一个用于组织目的的标签。
    *   接下来是**速度**字段。此字段控制动画的速度。
    *   **运动**字段是我们将向之前创建的动画剪辑添加连接的地方。
    *   **脚部 IK** 选项让我们决定是否要用 IK 计算部分动画。我们没有为这些动画设置任何 IK，所以我们不需要担心这个选项。
    *   最后一个选项**镜像**，用于翻转动画的左右(或 x 轴)。如果你创建了一个右手挥舞的动画，这个选项会让你把它变成左手挥舞的动画。
    *   下面是从这个状态到另一个状态的转换列表。这些是脱离状态的转变，而不是进入状态。您很快就会看到，该列表中的一个转换显示为当前状态的名称，右边有一个箭头，后面是它所连接的状态的名称。
    *   复选框也会出现在右侧的**独奏**和**静音**标签下。这些用于调试状态之间的转换。任何数量的转场都可以一次静音，但一次只能独奏一个。当转换被静音时，这意味着状态机在决定进行哪个转换时将忽略它。选中独奏框与静音除一个转场之外的所有转场相同。这只是让它成为唯一活跃过渡的快速方法。
6.  我们需要为每个目标的动画设置一个状态。因此，再创建五个状态，并重命名所有六个状态，以匹配我们之前创建的动画剪辑的名称。默认状态，橙色的，应该命名为`Idle_Retract`。
7.  In the **Project** window, click on the little triangle to the left of the **Target** model.

    ![Time for action – creating the target state machine](img/2014OT_03_13.png.jpg)

    *   这扩展了模型，因此我们可以在 Unity 中看到组成该模型的所有对象。第一组是原始网格数据，如每个对象旁边的小缩略图所示。接下来是一个头像对象；这是跟踪**装备**设置的东西。下面是动画剪辑对象；这些就是我们现在感兴趣的。组成模型的对象位于堆栈的底部。
8.  Select each state in your **Animator** window and pair it with the correct clip by dragging an animation clip from the **Project** window and dropping it on the **Motion** field in the **Inspector** window.

    ### 类型

    动画剪辑的缩略图看起来像一个小的播放按钮。

    ![Time for action – creating the target state machine](img/2014OT_03_14.png.jpg)

9.  在创建过渡之前，我们需要一些参数。点击窗口左下角**参数**旁边的 **+** 按钮，从出现的菜单中选择**浮动**。列表中现在应该会出现一个新参数。
10.  左边的新字段是参数的名称；把这个改名为`time`。右边的字段是该参数的当前值。当调试我们的状态机时，我们可以在这里修改这些值来触发状态机的改变。游戏运行时脚本所做的任何更改也会出现在这里。
11.  我们还需要两个参数。创建两个布尔参数，并将其重命名为`wasHit`和`inTheFront`。这些将触发机器变为命中状态，而`time`参数将触发机器使用`extend`和`retract`状态。
12.  要创建新的过渡，右键单击一个状态，并从弹出的菜单中选择**进行过渡**。现在，一条过渡线从该状态连接到您的鼠标。要完成转换创建，请单击您希望连接到的状态。线上有一个箭头，指示过渡的方向。
    1.  我们需要从`Idle_Retract`过渡到`Extend`。
    2.  我们也需要从`Extend`过渡到`Idle_Extend`。
    3.  `Idle_Extend`需要三次过渡，分别前往`Retract`、`Hit_Front`和`Hit_Back`。
    4.  `Retract`, `Hit_Front`, and `Hit_Back` need a transition going to `Idle_Retract`.

        ### 类型

        参考下图。如果您创建了不想要的过渡或状态，选择它并点击键盘上的*删除*键将其删除。

        ![Time for action – creating the target state machine](img/2014OT_03_16.jpg)

13.  If you click on one of the transition lines, then we can take a look at its settings.

    ![Time for action – creating the target state machine](img/2014OT_03_17.png.jpg)

    *   在**检查器**窗口的顶部，我们有相同的指示器，指示我们在状态中的哪些状态之间进行转换，转换开始的状态名称后跟箭头，最后是转换结束的状态名称。
    *   在熟悉的**转场**列表下面，有一个文本字段，我们可以在其中给我们的转场起特定的名字。如果我们在相同的两个状态之间有几种不同类型的转换，这将是有用的。
    *   在字段的正下方，有一个更精确的基于路径的指示，指示转换在哪些状态之间。
    *   The **Atomic** checkbox allows us to decide whether or not a transition can be interrupted. If **Atomic** is checked, it cannot be interrupted.

        在关于**任意状态**选项和死亡状态的例子中，也许我们在拔剑的时候被击中，从闲置状态进入攻击状态。这种转变不可能是原子性的，如果我们想避免在摔死之前完成剑拔弩张的怪异。

    *   Next is a timeline block that lets us preview the transition between animations. Dragging the little flag left and right, we can watch the transition in the **Preview** window below. The top half of this block holds wave forms that indicate the movement contained in an animation. The bottom half shows the states as boxes that overlap where the transition actually occurs. Either of these boxes can be dragged to change the length of the transition.

        ### 类型

        因为我们的两个空闲动画的长度可以忽略不计，这在我们的设置中是看不到的。如果您在`extend`和`retract`状态之间临时创建一个过渡，它将是可见的。

    *   Lastly, we have a **Conditions** list. Using the parameters we set up, we can create any number of conditions here that must be met before this transition can take place.

        默认条件为**退出时间**。这意味着，当第一个状态在其动画中达到某个百分比时，如右边的浮动字段所定义的，它将开始转换到下一个状态。对于我们一半的过渡，这是我们想要的。另一半，即退出空闲状态的任何东西，需要基于我们的参数。

        ### 类型

        在**检查员**面板的底部还有另一个**预览**窗口。它的功能就像动画导入设置页面的功能一样，但这一个在两个相关动画之间播放过渡。

14.  选择`Idle_Retract`状态和`Extend`状态之间的转换。我们希望目标随机出现。这将由更改`time`参数的脚本控制。
15.  点击**条件**列表下的`Exit Time`，调出参数列表，从列表中选择时间。
16.  为了将浮点值转换为条件语句，我们需要将其与另一个值进行比较。这就是为什么当我们选择参数时，我们得到了一个新的比较选项下拉按钮。浮点值将大于或小于右边的值。我们的时间会倒计时，所以从列表中选择**减去**，数值为零。
17.  将`Idle_Extend`和`Retract`状态之间的转换条件更改为相同。
18.  对于`Idle_Extend`状态和`Hit_Front`状态之间的过渡，我们将使用两个创建的布尔参数。选择过渡，点击**条件**下的 **+** 按钮，添加第二个条件。
19.  对于第一种情况，选择**清洗**，对于第二种情况，选择前方的**。**
20.  布尔值不是真就是假。在转换的情况下，它需要知道它正在等待哪些值。对于这种转变，两者都应该保持不变。
21.  接下来，为`Idle_Extend`和`Hit_Back`之间的转换设置条件，就像之前的转换一样。区别在于需要从`inTheFront`条件旁边的下拉列表中选择 false。

## *刚刚发生了什么？*

我们创建了一个将被我们的目标使用的状态机。通过将每个状态链接到一个动画，并用过渡将它们连接起来，目标将能够在动画之间切换。这种转换通过添加条件和参数来控制。

# 行动时间–为目标编写脚本

我们只需要再多一块就可以完成目标的组装。

1.  那是一个剧本。在我们的`Scripts`文件夹中创建一个新的脚本并命名为`Target`。
2.  首先，为了与我们的状态机交互，我们需要一个对`Animator`组件的引用。它是你从坦克和城市中移除的组件。`Animator`组件将所有动画片段联系在一起。

    ```java
    public Animator animator;
    ```

3.  接下来是两个浮点值，它们将决定我们的目标处于空闲状态的时间范围(以秒为单位)。

    ```java
    public float maxIdleTime = 10f;
    public float minIdleTime = 3f;
    ```

4.  接下来，我们有三个值将保存我们需要更改的参数的标识号。技术上可以只使用参数的名称来设置它们，但是使用 ID 号要快得多。

    ```java
    private int timeId = -1;
    private int wasHitId = -1;
    private int inTheFrontId = -1;
    ```

5.  最后两个变量将保存两个空闲状态的身份证号。我们需要这些来检查我们在哪个州。所有的 id 最初都被设置为`-1`作为一个伪值，我们用下面的函数将它们设置为它们的实际值:

    ```java
    private int idleRetractId = -1;
    private int idleExtendId = -1;
    ```

6.  `Awake`功能是 Unity 中的一个特殊功能，在游戏开始时每个脚本都会调用。它的目的是在游戏开始前进行初始化，非常适合最初设置我们的 ID 值。对于每个 ID，我们调用 `Animator.StringToHash`函数。这个函数计算我们给它命名的参数或状态的标识号。州名也需要以`Base Layer`为前缀。这是因为 Unity 希望我们在可能有几个不同层的状态被命名为同一事物时要具体。同样非常重要的是，这里的名称与 **Animator** 窗口中的名称完全匹配。如果不匹配，标识将不匹配，将出现错误，脚本将无法正常运行。

    ```java
    public void Awake() {
      timeId = Animator.StringToHash("time");
      wasHitId = Animator.StringToHash("wasHit");
      inTheFrontId = Animator.StringToHash("inTheFront");
      idleRetractId = Animator.StringToHash("Base Layer.Idle_Retract");
      idleExtendId = Animator.StringToHash("Base Layer.Idle_Extend");
    }
    ```

7.  为了利用所有这些身份证，我们求助于我们的好朋友——功能。在函数的开始，我们使用`GetCurrentAnimatorStateInfo`函数来计算哪个状态是当前状态。我们给它发送一个零，因为它想知道我们正在查询的层的索引，而我们只有一个。该函数返回一个包含当前状态信息的对象，我们立即获取该状态的`nameHash`值(也称为标识值)，并将变量设置为该值。

    ```java
    public void Update() {
      int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;
    ```

8.  下一行代码是与我们的空闲状态标识进行比较，以确定我们是否处于其中一种状态。如果是的话，我们调用`SubtractTime`函数(稍后我们会写出来)来减少`time`参数。

    ```java
      if(currentStateId == idleRetractId || currentStateId == idleExtendId) {
        SubtractTime();
      }
    ```

9.  如果目标不是当前处于闲置状态的，我们首先检查我们是否被击中。如果是，使用`ClearHit`功能清除命中，使用`ResetTime`功能重置`time`参数。这两个函数也将在一会儿写出来。最后，我们检查一下计时器是否降到了零以下。如果是这样，我们再次重置计时器。

    ```java
      else {
        if(animator.GetBool(wasHitId)) {
          ClearHit();
          ResetTime();
        }

        if(animator.GetFloat(timeId) < 0) {
          ResetTime();
        }
      }
    }
    ```

10.  在`SubtractTime`函数中，我们使用`Animator`组件的`GetFloat`函数来检索浮点参数的值。通过发送我们的`timeId`变量，我们可以接收`time`参数的当前值。就像我们对坦克所做的那样，然后我们使用`Time.deltaTime`来跟上我们的帧速率，并从计时器中减去时间。一旦完成，我们需要给状态机新的值，这是通过`SetFloat`功能完成的。我们通过给它一个 ID 值来告诉它要改变哪个参数，通过给它一个新的时间值来告诉它要改变什么。

    ```java
    public void SubtractTime() {
      float curTime = animator.GetFloat(timeId);
      curTime -= Time.deltaTime;
      animator.SetFloat(timeId, curTime);
    }
    ```

11.  下一个要创建的函数是`ClearHit`。该功能使用`Animator`组件中的`SetBool`来设置布尔参数。其功能与`SetFloat`功能相同。我们只是给它一个 ID 和一个值。在这种情况下，我们将我们的布尔参数都设置为假，这样状态机就不再认为它被击中了。

    ```java
    public void ClearHit() {
      animator.SetBool(wasHitId, false);
      animator.SetBool(inTheFrontId, false);
    }
    ```

12.  脚本的最后一个功能是`ResetTime`。这是另一个快速功能。首先，我们使用 `Random.Range`函数获得一个随机值。通过传递一个最小值和最大值，我们的新随机数将介于两者之间。最后，我们使用`SetFloat`函数给状态机赋予新的值。

    ```java
    public void ResetTime() {
      float newTime = Random.Range(minIdleTime, maxIdleTime);
      animator.SetFloat(timeId, newTime);
    }
    ```

## *刚刚发生了什么？*

我们创建了一个脚本来控制目标的状态机。为了比较状态和设置参数，我们收集并使用了标识。目前，不要担心命中状态何时被激活。当我们最终进行坦克射击时，这将在下一节中阐明。

## 创建预设

现在我们已经有了模型、动画、状态机和脚本，最后是时候创建目标并将它变成一个预置了。

# 行动时间——创建目标

我们有所有的碎片；下一步是把它们放在一起。

1.  首先将**目标**模型从**项目**窗口拖动到**层级**窗口。这将创建`target`对象的新实例。
2.  通过选择新的`target`对象，我们可以看到它已经附着了一个`Animator`组件；我们只需要添加对我们创建的`AnimatorController`的引用。通过从**项目**窗口拖动`TargetController`并将其放到动画师组件的**控制器**字段来完成，就像我们到目前为止设置的所有其他对象引用一样。
3.  此外，我们需要向对象添加`Target`脚本，并在其相关字段中连接对`Animator`组件的引用。
4.  对目标物体做的最后一件事是添加一个碰撞器来实际接收我们的大炮射击。不幸的是，因为`target`对象使用骨骼和装备来制作动画，所以它不像直接向我们将要拍摄的网格添加碰撞器那么简单。相反，我们需要创建一个新的空`GameObject`。
5.  将其重命名为`TargetCollider`，并使其成为目标的`Bone_Target`骨骼的子对象。
6.  在新的`GameObject`中添加一个`MeshCollider`组件。
7.  Now, we need to provide it with some mesh data. Find the `Target` mesh data in the **Project** window, underneath the **Target** model. Drag it to the **Mesh** value of the `MeshCollider` component. This causes a green cylinder to appear in the **Scene** view. This is our collision, but it is actually not on the target.

    ### 类型

    **项目**窗口中的许多对象可以很容易地通过每个对象旁边的小符号来区分。网格的符号是灰色和蓝色网格。

    ![Time for action – creating the target](img/1.jpg)

8.  使用**变换**组件将游戏对象的位置设置为 **X** 值的`4`，以及 **Y** 和 **Z** 的`0`。**X**`-90`为**Y**`90`为 **Z** 旋转需要改为`0`。
9.  当我们进行更改时，您可能注意到所有新的或更改的字体都变成了粗体。这是为了表明，与原始的相比，这个预制的实例有所不同。记住，模型本质上是预制的；他们的问题是，我们不能直接进行更改，例如添加脚本。要使这个目标成为一个新的预设，只需将其从**层次结构**窗口拖动，并将其放在**项目**窗口的`Prefabs`文件夹中。
10.  有了这个漂亮的新的预制建筑，用它来填充城市。
11.  在放置所有这些目标时，您可能会注意到它们有点大。我们不需要单独编辑每个目标，甚至不需要将所有目标作为一个组来编辑，我们只需要对最初的预设进行更改。在**项目**窗口中选择`Target`预设。**检查器**窗口显示的根预制对象信息与场景中任何其他对象的信息相同。选择我们的预设后，一半的比例和场景中的所有实例将自动更新以匹配。我们也可以改变最小和最大空闲时间，让它影响整个场景。

## *刚刚发生了什么？*

我们刚刚为我们的坦克创建了目标。通过使用 Unity 的预设系统，我们也能够在整个游戏中复制目标，并轻松做出影响所有目标的改变。

如果你想让一个目标比所有其他目标都大，你可以在场景中改变它。对预置实例所做的任何更改都会被保存，并且它们优先于对根预置对象所做的更改。另外，在**检查器**窗口中查看实例时，窗口顶部会有三个新按钮。**选择**按钮在**项目**窗口中选择根预制对象。**恢复**将删除对此实例所做的任何唯一更改，而**应用**按钮会用此实例中所做的所有更改更新根对象。

## 拥有一个围棋英雄——更多目标

利用你所学到的关于动画和状态机的知识，你的挑战是创建第二种类型的目标。玩不同的动作和行为。也许，创造一个从挥手到静止的过渡。

# 光线追踪拍摄

现在玩游戏；很酷。我们有可以驾驶的坦克和有质感的城市。我们甚至有奇特的动画目标。我们只是错过了一件事:我们如何拍摄？我们需要再做一个剧本，我们可以尽情地拍摄目标。

# 行动时间-简单拍摄

增加一个物体和一个脚本，我们就可以开始向目标射击了。

1.  首先，我们需要给我们的坦克增加一个空`GameObject`。将其重命名为`MuzzlePoint`，并使其成为大炮轴心点对象的子对象。一旦完成，把它放在大炮的末端，这样蓝色箭头就指向远离坦克的方向，与大炮的方向相同。这将是我们子弹的来源。
2.  我们还需要一些东西来指示我们在哪里拍摄。爆炸将在以后的章节中介绍，所以从**创建其他**菜单中选择**球体**，并将其重命名为`TargetPoint`。
3.  为每个轴将球体的比例设置为`0.2`，并给它一个红色的材质。这样可以更容易看到它，而不是完全招摇。
4.  从`TargetPoint`上拆下`SphereCollider`组件。`SphereCollider`必须移除，因为我们不想拍摄自己的目标指示器。
5.  现在，创建一个新的脚本并将其称为`FireControls`。
6.  你应该开始熟悉这个了。我们从变量开始，保存对我们的枪口和我们刚刚创建的目标对象的引用。紧随其后的是 `OnGUI`功能，在屏幕右下角绘制一个按钮，就在我们绘制炮塔控制按钮的上方。如果按钮被按下，我们调用下一步将创建的`Fire`功能。

    ```java
    public Transform muzzlePoint;
    public Transform targetPoint;

    public void OnGUI() {
      Rect fire = new Rect(Screen.width – 70, Screen.height – 220, 50, 50);
      if(GUI.Button(fire, "Fire")) {
        Fire();
      }
    }
    ```

7.  `Fire`函数从定义一个变量开始，该变量将保存拍摄内容的详细信息。随后是检查`Physics.Raycast`功能的`if`语句。`Raycast`功能的工作原理就像开枪一样。我们从一个指向特定方向(相对于枪口点向前)的位置(枪口点的位置)开始，找出被击中的地方。如果我们击中了什么东西，`if`的陈述被评估为真；否则它是错误的，我们将跳过。当我们击中某物时，我们首先将目标点移动到被击中的点。然后我们使用`SendMessage`功能来告诉我们击中了什么，它被击中了。`SendMessage`功能只对`GameObjects`和`MonoBehaviours`可用，我们的`Target`脚本在目标的根对象上，因此`hit.transform.root.gameObject`是为了到达被击中的`GameObject`。 `SendMessage`函数取一个函数的名称，并试图在消息发送到的`GameObject`上找到它。我们还为它提供了一个值`hit.point`，以赋予应该找到的函数。该行的`SendMessageOptions.DontRequireReceiver`部分防止函数在找不到所需函数时抛出错误。如果我们没有击中任何东西，我们的`Fire`功能的最后一部分就会出现。我们把我们的目标点送回世界原点，这样玩家就可以知道他们错过了一切。

    ```java
    public void Fire() {
      RaycastHit hit;
      if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
        targetPoint.position = hit.point;
        hit.transform.root.gameObject.SendMessage("Hit", hit.point, SendMessageOptions.DontRequireReceiver);
      }
      else {
        targetPoint.position = Vector3.zero;
      }
    }
    ```

8.  最后要做的就是在我们的`Target`脚本末尾添加`Hit`函数。我们通过获取当前状态 ID 来启动函数，就像我们在脚本中前面所做的那样。然而，这次我们只检查我们的扩展空闲 ID。如果它们不匹配，我们使用 return 提前退出函数。我们这样做是因为我们不想让玩家射击任何下降或过渡中期的目标。如果我们的状态是正确的，我们通过使用`SetBool`功能告诉动画我们被击中来继续。

    ```java
    public void Hit(Vector3 point) {
      int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;
      if(currentStateId != idleExtendId) return;
      animator.SetBool(wasHitId, true);
    ```

9.  `Hit`功能的其余部分计算出目标被击中的一侧。为了做到这一点，我们首先必须将我们从世界空间获得的点转换成局部空间。我们的**转换**组件的`InverseTransformPoint`功能很好地完成了这一点。然后我们检查一下子弹是从哪里来的。由于目标的构造方式，如果射击在 x 轴上是正的，那么它来自后面。否则，它来自前方。无论哪种方式，我们将状态机中的`inTheFront`参数设置为适当的值。然后，我们通过增加我们在`ScoreCounter`脚本中创建的静态变量来给玩家一些分数，这要追溯到这一章的开头。

    ```java
    Vector3 localPoint = transform.InverseTransformPoint(point);
      if(localPoint.x > 0) {
        animator.SetBool(inTheFrontId, false);
        ScoreCounter.score += 5;
      }
      else {
        animator.SetBool(inTheFrontId, true);
        ScoreCounter.score += 10;
      }
    }
    ```

10.  最后，一定要给坦克增加新的`FireControls`脚本。此外，您需要将引用连接到`MuzzelPoint`和`TargetPoint`对象。

## *刚刚发生了什么？*

我们创建了一个脚本，允许我们发射坦克的大炮。使用光线追踪的方法是最简单和最广泛使用的。一般来说，子弹飞得太快，我们看不见。光线追踪是这样的，也就是；这是瞬间的。然而，这种方法没有考虑重力，或者其他任何可能改变子弹方向的因素。

## 有围棋英雄——更好的图形用户界面

现在所有的按钮和组件都就位了，让它们看起来更好。使用您从上一章中获得的技能来设计图形用户界面并使其变得很棒。也许你甚至可以为这个动作设计一个方向垫。

# 总结

就这样！这一章很长，我们学到了很多。我们导入了网格并建立了一个坦克。我们创造了一些材质，以便为城市增添色彩。我们还制作了一些目标的动画，并学习了如何击落它们。太多了，是时候休息了。玩游戏，射击一些目标，收集那些点。项目已经全部完成，可以根据您选择的设备进行构建。构建过程与前面两个项目相同，所以玩得开心！

下一章是关于特殊的相机效果和灯光。我们将学习灯光及其类型。我们的坦克战游戏将通过增加一个天箱和几个灯来扩展。我们还会看一下距离雾。随着阴影和光照地图的加入，我们将要战斗的城市开始变得有趣和充满活力。